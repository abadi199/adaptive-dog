#include "stdafx.h"
#include "cube.h"
#include "cubedoc.h"
//#include "cubeview.h"
#include "NameDialog.h"

#include ".\cubeview.h"

#include "gl\gl.h"
#include "gl\glu.h"

#include <string>
#include <cmath>
#include <iostream>
#include <string>
using namespace std;

#include "defines.h"
#include "globals.h"

NameDialog* dlg;
CRect dlg_rect;

//#include "MRBspline.h"
//#include "ivectormatrix.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

unsigned char threeto8[8] =
{
	0, 0111>>1, 0222>>1, 0333>>1, 0444>>1, 0555>>1, 0666>>1, 0377
};

unsigned char twoto8[4] =
{
	0, 0x55, 0xaa, 0xff
};

unsigned char oneto8[2] =
{
	0, 255
};

static int defaultOverride[13] =
{
	0, 3, 24, 27, 64, 67, 88, 173, 181, 236, 247, 164, 91
};

static PALETTEENTRY defaultPalEntry[20] =
{
	{ 0,   0,   0,    0 },
	{ 0x80,0,   0,    0 },
	{ 0,   0x80,0,    0 },
	{ 0x80,0x80,0,    0 },
	{ 0,   0,   0x80, 0 },
	{ 0x80,0,   0x80, 0 },
	{ 0,   0x80,0x80, 0 },
	{ 0xC0,0xC0,0xC0, 0 },

	{ 192, 220, 192,  0 },
	{ 166, 202, 240,  0 },
	{ 255, 251, 240,  0 },
	{ 160, 160, 164,  0 },

	{ 0x80,0x80,0x80, 0 },
	{ 0xFF,0,   0,    0 },
	{ 0,   0xFF,0,    0 },
	{ 0xFF,0xFF,0,    0 },
	{ 0,   0,   0xFF, 0 },
	{ 0xFF,0,   0xFF, 0 },
	{ 0,   0xFF,0xFF, 0 },
	{ 0xFF,0xFF,0xFF, 0 }
};

///////////////////////////////////////////////////////////////////////////////
// Global variables

#define STEP	10
#define STEP2	10
//#define MAX_FRAMES 30

int file_loaded;
float x_size, y_size;
char prefix[256];
char sys_msg[256];

extern int cal3D;
extern point3D camera, Prevcamera, vanVec;
extern float camRot;
extern float camRot2;
extern float viewAngle;
extern int YZflag[MAX_TIP_FG_NUM];
extern char name[256];
extern char prefix[256];

point2D vanish;
point2D fg[MAX_TIP_FG_NUM][MAX_FRAMES][11];
point2D TC[MAX_TIP_FG_NUM][MAX_FRAMES][4];

point2D movement;
int isVanish = 0;
int isPnt;
ObjPnt which;
int pcount=1;

int status = NO_STATUS;
int status2 = NO_STATUS;
int fg_num = 0;
int frame_num = 1;
int fis_frame_num = 0;
int cur_fg = 1;

int	snapped; 

int scene_model_type = 0; // default scene_model_type is plane
int panoramic_view_created = 0; // if a parnoramic view has been created

// This is for test
CDC	memDC;

CDC	memDC2; // foreground texture
CDC	memDC3; // foreground mask
CDC	memDC4; // second image
CDC	double_buffer; // double buffer

CBitmap		bitmap;
CBitmap		bitmap2;
CBitmap		bitmap3;

extern float x_size, y_size;

// image size
extern int IMAGE_X, IMAGE_Y;
// view size
extern int view_x, view_y;


BITMAPINFO	m_bmi;
LPVOID		m_pBitmapBits;
HBITMAP	m_hDib;
CSize		m_szPage;

HDC	HmemDC;
HGLRC       memRC;
HDC   m_hOldDC;
HGLRC   m_hOldRC;

CRect       m_oldRect;
float       m_fRadius;

CPalette    m_cPalette2;
CPalette    *m_pOldPalette2;
CRect		m_oldRect2;

string cur_file_name;

/////////////////////////////////////////////////////////////////////////////
// CCubeView

IMPLEMENT_DYNCREATE(CCubeView, CView)

BEGIN_MESSAGE_MAP(CCubeView, CView)
	//{{AFX_MSG_MAP(CCubeView)
	ON_COMMAND(ID_FILE_PLAY, OnFilePlay)
	ON_UPDATE_COMMAND_UI(ID_FILE_PLAY, OnUpdateFilePlay)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_SIZE()
	ON_WM_TIMER()
	ON_WM_ERASEBKGND()
	//}}AFX_MSG_MAP
	ON_COMMAND(ID_FILE_OPEN, OnFileOpen)
	ON_COMMAND(ID_PAINT_RANDOMDESCENT, OnPaintRandomDescent)
	ON_COMMAND(ID_PAINT_GENETICPAINTER, OnPaintGeneticpainter)
	ON_COMMAND(ID_CURVE_FREEHAND, OnCurveFreehand)
	ON_WM_LBUTTONDOWN()
	ON_WM_RBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_RBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_KEYUP()
	ON_COMMAND(ID_IPEN_EXTERNAL, OnIpenExternal)
	ON_COMMAND(ID_IPEN_GVF, OnIpenGvf)
	ON_COMMAND(ID_IPEN_INTERNAL, OnIpenInternal)
	ON_COMMAND(ID_IPEN_OUTLINE, OnIpenOutline)
	ON_COMMAND(ID_IPEN_EDIT, OnIpenEdit)
	ON_COMMAND(ID_IPEN_PAINT, OnIpenPaint)
	//	ON_WM_MBUTTONDOWN()
	ON_WM_KEYDOWN()
	ON_COMMAND(ID_IPEN_EDITINDIV, OnIpenEditindiv)
	ON_COMMAND(ID_EDGE_CANNY, OnEdgeCanny)
	ON_COMMAND(ID_EDGE_PAINT, OnEdgePaint)
	ON_COMMAND(ID_EDGE_BOOST, OnEdgeBoost)
	ON_COMMAND(ID_IPEN_PAINT2, OnIpenPaint2)
	ON_COMMAND(ID_IPEN_BILATERAL, OnIpenBilateral)
	ON_COMMAND(ID_IPEN_BILATERAL2, OnIpenBilateral2)
	ON_COMMAND(ID_IPEN_EMAP, OnIpenEmap)
	ON_COMMAND(ID_IPEN_CARTOON, OnIpenCartoon)
	ON_COMMAND(ID_IPEN_WATER, OnIpenWater)
	ON_COMMAND(ID_IPEN_PENINK, OnIpenPenink)
	ON_COMMAND(ID_IPEN_STIPPLE, OnIpenStipple)
	ON_COMMAND(ID_IPEN_OIL, OnIpenOil)
	ON_COMMAND(ID_IPEN_MOSAIC, OnIpenMosaic)
	ON_COMMAND(ID_EDGE_TVF, OnEdgeTvf)
	ON_COMMAND(ID_EDGE_FLOWEDGE, OnEdgeFlowedge)
	ON_COMMAND(ID_EDGE_THINNING, OnEdgeThinning)
	ON_COMMAND(ID_EDGE_DOG, OnEdgeDog)
	ON_COMMAND(ID_IPEN_LINEART, OnIpenLineart)
	ON_COMMAND(ID_EDGE_GABOR, OnEdgeGabor)
	ON_COMMAND(ID_EDGE_BILATERAL, OnEdgeFlowBilateral)
	ON_COMMAND(ID_EDGE_TOON, OnEdgeToon)
	ON_COMMAND(ID_EDGE_ABSTRACT, OnEdgeAbstract)
	ON_COMMAND(ID_EDGE_LINES, OnEdgeLines)
	ON_COMMAND(ID_EDGE_GOOCH, OnEdgeGooch)
	ON_COMMAND(ID_EDGE_BILATERAL32816, OnEdgeBilateral)
	ON_COMMAND(ID_EDGE_FLOWGAUSS, OnEdgeFlowgauss)
	ON_COMMAND(ID_EDGE_SHOCK, OnEdgeShock)
	ON_COMMAND(ID_EDGE_FDOG, OnEdgeFdog)
	ON_COMMAND(ID_EDGE_FLOWBILATERAL2, OnEdgeFlowbilateral2)
	ON_COMMAND(ID_EDGE_ABSTRACT2, OnEdgeAbstract2)
	ON_COMMAND(ID_EDGE_FLOWSHOCK, OnEdgeFlowshock)
	ON_COMMAND(ID_EDGE_FLOWSHOCK2, OnEdgeFlowshock2)
	ON_COMMAND(ID_EDGE_FLOWSHOCK3, OnEdgeFlowshock3)
	ON_COMMAND(ID_EDGE_FLOWBILATERAL3, OnEdgeFlowbilateral3)
	ON_COMMAND(ID_EDGE_ETF, OnEdgeEtf)
	ON_COMMAND(ID_EDGE_CLD, OnEdgeCld)
	ON_COMMAND(ID_TOON_SHOCK, OnToonShock)
	ON_COMMAND(ID_TOON_WOODCUT, OnToonWoodcut)
	ON_COMMAND(ID_TOON_WOODCUT2, OnToonWoodcut2)
	ON_COMMAND(ID_TOON_SHOCK2, OnToonShock2)
	ON_COMMAND(ID_TOON_BILATERAL, OnToonBilateral)
	ON_COMMAND(ID_TOON_MEDIAN, OnToonMedian)
	ON_COMMAND(ID_TOON_BILATERAL2, OnToonBilateral2)
	ON_COMMAND(ID_TOON_BILATERAL3, OnToonBilateral3)
	ON_COMMAND(ID_TOON_CURVATURE, OnToonCurvature)
	ON_COMMAND(ID_TOON_CURVATURE2, OnToonCurvature2)
	ON_COMMAND(ID_TOON_CURVATURE3, OnToonCurvature3)
	ON_COMMAND(ID_TOON_CURVATURE4, OnToonCurvature4)
	ON_COMMAND(ID_TOON_CURVATURE5, OnToonCurvature5)
	ON_COMMAND(ID_TOON_CURVATURE6, OnToonCurvature6)
	ON_COMMAND(ID_TOON_SEGMENT, OnToonSegment)
	ON_COMMAND(ID_TOON_CURVATURE8, OnToonCurvature8)
	ON_COMMAND(ID_EDGE_VIDEOCLD, OnEdgeVideocld)
	ON_COMMAND(ID_EDGE_CLDITR, OnEdgeClditr)
	ON_COMMAND(ID_EDGE_CLDTHIN, OnEdgeCldthin)
	ON_COMMAND(ID_EDGE_VIDEOCLDTHIN, OnEdgeVideocldthin)
	ON_COMMAND(ID_EDGE_CLDTEXTURE, OnEdgeCldtexture)
	ON_COMMAND(ID_EDGE_VIDEOCLDTEX, OnEdgeVideocldtex)
	ON_COMMAND(ID_TOON_CURVATURE11, OnToonCurvature9)
	ON_COMMAND(ID_TOON_UPSAMPLING, OnToonUpsampling)
	ON_COMMAND(ID_TOON_UPSAMPLING2, OnToonUpsampling2)
	ON_COMMAND(ID_TOON_DOT2DOT, OnToonDot2dot)
	ON_COMMAND(ID_TOON_ETFMOTION, OnToonEtfmotion)
	ON_COMMAND(ID_EDGE_WEICKERT, OnEdgeWeickert)
	ON_COMMAND(ID_EDGE_TENSOR, OnEdgeTensor)
	ON_COMMAND(ID_EDGE_FBL, OnEdgeFbl)
	ON_COMMAND(ID_EDGE_VIDEOTOON, OnEdgeVideotoon)
	ON_COMMAND(ID_EDGE_VIDEOTOON2, OnEdgeVideotoon2)
	ON_COMMAND(ID_EDGE_FABSTRACT, OnEdgeFabstract)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCubeView construction/destruction

CCubeView::CCubeView()
{
	m_pDC = NULL;
	m_pOldPalette = NULL;
	m_play = FALSE;
	test = 12345;
}

CCubeView::~CCubeView()
{
}

/////////////////////////////////////////////////////////////////////////////
// CCubeView drawing

void CCubeView::OnDraw(CDC* pDC)
{
	CCubeDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	//DrawScene();
	TIPDrawScene(pDC);
}

/////////////////////////////////////////////////////////////////////////////
// CCubeView diagnostics

#ifdef _DEBUG
void CCubeView::AssertValid() const
{
	CView::AssertValid();
}

void CCubeView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}

CCubeDoc* CCubeView::GetDocument() // non-debug version is inline
{
	return STATIC_DOWNCAST(CCubeDoc, m_pDocument);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CCubeView message handlers

void CCubeView::OnFilePlay()
{
	m_play = m_play ? FALSE : TRUE;
	if (m_play)
		SetTimer(1, 15, NULL);
	else
		KillTimer(1);
}

void CCubeView::OnUpdateFilePlay(CCmdUI* pCmdUI)
{
	pCmdUI->SetCheck(m_play);
}

BOOL CCubeView::PreCreateWindow(CREATESTRUCT& cs)
{
	// An OpenGL window must be created with the following flags and must not
	// include CS_PARENTDC for the class style. Refer to SetPixelFormat
	// documentation in the "Comments" section for further information.
	cs.style |= WS_CLIPSIBLINGS | WS_CLIPCHILDREN;

	return CView::PreCreateWindow(cs);
}

void ComputeStdDev()
{
	double x[5] = { 
1366120.9,
1356020.1,
1368124.6,
1351647.1,
1361258.3
	};
	//double mean = 3606536.5;
	double mean = 0.0;
	for (int i = 0; i < 5; i++) {
		mean += x[i];
	}
	mean /= 5.0;

	double std;
	double var = 0.0;
	for (int i = 0; i < 5; i++) {
		var += (x[i] - mean) * (x[i] - mean);
	}
	var /= 4.0;
	std = sqrt(var);
	TRACE("mean = %f, var = %f, std = %f\n", mean, var, std);
}

int CCubeView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CView::OnCreate(lpCreateStruct) == -1)
		return -1;

	Init(); // initialize OpenGL

	image_mode = OPENGL_MODE; // image render mode initialization
	//image_mode = BITMAP_MODE; // image render mode initialization

	glClearColor(1.0, 1.0, 1.0, 1.0);
	glClear(GL_COLOR_BUFFER_BIT);
	swap();
	//OpenGL_InitMemoryDC();
	//OpenGL_Init(&memDC);
	InitMemDCandBitmap();
	//OpenGL_Init(&memDC);
	//AfxGetMainWnd()->SetWindowText("Curve Editor");
	CClientDC dc(this);
	InitAlphaMap(dc);

	GetParentFrame()->SetWindowPos(NULL, 0, 0, IMAGE_X+CHILDFRM_RIGHT_BAR_WIDTH, 
		IMAGE_Y+CHILDFRM_TITLE_BAR_WIDTH, SWP_NOMOVE);
	GetParentFrame()->SetWindowText(LPCTSTR("Paint"));
	//AfxGetMainWnd()->SetWindowText("Paint");

	cur_sigma = 1.0;
	hi_thres = 0.1;
	lo_thres = 0.01;
	MASK_SIZE = 71;

	/* show dialog window
	//m_wndDlgBar.Create(this, IDD_VIEWSELECT, CBRS_LEFT|CBRS_TOOLTIPS|CBRS_FLYBY, IDD_VIEWSELECT);
	dlg = new NameDialog;
	dlg->Create(IDD_DIALOG1);
	dlg->ShowWindow(1);
	//dlg.SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOMOVE);
	CRect rect, rect2;
	GetParentFrame()->GetWindowRect(rect);
	dlg->GetWindowRect(rect2); 
	dlg_rect = rect;
	dlg->MoveWindow(rect.right, rect.top, rect2.right-rect2.left, rect2.bottom-rect2.top, TRUE);
	*/

	///////////////////////////////////////////////////////////
	//dlg->m_Paint_radio.SetCheck(BST_CHECKED);
	//(CButton *)(GetDlgItem(IDC_PAINT))->SetCheck(BST_CHECKED);
	//TRACE("butten checked = %d\n", dlg->IsDlgButtonChecked(IDC_PAINT));
	//TRACE("m_Paint_radio2 = %d\n", dlg->m_Paint_radio2.GetCheck());
	//dlg->m_Paint_radio2.SetCheck(BST_UNCHECKED);
	//TRACE("m_Paint_radio2 = %d\n", dlg->m_Paint_radio2.GetCheck());
	//dlg->UpdateDialogControls();
	//dlg->UpdateData(FALSE);
	//TRACE("butten checked = %d\n", dlg->IsDlgButtonChecked(IDC_PAINT));
	//dlg->UpdateWindow();
	//dlg->ShowWindow(1);
	//dlg->m_Paint = 0;
	//dlg->UpdateWindow();
	//dlg.Create(this, IDD_DIALOG1, CBRS_LEFT, IDD_DIALOGBAR);
	//m_wndDialogBar.Create(this, IDD_DIALOGBAR, CBRS_LEFT, IDD_DIALOGBAR);
	//ComputeStdDev();
		
	Invalidate(FALSE);
	//GetParentFrame()->SetWindowText(LPCTSTR("Curve Editor"));
	//GenMRMatrices(); 
	//GenMRMatrices2(); 
	//GenMRMatricesWenjie2();
	//GenMRMatricesWenjie3(); // good approximation, but no endpoint preservation
	//GenMRMatricesWenjie4(); // bad approximation, correct P
	//GenMRMatricesWenjie5(); // good approximation, correct P, A
	//GenMRMatricesWenjie6(); // good approximation, correct P, A
	//GenMRMatricesWenjie7(); // biorthogonal
	
	return 0;
}

void CCubeView::OnDestroy()
{
	HGLRC   hrc;

	KillTimer(1);

	hrc = ::wglGetCurrentContext();

	::wglMakeCurrent(NULL,  NULL);

	if (hrc)
		::wglDeleteContext(hrc);

	if (m_pOldPalette)
		m_pDC->SelectPalette(m_pOldPalette, FALSE);

	if (m_pDC)
		delete m_pDC;

	CView::OnDestroy();
}

void CCubeView::OnSize(UINT nType, int cx, int cy)
{
	CView::OnSize(nType, cx, cy);

	if (cy > 0)
	{
		glViewport(0, 0, cx, cy);

		if((m_oldRect.right > cx) || (m_oldRect.bottom > cy))
			RedrawWindow();

		m_oldRect.right = cx;
		m_oldRect.bottom = cy;

		glMatrixMode(GL_PROJECTION);
		glLoadIdentity();
		gluPerspective(45.0f, (GLdouble)cx/cy, 3.0f, 7.0f);
		glMatrixMode(GL_MODELVIEW);
	}
	
	CClientDC dc(this);
	TIPDrawScene(&dc);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
}

void CCubeView::OnTimer(UINT nIDEvent)
{
	CString str_val;

	if (status == EDGE_TUNE) {
		switch (status2) {
			case SCALE_DOWN:
				cur_sigma -= 0.05;
				if (cur_sigma < 0.1) cur_sigma = 0.1;
				str_val.Format("%.1f", cur_sigma);
				dlg->SetDlgItemText(IDC_STATIC4, str_val);
				dlg->m_Scale_Scroll.SetScrollPos((int)(cur_sigma*10));
				break;
			case SCALE_UP:
				cur_sigma += 0.05;
				if (cur_sigma > max_cur_sigma) cur_sigma = max_cur_sigma;
				str_val.Format("%.1f", cur_sigma);
				dlg->SetDlgItemText(IDC_STATIC4, str_val);
				dlg->m_Scale_Scroll.SetScrollPos((int)(cur_sigma*10));
				break;
			case HI_THRES_DOWN:
				hi_thres -= 0.005;
				if (hi_thres < 0.0) hi_thres = 0.0;
				str_val.Format("%.2f", hi_thres);
				dlg->SetDlgItemText(IDC_STATIC_HTHRES, str_val);
				dlg->m_scrollbar_hthres.SetScrollPos((int)(hi_thres*100));
				break;
			case HI_THRES_UP:
				hi_thres += 0.005;
				if (hi_thres > max_hi_thres) hi_thres = max_hi_thres;
				str_val.Format("%.2f", hi_thres);
				dlg->SetDlgItemText(IDC_STATIC_HTHRES, str_val);
				dlg->m_scrollbar_hthres.SetScrollPos((int)(hi_thres*100));
				break;
			case LO_THRES_DOWN:
				lo_thres -= 0.005;
				if (lo_thres < 0.0) lo_thres = 0.0;
				str_val.Format("%.2f", lo_thres);
				dlg->SetDlgItemText(IDC_STATIC_LTHRES, str_val);
				dlg->m_scrollbar_lthres.SetScrollPos((int)(lo_thres*100));
				break;
			case LO_THRES_UP:
				lo_thres += 0.005;
				if (lo_thres > max_lo_thres) lo_thres = max_lo_thres;
				str_val.Format("%.2f", lo_thres);
				dlg->SetDlgItemText(IDC_STATIC_LTHRES, str_val);
				dlg->m_scrollbar_lthres.SetScrollPos((int)(lo_thres*100));
				break;
			case SIZE_DOWN:
				MASK_SIZE -= 1;
				if (MASK_SIZE < MIN_MASK_SIZE) MASK_SIZE = MIN_MASK_SIZE;
				str_val.Format("%d", MASK_SIZE);
				dlg->SetDlgItemText(IDC_STATIC_BRUSH, str_val);
				dlg->m_scrollbar_brush.SetScrollPos((int)(MASK_SIZE));
				break;
			case SIZE_UP:
				MASK_SIZE += 1;
				if (MASK_SIZE > MAX_MASK_SIZE) MASK_SIZE = MAX_MASK_SIZE;
				str_val.Format("%d", MASK_SIZE);
				dlg->SetDlgItemText(IDC_STATIC_BRUSH, str_val);
				dlg->m_scrollbar_brush.SetScrollPos((int)(MASK_SIZE));
				break;
		}
		/////////////////////////////////////////////
		CClientDC dc(this);
		double_buffer.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		gau_w = MakeGaussMask(cur_sigma, gau);
		max_grad2 = LocalCanny(IMAGE_X, IMAGE_Y, MASK_SIZE, seed, gray, gray2, gau_w);
		//DrawGrayImage(double_buffer, IMAGE_X, IMAGE_Y, gray2);
		DrawGrayImageMask(double_buffer, IMAGE_X, IMAGE_Y, MASK_SIZE, seed, gray2);
		memDC.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &double_buffer, 0, 0, SRCCOPY);
		DrawBoxMemDC(&double_buffer, MASK_SIZE, seed.x, IMAGE_Y-1-seed.y, 255, 0, 255);
		//NonmaxSuppressMask(IMAGE_X, IMAGE_Y);
		dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &double_buffer, 0, 0, SRCCOPY);
	}
	//DrawScene();

	CView::OnTimer(nIDEvent);

	// Eat spurious WM_TIMER messages
	MSG msg;
	while(::PeekMessage(&msg, m_hWnd, WM_TIMER, WM_TIMER, PM_REMOVE));
}

///////////////////////////////////////////////////////////////
void CCubeView::InitMemDCandBitmap()
{
	CClientDC dc(this);

	////////////////////////////
	// Make memDC OpenGL window!!!
	//OpenGL_Init(&memDC);

	//::ReleaseDC(this->m_hWnd, m_pDC);
	////////////////////////
	// init memDC
	bitmap.DeleteObject();
	bitmap.CreateCompatibleBitmap(&dc, IMAGE_X, IMAGE_Y);
	memDC.CreateCompatibleDC(&dc);
	memDC.SelectObject(&bitmap);
	
	// init double_buffer
    bitmap2.DeleteObject();
	bitmap2.CreateCompatibleBitmap(&dc, IMAGE_X, IMAGE_Y);
	double_buffer.CreateCompatibleDC(&dc);
	double_buffer.SelectObject(&bitmap2);

	memDC2.CreateCompatibleDC(&dc);
	
	bitmap3.DeleteObject();
	bitmap3.CreateCompatibleBitmap(&dc, TEXTURE, TEXTURE);
	memDC3.CreateCompatibleDC(&dc);
	memDC3.SelectObject(&bitmap3);

	memDC4.CreateCompatibleDC(&dc);
}


/////////////////////////////////////////////////////////////////////////////
// GL helper functions

void CCubeView::Init()
{
	PIXELFORMATDESCRIPTOR pfd;
	int         n;
	HGLRC       hrc;
	GLfloat     fMaxObjSize, fAspect;
	GLfloat     fNearPlane, fFarPlane;

	m_pDC = new CClientDC(this); 

	ASSERT(m_pDC != NULL);

	if (!bSetupPixelFormat())
		return;

	n = ::GetPixelFormat(m_pDC->GetSafeHdc());
	::DescribePixelFormat(m_pDC->GetSafeHdc(), n, sizeof(pfd), &pfd);

	CreateRGBPalette();

	hrc = wglCreateContext(m_pDC->GetSafeHdc());
	wglMakeCurrent(m_pDC->GetSafeHdc(), hrc);

	GetClientRect(&m_oldRect);
	glClearDepth(1.0f);
	glEnable(GL_DEPTH_TEST);

	if (m_oldRect.bottom)
		fAspect = (GLfloat)m_oldRect.right/m_oldRect.bottom;
	else    // don't divide by zero, not that we should ever run into that...
		fAspect = 1.0f;
	fNearPlane = 3.0f;
	fFarPlane = 7.0f;
	fMaxObjSize = 3.0f;
	m_fRadius = fNearPlane + fMaxObjSize / 2.0f;

	renderInit();

	// For Cube display
	//glMatrixMode(GL_PROJECTION);
	//glLoadIdentity();
	//gluPerspective(45.0f, fAspect, fNearPlane, fFarPlane);
	//glMatrixMode(GL_MODELVIEW);
}

BOOL CCubeView::bSetupPixelFormat()
{
	static PIXELFORMATDESCRIPTOR pfd =
	{
		sizeof(PIXELFORMATDESCRIPTOR),  // size of this pfd
		1,                              // version number
		PFD_DRAW_TO_WINDOW |            // support window
		  //PFD_SUPPORT_OPENGL,          // support OpenGL
		  PFD_SUPPORT_OPENGL |          // support OpenGL
		  PFD_DOUBLEBUFFER,             // double buffered
		PFD_TYPE_RGBA,                  // RGBA type
		24,                             // 24-bit color depth
		0, 0, 0, 0, 0, 0,               // color bits ignored
		0,                              // no alpha buffer
		0,                              // shift bit ignored
		0,                              // no accumulation buffer
		0, 0, 0, 0,                     // accum bits ignored
		32,                             // 32-bit z-buffer
		0,                              // no stencil buffer
		0,                              // no auxiliary buffer
		PFD_MAIN_PLANE,                 // main layer
		0,                              // reserved
		0, 0, 0                         // layer masks ignored
	};
	int pixelformat;

	if ( (pixelformat = ChoosePixelFormat(m_pDC->GetSafeHdc(), &pfd)) == 0 )
	{
		MessageBox("ChoosePixelFormat failed");
		return FALSE;
	}

	if (SetPixelFormat(m_pDC->GetSafeHdc(), pixelformat, &pfd) == FALSE)
	{
		MessageBox("SetPixelFormat failed");
		return FALSE;
	}

	return TRUE;
}

unsigned char CCubeView::ComponentFromIndex(int i, UINT nbits, UINT shift)
{
	unsigned char val;

	val = (unsigned char) (i >> shift);
	switch (nbits)
	{

	case 1:
		val &= 0x1;
		return oneto8[val];
	case 2:
		val &= 0x3;
		return twoto8[val];
	case 3:
		val &= 0x7;
		return threeto8[val];

	default:
		return 0;
	}
}


void CCubeView::CreateRGBPalette()
{
	PIXELFORMATDESCRIPTOR pfd;
	LOGPALETTE *pPal;
	int n, i;

	n = ::GetPixelFormat(m_pDC->GetSafeHdc());
	::DescribePixelFormat(m_pDC->GetSafeHdc(), n, sizeof(pfd), &pfd);

	if (pfd.dwFlags & PFD_NEED_PALETTE)
	{
		n = 1 << pfd.cColorBits;
		pPal = (PLOGPALETTE) new char[sizeof(LOGPALETTE) + n * sizeof(PALETTEENTRY)];

		ASSERT(pPal != NULL);

		pPal->palVersion = 0x300;
		pPal->palNumEntries = n;
		for (i=0; i<n; i++)
		{
			pPal->palPalEntry[i].peRed =
					ComponentFromIndex(i, pfd.cRedBits, pfd.cRedShift);
			pPal->palPalEntry[i].peGreen =
					ComponentFromIndex(i, pfd.cGreenBits, pfd.cGreenShift);
			pPal->palPalEntry[i].peBlue =
					ComponentFromIndex(i, pfd.cBlueBits, pfd.cBlueShift);
			pPal->palPalEntry[i].peFlags = 0;
		}

		/* fix up the palette to include the default GDI palette */
		if ((pfd.cColorBits == 8)                           &&
			(pfd.cRedBits   == 3) && (pfd.cRedShift   == 0) &&
			(pfd.cGreenBits == 3) && (pfd.cGreenShift == 3) &&
			(pfd.cBlueBits  == 2) && (pfd.cBlueShift  == 6)
		   )
		{
			for (i = 1 ; i <= 12 ; i++)
				pPal->palPalEntry[defaultOverride[i]] = defaultPalEntry[i];
		}

		m_cPalette.CreatePalette(pPal);
		delete pPal;

		m_pOldPalette = m_pDC->SelectPalette(&m_cPalette, FALSE);
		m_pDC->RealizePalette();
	}
}

void CCubeView::DrawScene(void)
{
	static BOOL     bBusy = FALSE;
	static GLfloat  wAngleY = 10.0f;
	static GLfloat  wAngleX = 1.0f;
	static GLfloat  wAngleZ = 5.0f;

	if(bBusy)
		return;
	bBusy = TRUE;

	glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	glPushMatrix();

		glTranslatef(0.0f, 0.0f, -m_fRadius);
		glRotatef(wAngleX, 1.0f, 0.0f, 0.0f);
		glRotatef(wAngleY, 0.0f, 1.0f, 0.0f);
		glRotatef(wAngleZ, 0.0f, 0.0f, 1.0f);

		wAngleX += 1.0f;
		wAngleY += 10.0f;
		wAngleZ += 5.0f;


		glBegin(GL_QUAD_STRIP);
			glColor3f(1.0f, 0.0f, 1.0f);
			glVertex3f(-0.5f, 0.5f, 0.5f);

			glColor3f(1.0f, 0.0f, 0.0f);
			glVertex3f(-0.5f, -0.5f, 0.5f);

			glColor3f(1.0f, 1.0f, 1.0f);
			glVertex3f(0.5f, 0.5f, 0.5f);

			glColor3f(1.0f, 1.0f, 0.0f);
			glVertex3f(0.5f, -0.5f, 0.5f);

			glColor3f(0.0f, 1.0f, 1.0f);
			glVertex3f(0.5f, 0.5f, -0.5f);

			glColor3f(0.0f, 1.0f, 0.0f);
			glVertex3f(0.5f, -0.5f, -0.5f);

			glColor3f(0.0f, 0.0f, 1.0f);
			glVertex3f(-0.5f, 0.5f, -0.5f);

			glColor3f(0.0f, 0.0f, 0.0f);
			glVertex3f(-0.5f, -0.5f,  -0.5f);

			glColor3f(1.0f, 0.0f, 1.0f);
			glVertex3f(-0.5f, 0.5f, 0.5f);

			glColor3f(1.0f, 0.0f, 0.0f);
			glVertex3f(-0.5f, -0.5f, 0.5f);

		glEnd();

		glBegin(GL_QUADS);
			glColor3f(1.0f, 0.0f, 1.0f);
			glVertex3f(-0.5f, 0.5f, 0.5f);

			glColor3f(1.0f, 1.0f, 1.0f);
			glVertex3f(0.5f, 0.5f, 0.5f);

			glColor3f(0.0f, 1.0f, 1.0f);
			glVertex3f(0.5f, 0.5f, -0.5f);

			glColor3f(0.0f, 0.0f, 1.0f);
			glVertex3f(-0.5f, 0.5f, -0.5f);
		glEnd();

		glBegin(GL_QUADS);
			glColor3f(1.0f, 0.0f, 0.0f);
			glVertex3f(-0.5f, -0.5f, 0.5f);

			glColor3f(1.0f, 1.0f, 0.0f);
			glVertex3f(0.5f, -0.5f, 0.5f);

			glColor3f(0.0f, 1.0f, 0.0f);
			glVertex3f(0.5f, -0.5f, -0.5f);

			glColor3f(0.0f, 0.0f, 0.0f);
			glVertex3f(-0.5f, -0.5f,  -0.5f);
		glEnd();

	glPopMatrix();

	glFinish();
	SwapBuffers(wglGetCurrentDC());

	bBusy = FALSE;
}

BOOL CCubeView::OnEraseBkgnd(CDC* pDC)
{
	return TRUE;
}

void swap(void)
{
    SwapBuffers(wglGetCurrentDC());
}

void CCubeView::OnFileOpen() 
{
	// TODO: Add your command handler code here
	CString str;
	//CFileDialog dlg(TRUE, "CFG Files", "*.cfg");
	CFileDialog dlg2(TRUE, "BMP Files", "*.bmp");

	if (dlg2.DoModal() == IDOK) {
		status = NO_STATUS;
		
		str = dlg2.GetPathName();

		file_loaded = 1;
		LoadImageBMP((char *)LPCTSTR(str));
		
        int size_x, size_y;

		size_x = IMAGE_X;
		size_y = IMAGE_Y;
		TRACE("%d %d", size_x, size_y);

		GetParentFrame()->SetWindowPos(NULL, 0, 0, size_x+CHILDFRM_RIGHT_BAR_WIDTH, 
			size_y+CHILDFRM_TITLE_BAR_WIDTH, SWP_NOMOVE);
		GetParentFrame()->SetWindowText(LPCTSTR(str));
		AfxGetMainWnd()->SetWindowText("Paint");

		Invalidate(FALSE);

		/*
		CRect rect, rect2;
		GetParentFrame()->GetWindowRect(rect);
		TRACE("rect.left = %d\n", rect.left);
		TRACE("rect.right = %d\n", rect.right);
		TRACE("rect.top = %d\n", rect.top);
		TRACE("rect.bottom = %d\n", rect.bottom);
		//dlg->GetWindowRect(rect2); 
		//dlg.MoveWindow(rect.right, rect.top, rect2.right-rect2.left, rect2.bottom-rect2.top, TRUE);
		//dlg.MoveWindow(rect.right, rect.top, dlg_rect.right-dlg_rect.left, dlg_rect.bottom-dlg_rect.top, TRUE);
		dlg->GetWindowRect(rect2); 
		//dlg_rect = rect;
		dlg->MoveWindow(rect.right, rect.top, rect2.right-rect2.left, rect2.bottom-rect2.top, TRUE);
		*/
		//////////////////////////////////////////////
		GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
		/*
		gray2.init(IMAGE_X, IMAGE_Y);
		tmp_x.init(IMAGE_X, IMAGE_Y);
		tmp_y.init(IMAGE_X, IMAGE_Y);
		G_x.init(IMAGE_X, IMAGE_Y);
		G_y.init(IMAGE_X, IMAGE_Y);
		G_mag.init(IMAGE_X, IMAGE_Y);
		thin_edge.init(IMAGE_X, IMAGE_Y);
		scale_map.init(IMAGE_X, IMAGE_Y);
		scale_map.set_all(cur_sigma);
        off_mark.init(IMAGE_X, IMAGE_Y);
		on_mark.init(IMAGE_X, IMAGE_Y);
		pixel_mark.init(IMAGE_X, IMAGE_Y);
		off_mark.zero();
		on_mark.zero();
		pixel_mark.zero();
		*/
		//gau_w = MakeGaussMask(cur_sigma, gau);
		//gau_w = MakeGaussMask(1.0, gau); // fix the maximum gradient with minimum scale!!!
		//max_grad2 = GetCannyGradient(IMAGE_X, IMAGE_Y, gray, gau_w);
		GLOBAL_CANNY_DONE = 0; 
		TRACE("cur_sigma = %f\n", cur_sigma);
		TRACE("max_grad2 = %f\n", max_grad2);
		/////////////////////////////////////////////////
		
	}	
	
	//pDC->BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	CClientDC dc(this);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//renderImage();
	//swap();
}

void CCubeView::LoadImageBMP(char *filename)
// Open BMP file
{
    int x, y;
	GLubyte r, g, b;
//	FILE *fp;

	//////////////////////////////////
	cur_file_name = filename;
	/////////////////////////////////

	LoadBMP((char *)LPCTSTR(filename), &memDC);
	IMAGE_X = m_Image.GetWidth();
	IMAGE_Y = m_Image.GetHeight();

	CClientDC dc(this);
	//bitmap.DeleteObject();
	//bitmap.CreateCompatibleBitmap(&dc, IMAGE_X, IMAGE_Y);
	//memDC.SelectObject(&bitmap);

	/// This is for double buffer
	bitmap2.DeleteObject();
	bitmap2.CreateCompatibleBitmap(&dc, IMAGE_X, IMAGE_Y);
	double_buffer.SelectObject(&bitmap2);

	// This is for memDC2
	bitmap3.DeleteObject();
	bitmap3.CreateCompatibleBitmap(&dc, IMAGE_X, IMAGE_Y);
	memDC2.SelectObject(&bitmap3);

	Dbuffer = new GLubyte [IMAGE_Y * IMAGE_X * 3];
	
	//CClientDC	dc(this);
	//memDC.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &dc, 0, 0, SRCCOPY);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	
	// Reverse the vertical for the OpenGL window
	for (y = IMAGE_Y - 1; y >= 0; y--) {
	//for (y = 0; y < IMAGE_Y; y++) {
		for (x = 0; x < IMAGE_X; x++) {
			COLORREF rgbcol = memDC.GetPixel(x, (IMAGE_Y-1)-y);
			r = (GLubyte)RGB_GETRED(rgbcol);
			g = (GLubyte)RGB_GETGREEN(rgbcol);
			b = (GLubyte)RGB_GETBLUE(rgbcol);
			Dbuffer[(y * IMAGE_X + x) * 3 + 0] = r;
			Dbuffer[(y * IMAGE_X + x) * 3 + 1] = g;
			Dbuffer[(y * IMAGE_X + x) * 3 + 2] = b;
			/// Set Pixel in MemDC
			//memDC.SetPixelV(x, (IMAGE_Y-1)-y, RGB(r, g, b));
		}
	}
}


void CCubeView::OnPaintRandomDescent()
{
	// TODO: Add your command handler code here
	// TODO: Add your command handler code here
	GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	max_grad = getGradient(IMAGE_X, IMAGE_Y, gradient, image);
	//max_grad = getSobelGradient(IMAGE_X, IMAGE_Y, gradient, image);
	///////////////////////////////////////////////////////////////////
	// Blurred gradient to control the stroke length
	//max_grad = getBlurredGradient(IMAGE_X, IMAGE_Y, gradient, image, 1); 
	InitGradField(IMAGE_X, IMAGE_Y, gfield, image);
	//AlignGradient(IMAGE_X, IMAGE_Y, gfield, 10);
	//AlignGradient(IMAGE_X, IMAGE_Y, gfield, 10);
	//AlignGradient(IMAGE_X, IMAGE_Y, gfield, 10);
	GVF(IMAGE_X, IMAGE_Y, gfield, 50);
	//max_grad = getBlurredGradient(IMAGE_X, IMAGE_Y, gradient, image, 5); 
	
	//DrawImage(IMAGE_X, IMAGE_Y, gradient);	
	//ImagetoNodesNPR(IMAGE_X, IMAGE_Y, image, max_grad, gradient);
	//InitNodesNPR(IMAGE_X, IMAGE_Y);
	CClientDC dc(this);
	//DrawStrokesRandomOrdered(dc, IMAGE_X, IMAGE_Y);
	//DrawStrokesHertzmannRandom(dc, IMAGE_X, IMAGE_Y);
	//DrawStrokesHertzmannOriented(dc, IMAGE_X, IMAGE_Y, gfield); // RASC version
	DrawStrokesHertzmannOrientedAlpha(dc, IMAGE_X, IMAGE_Y, gfield); // RASC version
	//DrawGradientField(dc, IMAGE_X, IMAGE_Y, gfield);
	//TRACE("Mean = %.1f\n", );
	//double mean = Get_mean();
	//TRACE("Variance = %.1f\n", variance(mean));
}

void CCubeView::OnPaintGeneticpainter()
{
	// TODO: Add your command handler code here
}

void CCubeView::OnCurveFreehand()
{
	// TODO: Add your command handler code here
	status = FREEHAND_CURVE;
	ClearMemDC(&memDC);
	TRACE("status = FREEHAND_CURVE\n");
}

///*
void CCubeView::OnIpenExternal()
{
	// TODO: Add your command handler code here
	GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	max_grad = getGradient(IMAGE_X, IMAGE_Y, gradient, image);
	CClientDC dc(this);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	renderImage();
	swap();

	//CClientDC dc(this);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);		

	status = IPEN_EXTERNAL;

	pc = -1; // pen counter = -1;

	//disp_x = disp_y = 0;
}

void CCubeView::OnIpenOutline()
{
	int x, y;
	GLubyte r, g, b;

	// TODO: Add your command handler code here
	int index = cur_file_name.find(".bmp");
	cur_file_name.replace(index, 4, "_sketch.bmp");

	if ( LoadBMP((char *)LPCTSTR(cur_file_name.c_str()), &memDC2) )
	{
		Maskbuffer = new GLubyte [IMAGE_Y * IMAGE_X * 3];
		// Reverse the vertical for the OpenGL window
		for (y = 0; y < IMAGE_Y; y++) {
			for (x = 0; x < IMAGE_X; x++) {
				COLORREF rgbcol = memDC2.GetPixel(x, (IMAGE_Y-1)-y);
				r = (GLubyte)RGB_GETRED(rgbcol);
				g = (GLubyte)RGB_GETGREEN(rgbcol);
				b = (GLubyte)RGB_GETBLUE(rgbcol);
				Maskbuffer[(y * IMAGE_X + x) * 3 + 0] = r;
				Maskbuffer[(y * IMAGE_X + x) * 3 + 1] = g;
				Maskbuffer[(y * IMAGE_X + x) * 3 + 2] = b;
				/// Set Pixel in MemDC
				//memDC.SetPixelV(x, (IMAGE_Y-1)-y, RGB(r, g, b));
			}
		}
	}

	//GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	GetImage(IMAGE_X, IMAGE_Y, image, Maskbuffer);
	max_grad = getGradient(IMAGE_X, IMAGE_Y, gradient, image);
	//CClientDC dc(this);
	//LoadBMP((char *)LPCTSTR("_maple3.bmp"), &memDC);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	renderImage();
	swap();

	delete[] Maskbuffer;
	//CClientDC dc(this);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);		

	status = IPEN_EXTERNAL;

	pc = -1; // pen counter = -1;

}



void CCubeView::OnIpenInternal()
{
	// TODO: Add your command handler code here
	GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	max_grad = getGradient(IMAGE_X, IMAGE_Y, gradient, image);
	InitGradField(IMAGE_X, IMAGE_Y, gfield, image);
	//GVF(IMAGE_X, IMAGE_Y, gfield, 50);
	//GVF(IMAGE_X, IMAGE_Y, gfield, 10);
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.01); // for sketch
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.1); // for original picture
	GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.01); // for sketch
	//GVF(IMAGE_X, IMAGE_Y, gfield, 200);
	renderImage();
	swap();

	/*
	for (int i = 0; i < IMAGE_X; i++)
		for (int j = 0; j < IMAGE_Y; j++) {
			TRACE("[%d, %d] gx = %.2f, gy = %.2f\n", i, j, gfield[i][j].gx, gfield[i][j].gy);
		}
	*/

	CClientDC dc(this);
	//DrawGradientField(dc, IMAGE_X, IMAGE_Y, gfield);
	//DrawGradientField2(dc, IMAGE_X, IMAGE_Y, gfield);
	//DrawGradientField_LIC(dc, IMAGE_X, IMAGE_Y, gfield, 10);
	DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 20);
	
	//CClientDC dc(this);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);		

	status = IPEN_INTERNAL;

	pc = -1; // pen counter = -1;

}


void CCubeView::OnIpenEdit()
{
	// TODO: Add your command handler code here
	status = STROKE_EDIT;
}



//void CCubeView::OnMButtonDown(UINT nFlags, CPoint point)
//{
//	// TODO: Add your message handler code here and/or call default
//
//	CView::OnMButtonDown(nFlags, point);
//}

void CCubeView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	// TODO: Add your message handler code here and/or call default
	//key_input(nChar); // you can enable repeating key effect while pressing it down

	CView::OnKeyDown(nChar, nRepCnt, nFlags);
}


void CCubeView::OnIpenEditindiv()
{
	// TODO: Add your command handler code here
	status = STROKE_EDIT_INDIV;
}

cimatrix	cmap, cmap2;
imatrix		gray, gray2, emap, gray3, dog;
imatrix		off_mark, on_mark;
imatrix		pixel_mark;

void CCubeView::OnEdgeCanny()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	//GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	//GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//DrawGrayImage(dc, IMAGE_X, IMAGE_Y, gray); 
	//max_grad = getGradient(IMAGE_X, IMAGE_Y, gradient, image);
	//DrawImage(IMAGE_X, IMAGE_Y, image);
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, image);
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.1); // for original picture
	//renderImage();
	//swap();
	cur_sigma = 1.0;
	gau_w = MakeGaussMask(cur_sigma, gau);
	//GaussSmooth(IMAGE_X, IMAGE_Y, image, gau_w);
	GlobalCanny(IMAGE_X, IMAGE_Y, gray, gray2, gau_w);
	//NonmaxSuppressGray(IMAGE_X, IMAGE_Y);
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
	
	//NonmaxSuppress(IMAGE_X, IMAGE_Y);
	//DrawImage(dc, IMAGE_X, IMAGE_Y, image); 
		
	//CClientDC dc(this);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);		

}

double cur_sigma;
double max_cur_sigma;
double hi_thres;
double max_hi_thres;
double lo_thres;
double max_lo_thres;
double factor1, factor2;
int	MASK_SIZE;
int MAX_MASK_SIZE, MIN_MASK_SIZE;

void CCubeView::OnEdgePaint()
{
	// TODO: Add your command handler code here
	//GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	if (file_loaded) {
		//CClientDC dc(this);
		//GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
		//cur_sigma = 1.0;
		//dlg->m_Scale_Scroll.SetScrollPos((int)(cur_sigma*10));
		//dlg->m_slider.SetScrollPos(SB_HORZ, (int)(cur_sigma*10), TRUE);
		//dlg->m_scale_val;
		//gau_w = MakeGaussMask(3.0, gau);
		//GaussSmooth(IMAGE_X, IMAGE_Y, image, gau_w);
		//max_grad2 = GlobalCanny(IMAGE_X, IMAGE_Y, gray, gray2, gau_w);
		//NonmaxSuppressGray(IMAGE_X, IMAGE_Y);
		//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
		//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		
		//dlg.Create(IDD_DIALOG1);
		//dlg.ShowWindow(1);
		//dlg.SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOMOVE);
		//CRect rect;
		//dlg.GetWindowRect(rect); 
		//dlg.MoveWindow(0, 0, rect.right-rect.left, rect.bottom-rect.top, TRUE);
		status = EDGE_PAINT;
	}
}

void CCubeView::OnEdgeBoost()
{
	// TODO: Add your command handler code here
		
	status = EDGE_TUNE;
	//OnGlobalCanny(dc, IMAGE_X, IMAGE_Y, gray, gray2);
}

void CCubeView::OnIpenPaint()
{
	// TODO: Add your command handler code here
	GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	max_grad = getGradient(IMAGE_X, IMAGE_Y, gradient, image);
	InitGradField(IMAGE_X, IMAGE_Y, gfield, image);
	//GVF(IMAGE_X, IMAGE_Y, gfield, 50);
	//GVF(IMAGE_X, IMAGE_Y, gfield, 10);
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 150, 0.01); // for sketch
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.01); // for sketch
	GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.1); // for original picture
	//GVF(IMAGE_X, IMAGE_Y, gfield, 200);
	renderImage();
	swap();

	//LoadImageBMP("beach_ball.bmp");
	//LoadImageBMP("beach_ball_gray.bmp");
	//LoadImageBMP("beach_ball_pen_ink.bmp");
	//LoadImageBMP("beach_ball_pen_ink2.bmp");

	CClientDC dc(this);
	//DrawGradientField(dc, IMAGE_X, IMAGE_Y, gfield);
	//DrawGradientField2(dc, IMAGE_X, IMAGE_Y, gfield);
	//DrawGradientField_LIC(dc, IMAGE_X, IMAGE_Y, gfield, 10);
	//DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 20);
	//DrawStrokesHertzmannOrientedAlpha(dc, IMAGE_X, IMAGE_Y, gfield);
	DrawStrokesHertzmannOrientedCurvedVector(dc, IMAGE_X, IMAGE_Y, gfield, 20, 60, 10); 
	//DrawStrokesCurvedTextured(dc, IMAGE_X, IMAGE_Y, gfield, 5, 50, 10); 
	//DrawStrokesCurvedTexturedPenInk(dc, IMAGE_X, IMAGE_Y, gfield, 10, 30); 
		
	//CClientDC dc(this);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);		

	//status = IPEN_INTERNAL;

	//pc = -1; // pen counter = -1;
}


void CCubeView::OnIpenGvf()
{
	// TODO: Add your command handler code here
	GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	max_grad = getGradient(IMAGE_X, IMAGE_Y, gradient, image);
	//max_grad = getSobelGradient(IMAGE_X, IMAGE_Y, gradient, image);
	///////////////////////////////////////////////////////////////////
	// Blurred gradient to control the stroke length
	//max_grad = getBlurredGradient(IMAGE_X, IMAGE_Y, gradient, image, 1); 
	InitGradField(IMAGE_X, IMAGE_Y, gfield, image);
	//AlignGradient(IMAGE_X, IMAGE_Y, gfield, 10);
	//GVF(IMAGE_X, IMAGE_Y, gfield, 50);
	//GVF(IMAGE_X, IMAGE_Y, gfield, 200);
	//GVF(IMAGE_X, IMAGE_Y, gfield, 100);
	GVF2(IMAGE_X, IMAGE_Y, gfield, 150, 0.1); // for original picture
	//max_grad = getBlurredGradient(IMAGE_X, IMAGE_Y, gradient, image, 5); 
	
	CClientDC dc(this);
	//DrawStrokesRandomOrdered(dc, IMAGE_X, IMAGE_Y);
	//DrawStrokesHertzmannRandom(dc, IMAGE_X, IMAGE_Y);
	//DrawStrokesHertzmannOriented(dc, IMAGE_X, IMAGE_Y, gfield); // RASC version
	//DrawStrokesHertzmannOrientedAlpha(dc, IMAGE_X, IMAGE_Y, gfield); // RASC version
	DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 20);
	//DrawGradientField(dc, IMAGE_X, IMAGE_Y, gfield);
}

void CCubeView::OnIpenBilateral2()
{
	// TODO: Add your command handler code here
	renderImage();
	swap();

	CClientDC dc(this);
	GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	max_grad = getGradient(IMAGE_X, IMAGE_Y, gradient, image);
	InitGradField(IMAGE_X, IMAGE_Y, gfield, image);
	//GVF(IMAGE_X, IMAGE_Y, gfield, 50);
	//GVF(IMAGE_X, IMAGE_Y, gfield, 10);
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.01); // for sketch
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.1); // for original picture

	/*
	LoadBMP((char *)LPCTSTR("rushmore_emap7.bmp"), &memDC2);
	//Backbuffer = new GLubyte [IMAGE_Y * IMAGE_X * 3];
	//////////////////////////////////////////////////////////////
	// Copy memDC2 to Backbuffer
	///*
	for (y = 0; y < IMAGE_Y; y++) {
		for (x = 0; x < IMAGE_X; x++) {
			r = (GLubyte)RGB_GETRED(memDC2.GetPixel(x, y));
			g = (GLubyte)RGB_GETGREEN(memDC2.GetPixel(x, y));
			b = (GLubyte)RGB_GETBLUE(memDC2.GetPixel(x, y));
			gray2[x][IMAGE_Y-1-y] = r;
			//Backbuffer[((IMAGE_Y-1-y) * IMAGE_X + x) * 3 + 0] = r;
			//Backbuffer[((IMAGE_Y-1-y) * IMAGE_X + x) * 3 + 1] = g;
			//Backbuffer[((IMAGE_Y-1-y) * IMAGE_X + x) * 3 + 2] = b;
		}
	}
	*/
	
	///*
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//////////////////////////////
	// for peppers
	//cur_sigma = 1.6;
	//hi_thres = 0.11;
	//lo_thres = 0.7;
	////////////////////////////////
	gau_w = MakeGaussMask(cur_sigma, gau);
	max_grad2 = GlobalCanny(IMAGE_X, IMAGE_Y, gray, gray2, gau_w);
	//*/

	/////////////////////////////////////////////////
	//DistanceField(IMAGE_X, IMAGE_Y, gray2, 3.0);
	//DistanceField(IMAGE_X, IMAGE_Y, gray2, 5.0);
	DistanceField(IMAGE_X, IMAGE_Y, gray2, 6.0);
	//DistanceField(IMAGE_X, IMAGE_Y, gray2, 10.0);
	//DistanceField(IMAGE_X, IMAGE_Y, gray2, 1.0);
	//InvertImage(IMAGE_X, IMAGE_Y, gray2);
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);

	///////////////////////////////////////////////////////////////
	/*
	AdaptiveGaussianBlur(memDC, IMAGE_X, IMAGE_Y, 2.0);
	//AdaptiveGaussianBlur(memDC, IMAGE_X, IMAGE_Y, 3.0);
	//AdaptiveGaussianBlur(memDC, IMAGE_X, IMAGE_Y, 1.5);
	glRasterPos2i(0, 0);
	glDrawPixels(IMAGE_X, IMAGE_Y, GL_RGB, GL_UNSIGNED_BYTE, Backbuffer);
	swap();
	*/
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	/////////////////////////////////////////////////
	// direction field
	///*
	//BilateralGfield3(IMAGE_X, IMAGE_Y, gfield, 1.5, 1.0, 5); // wide range of masking
	//BilateralGfield3(IMAGE_X, IMAGE_Y, gfield, 1.5, 1.0, 6); // wide range of masking
	BilateralGfield3(IMAGE_X, IMAGE_Y, gfield, 2.0, 1.0, 6); // wide range of masking
	//BilateralGfield3(IMAGE_X, IMAGE_Y, gfield, 0.3, 1.0, 30); // similar to GVF
	//BilateralGfield3(IMAGE_X, IMAGE_Y, gfield, 0.3, 1.0, 10); // similar to GVF
	DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 20);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//*/
	////////////////////////////////////////////////////////

	//BilateralGfield3(IMAGE_X, IMAGE_Y, gfield, 3.5, 1.0, 1); // wide range of masking
	//BilateralGfield3(IMAGE_X, IMAGE_Y, gfield, 0.3, 1.0, 15); // similar to GVF
	//BilateralGfield2(IMAGE_X, IMAGE_Y, gfield, 1.0, 1.0, 1);
	//BilateralGfield(IMAGE_X, IMAGE_Y, gfield, 0.5, 1.0, 20);
	//GVF(IMAGE_X, IMAGE_Y, gfield, 200);
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.01); // for sketch
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.15); // for sketch
	//GVF3(IMAGE_X, IMAGE_Y, gfield, 100, 0.2); // for sketch
	
}


void CCubeView::OnIpenPaint2()
{
	int x, y;
	GLubyte r, g, b;

	// TODO: Add your command handler code here
	GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	max_grad = getGradient(IMAGE_X, IMAGE_Y, gradient, image);
	InitGradField(IMAGE_X, IMAGE_Y, gfield, image);
	//GVF(IMAGE_X, IMAGE_Y, gfield, 50);
	//GVF(IMAGE_X, IMAGE_Y, gfield, 10);
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 150, 0.01); // for sketch
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.01); // for sketch
	//////////////////////////////////////////////////////////////////
	// This one is the best
	GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.1); // for original picture
	////////////////////////////////////////////////////////////////////
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 10, 0.1); // for original picture
	//GVF(IMAGE_X, IMAGE_Y, gfield, 200);
	renderImage();
	swap();

	//LoadBMP((char *)LPCTSTR("rushmore_emap.bmp"), &memDC2);
	LoadBMP((char *)LPCTSTR("rushmore_emap7.bmp"), &memDC2);
	//Backbuffer = new GLubyte [IMAGE_Y * IMAGE_X * 3];
	//////////////////////////////////////////////////////////////
	// Copy memDC2 to Backbuffer
	///*
	for (y = 0; y < IMAGE_Y; y++) {
		for (x = 0; x < IMAGE_X; x++) {
			r = (GLubyte)RGB_GETRED(memDC2.GetPixel(x, y));
			g = (GLubyte)RGB_GETGREEN(memDC2.GetPixel(x, y));
			b = (GLubyte)RGB_GETBLUE(memDC2.GetPixel(x, y));
			gray2[x][IMAGE_Y-1-y] = r;
			//Backbuffer[((IMAGE_Y-1-y) * IMAGE_X + x) * 3 + 0] = r;
			//Backbuffer[((IMAGE_Y-1-y) * IMAGE_X + x) * 3 + 1] = g;
			//Backbuffer[((IMAGE_Y-1-y) * IMAGE_X + x) * 3 + 2] = b;
		}
	}
	//*/
	////////////////////////////////////////////////////////////////////
	//GetImage(IMAGE_X, IMAGE_Y, gray2, Backbuffer); // from Backbuffer to image: for mosaic

	CClientDC dc(this);
	/*
	if (GLOBAL_CANNY_DONE == 0) {
		GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
		gau_w = MakeGaussMask(cur_sigma, gau);
		max_grad2 = GlobalCanny(IMAGE_X, IMAGE_Y, gray, gray2, gau_w);
	}
	*/
	//DistanceField(IMAGE_X, IMAGE_Y, gray2, 3.0);
	DistanceField(IMAGE_X, IMAGE_Y, gray2, 5.0);
	//DistanceField(IMAGE_X, IMAGE_Y, gray2, 2.0);
	//DistanceField(IMAGE_X, IMAGE_Y, gray2, 1.0);
	//InvertImage(IMAGE_X, IMAGE_Y, gray2);
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);

	/////////////////////////////////////////////////////////////
	//DrawColorSelected(dc, IMAGE_X, IMAGE_Y);
	DrawStrokesAdaptive2(dc, IMAGE_X, IMAGE_Y, gfield); 
	//DrawStrokesCurvedTexturedWater(dc, IMAGE_X, IMAGE_Y, gfield); 
	//DrawStrokesAdaptiveCartoon(dc, IMAGE_X, IMAGE_Y, gfield); 
	//DrawStrokesAdaptivePenInk(dc, IMAGE_X, IMAGE_Y, gfield); 
	
	//CClientDC dc(this);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);		

	//status = IPEN_INTERNAL;

	//pc = -1; // pen counter = -1;
}


void CCubeView::OnIpenCartoon()
{
	// TODO: Add your command handler code here
		GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	max_grad = getGradient(IMAGE_X, IMAGE_Y, gradient, image);
	InitGradField(IMAGE_X, IMAGE_Y, gfield, image);
	//GVF(IMAGE_X, IMAGE_Y, gfield, 50);
	//GVF(IMAGE_X, IMAGE_Y, gfield, 10);
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 150, 0.01); // for sketch
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.01); // for sketch
	//////////////////////////////////////////////////////////////////
	// This one is the best
	GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.1); // for original picture
	////////////////////////////////////////////////////////////////////
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 10, 0.1); // for original picture
	//GVF(IMAGE_X, IMAGE_Y, gfield, 200);
	renderImage();
	swap();

	CClientDC dc(this);
	/////////////////////////////////////////////////////////////
	//DrawColorSelected(dc, IMAGE_X, IMAGE_Y);
	//DrawStrokesAdaptive2(dc, IMAGE_X, IMAGE_Y, gfield); 
	DrawStrokesAdaptiveCartoon(dc, IMAGE_X, IMAGE_Y, gfield); 
	//DrawStrokesAdaptivePenInk(dc, IMAGE_X, IMAGE_Y, gfield); 
	
	//CClientDC dc(this);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);		

	//status = IPEN_INTERNAL;

	//pc = -1; // pen counter = -1;

}

void CCubeView::OnIpenWater()
{
	// TODO: Add your command handler code here
	// TODO: Add your command handler code here
	GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	max_grad = getGradient(IMAGE_X, IMAGE_Y, gradient, image);
	InitGradField(IMAGE_X, IMAGE_Y, gfield, image);
	//GVF(IMAGE_X, IMAGE_Y, gfield, 50);
	//GVF(IMAGE_X, IMAGE_Y, gfield, 10);
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 150, 0.01); // for sketch
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.01); // for sketch
	//////////////////////////////////////////////////////////////////
	// This one is the best
	GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.1); // for original picture
	////////////////////////////////////////////////////////////////////
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 10, 0.1); // for original picture
	//GVF(IMAGE_X, IMAGE_Y, gfield, 200);
	renderImage();
	swap();

	CClientDC dc(this);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	gau_w = MakeGaussMask(cur_sigma, gau);
	max_grad2 = GlobalCanny(IMAGE_X, IMAGE_Y, gray, gray2, gau_w);
	//DistanceField(IMAGE_X, IMAGE_Y, gray2, 3.0);
	//DistanceField(IMAGE_X, IMAGE_Y, gray2, 5.0);
	DistanceField(IMAGE_X, IMAGE_Y, gray2, 2.0);
	//DistanceField(IMAGE_X, IMAGE_Y, gray2, 1.0);
	//InvertImage(IMAGE_X, IMAGE_Y, gray2);
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);

	//LoadImageBMP("beach_ball.bmp");
	//LoadImageBMP("beach_ball_gray.bmp");
	//LoadImageBMP("beach_ball_pen_ink.bmp");
	//LoadImageBMP("beach_ball_pen_ink2.bmp");


	//DrawGradientField(dc, IMAGE_X, IMAGE_Y, gfield);
	//DrawGradientField2(dc, IMAGE_X, IMAGE_Y, gfield);
	//DrawGradientField_LIC(dc, IMAGE_X, IMAGE_Y, gfield, 10);
	//DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 20);
	//DrawStrokesHertzmannOrientedAlpha(dc, IMAGE_X, IMAGE_Y, gfield);
	//DrawStrokesHertzmannOrientedCurvedVector(dc, IMAGE_X, IMAGE_Y, gfield, 20, 60, 10); 
	//DrawStrokesCurvedTextured(dc, IMAGE_X, IMAGE_Y, gfield, 5, 50, 20); 
	DrawStrokesCurvedTexturedWater(dc, IMAGE_X, IMAGE_Y, gfield); 
	//DrawStrokesCurvedTexturedPenInk(dc, IMAGE_X, IMAGE_Y, gfield, 10, 30); 
	//////////////////////////////////////////////
	//DrawStrokesHertzmannOrientedCurvedVector2(dc, IMAGE_X, IMAGE_Y, gfield, 20, 60, 5); 
	//DrawStrokesHertzmannOrientedAlpha(dc, IMAGE_X, IMAGE_Y, gfield); // RASC version
	
	/////////////////////////////////////////////////////////////
	//DrawColorSelected(dc, IMAGE_X, IMAGE_Y);
	//DrawStrokesAdaptive2(dc, IMAGE_X, IMAGE_Y, gfield); 
	
	//CClientDC dc(this);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);		

	//status = IPEN_INTERNAL;

	//pc = -1; // pen counter = -1;
}

void CCubeView::OnIpenPenink()
{
	// TODO: Add your command handler code here
		// TODO: Add your command handler code here
	// TODO: Add your command handler code here
	GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	max_grad = getGradient(IMAGE_X, IMAGE_Y, gradient, image);
	InitGradField(IMAGE_X, IMAGE_Y, gfield, image);
	//GVF(IMAGE_X, IMAGE_Y, gfield, 50);
	//GVF(IMAGE_X, IMAGE_Y, gfield, 10);
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 150, 0.01); // for sketch
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.01); // for sketch
	//////////////////////////////////////////////////////////////////
	// This one is the best
	GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.1); // for original picture
	////////////////////////////////////////////////////////////////////
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 10, 0.1); // for original picture
	//GVF(IMAGE_X, IMAGE_Y, gfield, 200);
	renderImage();
	swap();

	CClientDC dc(this);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	gau_w = MakeGaussMask(cur_sigma, gau);
	max_grad2 = GlobalCanny(IMAGE_X, IMAGE_Y, gray, gray2, gau_w);
	//DistanceField(IMAGE_X, IMAGE_Y, gray2, 3.0);
	//DistanceField(IMAGE_X, IMAGE_Y, gray2, 5.0);
	//DistanceField(IMAGE_X, IMAGE_Y, gray2, 2.0);
	//DistanceField(IMAGE_X, IMAGE_Y, gray2, 1.0);
	//InvertImage(IMAGE_X, IMAGE_Y, gray2);
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);

	//LoadImageBMP("beach_ball.bmp");
	//LoadImageBMP("beach_ball_gray.bmp");
	//LoadImageBMP("beach_ball_pen_ink.bmp");
	//LoadImageBMP("beach_ball_pen_ink2.bmp");


	//DrawGradientField(dc, IMAGE_X, IMAGE_Y, gfield);
	//DrawGradientField2(dc, IMAGE_X, IMAGE_Y, gfield);
	//DrawGradientField_LIC(dc, IMAGE_X, IMAGE_Y, gfield, 10);
	//DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 20);
	//DrawStrokesHertzmannOrientedAlpha(dc, IMAGE_X, IMAGE_Y, gfield);
	//DrawStrokesHertzmannOrientedCurvedVector(dc, IMAGE_X, IMAGE_Y, gfield, 20, 60, 10); 
	//DrawStrokesCurvedTextured(dc, IMAGE_X, IMAGE_Y, gfield, 5, 50, 20); 
	//DrawStrokesCurvedTexturedPenInk(dc, IMAGE_X, IMAGE_Y, gfield, 10, 30); 
	//////////////////////////////////////////////
	//DrawStrokesHertzmannOrientedCurvedVector2(dc, IMAGE_X, IMAGE_Y, gfield, 20, 60, 5); 
	//DrawStrokesAdaptive(dc, IMAGE_X, IMAGE_Y, gfield); 
	
	/////////////////////////////////////////////////////////////
	//DrawColorSelected(dc, IMAGE_X, IMAGE_Y);
	//DrawStrokesAdaptive2(dc, IMAGE_X, IMAGE_Y, gfield); 
	//DrawStrokesAdaptiveCartoon(dc, IMAGE_X, IMAGE_Y, gfield); 
	//DrawStrokesAdaptivePenInk(dc, IMAGE_X, IMAGE_Y, gfield); // normal strokes
	//DrawStrokesAdaptivePenInkPerp(dc, IMAGE_X, IMAGE_Y, gfield); // perpendicular strokes
	DrawStrokesAdaptivePenInkHatch(dc, IMAGE_X, IMAGE_Y, gfield); // both
	
	//CClientDC dc(this);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);		

	//status = IPEN_INTERNAL;

	//pc = -1; // pen counter = -1;

}

void CCubeView::OnIpenStipple()
{
	// TODO: Add your command handler code here
		// TODO: Add your command handler code here
		// TODO: Add your command handler code here
	// TODO: Add your command handler code here
	GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	max_grad = getGradient(IMAGE_X, IMAGE_Y, gradient, image);
	InitGradField(IMAGE_X, IMAGE_Y, gfield, image);
	//GVF(IMAGE_X, IMAGE_Y, gfield, 50);
	//GVF(IMAGE_X, IMAGE_Y, gfield, 10);
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 150, 0.01); // for sketch
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.01); // for sketch
	//////////////////////////////////////////////////////////////////
	// This one is the best
	GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.1); // for original picture
	////////////////////////////////////////////////////////////////////
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 10, 0.1); // for original picture
	//GVF(IMAGE_X, IMAGE_Y, gfield, 200);
	renderImage();
	swap();

	CClientDC dc(this);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	gau_w = MakeGaussMask(cur_sigma, gau);
	max_grad2 = GlobalCanny(IMAGE_X, IMAGE_Y, gray, gray2, gau_w);
	//DistanceField(IMAGE_X, IMAGE_Y, gray2, 3.0);
	//DistanceField(IMAGE_X, IMAGE_Y, gray2, 5.0);
	DistanceField(IMAGE_X, IMAGE_Y, gray2, 2.0);
	//DistanceField(IMAGE_X, IMAGE_Y, gray2, 1.0);
	//InvertImage(IMAGE_X, IMAGE_Y, gray2);
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);

	//LoadImageBMP("beach_ball.bmp");
	//LoadImageBMP("beach_ball_gray.bmp");
	//LoadImageBMP("beach_ball_pen_ink.bmp");
	//LoadImageBMP("beach_ball_pen_ink2.bmp");


	//DrawGradientField(dc, IMAGE_X, IMAGE_Y, gfield);
	//DrawGradientField2(dc, IMAGE_X, IMAGE_Y, gfield);
	//DrawGradientField_LIC(dc, IMAGE_X, IMAGE_Y, gfield, 10);
	//DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 20);
	//DrawStrokesHertzmannOrientedAlpha(dc, IMAGE_X, IMAGE_Y, gfield);
	//DrawStrokesHertzmannOrientedCurvedVector(dc, IMAGE_X, IMAGE_Y, gfield, 20, 60, 10); 
	//DrawStrokesCurvedTextured(dc, IMAGE_X, IMAGE_Y, gfield, 5, 50, 20); 
	//DrawStrokesCurvedTexturedPenInk(dc, IMAGE_X, IMAGE_Y, gfield, 10, 30); 
	//////////////////////////////////////////////
	//DrawStrokesHertzmannOrientedCurvedVector2(dc, IMAGE_X, IMAGE_Y, gfield, 20, 60, 5); 
	//DrawStrokesAdaptive(dc, IMAGE_X, IMAGE_Y, gfield); 
	
	/////////////////////////////////////////////////////////////
	//DrawColorSelected(dc, IMAGE_X, IMAGE_Y);
	//DrawStrokesAdaptive2(dc, IMAGE_X, IMAGE_Y, gfield); 
	//DrawStrokesAdaptiveCartoon(dc, IMAGE_X, IMAGE_Y, gfield); 
	//DrawStrokesAdaptivePenInk(dc, IMAGE_X, IMAGE_Y, gfield); 
	DrawStrokesAdaptiveStipple(dc, IMAGE_X, IMAGE_Y, gfield); 
	
	//CClientDC dc(this);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);		

	//status = IPEN_INTERNAL;

	//pc = -1; // pen counter = -1;

}

void CCubeView::OnIpenOil()
{
	// TODO: Add your command handler code here
	GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	max_grad = getGradient(IMAGE_X, IMAGE_Y, gradient, image);
	InitGradField(IMAGE_X, IMAGE_Y, gfield, image);
	//GVF(IMAGE_X, IMAGE_Y, gfield, 50);
	//GVF(IMAGE_X, IMAGE_Y, gfield, 10);
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 150, 0.01); // for sketch
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.01); // for sketch
	//////////////////////////////////////////////////////////////////
	// This one is the best
	GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.1); // for original picture
	////////////////////////////////////////////////////////////////////
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 10, 0.1); // for original picture
	//GVF(IMAGE_X, IMAGE_Y, gfield, 200);
	renderImage();
	swap();

	CClientDC dc(this);
	if (GLOBAL_CANNY_DONE == 0) {
		GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
		gau_w = MakeGaussMask(cur_sigma, gau);
		max_grad2 = GlobalCanny(IMAGE_X, IMAGE_Y, gray, gray2, gau_w);
	}
	//DistanceField(IMAGE_X, IMAGE_Y, gray2, 3.0);
	//DistanceField(IMAGE_X, IMAGE_Y, gray2, 5.0);
	DistanceField(IMAGE_X, IMAGE_Y, gray2, 2.0);
	//DistanceField(IMAGE_X, IMAGE_Y, gray2, 1.0);
	//InvertImage(IMAGE_X, IMAGE_Y, gray2);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	
	//SaveBMPfromMemDC(dc, IMAGE_X, IMAGE_Y, "_result.bmp");

	//LoadImageBMP("beach_ball.bmp");
	//LoadImageBMP("beach_ball_gray.bmp");
	//LoadImageBMP("beach_ball_pen_ink.bmp");
	//LoadImageBMP("beach_ball_pen_ink2.bmp");


	//DrawGradientField(dc, IMAGE_X, IMAGE_Y, gfield);
	//DrawGradientField2(dc, IMAGE_X, IMAGE_Y, gfield);
	//DrawGradientField_LIC(dc, IMAGE_X, IMAGE_Y, gfield, 10);
	//DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 20);
	//DrawStrokesHertzmannOrientedAlpha(dc, IMAGE_X, IMAGE_Y, gfield);
	//DrawStrokesHertzmannOrientedCurvedVector(dc, IMAGE_X, IMAGE_Y, gfield, 20, 60, 10); 
	//DrawStrokesCurvedTextured(dc, IMAGE_X, IMAGE_Y, gfield, 5, 50, 20); 
	DrawStrokesCurvedTexturedOil(dc, IMAGE_X, IMAGE_Y, gfield); 
	//DrawStrokesCurvedTexturedPenInk(dc, IMAGE_X, IMAGE_Y, gfield, 10, 30); 
	//////////////////////////////////////////////
	//DrawStrokesHertzmannOrientedCurvedVector2(dc, IMAGE_X, IMAGE_Y, gfield, 20, 60, 5); 
	//DrawStrokesHertzmannOrientedAlpha(dc, IMAGE_X, IMAGE_Y, gfield); // RASC version
	
	/////////////////////////////////////////////////////////////
	//DrawColorSelected(dc, IMAGE_X, IMAGE_Y);
	//DrawStrokesAdaptive2(dc, IMAGE_X, IMAGE_Y, gfield); 
	
}

void CCubeView::OnIpenMosaic()
{
	int x, y;
	GLubyte r, g, b;

	// TODO: Add your command handler code here
	//LoadBMP((char *)LPCTSTR("rose_emap2.bmp"), &memDC2);
	LoadBMP((char *)LPCTSTR("rose_emap5.bmp"), &memDC2);
	Backbuffer = new GLubyte [IMAGE_Y * IMAGE_X * 3];
	//////////////////////////////////////////////////////////////
	// Copy memDC2 to Backbuffer
	for (y = 0; y < IMAGE_Y; y++) {
		for (x = 0; x < IMAGE_X; x++) {
			r = (GLubyte)RGB_GETRED(memDC2.GetPixel(x, y));
			g = (GLubyte)RGB_GETGREEN(memDC2.GetPixel(x, y));
			b = (GLubyte)RGB_GETBLUE(memDC2.GetPixel(x, y));
			Backbuffer[((IMAGE_Y-1-y) * IMAGE_X + x) * 3 + 0] = r;
			Backbuffer[((IMAGE_Y-1-y) * IMAGE_X + x) * 3 + 1] = g;
			Backbuffer[((IMAGE_Y-1-y) * IMAGE_X + x) * 3 + 2] = b;
		}
	}
	////////////////////////////////////////////////////////////////////
	GetImage(IMAGE_X, IMAGE_Y, image, Backbuffer); // from Backbuffer to image: for mosaic
	//GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer); // from Dbuffer to image
	max_grad = getGradient(IMAGE_X, IMAGE_Y, gradient, image);
	//max_grad = getSobelGradient(IMAGE_X, IMAGE_Y, gradient, image);
	///////////////////////////////////////////////////////////////////
	// Blurred gradient to control the stroke length
	//max_grad = getBlurredGradient(IMAGE_X, IMAGE_Y, gradient, image, 1); 
	InitGradField(IMAGE_X, IMAGE_Y, gfield, image);
	//AlignGradient(IMAGE_X, IMAGE_Y, gfield, 10);
	//AlignGradient(IMAGE_X, IMAGE_Y, gfield, 10);
	//AlignGradient(IMAGE_X, IMAGE_Y, gfield, 10);
	//GVF(IMAGE_X, IMAGE_Y, gfield, 50);
	GVF2(IMAGE_X, IMAGE_Y, gfield, 120, 0.1); // for original picture
	//max_grad = getBlurredGradient(IMAGE_X, IMAGE_Y, gradient, image, 5); 
	
	
	//DrawImage(IMAGE_X, IMAGE_Y, gradient);	
	//ImagetoNodesNPR(IMAGE_X, IMAGE_Y, image, max_grad, gradient);
	//InitNodesNPR(IMAGE_X, IMAGE_Y);
	CClientDC dc(this);
	//DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 20);

	///*
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//cur_sigma = 3.3;
	//hi_thres = 0.22;
	cur_sigma = 2.3;
	hi_thres = 0.15;
	gau_w = MakeGaussMask(cur_sigma, gau);
	max_grad2 = GlobalCanny(IMAGE_X, IMAGE_Y, gray, gray2, gau_w);
	//DistanceField(IMAGE_X, IMAGE_Y, gray2, 3.0);
	//DistanceField(IMAGE_X, IMAGE_Y, gray2, 5.0);
	DistanceField(IMAGE_X, IMAGE_Y, gray2, 2.0);
	//DistanceField(IMAGE_X, IMAGE_Y, gray2, 1.0);
	//InvertImage(IMAGE_X, IMAGE_Y, gray2);
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);

	DrawStrokesMosaicFast(dc, IMAGE_X, IMAGE_Y);
	//DrawStrokesMosaic(dc, IMAGE_X, IMAGE_Y);
	//DrawStrokesMosaicBlur(dc, IMAGE_X, IMAGE_Y);
	//*/

}


void CCubeView::OnEdgeFlowedge()
{
	// TODO: Add your command handler code here
	GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	//max_grad = getGradient(IMAGE_X, IMAGE_Y, gradient, image);
	InitGradField(IMAGE_X, IMAGE_Y, gfield, image);
	//////////////////////////////////////////////////////////////////
	// This one is the best
	GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.1); // for original picture
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.05); // for original picture
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.1); // for original picture
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 50, 0.1); // for original picture
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 150, 0.01); // for sketch
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.01); // for sketch
	///////////////////////////////////////
	//BilateralGfield4(IMAGE_X, IMAGE_Y, gfield, 2.0, 1);
	//BilateralGfield4(IMAGE_X, IMAGE_Y, gfield, 1.5, 1);
	///////////////////////////////////////////////////////
	CClientDC dc(this);
	DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 20);
	////////////////////////////////////////////////////////////

	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//GetSobelGradient(IMAGE_X, IMAGE_Y, gray, gray2, G_mag);
	GetDOG(IMAGE_X, IMAGE_Y, gray, G_mag, gray2, 50, 100, 0.99);
	//GetDOG(IMAGE_X, IMAGE_Y, gray, G_mag, gray2, 70, 150, 0.99);
	//GetFlowDOG(IMAGE_X, IMAGE_Y, G_mag, gray2, gfield, 20, 1.0); // get averaged DOG over flow
	//GetFlowGradient(memDC, IMAGE_X, IMAGE_Y, gray, gfield, gray2, 20, 4, 1.414);
	//GetFlowGradient(memDC, IMAGE_X, IMAGE_Y, gray, gfield, gray2, 100, 10, 1.414);
	//NonmaximaSuppression(IMAGE_X, IMAGE_Y, G_mag, gray2, 0.2);
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);


	////////////////////////////////////////////////////////
	/*
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//cur_sigma = 3.3;
	//hi_thres = 0.22;
	//cur_sigma = 2.3;
	cur_sigma = 2.5;
	//hi_thres = 0.15;
	hi_thres = 0.2;
	lo_thres = 0.5;
	gau_w = MakeGaussMask(cur_sigma, gau);
	max_grad2 = GlobalCanny(IMAGE_X, IMAGE_Y, gray, gray2, gau_w);
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	*/
	////////////////////////////////////////////////////////////

	///////////////////////////////////////////////////
	// show thin edge map
	/*
	ConvertThinEdgeMap2GrayImage(IMAGE_X, IMAGE_Y, thin_edge, gray2);
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	*/
	////////////////////////////////////////////

	//////////////////////////////////////////////////////
	/*
	FlowConnectEdges(IMAGE_X, IMAGE_Y, gray2, gfield); // connect edges using TVF
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	*/
	//FlowConnectEdges(gray2);
	//renderImage();
	//swap();
}


void CCubeView::OnEdgeThinning()
{
	// TODO: Add your command handler code here
	GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	//max_grad = getGradient(IMAGE_X, IMAGE_Y, gradient, image);
	InitGradField(IMAGE_X, IMAGE_Y, gfield, image);
	//////////////////////////////////////////////////////////////////
	// This one is the best
	GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.1); // for original picture
	///////////////////////////////////////
	//BilateralGfield4(IMAGE_X, IMAGE_Y, gfield, 2.0, 1);
	//BilateralGfield4(IMAGE_X, IMAGE_Y, gfield, 1.5, 1);
	///////////////////////////////////////////////////////
	CClientDC dc(this);
	//DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 20);
	////////////////////////////////////////////////////////////

	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//GetSobelGradient(IMAGE_X, IMAGE_Y, gray, gray2, G_mag);
	for (int i = 0; i < IMAGE_X; i++) {
		for (int j = 0; j < IMAGE_Y; j++) {
			G_mag[i][j] = (255-gray[i][j]) / 255.0;
		}
	}
	//GetDOG(IMAGE_X, IMAGE_Y, gray, G_mag, gray2, 50, 100, 0.99);
	//GetDOG(IMAGE_X, IMAGE_Y, gray, G_mag, gray2, 70, 150, 0.99);
	//GetFlowDOG(IMAGE_X, IMAGE_Y, G_mag, gray2, gfield, 20, 1.0); // get averaged DOG over flow
	//GetFlowGradient(memDC, IMAGE_X, IMAGE_Y, gray, gfield, gray2, 20, 4, 1.414);
	//GetFlowGradient(memDC, IMAGE_X, IMAGE_Y, gray, gfield, gray2, 100, 10, 1.414);
	//NonmaximaSuppression(IMAGE_X, IMAGE_Y, G_mag, gray2, 0.2);
	NonmaximaSuppression(IMAGE_X, IMAGE_Y, gfield, G_mag, gray2, 0.0);
	EdgeThinning(memDC, gray2); // morphological edge thinning
	
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
}




void CCubeView::OnIpenEmap()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	//GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	emap.init(IMAGE_X, IMAGE_Y);
	GetGrayImage(IMAGE_X, IMAGE_Y, emap, Dbuffer);
	//max_grad = getGradient(IMAGE_X, IMAGE_Y, gradient, image);
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, emap);
	
	/*
	// Edge Morephological Thinning!!!
	ClearMemDC(&memDC);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	EdgeThinning(dc, emap); // morphological edge thinning
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, emap);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	*/
	/////////////////////////////////////////////////////////////
	///*
	StoreEdgeStrokes4(IMAGE_X, IMAGE_Y, emap, bstrokes, 4); // a list of B-spline strokes
	TRACE("[before]number of bstrokes = %d\n", bstrokes.Size());
	ClearMemDC(&double_buffer);
	//DrawInterpBStrokes(double_buffer, bstrokes, 255, 0, 255); // interpolating B-spline strokes
	//DrawInterpBStrokesRandCol(double_buffer, bstrokes); // interpolating B-spline strokes
    
	//SampleBStrokes(bstrokes, 5); // sample points using interval
	SampleBStrokes(bstrokes, 3); // sample points using interval
	//ConstructBStrokesMap(bstrokes, b_map); // construct the stroke map
	ConstructBStrokesMap2(bstrokes, b_map); // construct the stroke map
	//CleanUpBStrokes(bstrokes, b_map);
    CleanUpBStrokes(bstrokes, b_map);
	DrawInterpBStrokesRandCol2(double_buffer, bstrokes, 3); // interpolating B-spline strokes
	TRACE("[after]number of bstrokes = %d\n", bstrokes.Size());
	//DrawInterpBStrokesRandCol(double_buffer, bstrokes); // interpolating B-spline strokes
	//DrawHermiteStrokes(double_buffer, bstrokes, gfield, 0, 0, 255);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &double_buffer, 0, 0, SRCCOPY);
	//*/
}

void CCubeView::OnEdgeGabor()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	//GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//////////////////////////////
	// DOG before Blurring the image! 
	//GetDOG(IMAGE_X, IMAGE_Y, gray, G_mag, gray2, 50, 100, 0.99); // Cameron Diaz!!! and Lena!!!
	//max_grad = getGradient(IMAGE_X, IMAGE_Y, gradient, image);
	//gau_w = MakeGaussMask(1.0, gau);
	//gau_w = MakeGaussMask(5.0, gau); // useful to denoising, and spreading thin lines
	//GaussSmooth2(IMAGE_X, IMAGE_Y, gray, gau_w);
	//GaussSmooth4(dc, IMAGE_X, IMAGE_Y, gray, gau_w);
	//GaussSmooth5(gray, 3.0); 
	//GaussSmooth5(gray, 1.0); 
	//GaussSmooth5(gray, 1.0); // normal Gaussian blur (no contrast-stretching)
	gray2.copy(gray);
	//GetDOG2(gray, G_mag, gray, 1.0, 0.99);  // cameron diaz
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//GaussSmooth5(gray2, 3.0); // normal Gaussian blur (no contrast-stretching)
	//GaussSmooth5(gray2, 4.0); // normal Gaussian blur (no contrast-stretching)
    GaussSmooth5(gray2, 5.0); // normal Gaussian blur (no contrast-stretching)
	//GaussSmooth5(gray2, 10.0); // normal Gaussian blur (no contrast-stretching)
	//GetContrast(gray2, G_mag, gray2, 2.0, 10.0);
	//GaussSmooth6(gray2, 5.0); // dahsed circle, we perform contrast-enhancing blurred intensity!
	//GaussSmooth6(gray2, 10.0); // dahsed circle, we perform contrast-enhancing blurred intensity!
	GetSobelGradient2(IMAGE_X, IMAGE_Y, gray2, gray2, G_mag); // used for TVF
	//gray.copy(gray2);
	//GetSobelGradient2(IMAGE_X, IMAGE_Y, gray2, gray2, G_mag); // used for TVF
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray3);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray); // B & W image
	InitGradField(IMAGE_X, IMAGE_Y, gfield, gray2); // orginary image
	//////////////////////////////////////////////
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 50, 0.1); // This improves DOG thinning quality!
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 200, 0.1); // This improves DOG thinning quality!
	//BilateralGfield8(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 7); // without Gaussian! Very good!
	//BilateralGfield8(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 13); // without Gaussian! Very good!
	//BilateralGfield9(dc, IMAGE_X, IMAGE_Y, gfield, 5.0, 3); // stipple circle
	BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 3.0, 2); // stipple circle
	//BilateralGfield9(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2); // stipple circle
	//BilateralGfield8(dc, IMAGE_X, IMAGE_Y, gfield, 2.0, 3); // fingerprint
	//BilateralGfield8(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 1); // without Gaussian! Very good!
	DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 20); // incorrect version? (looks better)
	//DrawGradientField_LIC7(dc, IMAGE_X, IMAGE_Y, gfield, 20); // correct version (bilinear interp)
	//////////////////////////////
	// DOG after Blurring the image! (this is better, especially if we have thin lines in image!)
	//GetGabor(gray, gfield, gray2, G_mag, 50, 100, 0.99); // Cameron Diaz!!! and Lena!!!
	//GetGabor(gray, gfield, gray2, G_mag, 100, 100, 0.99); // Cameron Diaz!!! and Lena!!!
	//GetOrientedDOG(gray, gfield, gray2, G_mag, 1.0, 0.99); // Cameron Diaz!!! and Lena!!!
	//GetOrientedDOG3(gray, gfield, gray2, G_mag, 1.0, 0.99); // FULL ORIENTED DOG!
	//GetOrientedDOG4(gray, gfield, gray2, G_mag, 1.0, 0.99); // FULL ORIENTED DOG! GOOD!
	//GetOrientedDOG4(gray, gfield, gray2, G_mag, 3.0, 0.99); // FULL ORIENTED DOG! GOOD!
	//GetFlowDOG2(gray, gfield, gray2, G_mag, 1.0, 0.99); // Flow-based DOG! Very good!
	//GetFlowLineBilateral(gray, gfield, 2.0, 0.1, 10); // works better when GVF is not adjusted!
	//GetDOG2(gray, G_mag, gray, 1.0, 0.995);  // cameron diaz
	GetFlowDOG2(gray, gfield, gray, G_mag, 1.0, 3.0, 0.995); // Flow-based DOG! Very good!
	GetFlowDOG2(gray, gfield, gray, G_mag, 1.0, 3.0, 0.995); // Flow-based DOG! Very good!
	//GetFlowDOG3(gray, gfield, gray, G_mag, 1.0, 3.0, 0.995); // Adjust GVF direction (bad)
	//GetFlowDOG2(gray, gfield, gray, G_mag, 1.0, 7.0, 0.995); // Flow-based DOG! Very good!
	//GetFlowDOG2(gray, gfield, gray, G_mag, 1.0, 7.0, 0.995); // Flow-based DOG! Very good!
	//GetDOG2(gray, G_mag, gray2, 1.0, 0.99);  // cameron diaz
	//GetOrientedDOG3(gray, gfield, gray2, G_mag, 0.7, 1.0); // FULL ORIENTED DOG!
	//Thresholding(IMAGE_X, IMAGE_Y, gray2, 0.9);
	//Thresholding(IMAGE_X, IMAGE_Y, gray2, 0.5);
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//////////////////////////////////////////////////////////////////
	// This one is the best
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.1); // This improves DOG thinning quality!
	///////////////////////////////////////
	//BilateralGfield4(IMAGE_X, IMAGE_Y, gfield, 2.0, 1);
	//BilateralGfield4(IMAGE_X, IMAGE_Y, gfield, 1.5, 1);
	///////////////////////////////////////////////////////
	//DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 20);
	////////////////////////////////////////////////////////////
	
	//GetSobelGradient(IMAGE_X, IMAGE_Y, gray, gray2, G_mag);
	//GetDOG(IMAGE_X, IMAGE_Y, gray, G_mag, gray2, 150, 200, 0.99); // thick edges
	//GetDOG(IMAGE_X, IMAGE_Y, gray, G_mag, gray2, 70, 150, 0.99); 
	//GetFlowDOG(IMAGE_X, IMAGE_Y, G_mag, gray2, gfield, 20, 1.0); // get averaged DOG over flow
	//GetFlowGradient(memDC, IMAGE_X, IMAGE_Y, gray, gfield, gray2, 20, 4, 1.414);
	//GetFlowGradient(memDC, IMAGE_X, IMAGE_Y, gray, gfield, gray2, 100, 10, 1.414);
	//NonmaximaSuppression(IMAGE_X, IMAGE_Y, gfield, G_mag, gray2, 0.2);
	//Thresholding(IMAGE_X, IMAGE_Y, gray2, 0.2);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
}


void CCubeView::OnIpenLineart()
{
	// TODO: Add your command handler code here
	/*
	if ( !LoadBMP((char *)LPCTSTR("cameron-diaz300_diffuse.bmp"), &memDC) )
		TRACE("the file does not exist!\n");
	CopyMemDCtoDbuffer(memDC);
	GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	*/
	CClientDC dc(this);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//gau_w = MakeGaussMask(0.5, gau);
	gau_w = MakeGaussMask(1.0, gau); // sigma = 0.1 works the best!
	//gau_w = MakeGaussMask(2.0, gau);
	GaussSmooth2(IMAGE_X, IMAGE_Y, gray, gau_w);
	GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); 
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//gray3.copy(gray2); // gray3 has the gradient magnitude image!
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray3);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
	InitGradField(IMAGE_X, IMAGE_Y, gfield, gray2);
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.01); // This improves DOG thinning quality!
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 50, 0.1); // This improves DOG thinning quality!
	//BilateralGfield6(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 5); // 5 times iteration
	//BilateralGfield6(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 10); // 5 times iteration
	//BilateralGfield6(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2); // 2 times iteration
	//BilateralGfield7(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 7); // 3x3 MASK! (just like GVF)
	//BilateralGfield8(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 7); // 3x3 MASK! (just like GVF)
	///////////////////////////////////////
	
	BilateralGfield8(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 13); // LENA ODOG
	//BilateralGfield8(dc, IMAGE_X, IMAGE_Y, gfield, 0.5, 1); // DIAZ ODOG (HAIR CONNECTED)
	//BilateralGfield8(dc, IMAGE_X, IMAGE_Y, gfield, 0.2, 5); // DIAZ ODOG (HAIR CONNECTED)
	//BilateralGfield8(dc, IMAGE_X, IMAGE_Y, gfield, 0.3, 3); // DIAZ ODOG (HAIR CONNECTED)
	//BilateralGfield8(dc, IMAGE_X, IMAGE_Y, gfield, 0.7, 1); 
	//BilateralGfield8(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 13); // 3x3 MASK! (just like GVF)
	//BilateralGfield8(dc, IMAGE_X, IMAGE_Y, gfield, 0.3, 13); // LENA DOG
	//BilateralGfield8(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 10); 
	//BilateralGfield8(dc, IMAGE_X, IMAGE_Y, gfield, 2.0, 3); // fingerprint DOG
	//BilateralGfield8(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 20); // 3x3 MASK! (just like GVF)
	//BilateralGfield8(dc, IMAGE_X, IMAGE_Y, gfield, 0.3, 11); // 3x3 MASK! (just like GVF)
	//BilateralGfield8(dc, IMAGE_X, IMAGE_Y, gfield, 0.7, 1); // 3x3 MASK! (just like GVF)
	//BilateralGfield8(dc, IMAGE_X, IMAGE_Y, gfield, 0.5, 5); // 3x3 MASK! (just like GVF)
	//BilateralGfield8(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 7); // 3x3 MASK! (just like GVF)
	//BilateralGfield8(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 5); // without Gaussian! Very good!
	////////////////////////////////////////////////
	//BilateralGfield7(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 3); // 3x3 MASK! (just like GVF)
	//////////////////////////////////////////////////////////////
	//BilateralGfield7(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2); // 2 times iteration
	//DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 20);
	//DrawGradientField_LIC7(dc, IMAGE_X, IMAGE_Y, gfield, 20); // correct version (bilinear interp)
	//DrawGradientFieldArrow(dc, gfield, 255, 0, 0);
	DrawTangentFieldArrow(dc, gfield, 255, 0, 0);
	
	///*
	//GetDOG(IMAGE_X, IMAGE_Y, gray, G_mag, gray2, 50, 100, 0.99); // Cameron Diaz!!! and Lena!!!
	//GetDOG2(gray, G_mag, gray2, 0.5, 0.99); 
	////////////////////////////////////////////////
	GetDOG2(gray, G_mag, gray2, 1.0, 0.99); // Lena
	//GetDOG2(gray, G_mag, gray2, 1.0, 0.995); // CUP
	//GetDOG2(gray, G_mag, gray2, 2.0, 0.99); // Lena
	//GetOrientedDOG4(gray, gfield, gray2, G_mag, 1.0, 0.99); // FULL ORIENTED DOG!
	//GetOrientedDOG5(gray, gfield, gray2, G_mag, 1.0, 0.99); // FULL ADAPTIVE ORIENTED DOG!
	//GetDOG2(gray, G_mag, gray2, 2.0, 0.99); // fingerprint
	//GetFlowBlur(dc, gfield, gray2, 30);
	NonmaximaSuppression(IMAGE_X, IMAGE_Y, gfield, G_mag, gray2, 0.2); // for DOG
	//////////////////////////////////////////
	//GetOrientedDOG3(gray, gfield, gray2, G_mag, 1.0, 0.99); // FULL ORIENTED DOG!
	//NonmaximaSuppression(IMAGE_X, IMAGE_Y, gfield, G_mag, gray2, 0.1); // for ODOG
	//NonmaximaSuppression(IMAGE_X, IMAGE_Y, gfield, G_mag, gray2, 0.3); // for ODOG
	////////////////////////////////////////////////////////
	//GetDOG2(gray, G_mag, gray2, 1.5, 0.99);  // Zeta Jones
	//GetDOG2(gray, G_mag, gray2, 1.0, 1.0); 
	
	EdgeThinning(memDC, gray2); // morphological edge thinning
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);

	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray3);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	
	///*
	////////////////////////////////////////////////////
	emap.copy(gray2);
	//StoreEdgeStrokes4(IMAGE_X, IMAGE_Y, emap, bstrokes, 5); // Diaz
	StoreEdgeStrokes4(IMAGE_X, IMAGE_Y, emap, bstrokes, 4); // Diaz
	//StoreEdgeStrokes4(IMAGE_X, IMAGE_Y, emap, bstrokes, 2); // Lena
	//SampleBStrokes(bstrokes, 3);
	//SampleBStrokes(bstrokes, 2);
	//SampleBStrokes(bstrokes, 1);
	//SplitBstrokesAll(dc, bstrokes, 1.0, 30); 
	//SplitBstrokesAll(dc, bstrokes, 2.0, 10); 
	//////////////////////////////////////////////
	//GetDOG2(gray, G_mag, gray2, 0.7, 1.0);  // stroke connecting DOG
	GetDOG2(gray, G_mag, gray2, 1.0, 1.0);  // stroke connecting DOG
	//GetDOG2(gray, G_mag, gray2, 2.0, 1.0);  // stroke connecting DOG
	//GetOrientedDOG4(gray, gfield, gray2, G_mag, 1.0, 1.0); // FULL ORIENTED DOG!
	//GetOrientedDOG5(gray, gfield, gray2, G_mag, 1.0, 1.0); // FULL ADAPTIVE ORIENTED DOG!
	//GetDOG2(gray, G_mag, gray2, 2.0, 1.0);  // fingerprint: stroke connecting DOG
	//GetFlowDiffusion(dc, gfield, gray2, G_mag, 1, 1);
	//GetOrientedDOG3(gray, gfield, gray2, G_mag, 0.7, 1.0); // FULL ORIENTED DOG!
	//GetOrientedDOG3(gray, gfield, gray2, G_mag, 1.0, 1.0); // FULL ORIENTED DOG!
	////////////////////////////////////////////////////////
	// Now gray2 has either 255 or 0!
	//Thresholding(IMAGE_X, IMAGE_Y, gray2, 0.5); // DOG value 0.2 or below
	Thresholding(IMAGE_X, IMAGE_Y, gray2, 0.99); // DOG value 0.2 or below
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	
	//ConstructBStrokesMap3(bstrokes, b_map); // construct the stroke map
	MergeBStrokesAll3(double_buffer, bstrokes, 20, 5);
	//MergeBStrokesAll3(double_buffer, bstrokes, 20, 7);
	//SimplifyBstrokesAll(dc, bstrokes, G_mag, 0.000001); // Lena
	//SimplifyBstrokesAll(dc, bstrokes, G_mag, 0.00001); // Diaz
	//MergeBStrokesAll3(bstrokes, 20, 5);
	//SmoothBstrokesAll(dc, bstrokes, G_mag);
	ClearMemDC(&memDC2); // used as white canvas for clearing memDC
	LengthenBstrokesAll(dc, double_buffer, bstrokes, gfield);
	//TRACE("bstrokes.Size() = %d\n", bstrokes.Size());
	//ConstructBStrokesMap3(bstrokes, b_map); // construct the stroke map
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray3);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//SnapBstrokesAll(dc, double_buffer, bstrokes, gfield);
	ConnectBstrokesAll(dc, double_buffer, bstrokes, gfield);
	//MergeBStrokesAll3(bstrokes, 30, 5);
	//TRACE("bstrokes.Size() = %d\n", bstrokes.Size());
	
	///*
	//SimplifyBstrokesAll(dc, bstrokes, G_mag, 0.0000001); // SOMETHING WRONG WITH THIS FUNCTION!
	//SmoothBstrokesAll(dc, bstrokes, G_mag);
	//MergeBStrokesAll2(bstrokes, 1.0, 0.5, 5); // distance: 3
	
	//ConstructBStrokesMap(bstrokes, b_map); // construct the stroke map
    //CleanUpBStrokes(bstrokes, b_map); // merge neighboring strokes
		
	ClearMemDC(&double_buffer);
	//SampleBStrokes(bstrokes, 3); // sample points using interval
	//DrawInterpBStrokesRandCol2(double_buffer, bstrokes, 3); // interpolating B-spline strokes
	//DrawBStrokesPoints(double_buffer, bstrokes, 0, 255, 0); 
	DrawInterpBStrokes2(double_buffer, bstrokes, 0, 0, 0, 3); // interpolating B-spline strokes
	//DrawNormalBStrokes(double_buffer, bstrokes, 0, 0, 0);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &double_buffer, 0, 0, SRCCOPY);
	///////////////////////////////////////////////
	//*/
}

void CCubeView::OnEdgeToon()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	//GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//////////////////////////////
	// DOG before Blurring the image! 
	//GetDOG(IMAGE_X, IMAGE_Y, gray, G_mag, gray2, 50, 100, 0.99); // Cameron Diaz!!! and Lena!!!
	//max_grad = getGradient(IMAGE_X, IMAGE_Y, gradient, image);
	gau_w = MakeGaussMask(1.0, gau);
	//gau_w = MakeGaussMask(5.0, gau); // useful to denoising, and spreading thin lines
	GaussSmooth2(IMAGE_X, IMAGE_Y, gray, gau_w);
	//GaussSmooth3(IMAGE_X, IMAGE_Y, gray, gau_w); // there's something wrong
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
	//BilateralGfield8(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 7); // without Gaussian! Very good!
	BilateralGfield8(dc, IMAGE_X, IMAGE_Y, gfield, 2.0, 3); // without Gaussian! Very good!
	//BilateralGfield9(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2); // half_w adjusted!
	//BilateralGfield9(dc, IMAGE_X, IMAGE_Y, gfield, 2.0, 3); // fingerprint
	DrawGradientField_LIC7(dc, IMAGE_X, IMAGE_Y, gfield, 20); // correct version (bilinear interp)
	//////////////////////////////
	// DOG after Blurring the image! (this is better, especially if we have thin lines in image!)
	//GetDOG(IMAGE_X, IMAGE_Y, gray, G_mag, gray2, 50, 95, 0.99); // Cameron Diaz!!! and Lena!!!
	//GetDOG2(gray, G_mag, gray2, 1.5, 0.99);  // Zeta Jones
	//GetDOG2(gray, G_mag, gray2, 1.0, 0.99);  // cameron diaz
	//Thresholding(IMAGE_X, IMAGE_Y, gray2, 0.2); // DOG value 0.2 or below
	//GetDOG2(gray, G_mag, gray2, 0.7, 0.995);  // Heath data
	//GetFlowBilateral(dc, gfield, gray2, 1.0, 0.1, 1);
	//GetFlowBilateral2(dc, gfield, gray, 1.0, 0.1, 5);
	//GetFlowMedian2(dc, gfield, gray, 3, 5, 1);
	//GetFlowMedian(gray, gfield, gray2, G_mag, 1, 10, 1);
	//GetDOG2(gray, G_mag, gray2, 1.0, 0.997);  // cameron diaz
	//GetContrast(gray, G_mag, gray, 2.0, 5.0); 
	//GetFlowLineContrast(gray, gfield, 2.0, 1);
	//GetFlowLineBilateral(gray, gfield, 2.0, 0.1, 20);
	//GetFlowLineBilateral(gray, gfield, 2.0, 0.1, 5); // works better when GVF is not adjusted!
	//GetFlowLineGaussian(gray, gfield, 2.0, 0.1, 5); // works better when GVF is not adjusted!
	//GetDOG2(gray, G_mag, gray, 1.0, 0.99);  // cameron diaz
	//GetDOG2(gray, G_mag, gray, 1.0, 0.998);  // cameron diaz
	//////////////////////////////////////////////////////
	GetDOG2(gray, G_mag, gray2, 1.0, 0.99);  // cameron diaz
	Thresholding(IMAGE_X, IMAGE_Y, gray2, 0.2); // DOG value 0.2 or below
    dog.copy(gray2);
	//GetFlowLineContrast2(gray, gfield, dog, 3.0, 1);
	//GetFlowLineGaussian(gray, gfield, 2.0, 0.1, 5); // works better when GVF is not adjusted!
	GetFlowLineBilateral(gray, gfield, 2.0, 0.1, 10); // works better when GVF is not adjusted!
	//GetDOG2(gray, G_mag, gray, 1.0, 0.998);  // cameron diaz
	GetFlowDOG2(gray, gfield, gray, G_mag, 1.0, 4.0, 0.995); // Flow-based DOG! Very good!
	////////////////////////////////////////////////////
	//GetFlowLineBilateral(gray, gfield, 2.0, 0.1, 20);
	//GetFlowBilateral3(gfield, gray, dog, 1.0, 0.1, 3);
	//GetFlowBilateral2(dc, gfield, gray, 0.1, 0.1, 10);
	//GetAnisotropic(gray, 1000);
	//GaussBlurBilateral(IMAGE_X, IMAGE_Y, gray, 1.0, 0.1, 3);
	//GetDOG2(gray, G_mag, gray, 1.0, 0.99);  // cameron diaz
	//GetDOG2(gray, G_mag, gray, 1.0, 0.998);  // cameron diaz
	//GetFlowDOG2(gray, gfield, gray, G_mag, 1.0, 0.995); // Flow-based DOG! Very good!
	//GetFlowMedian(gray2, gfield, gray2, G_mag, 3, 5, 3);
	//GetDOG2(gray, G_mag, gray2, 1.0, 0.996);  // cameron diaz
	//GetFlowMedian(gray2, gfield, gray2, G_mag, 3, 5, 3);
	//GetDOG2(gray2, G_mag, gray2, 1.0, 0.997);  // cameron diaz
	//GetFlowMedian(gray2, gfield, gray2, G_mag, 3, 3, 5);
	//GetFlowMedianDiffusion(gray2, gfield, gray2, G_mag, 5);
    //GetFlowDiffusion(dc, gfield, gray2, G_mag, 1, 30);
	//GetFlowBlur(dc, gfield, gray2, 30);
	//GetDOG2(gray, G_mag, gray2, 0.5, 0.99);  // cameron diaz
	//GetDOG2(gray, G_mag, gray2, 0.7, 1.0);  // stroke connecting DOG
	//GetDOG(IMAGE_X, IMAGE_Y, gray, G_mag, gray2, 100, 150, 0.99); // Cameron Diaz!!! and Lena!!!
	//////////////////////////////////////////////////
	//Thresholding(IMAGE_X, IMAGE_Y, gray2, 0.2); // DOG value 0.2 or below
	//Thresholding(IMAGE_X, IMAGE_Y, gray2, 1.0); // stroke connectig DOG
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, dog);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//////////////////////////////////////////////////////////////////
}

void CCubeView::OnIpenBilateral()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	//max_grad = getGradient(IMAGE_X, IMAGE_Y, gradient, image);
	//max_grad = getSobelGradient(IMAGE_X, IMAGE_Y, gradient, image);
	//////////////////////////////////////////////////////////
	///*
	//gau_w = MakeGaussMask(5.0, gau);
	//gau_w = MakeGaussMask(0.1, gau);
	//TRACE("gau_w = %d\n", gau_w);
	//GaussSmooth2(IMAGE_X, IMAGE_Y, gray2, gau_w);
	//GaussSmooth3(IMAGE_X, IMAGE_Y, gray, gau_w);
	
	//GaussBlur(IMAGE_X, IMAGE_Y, gray, 3.0);
	//GaussBlurBilateral(IMAGE_X, IMAGE_Y, gray, 3.0, 30.0); // old
	//GaussBlurBilateral(IMAGE_X, IMAGE_Y, gray, 3.0, 0.1, 1); // new
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 3.0, 0.1, 3);
	StartTimer();
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 1.0, 0.1, 3);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 1.0, 0.1, 1);
	//GaussBlurBilateral(IMAGE_X, IMAGE_Y, gray, 1.0, 0.1, 3); // new
	TRACE("Elapsed Time = %f\n", ElapsedTime()); // 5 seconds for Paolina
	//InvertImage(IMAGE_X, IMAGE_Y, gray2);
	//*/
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	TRACE("Bilateral color filter done!\n");

}


void CCubeView::OnEdgeDog()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	//GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//////////////////////////////
	// DOG before Blurring the image! 
	//GetDOG(IMAGE_X, IMAGE_Y, gray, G_mag, gray2, 50, 100, 0.99); // Cameron Diaz!!! and Lena!!!
	//max_grad = getGradient(IMAGE_X, IMAGE_Y, gradient, image);
	//gau_w = MakeGaussMask(1.0, gau);
	//gau_w = MakeGaussMask(3.0, gau);
	//gau_w = MakeGaussMask(5.0, gau); // useful to denoising, and spreading thin lines
	//GaussSmooth2(IMAGE_X, IMAGE_Y, gray, gau_w);
	//GaussSmooth5(gray, 1.0); 
	//GaussSmooth5(gray, 5.0); 
	GaussSmooth5(gray, 0.7); 
	//GaussSmooth5(gray, 0.5); 
	//GaussSmooth5(gray, 1.5); // mandrill
	//GaussSmooth3(IMAGE_X, IMAGE_Y, gray, gau_w); // there's something wrong
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 50, 0.1); // for original picture
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2); // without Gaussian! Very good!
	//DrawGradientField_LIC7(dc, IMAGE_X, IMAGE_Y, gfield, 20); // correct version (bilinear interp)
	//////////////////////////////
	// DOG after Blurring the image! (this is better, especially if we have thin lines in image!)
	//GetDOG(IMAGE_X, IMAGE_Y, gray, G_mag, gray2, 50, 95, 0.99); // Cameron Diaz!!! and Lena!!!
	//GetDOG2(gray, G_mag, gray2, 1.3, 0.99);  // Zeta Jones
	//GetDOG2(gray, G_mag, gray2, 1.0, 0.97);  // Zeta Jones
	//GetDOG2(gray, G_mag, gray2, 1.0, 0.99);  // cameron diaz
	//GetDOG2(gray, G_mag, gray2, 1.0, 0.98);  // cameron diaz
	//GetDOG2(gray, G_mag, gray2, 1.0, 0.999);  // cameron diaz
	//GetDOG2(gray, G_mag, gray2, 1.0, 0.99);  // cameron diaz
	GetDOG2(gray, G_mag, gray2, 1.0, 0.995);  // cameron diaz
	//GetDOG2(gray, G_mag, gray2, 2.0, 0.995);  // cameron diaz
	//GetDOG4(gray, G_mag, gray2, 1.0, 0.99, 3.0);  // cameron diaz
	//GetFlowDOG2(gray, gfield, gray2, G_mag, 1.0, 1.0, 0.995); // Flow-based DOG! Very good!
	
	//GetDOG3(gray, G_mag, gray2, 1.0, 1.0);  // BAD!
	//GetDOG2(gray, G_mag, gray2, 0.5, 0.99);  // cameron diaz
	//GetFlowLineMedian(gray2, gfield, 1.0, 3);
	//GetFlowLineGaussian(gray2, gfield, 1.0, 3);
	//Thresholding(IMAGE_X, IMAGE_Y, gray2, 0.5); // DOG value 0.2 or below
	//GetDOG2(gray, G_mag, gray2, 0.7, 0.995);  // Heath data
	//GetFlowMedian(gray2, gfield, gray2, G_mag, 3, 3, 5);
	//GetFlowMedianDiffusion(gray2, gfield, gray2, G_mag, 5);
    //GetFlowDiffusion(dc, gfield, gray2, G_mag, 1, 3);
	//GetDOG2(gray, G_mag, gray2, 2.0, 0.99);  // fingerprint
	//GetDOG2(gray, G_mag, gray2, 0.5, 1.0);  // fingerprint
	//GetDOG2(gray, G_mag, gray2, 1.0, 1.0);  // stroke connecting DOG
	//GetOrientedDOG5(gray, gfield, gray2, G_mag, 1.0, 0.99); // FULL ADAPTIVE ORIENTED DOG!
	//GetFlowDiffusion(dc, gfield, gray2, 30, 1);
	//GetFlowDiffusion(dc, gfield, gray2, G_mag, 1, 5);
	//GetFlowBlur(dc, gfield, gray2, 30);
	//GetDOG2(gray, G_mag, gray2, 0.5, 0.99);  // cameron diaz
	//GetDOG2(gray, G_mag, gray2, 0.7, 1.0);  // stroke connecting DOG
	//GetDOG(IMAGE_X, IMAGE_Y, gray, G_mag, gray2, 100, 150, 0.99); // Cameron Diaz!!! and Lena!!!
	//////////////////////////////////////////////////
	Thresholding(IMAGE_X, IMAGE_Y, gray2, 0.5); // DOG value 0.2 or below
	//Thresholding(IMAGE_X, IMAGE_Y, gray2, 0.1); // DOG value 0.2 or below
	//Thresholding(IMAGE_X, IMAGE_Y, gray2, 0.8); // DOG value 0.2 or below
	//Thresholding(IMAGE_X, IMAGE_Y, gray2, 0.7); // zucker
	//Thresholding(IMAGE_X, IMAGE_Y, gray2, 1.0); // stroke connectig DOG
	//GetFlowLineMedian(gray2, gfield, 1.0, 3);
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//////////////////////////////////////////////////////////////////
	
}


void CCubeView::OnEdgeTvf()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	//GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//max_grad = getGradient(IMAGE_X, IMAGE_Y, gradient, image);
	//gau_w = MakeGaussMask(1.0, gau);
	//gau_w = MakeGaussMask(3.0, gau);
	//gau_w = MakeGaussMask(10.0, gau);
	//TRACE("gau_w = %d\n", gau_w);
	//GaussSmooth2(IMAGE_X, IMAGE_Y, gray, gau_w);
	GaussSmooth5(gray, 0.7); // normal image
	//GaussSmooth5(gray, 2.0); // normal image
	//GaussSmooth6(gray, 0.7); // dashed circle
	/////////////////////////////////////////////////////
	// make edge pixels white (not black)
	GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); 
	//////////////////////////////////////////////////
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
	////////////////////////////////////////////////////////////
	// 11/26/2006: We need use Gradient map instead of input image!
	// to create correct GVF vector directions!
	// so that the vectors can always point to the nearest pixels with highest magnitude!
	InitGradField(IMAGE_X, IMAGE_Y, gfield, gray2); // now (gx, gy) is computed from gradient map!
	//////////////////////////////////////////////////////
	//GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	//max_grad = getGradient(IMAGE_X, IMAGE_Y, gradient, image);
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, image);
	
	//////////////////////////////////////////////////////////////////
	// This one is the best
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.1); // for original picture
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 200, 0.1); // for original picture
	////////////////////////////////////////////////////////
	//BilateralGfield10_speedcheck(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 1); 
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 1); 
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 13); 
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 30); 
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 2.0, 3); 
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 20);
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 10); 
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 7);
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 10);
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 20);
	//BilateralGfield11(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 20);
	//BilateralGfield12(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2);
	//BilateralGfield12(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 10);
	BilateralGfield13(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 1);
	//BilateralGfield13(dc, IMAGE_X, IMAGE_Y, gfield, 2.0, 6);

	//////////////////////////////////////////////////
	// 11/21/2006
	// I thought LIC2 is incorrect becaues it uses iteger positions only to advance
	// But it turns out that this one produces better result than LIC3
	// So this one needs some further evaluation!
	
	//DrawGradientFieldArrow(dc, gfield, 255, 0, 0);
	//DrawTangentFieldArrow(dc, gfield, 255, 0, 0);
	DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 20); // incorrect version? (looks better)
	//DrawGradientField_LIC4(dc, IMAGE_X, IMAGE_Y, gfield, 20); // incorrect version? (looks better)
	//DrawGradientField_LIC5(dc, IMAGE_X, IMAGE_Y, gfield, 20); // incorrect version? (looks better)
	//DrawGradientField_LIC3(dc, IMAGE_X, IMAGE_Y, gfield, 20);  
	//DrawGradientField_LIC6(dc, IMAGE_X, IMAGE_Y, gfield, 20); 
	///////////////////////////////////////////////////////////////////
	// 3/26/2007: I foudn where it takes the longest time!
	//DrawGradientField_LIC7(dc, IMAGE_X, IMAGE_Y, gfield, 20); // this takes almost 30 seconds!
	// I think it's mainly due to the bilinear interpolation part!
	/////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////
	TRACE("TVF construction done!\n");

}

void CCubeView::OnEdgeFdog()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	//GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	//StartTimer();
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//////////////////////////////
	//gau_w = MakeGaussMask(1.0, gau);
	//GaussSmooth2(IMAGE_X, IMAGE_Y, gray, gau_w);
	//GaussSmooth5(gray, 1.0); // paolina
	//StartTimer();
	//GaussSmooth5(gray, 0.7); // lena
	GaussSmooth5(gray, 0.5); // lena
	//GaussSmooth5(gray, 1.0); // mandrill
	//GaussSmooth5(gray, 1.5); // mandrill
	//TRACE("Elapsed Time = %f\n", ElapsedTime());
	//GaussBlurBilateral(IMAGE_X, IMAGE_Y, gray, 1.0, 0.1, 1); // new
	//GaussSmooth5(gray, 0.5); // leesy
	gray2.copy(gray);
	imatrix tmp;
	tmp.init(gray.getRow(), gray.getCol());
	tmp.copy(gray);
	//GaussSmooth5(gray2, 4.0); // for dotted circle
	//GaussSmooth5(gray2, 1.0); // for dotted circle
	//////////////////////////////////////////////////
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	///////////////////////////////////////////////////////////////
	InitGradField(IMAGE_X, IMAGE_Y, gfield, gray); // orginary image
	GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); // used for TVF
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray2); // Sobel magnitude image
	//////////////////////////////////////////////
	//BilateralGfield12(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2); // smooth with smaller magnitude too!
	BilateralGfield13(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2); // fastest version
	//TRACE("Elapsed Time = %f\n", ElapsedTime());
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 3.0, 5); // fingerprint!
	//DrawGradientField_LIC7(dc, IMAGE_X, IMAGE_Y, gfield, 20); // correct version (bilinear interp)
	//DrawTangentFieldArrow(dc, gfield, 255, 0, 0);
	DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 20);
	//////////////////////////////

	///////////////////////////////////////////////////////
	// Testing the single applicatino of FDoG (for NPAR)
	//GetDOG2(gray, G_mag, gray2, 1.0, 0.995);  // cameron diaz
	//GetFlowDOG2(gray, gfield, gray, G_mag, 0.8, 1.0, 0.997); // Initial FDoG. Also works!
	//GetFlowDOG2(gray, gfield, gray, G_mag, 1.0, 1.0, 0.996); // Initial FDoG. Also works!
	//GetFlowDOG2(gray, gfield, gray, G_mag, 1.0, 3.0, 0.996); // Initial FDoG. Also works!
	//GetFlowDOG2(gray, gfield, gray, G_mag, 1.0, 2.0, 0.996); // Initial FDoG. Also works!

	//StartTimer();
	GetFlowDOG4(gray, gfield, gray, G_mag, 1.0, 3.0, 0.996); // Initial FDoG. Also works!
	//GetFlowDOG4(gray, gfield, gray, G_mag, 0.9, 1.4, 0.996); // Initial FDoG. Also works!
	//GetFlowDOG4(gray, gfield, gray, G_mag, 10, 10, 0.996); // Initial FDoG. Also works!
	//EndTimer("_Result_FDOG.txt");
	//GetFlowDOG2(gray, gfield, gray, G_mag, 1.0, 2.0, 0.996); // Initial FDoG. Also works!
	//GetFlowDOG2(gray, gfield, gray, G_mag, 1.0, 3.0, 0.996); // Initial FDoG. Also works!
	//GetFlowDOG2(gray, gfield, gray, G_mag, 1.0, 3.0, 0.999); // Initial FDoG. Also works!
	//GetFlowDOG2(gray, gfield, gray, G_mag, 1.0, 5.0, 0.998); // Initial FDoG. Also works!
	//GetFlowDOG2(gray, gfield, gray, G_mag, 0.8, 10.0, 0.996); // Initial FDoG. Also works!
	//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.7); // zucker
	Thresholding(IMAGE_X, IMAGE_Y, gray, 0.5); // zucker
	//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.2); // zucker
	//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.99); // zucker
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	/////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////
	
	///////////////////////////////////////////
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	TRACE("FDoG completed!\n");
	printf("FDoG completed!\n");
	//TRACE("Elapsed Time = %f\n", ElapsedTime());

	//GetFlowDOG3(gray, gfield, gray, G_mag, 1.0, 3.0, 0.995); // Adjust GVF direction (bad)
	//GetFlowDOG2(gray, gfield, gray, G_mag, 1.0, 7.0, 0.995); // Flow-based DOG! Very good!
	//GetFlowDOG2(gray, gfield, gray, G_mag, 1.0, 7.0, 0.995); // Flow-based DOG! Very good!
	//GetDOG2(gray, G_mag, gray2, 1.0, 0.99);  // cameron diaz
	//GetOrientedDOG3(gray, gfield, gray2, G_mag, 0.7, 1.0); // FULL ORIENTED DOG!
	//Thresholding(IMAGE_X, IMAGE_Y, gray2, 0.9);
	//Thresholding(IMAGE_X, IMAGE_Y, gray2, 0.5);
	//////////////////////////////////////////////////////////////////
	// This one is the best
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.1); // This improves DOG thinning quality!
	///////////////////////////////////////
	//BilateralGfield4(IMAGE_X, IMAGE_Y, gfield, 2.0, 1);
	//BilateralGfield4(IMAGE_X, IMAGE_Y, gfield, 1.5, 1);
	///////////////////////////////////////////////////////
	//DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 20);
	////////////////////////////////////////////////////////////
	
	//GetSobelGradient(IMAGE_X, IMAGE_Y, gray, gray2, G_mag);
	//GetDOG(IMAGE_X, IMAGE_Y, gray, G_mag, gray2, 150, 200, 0.99); // thick edges
	//GetDOG(IMAGE_X, IMAGE_Y, gray, G_mag, gray2, 70, 150, 0.99); 
	//GetFlowDOG(IMAGE_X, IMAGE_Y, G_mag, gray2, gfield, 20, 1.0); // get averaged DOG over flow
	//GetFlowGradient(memDC, IMAGE_X, IMAGE_Y, gray, gfield, gray2, 20, 4, 1.414);
	//GetFlowGradient(memDC, IMAGE_X, IMAGE_Y, gray, gfield, gray2, 100, 10, 1.414);
	//NonmaximaSuppression(IMAGE_X, IMAGE_Y, gfield, G_mag, gray2, 0.2);
	//Thresholding(IMAGE_X, IMAGE_Y, gray2, 0.2);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
}



void CCubeView::OnEdgeGooch()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	//max_grad = getGradient(IMAGE_X, IMAGE_Y, gradient, image);
	//max_grad = getSobelGradient(IMAGE_X, IMAGE_Y, gradient, image);
	GaussSmooth5(gray, 0.7); // lena
	GetDOG2(gray, G_mag, gray, 1.0, 0.99);  // cameron diaz
	//GetDOG2(gray, G_mag, gray, 1.0, 0.995);  // cameron diaz
	//GetMedian(gray, 1.0, 1);
    Thresholding(IMAGE_X, IMAGE_Y, gray, 0.2); // DOG value 0.2 or below
	//////////////////////////////////////////////////////////
	//GaussBlur(IMAGE_X, IMAGE_Y, gray, 3.0);
	//GaussBlurBilateral(IMAGE_X, IMAGE_Y, gray, 3.0, 30.0); // old
	//GaussBlurBilateral(IMAGE_X, IMAGE_Y, gray, 3.0, 0.1, 1); // new
	BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.1, 2);
	//StartTimer();
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 1.0, 0.1, 3);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 1.0, 0.1, 1);
	//GaussBlurBilateral(IMAGE_X, IMAGE_Y, gray, 1.0, 0.1, 3); // new
	//TRACE("Elapsed Time = %f\n", ElapsedTime()); // 5 seconds for Paolina
	//InvertImage(IMAGE_X, IMAGE_Y, gray2);
	//*/
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	ColorQuantization(cmap, 10); 
	ConstructCartoonImage(cmap, gray, cmap);
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	TRACE("Gooch abstraction!\n");
}


void CCubeView::OnEdgeFlowBilateral()
{
	// Flow bilateral filter
	CClientDC dc(this);
	//GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	//////////////////////////////
	// DOG before Blurring the image! 
	//GaussColorSmooth5(cmap, 1.0); // leesy
	//GaussSmooth5(gray, 0.7); // lena
	//GaussSmooth5(gray, 1.0); // lena
	//GaussSmooth5(gray, 20.0); // noisy circle
	//gau_w = MakeGaussMask(1.0, gau);
	//GaussSmooth2(IMAGE_X, IMAGE_Y, gray, gau_w);
	//GaussSmooth3(IMAGE_X, IMAGE_Y, gray, gau_w); // there's something wrong
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	////////////////////////////////////////////////
	GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); // used for TVF
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray2);
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 50, 0.1); // for original picture
	//GetDOG2(gray, G_mag, gray2, 1.0, 0.99);  // cameron diaz
	//BilateralGfield8(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 7); // LENA 
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2); 
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 3); 
	BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 10); 
	//BilateralGfield12(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2); 
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 7); 
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 20); 
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 2.0, 3); 
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 10); 
	DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 20); // correct version (bilinear interp)
	//GetFlowBilateral(dc, gfield, gray, 1.0, 0.1, 1);
	//for (int i = 0; i < 2; i++) {
	//GetFlowLineColBilateral3(cmap, gfield, 2.0, 0.1, 10);
	//GetFlowColBilateral(cmap, gfield, 2.0, 0.1, 0.1, 5);
	//GetFlowColBilateral(cmap, gfield, 2.0, 1.0, 0.1, 5);
	//GetFlowColBilateral(cmap, gfield, 2.0, 0.5, 0.5, 5);
	//GetFlowColBilateral(cmap, gfield, 2.0, 0.01, 0.1, 5);
	//GetFlowColBilateral(cmap, gfield, 2.0, 0.1, 0.1, 8);
	//GetFlowColBilateral(cmap, gfield, 2.0, 0.5, 0.1, 8);
	//GetFlowColBilateral(cmap, gfield, 10.0, 0.7, 5.0, 10); // works for noisy circle (no tooning)
	//GetFlowColBilateral(cmap, gfield, 10.0, 0.3, 10.0, 5); // works for noisy circle (tooning)
	///////////////////////////////////////////////
	//GetFlowColBilateral(cmap, gfield, 2.0, 2.0, 0.1, 3);
	//GetFlowColBilateral(cmap, gfield, 2.0, 2.0, 0.1, 1);
	GetFlowColBilateral(cmap, gfield, 2.0, 0.3, 0.1, 10);
	//GetFlowColBilateral(cmap, gfield, 2.0, 0.5, 0.1, 10);
	//GetFlowColBilateral(cmap, gfield, 2.0, 0.3, 0.1, 30);
	//GetFlowColBilateral(cmap, gfield, 2.0, 0.1, 0.1, 20);
	//GetFlowColBilateral(cmap, gfield, 2.0, 1.0, 0.1, 10);
	//GetFlowColGaussian(cmap, gfield, 2.0, 0.01, 5);
	//}
	//GaussBlurBilateral(IMAGE_X, IMAGE_Y, gray, 3.0, 0.1,1);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	//ColorQuantization(cmap, 5); 
	ColorQuantization(cmap, 7); 
	//ColorQuantization(cmap, 4); 
	//ColorQuantization(cmap, 9); 
	//ColorQuantization(cmap, 10); 
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//////////////////////////////////////////////////////////////////
	CopyCmap2Membuffer(cmap, Dbuffer);
}

void CCubeView::OnEdgeFlowbilateral2()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	//GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	//////////////////////////////
	// DOG before Blurring the image! 
	//gau_w = MakeGaussMask(1.0, gau);
	//GaussSmooth2(IMAGE_X, IMAGE_Y, gray, gau_w);
	//GaussSmooth3(IMAGE_X, IMAGE_Y, gray, gau_w); // there's something wrong
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); // used for TVF
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray2);
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 50, 0.1); // for original picture
	//GetDOG2(gray, G_mag, gray2, 1.0, 0.99);  // cameron diaz
	//BilateralGfield8(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 7); // LENA 
	BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2); 
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 2.0, 3); 
	DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 20); // correct version (bilinear interp)
	//GetFlowBilateral(dc, gfield, gray, 1.0, 0.1, 1);
	//for (int i = 0; i < 2; i++) {
	//GetFlowLineColBilateral3(cmap, gfield, 2.0, 0.1, 10);
	//////////////////////////////////////////////////////////////////////
	//GetFlowColBilateral2(cmap, gfield, 2.0, 0.1, 0.1, 1); // painting effect is too strong!
	//GetFlowColBilateral2(cmap, gfield, 2.0, 0.1, 0.1, 10); // painting effect is too strong!
	//GetFlowColBilateral2(cmap, gfield, 2.0, 0.5, 0.3, 5); // painting effect is too strong!
	/////////////////////////////////////////////////////////////////////////////
	//GetFlowColGaussian(cmap, gfield, 2.0, 0.01, 5);
	//}
	//GaussBlurBilateral(IMAGE_X, IMAGE_Y, gray, 3.0, 0.1,1);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//////////////////////////////////////////////////////////////////
	CopyCmap2Membuffer(cmap, Dbuffer);
}

void CCubeView::OnEdgeBilateral()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	//max_grad = getGradient(IMAGE_X, IMAGE_Y, gradient, image);
	//max_grad = getSobelGradient(IMAGE_X, IMAGE_Y, gradient, image);
	//////////////////////////////////////////////////////////
	///*
	//gau_w = MakeGaussMask(5.0, gau);
	//gau_w = MakeGaussMask(0.1, gau);
	//TRACE("gau_w = %d\n", gau_w);
	//GaussSmooth2(IMAGE_X, IMAGE_Y, gray2, gau_w);
	//GaussSmooth3(IMAGE_X, IMAGE_Y, gray, gau_w);
	
	//GaussBlur(IMAGE_X, IMAGE_Y, gray, 3.0);
	//GaussBlurBilateral(IMAGE_X, IMAGE_Y, gray, 3.0, 30.0); // old
	//GaussBlurBilateral(IMAGE_X, IMAGE_Y, gray, 3.0, 0.1, 1); // new
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.1, 10); // noisy circle
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.4, 1);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.1, 1);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 3.0, 0.1, 1);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.1, 3);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.1, 2);
	
	//StartTimer();
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.1, 5);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.05, 5);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.05, 5);
	//BilateralColorSep(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.05, 10);
	BilateralColorSep(IMAGE_X, IMAGE_Y, cmap, 2.0, 10.0, 3);
	//BilateralGraySep(gray, 2.0, 10.0, 3);
	////////////////////////////////////////////
	//BilateralColorSep(IMAGE_X, IMAGE_Y, cmap, 2.0, 10.0, 3);
	//////////////////////////////////////////////////////

	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.05, 3);
	//BilateralColorTomasi(IMAGE_X, IMAGE_Y, cmap, 2.0, 20, 3);
	//BilateralColorChui(cmap, 2.0, 100, 3);
	//EndTimer("_Result_BL.txt");
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 4.0, 0.1, 1);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 3.0, 0.1, 1);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.1, 1);
	//StartTimer();
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 1.0, 0.1, 3);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 1.0, 0.1, 1);
	//GaussBlurBilateral(IMAGE_X, IMAGE_Y, gray, 1.0, 0.1, 3); // new
	//TRACE("Elapsed Time = %f\n", ElapsedTime()); // 5 seconds for Paolina
	//InvertImage(IMAGE_X, IMAGE_Y, gray2);
	//*/
	
	//ColorQuantization(cmap, 4); 
	//ColorQuantization(cmap, 5); 
	//ColorQuantization(cmap, 10); 
	//ColorQuantization(cmap, 7); 
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	TRACE("Bilateral color filter done!\n");
	CopyCmap2Membuffer(cmap, Dbuffer);

}


void CCubeView::OnEdgeFlowbilateral3()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	//GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	/////////////////////////////////////////
	//GetPSNR(dc, cmap, "_circle_bl_psnr.bmp", "_circle_fbl_psnr.bmp");
	//GetPSNR_partial(dc, cmap, "_circle_bl_psnr.bmp", "_circle_fbl_psnr.bmp");
	//GetPSNR(dc, cmap, "_circle_noise3_bl.bmp", "_circle_noise3_fbl.bmp");
	//GetPSNR_partial(dc, cmap, "_circle_noise3_bl.bmp", "_circle_noise3_fbl.bmp");
	//GetPSNR(dc, cmap, "maple_etf_full_4_2.bmp", "maple_etf_sep_4_2.bmp");
	

	//RGB2LAB(255, 0, 0, L, a, b);
	//ConvertRGBtoLAB256(cmap, cmap);
	//////////////////////////////
	// DOG before Blurring the image! 
	//GaussColorSmooth5(cmap, 1.0); // leesy
	GaussSmooth5(gray, 0.7); // lena
	//GaussSmooth5(gray, 1.0); // lena
	//GaussSmooth5(gray, 20.0); // noisy circle
	//gau_w = MakeGaussMask(1.0, gau);
	//GaussSmooth2(IMAGE_X, IMAGE_Y, gray, gau_w);
	//GaussSmooth3(IMAGE_X, IMAGE_Y, gray, gau_w); // there's something wrong
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	////////////////////////////////////////////////
	//GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); // used for TVF
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray2);
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 50, 0.1); // for original picture
	//GetDOG2(gray, G_mag, gray2, 1.0, 0.99);  // cameron diaz
	//StartTimer();
	//BilateralGfield12(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2);
	BilateralGfield13(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2);
	//BilateralGfield13(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 3);
    //BilateralGfield12(dc, IMAGE_X, IMAGE_Y, gfield, 1.5, 1); 
	//BilateralGfield12(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 7); 
	//EndTimer("_Result_ETF.txt");
	DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 20); // correct version (bilinear interp)
	//GetFlowBilateral(dc, gfield, gray, 1.0, 0.1, 1);
	//for (int i = 0; i < 2; i++) {
	//StartTimer();
	//GetFlowColBilateral3(cmap, gfield, 2.0, 0.3, 0.1, 4);
	//GetFlowColBilateral3(cmap, gfield, 2.0, 2.0, 0.1, 4);
	//GetFlowColBilateral4(cmap, gfield, 3.0, 2.0, 0.1, 5, 8); // circle
	//GetFlowColBilateral4(cmap, gfield, 2.0, 2.0, 0.1, 8, 0); // circle
	//GetFlowColBilateral5(cmap, gfield, 3.0, 2.5, 0.1, 3); // circle (OPTIMAL!)
	//GetFlowColBilateral5(cmap, gfield, 3.0, 3.0, 0.1, 5); // circle 
	//GetFlowColBilateral5(cmap, gfield, 2.0, 2.0, 0.1, 8); // eagle
	//GetFlowColBilateral4(cmap, gfield, 2.0, 0.3, 0.1, 8, 8);
	//GetFlowColBilateral6(cmap, gfield, 2.0, 2.0, 0.1, 8, 8);
	
	//GetFlowColBilateral4(cmap, gfield, 2.0, 0.1, 0.1, 10, 10); // eagle
	//GetFlowColBilateral4(cmap, gfield, 2.0, 0.1, 0.1, 10, 8); // eagle
	//GetFlowColBilateral5(cmap, gfield, 1.0, 0.3, 0.1, 10); // eagle
	//GetFlowColBilateral5(cmap, gfield, 2.0, 0.1, 0.1, 10); // skull
	//GetFlowColBilateral5(cmap, gfield, 2.0, 0.3, 0.1, 10); // skull
	//GetFlowColBilateral7(cmap, gfield, 2.0, 0.3, 0.1, 5); // skull
	//GetFlowColBilateral5(cmap, gfield, 2.0, 0.1, 0.1, 5); // skull

	//GetFlowColBilateral7(cmap, gfield, 2.0, 2.0, 0.1, 8); // circle -> like Gaussian
	//StartTimer();
	//GetFlowColBilateral9(cmap, gfield, 0.1, 2.0, 0.1, 0.1, 4); // circle -> like Gaussian
	//GetFlowColBilateral9(cmap, gfield, 2.0, 2.0, 1.0, 0.1, 4); // circle -> like Gaussian
	//GetFlowColBilateral9(cmap, gfield, 2.0, 2.0, 1.0, 0.1, 5); // circle -> like Gaussian
	//GetFlowColBilateral9(cmap, gfield, 2.0, 2.0, 50.0, 10.0, 5); // circle -> like Gaussian
    //GetFlowColBilateral9(cmap, gfield, 2.0, 0.3, 10.0, 10.0, 1); // same parameter as Tomasi's
	//GetFlowColBilateral9(cmap, gfield, 2.0, 0.3, 10.0, 10.0, 5); // same parameter as Tomasi's

	//GetFlowColBilateralLAB(cmap, gfield, 2.0, 0.5, 10.0, 10.0, 5); // same parameter as Tomasi's
	//GetFlowColBilateralLAB(cmap, gfield, 2.0, 2.0, 10.0, 3.0, 5); // same parameter as Tomasi's
	//GetFlowColBilateralLAB(cmap, gfield, 2.0, 0.3, 5.0, 3.0, 5); // Eagle 
	//GetFlowColBilateralLAB(cmap, gfield, 2.0, 0.3, 10.0, 3.0, 5); // MRI 
	//GetFlowColBilateralLAB(cmap, gfield, 2.0, 0.5, 10.0, 5.0, 10); // Skull 
	//GetFlowColBilateralLAB(cmap, gfield, 2.0, 0.5, 10.0, 5.0, 10); // Heart
	//GetFlowColBilateralLAB(cmap, gfield, 2.0, 0.3, 10.0, 5.0, 10); // Matthew
	//GetFlowColBilateralLAB(cmap, gfield, 2.0, 0.3, 10.0, 10.0, 10); // David
	
	//GetFlowColBilateral9(cmap, gfield, 2.0, 0.5, 50.0, 10.0, 10); // Heart 
	//GetFlowColBilateral9(cmap, gfield, 2.0, 0.3, 30.0, 10.0, 10); // David
	GetFlowColBilateral9(cmap, gfield, 2.0, 0.3, 30.0, 10.0, 5); // David
	//GetFlowColBilateralFlowAxis(cmap, gfield, 2.0, 10.0, 5);
	//GetFlowColBilateralGradAxis(cmap, gfield, 2.0, 10.0, 5);
	//BilateralColorSep(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.05, 5);
	//GetFlowColBilateral9(cmap, gfield, 2.0, 2.0, 1.0, 0.1, 8); // circle -> like Gaussian
	//GetFlowColBilateral9(cmap, gfield, 2.0, 0.5, 1.0, 0.1, 1); // MRI -> like Gaussian
	//GetFlowColBilateral9(cmap, gfield, 2.0, 0.5, 0.1, 0.1, 5); // MRI -> like Gaussian
	//GetFlowColBilateral9(cmap, gfield, 2.0, 0.5, 1.0, 0.1, 5); // MRI -> like Gaussian
	//EndTimer("_Result_FBL.txt");
	//GetFlowColBilateral7(cmap, gfield, 2.0, 0.1, 0.1, 10); // mri -> like Gaussian

	//EndTimer("_Result_FBL.txt");
	//}
	//GaussBlurBilateral(IMAGE_X, IMAGE_Y, gray, 3.0, 0.1,1);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	//ConvertLABtoRGB256(cmap, cmap);
	//ColorQuantization(cmap, 2); 
	ColorQuantization(cmap, 4); 
	//ColorQuantizationLAB(cmap, 7); 
	//ColorQuantization(cmap, 10); 
	//ColorQuantization(cmap, 12); 
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//////////////////////////////////////////////////////////////////
	CopyCmap2Membuffer(cmap, Dbuffer);
}


void CCubeView::OnEdgeFlowgauss()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	//GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	//////////////////////////////
	// DOG before Blurring the image! 
	//gau_w = MakeGaussMask(1.0, gau);
	//GaussSmooth2(IMAGE_X, IMAGE_Y, gray, gau_w);
	//GaussSmooth3(IMAGE_X, IMAGE_Y, gray, gau_w); // there's something wrong
	GaussSmooth5(gray, 1.5); // lena
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); // used for TVF
	GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); // used for TVF
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray); // get ETF from original
	InitGradField(IMAGE_X, IMAGE_Y, gfield, gray2); // get ETF from Sobel(I) -> destroys feature! (Eagle eye)
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 50, 0.1); // for original picture
	//BilateralGfield8(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 7); // LENA 
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 1); 
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2); 
	BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 3); 
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 2.0, 3); 
	DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 20); // correct version (bilinear interp)
	//GetFlowBilateral(dc, gfield, gray, 1.0, 0.1, 1);
	//for (int i = 0; i < 2; i++) {
	GetDOG2(gray, G_mag, gray, 1.0, 0.99);  // cameron diaz
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//GetFlowLineColBilateral3(cmap, gfield, 2.0, 0.1, 10);
	//GetFlowColBilateral(cmap, gfield, 2.0, 0.1, 0.1, 10);
	//GetFlowColBilateral(cmap, gfield, 2.0, 0.1, 1.0, 10);
	GetFlowDiffusion(dc, gfield, gray, G_mag, 3, 10);
	//GetFlowColGaussian(cmap, gfield, 2.0, 0.01, 10);
	//GetFlowLineColGaussian(cmap, gfield, 2.0, 20);
	//}
	//GaussBlurBilateral(IMAGE_X, IMAGE_Y, gray, 3.0, 0.1,1);
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	//DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//////////////////////////////////////////////////////////////////
}

void CCubeView::OnEdgeLines()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	//GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	//StartTimer();
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//////////////////////////////
	//gau_w = MakeGaussMask(1.0, gau);
	//GaussSmooth2(IMAGE_X, IMAGE_Y, gray, gau_w);
	//GaussSmooth5(gray, 1.0); // paolina
	//StartTimer();
	//GaussBlurBilateral(IMAGE_X, IMAGE_Y, gray, 1.0, 0.1, 2);
	GaussSmooth5(gray, 0.7); // lena
	//GaussSmooth5(gray, 0.5); // lena
	//GaussSmooth5(gray, 1.0); // mandrill
	//GaussSmooth5(gray, 1.5); // mandrill
	//TRACE("Elapsed Time = %f\n", ElapsedTime());
	//GaussBlurBilateral(IMAGE_X, IMAGE_Y, gray, 1.0, 0.1, 1); // new
	//GaussSmooth5(gray, 0.5); // leesy
	gray2.copy(gray);
	imatrix tmp;
	tmp.init(gray.getRow(), gray.getCol());
	tmp.copy(gray);
	//GaussSmooth5(gray2, 4.0); // for dotted circle
	//GaussSmooth5(gray2, 1.0); // for dotted circle
	///////////////////////////////////////////////////////////////
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray); // orginary image
	GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); // used for ETF
	InitGradField(IMAGE_X, IMAGE_Y, gfield, gray2); // Sobel magnitude image
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray); // Sobel magnitude image
	//////////////////////////////////////////////////////
	// DOG first and then TVF
	//GetDOG2(gray, G_mag, gray, 1.0, 0.99);  // // TVF is obtained from DOG!
	//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.5); // paolina
	//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.7); // zucker
	//ConstructMergedImage(tmp, gray, gray); // // TVF is obtained from DOG!
	////////////////////////////////////////////
	//GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); // used for TVF
	/////////////////////////////////////////////////
	// TVF first and then DOG
	//GetDOG2(gray, G_mag, gray, 1.0, 0.99);  // TVF is directly obtained from input image!
	//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.5); // zucker
	//////////////////////////////////////////////////
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//////////////////////////////////////////////
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.1); // for original picture
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.1); // for original picture
	//BilateralGfield9(dc, IMAGE_X, IMAGE_Y, gfield, 10.0, 1); // stipple circle
	//BilateralGfield9(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2); // Diaz and others!
	//StartTimer();
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 3); // smooth with smaller magnitude too!
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 7); // smooth with smaller magnitude too!
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 1); // smooth with smaller magnitude too!
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2); // smooth with smaller magnitude too!
	//BilateralGfield12(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2);
	//BilateralGfield12(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 7);
	//BilateralGfield12(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2);
	BilateralGfield13(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2);
	//TRACE("Elapsed Time = %f\n", ElapsedTime());
	//BilateralGfield9(dc, IMAGE_X, IMAGE_Y, gfield, 2.0, 3); // fingerprint!
	//BilateralGfield9(dc, IMAGE_X, IMAGE_Y, gfield, 3.0, 3); // fingerprint!
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 3.0, 5); // fingerprint!
	//DrawGradientField_LIC7(dc, IMAGE_X, IMAGE_Y, gfield, 20); // correct version (bilinear interp)
	//DrawTangentFieldArrow(dc, gfield, 255, 0, 0);
	DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 20);
	//////////////////////////////

	///////////////////////////////////////////////////////
	// Initial DoG or FDoG
	GetDOG2(gray, G_mag, gray, 1.0, 0.99);  
	//GetFlowDOG4(gray, gfield, gray, G_mag, 1.0, 1.0, 0.995); // Initial FDoG. Also works!
	//GetDOG2(gray, G_mag, gray, 1.0, 0.995);  
	//GetDOG2(gray, G_mag, gray, 0.8, 0.995);  
	//GetFlowDOG2(gray, gfield, gray, G_mag, 0.8, 1.0, 0.997); // Initial FDoG. Also works!
	//GetFlowDOG2(gray, gfield, gray, G_mag, 1.0, 1.0, 0.995); // Initial FDoG. Also works!
	//GetFlowDOG2(gray, gfield, gray, G_mag, 1.0, 0.8, 0.996); // Initial FDoG. Also works!
	//GetFlowDOG2(gray, gfield, gray, G_mag, 0.8, 10.0, 0.996); // Initial FDoG. Also works!
	//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.2); // zucker
	Thresholding(IMAGE_X, IMAGE_Y, gray, 0.5); // zucker
	//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.7); // zucker
	//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.8); // zucker
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	/////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////
	///*
	//double tao = 0.995;
	double tao = 0.995;
	//double tao = 0.99;
	//double tao = 0.98;
	//double tao = 1.0;
	for (int i = 0; i < 4; i++) {
		ConstructMergedImage(tmp, gray, gray); // merge with the original image
		//GaussSmooth5(gray, 1.0); // paolina
		//GaussSmooth5(gray, 0.7); // lena
		//GaussBlurBilateral(IMAGE_X, IMAGE_Y, gray, 1.0, 0.1, 1); // new
		//GetFlowLineGaussian(gray, gfield, 1.0, 5);
		//GaussSmooth5(gray, 0.5); // leesy
		GaussSmooth5(gray, 0.7); // leesy
		//GaussSmooth5(gray, 1.0); // fingerprint
		//GaussSmooth5(gray, 1.5); // fingerprint
		//StartTimer();
		//GetFlowDOG2(gray, gfield, gray, G_mag, 1.0, 3.0, tao); // Flow-based DOG! Very good!
		//GetFlowDOG2_speedcheck(gray, gfield, gray, G_mag, 1.0, 3.0, tao); // Flow-based DOG! Very good!
		//GetFlowDOG2(gray, gfield, gray, G_mag, 0.8, 3.0, tao); // Flow-based DOG! Very good!
		//GetFlowDOG2(gray, gfield, gray, G_mag, 0.8, 0.8, tao); // Flow-based DOG! Very good!
		//GetFlowDOG2(gray, gfield, gray, G_mag, 1.0, 3.0, tao); // Flow-based DOG! Very good!
		//GetFlowDOG4(gray, gfield, gray, G_mag, 1.0, 2.0, tao); // Initial FDoG. Also works!
		GetFlowDOG4(gray, gfield, gray, G_mag, 0.9, 2.0, tao); // Initial FDoG. Also works!
		//GetFlowDOG2(gray, gfield, gray, G_mag, 1.0, 1.0, tao); // shorter distance
		//TRACE("Elapsed Time = %f\n", ElapsedTime());
		//GetFlowDOG2(gray, gfield, gray, G_mag, 1.0, 5.0, tao); // Flow-based DOG! Very good!
		//tao += 0.001;
		//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.1); // paolina, lena, greenspan
		//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.2); // paolina, lena, greenspan
		Thresholding(IMAGE_X, IMAGE_Y, gray, 0.5); // 
		//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.7); // fingerprint, zucker
		DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
		dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		TRACE("FDOG iteration %d complete.\n", i+1);
	}
	//*/
	
	/////////////////////////////////////////////////////////
	// Performing one final DOG improves the quality!
	/*
	GaussSmooth5(gray, 0.5); // leesy
	GetDOG2(gray, G_mag, gray, 1.0, 0.995);  // TVF is directly obtained from input image!
	Thresholding(IMAGE_X, IMAGE_Y, gray, 0.5); // 
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	TRACE("Final DOG done\n");
	*/
	///////////////////////////////////////////
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	TRACE("Line drawing completed!\n");
	printf("Line drawing completed!\n");
	//TRACE("Elapsed Time = %f\n", ElapsedTime());

	//GetFlowDOG3(gray, gfield, gray, G_mag, 1.0, 3.0, 0.995); // Adjust GVF direction (bad)
	//GetFlowDOG2(gray, gfield, gray, G_mag, 1.0, 7.0, 0.995); // Flow-based DOG! Very good!
	//GetFlowDOG2(gray, gfield, gray, G_mag, 1.0, 7.0, 0.995); // Flow-based DOG! Very good!
	//GetDOG2(gray, G_mag, gray2, 1.0, 0.99);  // cameron diaz
	//GetOrientedDOG3(gray, gfield, gray2, G_mag, 0.7, 1.0); // FULL ORIENTED DOG!
	//Thresholding(IMAGE_X, IMAGE_Y, gray2, 0.9);
	//Thresholding(IMAGE_X, IMAGE_Y, gray2, 0.5);
	//////////////////////////////////////////////////////////////////
	// This one is the best
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 100, 0.1); // This improves DOG thinning quality!
	///////////////////////////////////////
	//BilateralGfield4(IMAGE_X, IMAGE_Y, gfield, 2.0, 1);
	//BilateralGfield4(IMAGE_X, IMAGE_Y, gfield, 1.5, 1);
	///////////////////////////////////////////////////////
	//DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 20);
	////////////////////////////////////////////////////////////
	
	//GetSobelGradient(IMAGE_X, IMAGE_Y, gray, gray2, G_mag);
	//GetDOG(IMAGE_X, IMAGE_Y, gray, G_mag, gray2, 150, 200, 0.99); // thick edges
	//GetDOG(IMAGE_X, IMAGE_Y, gray, G_mag, gray2, 70, 150, 0.99); 
	//GetFlowDOG(IMAGE_X, IMAGE_Y, G_mag, gray2, gfield, 20, 1.0); // get averaged DOG over flow
	//GetFlowGradient(memDC, IMAGE_X, IMAGE_Y, gray, gfield, gray2, 20, 4, 1.414);
	//GetFlowGradient(memDC, IMAGE_X, IMAGE_Y, gray, gfield, gray2, 100, 10, 1.414);
	//NonmaximaSuppression(IMAGE_X, IMAGE_Y, gfield, G_mag, gray2, 0.2);
	//Thresholding(IMAGE_X, IMAGE_Y, gray2, 0.2);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
}

void CCubeView::OnEdgeAbstract()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	//GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	//GaussColorSmooth5(cmap, 0.7); // leesy
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//gau_w = MakeGaussMask(1.0, gau);
	//StartTimer();
	//GaussSmooth2(IMAGE_X, IMAGE_Y, gray, gau_w);
	GaussSmooth5(gray, 0.7); // lena
	//GaussSmooth5(gray, 1.0); // lena
	//TRACE("Elapsed Time = %f\n", ElapsedTime());
	/////////////////////////////////////////////////
	GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); // used for ETF
	InitGradField(IMAGE_X, IMAGE_Y, gfield, gray2);
	//////////////////////////////////
	GetDOG2(gray, G_mag, gray, 1.0, 0.995);  // cameron diaz
	//GetMedian(gray, 1.0, 1);
	//GaussSmooth5(gray, 0.3); // leesy
    Thresholding(IMAGE_X, IMAGE_Y, gray, 0.5); // DOG value 0.2 or below
	//GetFlowLineMedian(gray, gfield, 2.0, 1);
    ConstructCartoonImage(cmap, gray, cmap);
	//ConstructCartoonImage3(cmap, gray, cmap);
	//ConstructCartoonImage2(cmap, gray, cmap, 0.2);
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	CopyCol2GrayImage(IMAGE_X, IMAGE_Y, cmap, gray); 
	//////////////////////////////
	// DOG before Blurring the image! 
	//GetDOG(IMAGE_X, IMAGE_Y, gray, G_mag, gray2, 50, 100, 0.99); // Cameron Diaz!!! and Lena!!!
	//max_grad = getGradient(IMAGE_X, IMAGE_Y, gradient, image);
	//GaussSmooth3(IMAGE_X, IMAGE_Y, gray, gau_w); // there's something wrong
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	/////////////////////////////////////////////
	////////////////////////////////////////
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 30, 0.01); 
	//BilateralGfield8(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 13); // without Gaussian! Very good!
	//BilateralGfield9(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 3); // Lena!
	//BilateralGfield9(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2); // Diaz and others!
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2); // Diaz and others!
	BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 7); // Diaz and others!
	//BilateralGfield9(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 3); 
	//BilateralGfield9(dc, IMAGE_X, IMAGE_Y, gfield, 2.0, 3); // fingerprint
	DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 20); // correct version (bilinear interp)
	//DrawGradientField_LIC7(dc, IMAGE_X, IMAGE_Y, gfield, 20); // correct version (bilinear interp)
	////////////////////////////////////////////////////
	//////////////////////////////////////
	//dog.copy(gray2);
	//GetFlowLineBilateral(gray, gfield, 2.0, 0.1, 30); // works better when GVF is not adjusted!
	//GetFlowLineBilateral3(gray, gfield, 2.0, 0.1, 10); // adaptive step size! (good!)
	for (int i = 0; i < 3; i++) {
		//GetFlowLineColBilateral3(cmap, gfield, 2.0, 0.1, 1);
		//GaussColorSmooth5(cmap, 0.7); // leesy
		//GetFlowColBilateral(cmap, gfield, 2.0, 0.1, 0.1, 5); // expand the kernel sideways
		//GetFlowColBilateral(cmap, gfield, 2.0, 0.1, 0.1, 1); // expand the kernel sideways
		GetFlowColBilateral(cmap, gfield, 2.0, 1.0, 0.1, 1); // expand the kernel sideways
		//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 1.0, 0.1, 3);
		CopyCol2GrayImage(IMAGE_X, IMAGE_Y, cmap, gray); 
		//GaussSmooth2(IMAGE_X, IMAGE_Y, gray, gau_w);
		GaussSmooth5(gray, 0.7); // leesy
		//GetFlowLineBilateral2(gray, gfield, 2.0, 0.1, 10); // cuts if the angle is too big (very bad)
		//GetDOG2(gray, G_mag, gray, 1.0, 0.998);  // cameron diaz
		GetFlowDOG2(gray, gfield, gray, G_mag, 1.0, 3.0, 0.995); // Flow-based DOG! Very good!
		//GetMedian(gray, 1.0, 1);
		//GetFlowLineMedian(gray, gfield, 1.0, 3);
		//GaussSmooth5(gray, 0.5); // leesy
		//GetFlowLineGaussian(gray, gfield, 3.0, 1.0, 1);
		Thresholding(IMAGE_X, IMAGE_Y, gray, 0.5); // DOG value 0.5 or below
		//GetFlowLineMedian(gray, gfield, 2.0, 1);
		////////////////////////////////////////////////////
		//DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
		ConstructCartoonImage(cmap, gray, cmap);
		//ConstructCartoonImage3(cmap, gray, cmap);
		//CopyCol2GrayImage(IMAGE_X, IMAGE_Y, cmap, gray); 
		//ConstructCartoonImage2(cmap, gray, cmap, 0.5);
		DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
		//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
		//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
		//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, dog);
		dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	}
	//GetFlowLineColBilateral3(cmap, gfield, 2.0, 0.1, 10); // linear kernel
	//GaussColorSmooth5(cmap, 0.7); // leesy
	TRACE("\nFinalizing...\n");
	//GetFlowColBilateral(cmap, gfield, 2.0, 0.1, 0.1, 20); // expand the kernel sideways
	GetFlowColBilateral(cmap, gfield, 2.0, 1.0, 0.1, 5); // expand the kernel sideways
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	ColorQuantization(cmap, 10); 
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	TRACE("End of Image Abstraction\n");
	///////////////////////////////////////////////
	// Smooth out the outlines
	///*
	//GetFlowLineColBilateral3(cmap, gfield, 2.0, 0.1, 20);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 3.0, 0.1, 3);
	//DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//*/
	//////////////////////////////////////////////////////////////////
}


void CCubeView::OnEdgeAbstract2()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	//GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	//GaussColorSmooth5(cmap, 0.7); // leesy
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//gau_w = MakeGaussMask(1.0, gau);
	//StartTimer();
	//GaussSmooth2(IMAGE_X, IMAGE_Y, gray, gau_w);
	GaussSmooth5(gray, 0.7); // lena
	//GaussSmooth5(gray, 1.0); // lena
	//TRACE("Elapsed Time = %f\n", ElapsedTime());
	/////////////////////////////////////////////////
	GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); // used for ETF
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
	InitGradField(IMAGE_X, IMAGE_Y, gfield, gray2);
	//////////////////////////////////
	GetDOG2(gray, G_mag, gray, 1.0, 0.99);  // cameron diaz
	//GetMedian(gray, 1.0, 1);
	//GaussSmooth5(gray, 0.3); // leesy
    Thresholding(IMAGE_X, IMAGE_Y, gray, 0.2); // DOG value 0.2 or below
	//GetFlowLineMedian(gray, gfield, 2.0, 1);
    ConstructCartoonImage(cmap, gray, cmap);
	//ConstructCartoonImage3(cmap, gray, cmap);
	//ConstructCartoonImage2(cmap, gray, cmap, 0.2);
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	CopyCol2GrayImage(IMAGE_X, IMAGE_Y, cmap, gray); 
	//////////////////////////////
	// DOG before Blurring the image! 
	//GetDOG(IMAGE_X, IMAGE_Y, gray, G_mag, gray2, 50, 100, 0.99); // Cameron Diaz!!! and Lena!!!
	//max_grad = getGradient(IMAGE_X, IMAGE_Y, gradient, image);
	//GaussSmooth3(IMAGE_X, IMAGE_Y, gray, gau_w); // there's something wrong
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	/////////////////////////////////////////////
	////////////////////////////////////////
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
	//GVF2(IMAGE_X, IMAGE_Y, gfield, 30, 0.01); 
	//BilateralGfield8(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 13); // without Gaussian! Very good!
	//BilateralGfield9(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 3); // Lena!
	//BilateralGfield9(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2); // Diaz and others!
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2); // Diaz and others!
	BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 3); // Diaz and others!
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 7); // Diaz and others!
	DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 20); // correct version (bilinear interp)
	//DrawGradientField_LIC7(dc, IMAGE_X, IMAGE_Y, gfield, 20); // correct version (bilinear interp)
	////////////////////////////////////////////////////
	//////////////////////////////////////
	//dog.copy(gray2);
	//GetFlowLineBilateral(gray, gfield, 2.0, 0.1, 30); // works better when GVF is not adjusted!
	//GetFlowLineBilateral3(gray, gfield, 2.0, 0.1, 10); // adaptive step size! (good!)
	for (int i = 0; i < 3; i++) {
		//GetFlowLineColBilateral3(cmap, gfield, 2.0, 0.1, 1);
		//GaussColorSmooth5(cmap, 0.7); // leesy
		//GetFlowColBilateral(cmap, gfield, 2.0, 0.1, 0.1, 5); // expand the kernel sideways
		//GetFlowColBilateral(cmap, gfield, 2.0, 0.1, 0.1, 1); // expand the kernel sideways
		//GetFlowColBilateral(cmap, gfield, 2.0, 1.0, 0.1, 1); // expand the kernel sideways
		//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 1.0, 0.1, 3);
		CopyCol2GrayImage(IMAGE_X, IMAGE_Y, cmap, gray); 
		//GaussSmooth2(IMAGE_X, IMAGE_Y, gray, gau_w);
		GaussSmooth5(gray, 0.7); // leesy
		//GetFlowLineBilateral2(gray, gfield, 2.0, 0.1, 10); // cuts if the angle is too big (very bad)
		//GetDOG2(gray, G_mag, gray, 1.0, 0.998);  // cameron diaz
		GetFlowDOG2(gray, gfield, gray, G_mag, 1.0, 3.0, 0.995); // Flow-based DOG! Very good!
		//GetMedian(gray, 1.0, 1);
		//GetFlowLineMedian(gray, gfield, 1.0, 3);
		//GaussSmooth5(gray, 0.5); // leesy
		//GetFlowLineGaussian(gray, gfield, 3.0, 1.0, 1);
		//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.5); // DOG value 0.5 or below
		Thresholding(IMAGE_X, IMAGE_Y, gray, 0.5); // DOG value 0.5 or below
		//GetFlowLineMedian(gray, gfield, 2.0, 1);
		////////////////////////////////////////////////////
		//DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
		ConstructCartoonImage(cmap, gray, cmap);
		//ConstructCartoonImage3(cmap, gray, cmap);
		//CopyCol2GrayImage(IMAGE_X, IMAGE_Y, cmap, gray); 
		//ConstructCartoonImage2(cmap, gray, cmap, 0.5);
		TRACE("\nFDoG Iteration No. %d\n\n", i+1);
		DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
		//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
		//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
		//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, dog);
		dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	}
	//GetFlowLineColBilateral3(cmap, gfield, 2.0, 0.1, 10); // linear kernel
	//GaussColorSmooth5(cmap, 0.7); // leesy
	TRACE("\nFBL filtering...\n\n");
	//GetFlowColBilateral(cmap, gfield, 2.0, 0.3, 0.1, 10); // expand the kernel sideways
	GetFlowColBilateral(cmap, gfield, 2.0, 0.5, 0.1, 10); // expand the kernel sideways
	//GetFlowColBilateral(cmap, gfield, 2.0, 1.0, 0.1, 5); // expand the kernel sideways
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	TRACE("\nQuantizing...\n\n");
	//ColorQuantization(cmap, 10); 
	ColorQuantization(cmap, 7); 
	//ColorQuantization(cmap, 5); 
	//ColorQuantization(cmap, 2); 
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	TRACE("End of Image Abstraction\n");
	///////////////////////////////////////////////
	// Smooth out the outlines
	///*
	//GetFlowLineColBilateral3(cmap, gfield, 2.0, 0.1, 20);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 3.0, 0.1, 3);
	//DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//*/
	//////////////////////////////////////////////////////////////////
}

void CCubeView::OnEdgeShock()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	//GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	//GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	//////////////////////////////
	// DOG before Blurring the image! 
	//GaussSmooth5(gray, 0.7); 
	//GaussSmooth5(gray, 1.0); 
	//GaussSmooth5(gray, 2.0); 
	//GaussColorSmooth5(cmap, 1.0); // leesy
	GaussColorSmooth5(cmap, 2.0); // leesy
	CopyCol2GrayImage(IMAGE_X, IMAGE_Y, cmap, gray); 
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); // used for TVF
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray2);
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 7); // Diaz and others!
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2); // Diaz and others!
	//DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 20); // correct version (bilinear interp)
	//GetShock(gray, G_mag, gray2, 1.0, 1.0);  // cameron diaz
	//GetShock2(gray, G_mag, gray2, 1.0, 0.99);  // cameron diaz
	//GetShock2(gray, G_mag, gray, 1.0, 1.0, 0.1);  // cameron diaz
	//GetColShock3(cmap, gray, 1.0, 1.0, 0.1);  // cameron diaz
	//GetColShock3(cmap, gray, 1.0, 1.0, 0.1);  // cameron diaz
	//DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//GetFlowShock(gray, gfield, gray, G_mag, 1.0, 3.0, 0.996);
	//GetFlowShock(gray, gfield, gray, G_mag, 1.0, 3.0, 1.0);
	///*
	//double tao = 0.995;
	for (int i = 0; i < 10; i++) {
		//ConstructMergedImage(tmp, gray, gray); // merge with the original image
		//GaussSmooth5(gray, 2.0); // leesy
		//GetFlowDOG2(gray, gfield, gray, G_mag, 1.0, 3.0, tao); // Flow-based DOG! Very good!
		//GetFlowShock(gray, gfield, gray, G_mag, 1.0, 3.0, 1.0, 0.1);
		//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.5); // 
		//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
		GetColShock3(cmap, gray, 1.0, 1.0, 2, 0.1);  // cameron diaz
		DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
		dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		TRACE("ColShock iteration %d complete.\n", i+1);
	}
	////////////////////////////
	//GetShock2(gray, G_mag, gray, 1.0, 1.0, 0.0);  // cameron diaz
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	//DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//*/
	TRACE("\nEnd of F-Shock iteration\n");
	//////////////////////////////////////////////////////////////////
}

void CCubeView::OnEdgeFlowshock()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	//GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	//GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	//////////////////////////////
	// DOG before Blurring the image! 
	GaussColorSmooth5(cmap, 1.0); // leesy
	//GaussColorSmooth5(cmap, 1.5); // leesy
	//GaussColorSmooth5(cmap, 3.0); // leesy
	CopyCol2GrayImage(IMAGE_X, IMAGE_Y, cmap, gray); 
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); // used for TVF
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
	InitGradField(IMAGE_X, IMAGE_Y, gfield, gray2);
	BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 7); // Diaz and others!
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2); // Diaz and others!
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 2.0, 3); // Diaz and others!
	DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 20); // correct version (bilinear interp)
	//GetShock(gray, G_mag, gray2, 1.0, 1.0);  // cameron diaz
	//GetShock2(gray, G_mag, gray2, 1.0, 0.99);  // cameron diaz
	//GetShock2(gray, G_mag, gray, 1.0, 1.0, 0.1);  // cameron diaz
	GetColShock(cmap, gray, 1.0, 1.0, 0.1);  // cameron diaz
	//GetColShock2(cmap, gray, 1.0, 1.0, 0.1);  // cameron diaz
	//GetFlowColShock(cmap, gfield, gray, 1.0, 1.0, 1.0, 0.0);
	//GetFlowShock(gray, gfield, gray, G_mag, 1.0, 3.0, 1.0, 0.0);
	//GetFlowShock(gray, gfield, gray, G_mag, 1.0, 1.0, 1.0, 0.0);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	//GetColContrastEnhance(cmap, 0.6, 0.9); 
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//GetFlowShock(gray, gfield, gray, G_mag, 1.0, 3.0, 0.996);
	//GetFlowShock(gray, gfield, gray, G_mag, 1.0, 3.0, 1.0);
	//double tao = 0.995;
	for (int i = 0; i < 3; i++) {
		//ConstructMergedImage(tmp, gray, gray); // merge with the original image
		GaussColorSmooth5(cmap, 1.0); // leesy
		CopyCol2GrayImage(IMAGE_X, IMAGE_Y, cmap, gray); 
		//GetFlowDOG2(gray, gfield, gray, G_mag, 1.0, 3.0, tao); // Flow-based DOG! Very good!
		//GetFlowShock(gray, gfield, gray, G_mag, 1.0, 3.0, 1.0, 0.1);
		GetFlowColShock(cmap, gfield, gray, 1.0, 3.0, 1.0, 0.1);
		//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.5); // 
		//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
		DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
		dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		TRACE("F-Shock iteration %d complete.\n", i+1);
	}
	////////////////////////////
	//GetShock2(gray, G_mag, gray, 1.0, 1.0, 0.0);  // cameron diaz
	GaussColorSmooth5(cmap, 1.0); // leesy
	CopyCol2GrayImage(IMAGE_X, IMAGE_Y, cmap, gray); 
	GetColShock(cmap, gray, 1.0, 1.0, 0.1);  // cameron diaz
	//DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);

	GetColContrastEnhance(cmap, 0.6, 0.8); 
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	TRACE("\nEnd of F-Shock iteration\n");
	//////////////////////////////////////////////////////////////////
}

void CCubeView::OnEdgeFlowshock2()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	//GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	//GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	//////////////////////////////
	// DOG before Blurring the image! 
	GaussColorSmooth5(cmap, 1.0); // leesy
	//GaussColorSmooth5(cmap, 1.5); // leesy
	//GaussColorSmooth5(cmap, 2.0); // leesy
	//GaussColorSmooth5(cmap, 3.0); // leesy
	CopyCol2GrayImage(IMAGE_X, IMAGE_Y, cmap, gray); 
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); // used for TVF
	InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray2);
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 7); // Diaz and others!
	//BilateralGfield11(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 7); // Diaz and others!
	BilateralGfield11(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2); // Diaz and others!
	//BilateralGfield11(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 3); // Diaz and others!
	//BilateralGfield11(dc, IMAGE_X, IMAGE_Y, gfield, 2.0, 3); // Diaz and others!
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 30); // Diaz and others!
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2); // Diaz and others!
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 3); // Diaz and others!
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 6); // Diaz and others!
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 2.0, 3); // Diaz and others!
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 2.0, 6); // Diaz and others!
	DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 20); // correct version (bilinear interp)
	//GetShock(gray, G_mag, gray2, 1.0, 1.0);  // cameron diaz
	//GetShock2(gray, G_mag, gray2, 1.0, 0.99);  // cameron diaz
	//GetShock2(gray, G_mag, gray, 1.0, 1.0, 0.1);  // cameron diaz
	//GetColShock(cmap, gray, 1.0, 1.0, 0.1);  // cameron diaz
	
	///////////////////////////////////////////////
	// After getting ETF, smooth the image (following Weickert's idea)
	//GaussColorSmooth5(cmap, 1.5); // leesy
	//CopyCol2GrayImage(IMAGE_X, IMAGE_Y, cmap, gray); 
	//DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	//////////////////////////////////////////////////
	
	double tau;
	tau = 0.99;
	//tau = 0.995;
	//tau = 1.0;
	GetColShock(cmap, gray, 1.0, tau, 0.1);  // cameron diaz
	//GetColShock(cmap, gray, 1.5, tau, 0.1);  // cameron diaz
	//GetColShock(cmap, gray, 2.0, tau, 0.1);  // cameron diaz
	//GetColShock3(cmap, gray, 1.0, 1.0, 4, 0.1);  // cameron diaz
	//GetColShock2(cmap, gray, 1.0, 1.0, 0.1);  // cameron diaz
	//GetFlowColShock(cmap, gfield, gray, 1.0, 1.0, 1.0, 0.0);
	//GetFlowShock(gray, gfield, gray, G_mag, 1.0, 3.0, 1.0, 0.0);
	//GetFlowShock(gray, gfield, gray, G_mag, 1.0, 1.0, 1.0, 0.0);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	//GetColContrastEnhance(cmap, 0.6, 0.9); 
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//GetFlowShock(gray, gfield, gray, G_mag, 1.0, 3.0, 0.996);
	//GetFlowShock(gray, gfield, gray, G_mag, 1.0, 3.0, 1.0);
	//double tao = 0.995;
	//tau = 0.995;
	//tau = 0.99;
	for (int i = 0; i < 4; i++) {
		//ConstructMergedImage(tmp, gray, gray); // merge with the original image
		GaussColorSmooth5(cmap, 1.0); // leesy
		CopyCol2GrayImage(IMAGE_X, IMAGE_Y, cmap, gray); 
		//GetFlowColShock2(cmap, gfield, gray, 1.5, 3.0, tau, 4, 0.1);
		GetFlowColShock2(cmap, gfield, gray, 1.0, 3.0, tau, 0.05, 0.001);
		//GetFlowColShock2(cmap, gfield, gray, 2.0, 3.0, tau, 4, 0.1);
		DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
		dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		TRACE("F-Shock iteration %d complete.\n", i+1);
	}
	////////////////////////////
	//GetShock2(gray, G_mag, gray, 1.0, 1.0, 0.0);  // cameron diaz
	GaussColorSmooth5(cmap, 1.0); // leesy
	CopyCol2GrayImage(IMAGE_X, IMAGE_Y, cmap, gray); 
	tau = 0.99;
	GetColShock(cmap, gray, 1.0, tau, 0.1);  // cameron diaz
	//GetColShock3(cmap, gray, 1.0, 1.0, 4, 0.1);  // cameron diaz
	//DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//GetColContrastEnhance(cmap, 0.6, 0.8); 
	GetColContrastEnhance(cmap, 0.5, 0.6); 
	//ColorQuantization(cmap, 10); 
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	TRACE("\nEnd of F-Shock Filtering\n");
	//////////////////////////////////////////////////////////////////
}

void CCubeView::OnEdgeFlowshock3()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	//GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	//GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	cmap2.init(cmap.getRow(), cmap.getCol());
	ConvertRGBtoLAB(cmap, cmap2);
	//ConvertLABtoRGB(cmap2, cmap);
	//////////////////////////////
	// DOG before Blurring the image! 
	//GaussColorSmooth5(cmap, 1.0); // leesy
	GaussColorSmooth5(cmap2, 1.0); // leesy
	//DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap2);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//GaussColorSmooth5(cmap, 2.0); // leesy
	//GaussColorSmooth5(cmap, 3.0); // leesy
	CopyCol2GrayImage(IMAGE_X, IMAGE_Y, cmap2, gray); 
	//DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); // used for TVF
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
	InitGradField(IMAGE_X, IMAGE_Y, gfield, gray2);
	BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 0.1, 7); // Diaz and others!
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2); // Diaz and others!
	//BilateralGfield10(dc, IMAGE_X, IMAGE_Y, gfield, 2.0, 3); // Diaz and others!
	DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 20); // correct version (bilinear interp)
	//GetShock(gray, G_mag, gray2, 1.0, 1.0);  // cameron diaz
	//GetShock2(gray, G_mag, gray2, 1.0, 0.99);  // cameron diaz
	//GetShock2(gray, G_mag, gray, 1.0, 1.0, 0.1);  // cameron diaz
	//GetColShock(cmap, gray, 1.0, 1.0, 0.1);  // cameron diaz
	double tau;
	//tau = 0.99;
	tau = 0.995;
	//tau = 1.0;
	GetColShock(cmap2, gray, 1.0, tau, 0.1);  // cameron diaz
	//GetColShock3(cmap, gray, 1.0, 1.0, 4, 0.1);  // cameron diaz
	//GetColShock2(cmap, gray, 1.0, 1.0, 0.1);  // cameron diaz
	//GetFlowColShock(cmap, gfield, gray, 1.0, 1.0, 1.0, 0.0);
	//GetFlowShock(gray, gfield, gray, G_mag, 1.0, 3.0, 1.0, 0.0);
	//GetFlowShock(gray, gfield, gray, G_mag, 1.0, 1.0, 1.0, 0.0);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	//GetColContrastEnhance(cmap, 0.6, 0.9); 
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap2);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//GetFlowShock(gray, gfield, gray, G_mag, 1.0, 3.0, 0.996);
	//GetFlowShock(gray, gfield, gray, G_mag, 1.0, 3.0, 1.0);
	//double tao = 0.995;
	//tau = 0.995;
	for (int i = 0; i < 3; i++) {
		//ConstructMergedImage(tmp, gray, gray); // merge with the original image
		GaussColorSmooth5(cmap2, 1.0); // leesy
		CopyCol2GrayImage(IMAGE_X, IMAGE_Y, cmap2, gray); 
		//GetFlowDOG2(gray, gfield, gray, G_mag, 1.0, 3.0, tao); // Flow-based DOG! Very good!
		//GetFlowShock(gray, gfield, gray, G_mag, 1.0, 3.0, 1.0, 0.1);
		//GetFlowColShock(cmap, gfield, gray, 1.0, 3.0, 1.0, 0.1);
		//GetFlowColShock2(cmap, gfield, gray, 1.0, 3.0, 1.0, 4, 0.1);
		//GetFlowColShock2(cmap, gfield, gray, 1.0, 3.0, tau, 4, 0.1);
		GetFlowColShock3(cmap2, gfield, gray, 1.0, 3.0, tau, 4, 0.1); // LAB version
		//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.5); // 
		//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
		DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap2);
		dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		TRACE("F-Shock iteration %d complete.\n", i+1);
	}
	ConvertLABtoRGB(cmap2, cmap);
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	/*
	////////////////////////////
	//GetShock2(gray, G_mag, gray, 1.0, 1.0, 0.0);  // cameron diaz
	GaussColorSmooth5(cmap, 1.0); // leesy
	CopyCol2GrayImage(IMAGE_X, IMAGE_Y, cmap, gray); 
	//GetColShock(cmap, gray, 1.0, 1.0, 0.1);  // cameron diaz
	//tau = 0.99;
	GetColShock(cmap, gray, 1.0, tau, 0.1);  // cameron diaz
	//GetColShock3(cmap, gray, 1.0, 1.0, 4, 0.1);  // cameron diaz
	//DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);

	//GetColContrastEnhance(cmap, 0.6, 0.8); 
	GetColContrastEnhance(cmap, 0.5, 0.6); 
	//ColorQuantization(cmap, 10); 
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	TRACE("\nEnd of F-Shock iteration\n");
	//////////////////////////////////////////////////////////////////
	*/
}




void CCubeView::OnToonShock()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	//GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	//GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	//////////////////////////////
	// DOG before Blurring the image! 
	//GaussColorSmooth5(cmap, 1.0); // leesy
	//GaussSmoothSep(gray, 1.0); // lena
	CopyCol2GrayImage(IMAGE_X, IMAGE_Y, cmap, gray); 
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); // used for TVF
	InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray2);
	BilateralGfield13(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2);
	DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 10); // correct version (bilinear interp)
	//GetShock(gray, G_mag, gray2, 1.0, 1.0);  // cameron diaz
	//GetShock2(gray, G_mag, gray2, 1.0, 0.99);  // cameron diaz
	//GetShock2(gray, G_mag, gray, 1.0, 1.0, 0.1);  // cameron diaz
	//GetColShock(cmap, gray, 1.0, 1.0, 0.1);  // cameron diaz
	
	///////////////////////////////////////////////
	// After getting ETF, smooth the image (following Weickert's idea)
	//GaussColorSmooth5(cmap, 1.5); // leesy
	//CopyCol2GrayImage(IMAGE_X, IMAGE_Y, cmap, gray); 
	//DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	//////////////////////////////////////////////////
	
	double tau = 0.99;
	//tau = 0.995;
	double z1, z2;
	z1 = 0.05, z2 = 0.05;
	//tau = 1.0;
	//GetColShock(cmap, gray, 1.0, tau, 0.1);  // cameron diaz
	GetFlowColShock2(cmap, gfield, gray, 1.0, 1.0, tau, z1, z2);
	//GetFlowColShock(cmap, gfield, gray, 1.0, 1.0, 1.0, 0.0);
	//GetFlowShock(gray, gfield, gray, G_mag, 1.0, 3.0, 1.0, 0.0);
	//GetFlowShock(gray, gfield, gray, G_mag, 1.0, 1.0, 1.0, 0.0);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	//GetColContrastEnhance(cmap, 0.6, 0.9); 
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//GetFlowShock(gray, gfield, gray, G_mag, 1.0, 3.0, 0.996);
	//GetFlowShock(gray, gfield, gray, G_mag, 1.0, 3.0, 1.0);
	//double tao = 0.995;
	//tau = 0.995;
	z1 = 0.05, z2 = 0.01;
	//tau = 0.99;
	for (int i = 0; i < 10; i++) {
		//ConstructMergedImage(tmp, gray, gray); // merge with the original image
		//GaussColorSmooth5(cmap, 0.3); // leesy
		GaussColorSmooth5(cmap, 1.0); // leesy
		//GaussSmoothSep(gray, 0.7); // lena
		CopyCol2GrayImage(IMAGE_X, IMAGE_Y, cmap, gray); 
		//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
		//BilateralGfield13(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2);
		//DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 10); 
		//GetFlowColShock2(cmap, gfield, gray, 1.5, 3.0, tau, 4, 0.1);
		GetFlowColShock2(cmap, gfield, gray, 1.0, 3.0, tau, z1, z2);
		//GetFlowColShock2(cmap, gfield, gray, 2.0, 3.0, tau, 4, 0.1);
		DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
		dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		TRACE("Toon-Shock iteration %d complete.\n", i+1);
	}
	////////////////////////////
	//GetShock2(gray, G_mag, gray, 1.0, 1.0, 0.0);  // cameron diaz
	//GaussColorSmooth5(cmap, 1.0); // leesy
	CopyCol2GrayImage(IMAGE_X, IMAGE_Y, cmap, gray); 
	tau = 0.99;
	//GetColShock(cmap, gray, 1.0, tau, 0.1);  // cameron diaz
	//GetColShock3(cmap, gray, 1.0, 1.0, 4, 0.1);  // cameron diaz
	//DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//GetColContrastEnhance(cmap, 0.6, 0.8); 
	GetColContrastEnhance(cmap, 0.5, 0.6); 
	//ColorQuantization(cmap, 10); 
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	TRACE("\nEnd of F-Shock Filtering\n");
	//////////////////////////////////////////////////////////////////
}

void CCubeView::OnToonWoodcut()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//gray2.copy(gray);
	//GaussSmooth5(gray, 1.0); // lena
	//GaussSmoothSep(gray, 1.0); // lena
	int image_x = gray.getRow();
	int image_y = gray.getCol();
	imatrix input(image_x, image_y);
	input.copy(gray);
	//////////////////////////////
	DrawGrayImage(memDC, image_x, image_y, gray);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
	//////////////////////////////////////////////////
	GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); // used for ETF
	ETF e;
	e.init(image_x, image_y);
	//e.set(gray);
	e.set(gray2);
	e.Smooth(4, 2);
	//////////////////////////////////////////////////////
	//DrawETF_LIC(dc, e, 20);

	///////////////////////////////////////////////////////
	// Initial DoG or FDoG
	double tao = 0.99;
	//GetDOG2(gray, G_mag, gray, 1.0, 0.99);  
	GetFDoG(gray, e, 0.7, 0.7, tao); // Initial FDoG. Also works!
	//GetLDoG(gray, e, 0.7, 0.7, tao); // Initial FDoG. Also works!
	Binarize(gray, 0.2); // zucker
	DrawInverseGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	/////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////
	///*
	//double tao = 0.995;
	tao = 0.99;
	//////////////////
	for (int i = 0; i < 5; i++) {
		ConstructMergedImage(input, gray, gray); // merge with the original image
		//GaussSmoothSep(gray, 0.7); // lena
		//e.set(gray);
		//e.Smooth(4, 3);
		//GetFlowDOG4(gray, gfield, gray, G_mag, 0.9, 2.0, tao); // Initial FDoG. Also works!
		GetFDoG(gray, e, 0.7, 3.0, tao); // Initial FDoG. Also works!
		//GetLDoG(gray, e, 0.7, 3.0, tao); // Initial FDoG. Also works!
		Binarize(gray, 0.9); 
		//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
		DrawInverseGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
		dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		TRACE("FDOG iteration %d complete.\n", i+1);
	}
	//*/
	
	///////////////////////////////////////////
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	TRACE("Woodcut printing completed!\n");
	//printf("Line drawing completed!\n");
	//TRACE("Elapsed Time = %f\n", ElapsedTime());
}

void CCubeView::OnToonWoodcut2()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//Binarize(gray, 0.5); // zucker
	//gray2.copy(gray);
	//GaussSmooth5(gray, 1.0); // lena
	GaussSmoothSep(gray, 1.0); // lena
	//////////////////////////////////
	int image_x = gray.getRow();
	int image_y = gray.getCol();
	///////////////////////////////////
	double thres = 0.5;
	//double zone_size = 1.2;
	double zone_size = 1.5; // good for human facial portrait!
	imatrix bw(image_x, image_y);
	bw.copy(gray);
	Binarize(bw, thres); // zucker
	//GaussSmooth5(bw, 1.0); // lena
	imatrix redzone(image_x, image_y);
	redzone.copy(bw);
	//GaussSmoothSep(redzone, 1.0); 
	CreateRedZone(redzone, zone_size);
	///////////////////////////////////////////////
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, bw);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//////////////////////////////////////
	imatrix input(image_x, image_y);
	input.copy(gray);
	//imatrix original(image_x, image_y);
	//original.copy(gray);
	//////////////////////////////
	DrawGrayImage(memDC, image_x, image_y, gray);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
	//////////////////////////////////////////////////
	GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); // used for ETF
	ETF e;
	e.init(image_x, image_y);
	//e.set(gray);
	e.set(gray2);
	e.Smooth(4, 2); // works best for Yul Brynner!
	//e.Smooth(5, 3);
	//////////////////////////////////////////////////////
	//DrawETF_LIC(dc, e, 20);

	///*
	///////////////////////////////////////////////////////
	// Initial DoG or FDoG
	double tao = 0.99;
	//GetDOG2(gray, G_mag, gray, 1.0, 0.99);  
	GetFDoG(gray, e, 0.7, 0.7, tao); // Initial FDoG. Also works!
	//GetFDoGRedZone(gray, e, redzone, bw, 0.7, 0.7, tao); // Initial FDoG. Also works!
	//GetLDoG(gray, e, 0.7, 0.7, tao); // Initial FDoG. Also works!
	Binarize(gray, 0.5); // zucker
	//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.7); // zucker
	//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.8); // zucker
	//DrawInverseGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	//DrawCondInverseGrayImage(memDC, gray, bw);
	DrawCondInverseGrayImageRedZone(memDC, gray, bw, redzone);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	/////////////////////////////////////////////////////////
	//*/
	
	/////////////////////////////////////////////////////
	///*
	//double tao = 0.995;
	tao = 0.999;
	//////////////////
	for (int i = 0; i < 10; i++) {
		GaussSmoothSep(input, 1.0); 
		bw.copy(input);
		Binarize(bw, thres); 
		//////////////////////////////
		redzone.copy(bw);
		CreateRedZone(redzone, zone_size);
		///////////////////////////////////
		ConstructMergedImage(input, gray, gray); // merge with the original image
		GaussSmoothSep(gray, 1.1); // lena
		//e.set(gray);
		//e.Smooth(4, 2);
		//GetFlowDOG4(gray, gfield, gray, G_mag, 0.9, 2.0, tao); // Initial FDoG. Also works!
		//GetFDoG(gray, e, 0.7, 3.0, tao); // Works well for most images
		///////////////////////////////////////////////////////////////////////
		GetFDoG(gray, e, 0.7, 3.0, tao); // This might produce more realistic woodcut print!
		/////////////////////////////////////////////////////////////////
		Binarize(gray, 0.7); 
		
		//DrawInverseGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
		//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
		//DrawCondInverseGrayImage(memDC, gray, bw);
		DrawCondInverseGrayImageRedZone(memDC, gray, bw, redzone);
		dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		TRACE("FDOG iteration %d complete.\n", i+1);
	}
	//*/
	/*
	ConstructMergedImage(input, gray, gray); // merge with the original image
	GaussSmoothSep(gray, 0.7); // lena
	//GaussSmooth5(gray, 1.0); // lena
	GetDOG2(gray, G_mag, gray, 1.0, 0.99);  
	Binarize(gray, 0.7); 
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	//DrawCondInverseGrayImage(memDC, gray, bw);
	///////////////////////////////////////////
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	*/

	TRACE("\nWoodcut printing completed!\n");
	//printf("Line drawing completed!\n");
	//TRACE("Elapsed Time = %f\n", ElapsedTime());
}

void CCubeView::OnToonShock2()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	//GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	//GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	//////////////////////////////
	// DOG before Blurring the image! 
	//GaussColorSmooth5(cmap, 1.0); // leesy
	//GaussSmoothSep(gray, 1.0); // lena
	CopyCol2GrayImage(IMAGE_X, IMAGE_Y, cmap, gray); 
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); // used for TVF
	InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray2);
	BilateralGfield13(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2);
	DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 10); // correct version (bilinear interp)
	//GetShock(gray, G_mag, gray2, 1.0, 1.0);  // cameron diaz
	//GetShock2(gray, G_mag, gray2, 1.0, 0.99);  // cameron diaz
	//GetShock2(gray, G_mag, gray, 1.0, 1.0, 0.1);  // cameron diaz
	//GetColShock(cmap, gray, 1.0, 1.0, 0.1);  // cameron diaz
	
	///////////////////////////////////////////////
	// After getting ETF, smooth the image (following Weickert's idea)
	GaussColorSmooth5(cmap, 2.0); // leesy
	CopyCol2GrayImage(IMAGE_X, IMAGE_Y, cmap, gray); 
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//////////////////////////////////////////////////
	
	double tau = 0.99;
	//tau = 0.995;
	double z1, z2;
	z1 = 0.05, z2 = 0.05;
	//tau = 1.0;
	//GetColShock(cmap, gray, 1.0, tau, 0.1);  // cameron diaz
	//GetFlowColShock2(cmap, gfield, gray, 1.0, 1.0, tau, z1, z2);
	GetColShockWeickert(cmap, gfield, gray, 1.0, 1.0, tau, z1, z2);
	//GetFlowColShock(cmap, gfield, gray, 1.0, 1.0, 1.0, 0.0);
	//GetFlowShock(gray, gfield, gray, G_mag, 1.0, 3.0, 1.0, 0.0);
	//GetFlowShock(gray, gfield, gray, G_mag, 1.0, 1.0, 1.0, 0.0);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	//GetColContrastEnhance(cmap, 0.6, 0.9); 
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//GetFlowShock(gray, gfield, gray, G_mag, 1.0, 3.0, 0.996);
	//GetFlowShock(gray, gfield, gray, G_mag, 1.0, 3.0, 1.0);

	/*
	//double tao = 0.995;
	//tau = 0.995;
	z1 = 0.05, z2 = 0.01;
	//tau = 0.99;
	for (int i = 0; i < 10; i++) {
		//ConstructMergedImage(tmp, gray, gray); // merge with the original image
		//GaussColorSmooth5(cmap, 0.3); // leesy
		GaussColorSmooth5(cmap, 1.0); // leesy
		//GaussSmoothSep(gray, 0.7); // lena
		CopyCol2GrayImage(IMAGE_X, IMAGE_Y, cmap, gray); 
		//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
		//BilateralGfield13(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2);
		//DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 10); 
		//GetFlowColShock2(cmap, gfield, gray, 1.5, 3.0, tau, 4, 0.1);
		GetFlowColShock2(cmap, gfield, gray, 1.0, 3.0, tau, z1, z2);
		//GetFlowColShock2(cmap, gfield, gray, 2.0, 3.0, tau, 4, 0.1);
		DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
		dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		TRACE("Toon-Shock iteration %d complete.\n", i+1);
	}
	////////////////////////////
	//GetShock2(gray, G_mag, gray, 1.0, 1.0, 0.0);  // cameron diaz
	//GaussColorSmooth5(cmap, 1.0); // leesy
	CopyCol2GrayImage(IMAGE_X, IMAGE_Y, cmap, gray); 
	tau = 0.99;
	//GetColShock(cmap, gray, 1.0, tau, 0.1);  // cameron diaz
	//GetColShock3(cmap, gray, 1.0, 1.0, 4, 0.1);  // cameron diaz
	//DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//GetColContrastEnhance(cmap, 0.6, 0.8); 
	GetColContrastEnhance(cmap, 0.5, 0.6); 
	//ColorQuantization(cmap, 10); 
	*/

	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	TRACE("\nEnd of F-Shock Filtering\n");
	//////////////////////////////////////////////////////////////////
}

void CCubeView::OnToonBilateral()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	//max_grad = getGradient(IMAGE_X, IMAGE_Y, gradient, image);
	//max_grad = getSobelGradient(IMAGE_X, IMAGE_Y, gradient, image);
	//////////////////////////////////////////////////////////
	///*
	//gau_w = MakeGaussMask(5.0, gau);
	//gau_w = MakeGaussMask(0.1, gau);
	//TRACE("gau_w = %d\n", gau_w);
	//GaussSmooth2(IMAGE_X, IMAGE_Y, gray2, gau_w);
	//GaussSmooth3(IMAGE_X, IMAGE_Y, gray, gau_w);
	//GaussColSmoothSep(cmap, 1.0);
	
	//GaussBlur(IMAGE_X, IMAGE_Y, gray, 3.0);
	//GaussBlurBilateral(IMAGE_X, IMAGE_Y, gray, 3.0, 30.0); // old
	//GaussBlurBilateral(IMAGE_X, IMAGE_Y, gray, 3.0, 0.1, 1); // new
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.1, 10); // noisy circle
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.4, 1);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.1, 1);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 3.0, 0.1, 1);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.1, 3);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.1, 2);
	
	//StartTimer();
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.1, 5);
	//BilateralToon(cmap, 2.0, 10, 3);
	//BilateralToonSep(dc, cmap, 2.0, 10, 5);
	for (int i = 0; i < 5; i++) {
		BilateralToonSep(dc, cmap, 2.0, 10, 3);
		//GaussColSmoothSep(cmap, 1.0);
		DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
		dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		//////////////////////////////////
		GetColMaxMin(dc, cmap, 2.0, 3); 
		//CopyCol2GrayImage(IMAGE_X, IMAGE_Y, cmap, gray); 
		//GetColShock3(cmap, gray, 1.0, 1.0, 4, 0.1);  // cameron diaz
		TRACE("Iteration %d\n", i);
	}
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.05, 5);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.05, 5);
	//BilateralColorSep(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.05, 10);
	//BilateralColorSep(IMAGE_X, IMAGE_Y, cmap, 2.0, 10.0, 3);
	//BilateralColorSep(IMAGE_X, IMAGE_Y, cmap, 2.0, 10.0, 10);
	//EndTimer("_Result_BL.txt");
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 4.0, 0.1, 1);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 3.0, 0.1, 1);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.1, 1);
	//StartTimer();
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 1.0, 0.1, 3);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 1.0, 0.1, 1);
	//GaussBlurBilateral(IMAGE_X, IMAGE_Y, gray, 1.0, 0.1, 3); // new
	//TRACE("Elapsed Time = %f\n", ElapsedTime()); // 5 seconds for Paolina
	//InvertImage(IMAGE_X, IMAGE_Y, gray2);
	//*/
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	//ColorQuantization(cmap, 4); 
	//ColorQuantization(cmap, 5); 
	//ColorQuantization(cmap, 10); 
	//ColorQuantization(cmap, 7); 
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	CopyCmap2Membuffer(cmap, Dbuffer);
	//CopyGray2Membuffer(lap, Dbuffer);
	TRACE("Bilateral color filter done!\n");
}

void CCubeView::OnToonMedian()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//gray2.copy(gray);
	//GaussSmooth5(gray, 1.0); // lena
	//GaussSmoothSep(gray, 1.0); // lena
	int image_x = gray.getRow();
	int image_y = gray.getCol();
	imatrix input(image_x, image_y);
	input.copy(gray);
	//////////////////////////////
	DrawGrayImage(memDC, image_x, image_y, gray);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
	//////////////////////////////////////////////////
	//GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); // used for ETF
	ETF e;
	e.init(image_x, image_y);
	e.set(gray);
	e.Smooth(4, 3);
	//////////////////////////////////////////////////////
	//DrawETF_LIC(dc, e, 10);

	///////////////////////////////////////////////////////
	// Initial DoG or FDoG
	//double tao = 0.99;
	//GetDOG2(gray, G_mag, gray, 1.0, 0.99);  
	//GetFDoG(gray, e, 0.7, 0.7, tao); // Initial FDoG. Also works!
	//BilateralToonSep(cmap, 2.0, 10, 5);
	//BilateralGrayToonSep(gray, 2.0, 10, 5);
	//GetFMedian(gray, e, 1); 
	//GetFMedian2(gray, e, 10); 
	GetFMedian3(gray, e, 5); 
	//GetFMedian4(gray, 1); 
	//GetFMedian5(dc, gray, e, 10); 
	//GetLDoG(gray, e, 0.7, 0.7, tao); // Initial FDoG. Also works!
	//Binarize(gray, 0.2); // zucker
	//DrawInverseGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	/////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////
	/*
	//double tao = 0.995;
	tao = 0.99;
	//////////////////
	for (int i = 0; i < 5; i++) {
		ConstructMergedImage(input, gray, gray); // merge with the original image
		//GaussSmoothSep(gray, 0.7); // lena
		//e.set(gray);
		//e.Smooth(4, 3);
		//GetFlowDOG4(gray, gfield, gray, G_mag, 0.9, 2.0, tao); // Initial FDoG. Also works!
		GetFDoG(gray, e, 0.7, 3.0, tao); // Initial FDoG. Also works!
		//GetLDoG(gray, e, 0.7, 3.0, tao); // Initial FDoG. Also works!
		Binarize(gray, 0.9); 
		//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
		DrawInverseGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
		dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		TRACE("FDOG iteration %d complete.\n", i+1);
	}
	*/
	
	///////////////////////////////////////////
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	TRACE("Flow Median completed!\n");
	//printf("Line drawing completed!\n");
	
}

void CCubeView::OnToonBilateral2()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	//max_grad = getGradient(IMAGE_X, IMAGE_Y, gradient, image);
	//max_grad = getSobelGradient(IMAGE_X, IMAGE_Y, gradient, image);
	//////////////////////////////////////////////////////////
	///*
	//gau_w = MakeGaussMask(5.0, gau);
	//gau_w = MakeGaussMask(0.1, gau);
	//TRACE("gau_w = %d\n", gau_w);
	//GaussSmooth2(IMAGE_X, IMAGE_Y, gray2, gau_w);
	//GaussSmooth3(IMAGE_X, IMAGE_Y, gray, gau_w);
	//GaussColSmoothSep(cmap, 1.0);
	
	//GaussBlur(IMAGE_X, IMAGE_Y, gray, 3.0);
	//GaussBlurBilateral(IMAGE_X, IMAGE_Y, gray, 3.0, 30.0); // old
	//GaussBlurBilateral(IMAGE_X, IMAGE_Y, gray, 3.0, 0.1, 1); // new
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.1, 10); // noisy circle
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.4, 1);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.1, 1);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 3.0, 0.1, 1);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.1, 3);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.1, 2);
	
	//StartTimer();
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.1, 5);
	//BilateralToon(cmap, 2.0, 10, 3);
	//BilateralToonSep(dc, cmap, 2.0, 10, 5);
	double tau;
	tau = 1.0;
	////////////////////////
	for (int i = 0; i < 10; i++) {
		BilateralToonSep(dc, cmap, 2.0, 10, 1);
		//GaussColSmoothSep(cmap, 1.0);
		DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
		dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		//////////////////////////////////
		//GetColMaxMin(dc, cmap, 2.0, 3); 
		//tau += 0.002; if (tau > 1.0) tau = 1.0;
		GetColMaxMin2(dc, cmap, 2.0, tau, 3); 
		//CopyCol2GrayImage(IMAGE_X, IMAGE_Y, cmap, gray); 
		//GetColShock3(cmap, gray, 1.0, 1.0, 4, 0.1);  // cameron diaz
		TRACE("Iteration %d\n", i);
	}
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.05, 5);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.05, 5);
	//BilateralColorSep(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.05, 10);
	//BilateralColorSep(IMAGE_X, IMAGE_Y, cmap, 2.0, 10.0, 3);
	//BilateralColorSep(IMAGE_X, IMAGE_Y, cmap, 2.0, 10.0, 10);
	//EndTimer("_Result_BL.txt");
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 4.0, 0.1, 1);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 3.0, 0.1, 1);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.1, 1);
	//StartTimer();
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 1.0, 0.1, 3);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 1.0, 0.1, 1);
	//GaussBlurBilateral(IMAGE_X, IMAGE_Y, gray, 1.0, 0.1, 3); // new
	//TRACE("Elapsed Time = %f\n", ElapsedTime()); // 5 seconds for Paolina
	//InvertImage(IMAGE_X, IMAGE_Y, gray2);
	//*/
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	//ColorQuantization(cmap, 4); 
	//ColorQuantization(cmap, 5); 
	//ColorQuantization(cmap, 10); 
	//ColorQuantization(cmap, 7); 
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	CopyCmap2Membuffer(cmap, Dbuffer);
	//CopyGray2Membuffer(lap, Dbuffer);
	TRACE("Bilateral color filter done!\n");
}

void CCubeView::OnToonBilateral3()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	
	GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	//max_grad = getGradient(IMAGE_X, IMAGE_Y, gradient, image);
	//max_grad = getSobelGradient(IMAGE_X, IMAGE_Y, gradient, image);
	//////////////////////////////////////////////////////////
	GaussColSmoothSep(cmap, 1.0);
	//GaussSmoothSep(gray, 1.0); // lena
	//GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//////////////////////////////////
	int image_x = cmap.getRow();
	int image_y = cmap.getCol();
	CopyCol2GrayImage(image_x, image_y, cmap, gray); 
	//GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); // used for ETF
	ETF e;
	e.init(image_x, image_y);
	e.set(gray);
	//e.set(gray2);
	e.Smooth(5, 1); // works best for Yul Brynner!
	//e.orient180(); // [0, 180]
	DrawETF_LIC(dc, e, 10);
	
	//GaussBlur(IMAGE_X, IMAGE_Y, gray, 3.0);
	//GaussBlurBilateral(IMAGE_X, IMAGE_Y, gray, 3.0, 30.0); // old
	//GaussBlurBilateral(IMAGE_X, IMAGE_Y, gray, 3.0, 0.1, 1); // new
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.1, 10); // noisy circle
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.4, 1);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.1, 1);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 3.0, 0.1, 1);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.1, 3);
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.1, 2);
	
	//BilateralColor(IMAGE_X, IMAGE_Y, cmap, 2.0, 0.1, 5);
	//BilateralToon(cmap, 2.0, 10, 3);
	//BilateralToonSep(dc, cmap, 2.0, 10, 5);
	double tau;
	//tau = 0.99;
	tau = 1.0;
	//GetFDoG(gray, e, 1.0, 1.0, tau); // Initial FDoG. Also works!
	//BilateralToonSep(dc, cmap, 2.0, 10, 1);
	//GetFlowColBilateral10(cmap, e, 2.0, 1.0, 30.0, 10.0, 5); // David
	//GetFlowColGaussian10(cmap, e, 2.0, 1.0, 3); // David
	//GetFlowColMaxMin(dc, cmap, e, 1.0, 2.0, tau, 3); 
	////////////////////////
	for (int i = 0; i < 5; i++) {
		//BilateralToonSep(dc, cmap, 2.0, 10, 1);
		GetFlowColGaussian10(cmap, e, 2.0, 1.0, 1); // David
		//GaussColSmoothSep(cmap, 1.0);
		DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
		dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		//////////////////////////////////
		//GetColMaxMin(dc, cmap, 2.0, 3); 
		//tau += 0.002; if (tau > 1.0) tau = 1.0;
		//GetColMaxMin2(dc, cmap, 2.0, tau, 3); 
		GetFlowColMaxMin(dc, cmap, e, 1.0, 2.0, tau, 5); 
		CopyCol2GrayImage(IMAGE_X, IMAGE_Y, cmap, gray); 
		e.set(gray);
		e.Smooth(5, 1); 
		//e.Smooth(4, 2); 
		//GetColShock3(cmap, gray, 1.0, 1.0, 4, 0.1);  // cameron diaz
		TRACE("Iteration %d\n", i);
	}
	//*/
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	//ColorQuantization(cmap, 10); 
	//GetColContrastEnhance(cmap, 0.5, 0.7); 
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	CopyCmap2Membuffer(cmap, Dbuffer);
	//CopyGray2Membuffer(lap, Dbuffer);
	TRACE("Bilateral color filter done!\n");
}


void CCubeView::OnToonCurvature2()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	
	//GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	//////////////////////////////////////////////////////////
	//GaussColSmoothSep(cmap, 1.0);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	GaussSmoothSep(gray, 1.0); // lena
	//////////////////////////////////
	int image_x = gray.getRow();
	int image_y = gray.getCol();
	/*
	ETF e;
	e.init(image_x, image_y);
	e.set(gray);
	//e.set(gray2);
	//e.tensor(gray);
	//e.tensor(gray2);
	e.Smooth(4, 2);
	//e.Smooth(10, 10);
	//e.orient180();
	//e.Smooth3(4, 3);
	//e.Smooth3(10, 5);
	//////////////////////////////////////////////////////
	DrawETF_LIC(dc, e, 10);
	//DrawETFColor360(dc, e);
	//DrawETFColor180(dc, e);
	//DrawETFColorTensor(dc, e);
	*/

	///////////////////////////////////////////////////////
	// Initial DoG or FDoG
	imatrix line(image_x, image_y);
	line.copy(gray);

	//double tau = 0.995;
	double tau = 1.0;
	//GetDOG2(line, G_mag, line, 1.0, 0.99);  

	for (int i = 0; i < 15; i++) {
		GetDogSep(gray, 1.0, line, tau);
		//GetDOG2(gray, G_mag, gray, 1.5, 0.99);  
		//GetFDoG(gray, e, 0.9, 0.9, tao); // Initial FDoG. Also works!
		//GetFDoG(line, e, 1.0, 1.0, tao); // Initial FDoG. Also works!
		//GetFDoG(gray, e, 1.5, 1.5, tao); // fingerprint
		//Binarize(line, 0.5); // zucker
		//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.7); // zucker
		//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.8); // zucker
		DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, line);
		dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		/////////////////////////////////////////////////////////
		
		/////////////////////////////////////////////////////
		/*
		tao = 0.995;
		//double tao = 0.995;
		for (int i = 0; i < 3; i++) {
			ConstructMergedImage(gray, line, line); // merge with the original image
			//DrawGrayImage(memDC, image_x, image_y, line);
			//dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
			GaussSmoothSep(line, 1.0); // lena
			//GetFlowDOG4(gray, gfield, gray, G_mag, 0.9, 2.0, tao); // Initial FDoG. Also works!
			//GetFDoG(gray, e, 0.7, 2.0, tao); // Initial FDoG. Also works!
			//GetFDoG(gray, e, 0.9, 2.0, tao); // Initial FDoG. Also works!
			GetFDoG(line, e, 1.0, 2.0, tao); // Initial FDoG. Also works!
			//GetFDoG(gray, e, 1.5, 3.0, tao); // fingerprint
			Binarize(line, 0.5); 
			DrawGrayImage(memDC, image_x, image_y, line);
			dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
			TRACE("FDOG iteration %d complete.\n", i+1);
		}
		*/

		//GetAnisotropic(gray, 500);
		//GaussSmoothSep(line, 10.0); // 
		GaussSmoothSep(line, 3.0); // smooth out the lines
		DrawGrayImage(memDC, image_x, image_y, line);
		dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
		//MeanCurvatureFlow(gray, 10);
		MeanCurvatureFlow2(gray, line, 10);
		//DrawGrayImage(memDC, image_x, image_y, gray);
		//dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
		//////////////////////////////////////////
		GetShockFlow(dc, gray, 2.0, 1.0, 3); 
		DrawGrayImage(memDC, image_x, image_y, gray);
		dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
	}

	////////////////////////
	//GrayQuantization(gray, 7); 
	//DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	DrawGrayImage(memDC, image_x, image_y, gray);
	dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
	//CopyCmap2Membuffer(cmap, Dbuffer);
	//CopyGray2Membuffer(gray, Dbuffer);
	TRACE("Mean Curvature Flow done!\n");

}

void CCubeView::OnToonCurvature3()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	
	//GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	//////////////////////////////////////////////////////////
	//GaussColSmoothSep(cmap, 1.0);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	GaussSmoothSep(gray, 1.0); // lena
	//////////////////////////////////
	int image_x = gray.getRow();
	int image_y = gray.getCol();
	/*
	ETF e;
	e.init(image_x, image_y);
	e.set(gray);
	//e.set(gray2);
	//e.tensor(gray);
	//e.tensor(gray2);
	e.Smooth(4, 2);
	//e.Smooth(10, 10);
	//e.orient180();
	//e.Smooth3(4, 3);
	//e.Smooth3(10, 5);
	//////////////////////////////////////////////////////
	DrawETF_LIC(dc, e, 10);
	//DrawETFColor360(dc, e);
	//DrawETFColor180(dc, e);
	//DrawETFColorTensor(dc, e);
	*/

	///////////////////////////////////////////////////////
	// Initial DoG or FDoG
	imatrix line(image_x, image_y);
	line.copy(gray);

	//double tau = 0.995;
	double tau = 1.0;
	//GetDOG2(line, G_mag, line, 1.0, 0.99);  

	for (int i = 0; i < 10; i++) {
		//GetDogSep(gray, 1.0, line, tau);
		//GetDOG2(gray, G_mag, gray, 1.5, 0.99);  
		//GetFDoG(gray, e, 0.9, 0.9, tao); // Initial FDoG. Also works!
		//GetFDoG(line, e, 1.0, 1.0, tao); // Initial FDoG. Also works!
		//GetFDoG(gray, e, 1.5, 1.5, tao); // fingerprint
		//Binarize(line, 0.5); // zucker
		//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.7); // zucker
		//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.8); // zucker
		//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, line);
		//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		/////////////////////////////////////////////////////////
		
		//GetAnisotropic(gray, 500);
		//GaussSmoothSep(line, 10.0); // 
		//GaussSmoothSep(line, 3.0); // smooth out the lines
		//DrawGrayImage(memDC, image_x, image_y, line);
		//dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
		MeanCurvatureFlow(gray, 10);
		//MeanCurvatureFlow2(gray, line, 10);
		//DrawGrayImage(memDC, image_x, image_y, gray);
		//dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
		//////////////////////////////////////////
		GetLaplacian6(gray, 2.0, gray, 1.0);
		//GetShockFlow(dc, gray, 2.0, 1.0, 1); 
		//GetShockFlow(dc, gray, 1.0, 0.99, 3); 
		DrawGrayImage(memDC, image_x, image_y, gray);
		dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
	}

	////////////////////////
	//GrayQuantization(gray, 7); 
	//DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	//DrawGrayImage(memDC, image_x, image_y, gray);
	//dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
	//CopyCmap2Membuffer(cmap, Dbuffer);
	//CopyGray2Membuffer(gray, Dbuffer);
	TRACE("Mean Curvature Flow done!\n");
}

void CCubeView::OnToonCurvature4()
{
	// TODO: Add your command handler code here
		CClientDC dc(this);
	
	//GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	//////////////////////////////////////////////////////////
	//GaussColSmoothSep(cmap, 1.0);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	GaussSmoothSep(gray, 1.0); // lena
	//////////////////////////////////
	int image_x = gray.getRow();
	int image_y = gray.getCol();
	/*
	ETF e;
	e.init(image_x, image_y);
	e.set(gray);
	//e.set(gray2);
	//e.tensor(gray);
	//e.tensor(gray2);
	e.Smooth(4, 2);
	//e.Smooth(10, 10);
	//e.orient180();
	//e.Smooth3(4, 3);
	//e.Smooth3(10, 5);
	//////////////////////////////////////////////////////
	DrawETF_LIC(dc, e, 10);
	//DrawETFColor360(dc, e);
	//DrawETFColor180(dc, e);
	//DrawETFColorTensor(dc, e);
	*/

	///////////////////////////////////////////////////////
	// Initial DoG or FDoG
	imatrix line(image_x, image_y);
	//line.copy(gray);

	//double tau = 0.995;
	double tau = 1.0;
	//GetDOG2(line, G_mag, line, 1.0, 0.99);  

	for (int i = 0; i < 15; i++) {
		//GetDogSep(gray, 1.0, line, tau);
		//GetFDoG(gray, e, 0.9, 0.9, tao); // Initial FDoG. Also works!
		//Binarize(line, 0.5); // zucker
		//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.7); // zucker
		//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.8); // zucker
		/////////////////////////////////////////////////////////
		line.copy(gray);
		//GetAnisotropic(gray, 500);
		//GaussSmoothSep(line, 2.0); // smooth out the lines
		GaussSmoothSep(line, 4.0); // smooth out the lines
		//DrawGrayImage(memDC, image_x, image_y, line);
		//dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
		//DrawGrayImage(memDC, image_x, image_y, line);
		//dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
		//GaussSmoothSep(gray, 4.0); // smooth out the lines
		//MeanCurvatureFlow(gray, 10);
		MeanCurvatureFlow2(gray, line, 10);
		//DrawGrayImage(memDC, image_x, image_y, gray);
		//dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
		//////////////////////////////////////////
		GetShockFlow(dc, gray, 2.0, 1.0, 3); 
		//DrawGrayImage(memDC, image_x, image_y, gray);
		//dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
	}

	////////////////////////
	//GrayQuantization(gray, 7); 
	//DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	//DrawGrayImage(memDC, image_x, image_y, gray);
	//dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
	//CopyCmap2Membuffer(cmap, Dbuffer);
	//CopyGray2Membuffer(gray, Dbuffer);
	TRACE("Mean Curvature Flow done!\n");
}

void CCubeView::OnToonCurvature()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	
	//GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	//////////////////////////////////////////////////////////
	//GaussColSmoothSep(cmap, 1.0);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//GaussSmoothSep(gray, 1.0); // lena
	//////////////////////////////////
	//int image_x = gray.getRow();
	//int image_y = gray.getCol();
	//GetAnisotropic(gray, 500);
	//MeanCurvatureFlow(gray, 16);
	//MeanCurvatureFlowSapiro(gray, 10);
	//MinMaxFlow(gray, 1.0, 10);
	//MinMaxFlow2(gray, 2, 127.5, 20);
	//MinMaxFlow2(gray, 2, 127.5, 20);
	//MinMaxFlow3(gray, 1, 30);
	//MinMaxFlow4(gray, 1, 30);

	////////////////////////
	//DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//CopyCmap2Membuffer(cmap, Dbuffer);
	CopyGray2Membuffer(gray, Dbuffer);
	TRACE("Mean Curvature Flow done!\n");
}

void CCubeView::OnToonCurvature5()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	
	//GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	//////////////////////////////////////////////////////////
	//GaussColSmoothSep(cmap, 1.0);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	GaussSmoothSep(gray, 1.0); // lena
	//////////////////////////////////
	int image_x = gray.getRow();
	int image_y = gray.getCol();

	///////////////////////////////////////////////////////
	// Initial DoG or FDoG
	imatrix line(image_x, image_y);
	line.copy(gray);

	ETF e;
	e.init(image_x, image_y);
	e.set(line);
	//e.set(gray2);
	//e.tensor(gray);
	//e.tensor(gray2);
	e.Smooth(4, 2);
	//e.Smooth(10, 10);
	e.orient180();
	//e.Smooth3(4, 3);
	//e.Smooth3(10, 5);
	//////////////////////////////////////////////////////
	DrawETF_LIC(dc, e, 10);
	//DrawETFColor360(dc, e);
	//DrawETFColor180(dc, e);
	//DrawETFColorTensor(dc, e);
	///////////////////////////////////////////////////////
	// Initial DoG or FDoG
	double tao = 0.99;
	GetDogSep(line, 1.0, line, 0.99);
	//GetFDoG(line, e, 1.0, 1.0, tao); // Initial FDoG. Also works!
	//GetFDoG(gray, e, 1.5, 1.5, tao); // fingerprint
	Binarize(line, 0.5); // zucker
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, line);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	/////////////////////////////////////////////////////
	tao = 0.995;
	//double tao = 0.995;
	for (int i = 0; i < 3; i++) {
		ConstructMergedImage(gray, line, line); // merge with the original image
		//GaussSmooth5(line, 0.5); // leesy
		GaussSmoothSep(line, 0.5); // lena
		GetFDoG(line, e, 1.0, 2.0, tao); // Initial FDoG. Also works!
		//GetFDoG(gray, e, 1.5, 3.0, tao); // fingerprint
		Binarize(line, 0.5); 
		DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, line);
		dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	}
	
	imatrix merged(image_x, image_y);
	
	//double tau = 0.995;
	//double tau = 1.0;

	//GetDogSep(gray, 1.0, line, 0.995);
	//Binarize(line, 0.5); // zucker

	//DrawGrayImage(memDC, image_x, image_y, line);
	//dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);

	for (int i = 0; i < 30; i++) {
		///////////////////////////////
		// smoothing the regions
		//MeanCurvatureFlow(gray, 10);
		MeanCurvatureFlow2(gray, line, 10);
		ConstructMergedImage(gray, line, merged); // merge with the original image
		//GaussSmoothSep(line, 10.0); // 
		//GaussSmoothSep(line, 3.0); // smooth out the lines
		DrawGrayImage(memDC, image_x, image_y, merged);
		dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
		/////////////////////////////////
		// smoothing the lines
		//MeanCurvatureFlow(line, 10);
		//MinMaxFlow(line, 1.0, 10); // Henry's version
		//MinMaxFlow2(line, 4, 127.5, 10); // Malladi's version for binary image
		MinMaxFlow3(line, 3, 10); // Malladi's grayscale version
		//MinMaxFlow4(line, 3, 10); // Henry's version: corrected Mallidi's grayscale version
		//MeanCurvatureFlow2(gray, line, 10);
		//DrawGrayImage(memDC, image_x, image_y, gray);
		//dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
		//////////////////////////////////////////
		//Binarize(line, 0.5); 
		GetLaplacian6(line, 2.0, line, 1.0);
		//////////////////////////////////////
		DrawGrayImage(memDC, image_x, image_y, line);
		dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
	}

	////////////////////////
	GrayQuantization(gray, 7); 
	//DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	ConstructMergedImage(gray, line, merged); // merge with the original image
	DrawGrayImage(memDC, image_x, image_y, merged);
	dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
	//CopyCmap2Membuffer(cmap, Dbuffer);
	//CopyGray2Membuffer(gray, Dbuffer);
	TRACE("Mean Curvature Flow done!\n");
}

void CCubeView::OnEdgeCldthin()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//gray2.copy(gray);
	//GaussSmooth5(gray, 0.7); // lena
	//GaussSmoothSep(gray, 0.7); // lena
	//GaussSmoothSep(gray, 2.0); // lena
	int image_x = gray.getRow();
	int image_y = gray.getCol();
	//imatrix input(image_x, image_y);
	//input.copy(gray);
	//////////////////////////////
	DrawGrayImage(memDC, image_x, image_y, gray);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
	//////////////////////////////////////////////////
	//GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); // used for ETF
	ETF e;
	e.init(image_x, image_y);
	e.set(gray);
	//e.set(gray2);
	//e.tensor(gray);
	//e.tensor(gray2);
	e.Smooth(4, 2);
	//e.Smooth(10, 10);
	//e.orient180();
	//////////////////////////////////////////////////////
	//DrawETF_LIC(dc, e, 20);
	//DrawETFColor360(dc, e);
	//DrawETFColor180(dc, e);
	//DrawETFColorTensor(dc, e);

	matrix G_mag(image_x, image_y);

	///////////////////////////////////////////////////////
	// Initial DoG or FDoG
	double tao = 0.99;
	//GetFDoG(gray, e, 1.0, 3.0, tao); // Initial FDoG. Also works!
	GetFDoGDouble(gray, e, G_mag, 1.0, 3.0, tao);
	//GetDogSep(gray, 1.0, gray, tao);
	//GetDoGLIC(gray, e, 1.0, 3.0, tao); // fingerprint
	//Binarize(gray, 0.5); // zucker
	GrayThresholding(gray, 0.7); // zucker
	//GrayThresholding(gray, 0.9); // zucker
	NonmaximaSuppressionETF(G_mag, e, gray, 0.7);
	EdgeThinning(dc, gray); // morphological edge thinning
	//int count = CountBlackPixels(gray);
	//TRACE("back pixel count = %d\n", count);
	//emap.copy(gray2);
	StoreEdgeStrokes4(IMAGE_X, IMAGE_Y, gray, bstrokes, 0); // Diaz
	ClearMemDC(&memDC);
	//DrawInterpBStrokesRandCol2(memDC, bstrokes, 3); // interpolating B-spline strokes
	DrawInterpBStrokes3(memDC, bstrokes, 0, 0, 0, 3); // black lines
	//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.7); // zucker
	//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.8); // zucker
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	/////////////////////////////////////////////////////////
	
	///////////////////////////////////////////
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//SaveBMPfromMemDC(memDC, IMAGE_X, IMAGE_Y, "_result.bmp");
	TRACE("Line drawing completed!\n");
	//printf("Line drawing completed!\n");
	//TRACE("Elapsed Time = %f\n", ElapsedTime());
}

void CCubeView::OnEdgeVideocldthin()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	int image_x = IMAGE_X;
	int image_y = IMAGE_Y;

	ETF e;
	
	gray.init(image_x, image_y);
	e.init(image_x, image_y);

	matrix G_mag(image_x, image_y);
	
	char s[10], s2[2], s1[10];



	for (int i = 1; i <= 60; i++) {
		strcpy(s, "org");
		//strcpy(s, "result1_original");
		sprintf(s2, "%.2d", i);
		strcat(s, s2);
		strcpy(s1, s);
		strcat(s, ".bmp");
		if ( !LoadBMP3(dc, (char *)LPCTSTR(s), &memDC) ) 
			TRACE("%s does not exist!\n", s);

		gray.init(image_x, image_y);
	
		GetGrayImageFromMemDC(image_x, image_y, gray, memDC);
		//gray2.copy(gray);
		//GaussSmoothSep(gray, 0.7); // lena
		//GaussSmoothSep(gray, 2.0); // lena
		//////////////////////////////
		//DrawGrayImage(memDC, image_x, image_y, gray);
		//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
		//////////////////////////////////////////////////
		//GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); // used for ETF
		e.init(image_x, image_y);
		e.set(gray);
		e.Smooth(4, 2);
		//e.Smooth(10, 10);
		//e.orient180();
		//////////////////////////////////////////////////////
		//DrawETF_LIC(dc, e, 10);

		///////////////////////////////////////////////////////
		// Initial DoG or FDoG
		double tao = 0.99;
		//GetDOG2(gray, G_mag, gray, 1.0, 0.99);  
		//GetDOG2(gray, G_mag, gray, 1.5, 0.99);  
		//GetFDoG(gray, e, 1.0, 3.0, tao); // Initial FDoG. Also works!
		GetFDoGDouble(gray, e, G_mag, 1.0, 3.0, tao);
		//GetDogSep(gray, 1.0, gray, tao);
		//GetDoGLIC(gray, e, 1.0, 3.0, tao); // fingerprint
		//Binarize(gray, 0.5); // zucker
		GrayThresholding(gray, 0.7); // zucker
		//GrayThresholding(gray, 0.9); // zucker
		NonmaximaSuppressionETF(G_mag, e, gray, 0.7);
		EdgeThinning(dc, gray); // morphological edge thinning
		//emap.copy(gray2);
		bstrokes.init();
		StoreEdgeStrokes4(IMAGE_X, IMAGE_Y, gray, bstrokes, 0); // Diaz
		ClearMemDC(&memDC);
		//DrawInterpBStrokesRandCol2(memDC, bstrokes, 3); // interpolating B-spline strokes
		DrawInterpBStrokes3(memDC, bstrokes, 0, 0, 0, 3); // black lines
		//GetDogSep(gray, 1.0, gray, tao);
		//GetDoGLIC(gray, e, 1.0, 3.0, tao); // fingerprint
		//Binarize(gray, 0.5); // zucker
		//GrayThresholding(gray, 0.7); // zucker
		//GrayThresholding(gray, 0.5); // zucker
		//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.7); // zucker
		//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.8); // zucker
		//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
		//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		/////////////////////////////////////////////////////////
		
		/////////////////////////////////////////////////////
		
		///////////////////////////////////////////
		//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
		dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		strcpy(s, "cld_");
		strcat(s, s1);
		strcat(s, ".bmp");
		SaveBMPfromMemDC(memDC, IMAGE_X, IMAGE_Y, s);
		TRACE("Frame %d completed!\n", i);
		//printf("Line drawing completed!\n");
		//TRACE("Elapsed Time = %f\n", ElapsedTime());
	}

	TRACE("\nVideo CLD completed!\n");
}

void CCubeView::OnEdgeCldtexture()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//gray2.copy(gray);
	//GaussSmoothSep(gray, 0.7); // lena
	//GaussSmoothSep(gray, 2.0); // lena
	int image_x = gray.getRow();
	int image_y = gray.getCol();
	//imatrix input(image_x, image_y);
	//input.copy(gray);
	//////////////////////////////
	DrawGrayImage(memDC, image_x, image_y, gray);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
	//////////////////////////////////////////////////
	//GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); // used for ETF
	ETF e;
	e.init(image_x, image_y);
	e.set(gray);
	//e.set(gray2);
	//e.tensor(gray);
	//e.tensor(gray2);
	e.Smooth(4, 2);
	//e.Smooth(10, 10);
	//e.orient180();
	//////////////////////////////////////////////////////
	//DrawETF_LIC(dc, e, 20);
	//DrawETFColor360(dc, e);
	//DrawETFColor180(dc, e);
	//DrawETFColorTensor(dc, e);

	int tex_x, tex_y;
	//if ( !LoadBMP4(dc, (char *)LPCTSTR("watercolor64.bmp"), &memDC3, tex_x, tex_y) ) 
	//if ( !LoadBMP4(dc, (char *)LPCTSTR("pencil9.bmp"), &memDC3, tex_x, tex_y) ) 
	//if ( !LoadBMP4(dc, (char *)LPCTSTR("pencil10.bmp"), &memDC3, tex_x, tex_y) ) 
	//if ( !LoadBMP4(dc, (char *)LPCTSTR("circle.bmp"), &memDC3, tex_x, tex_y) ) 
	//if ( !LoadBMP4(dc, (char *)LPCTSTR("dots4.bmp"), &memDC3, tex_x, tex_y) ) 
	if ( !LoadBMP4(dc, (char *)LPCTSTR("stripe3.bmp"), &memDC3, tex_x, tex_y) ) 
	//if ( !LoadBMP4(dc, (char *)LPCTSTR("cross2.bmp"), &memDC3, tex_x, tex_y) )
	//if ( !LoadBMP4(dc, (char *)LPCTSTR("charcoal.bmp"), &memDC3, tex_x, tex_y) ) 
	//if ( !LoadBMP4(dc, (char *)LPCTSTR("smear.bmp"), &memDC3, tex_x, tex_y) ) 
	//if ( !LoadBMP4(dc, (char *)LPCTSTR("signpen.bmp"), &memDC3, tex_x, tex_y) ) 
	//if ( !LoadBMP4(dc, (char *)LPCTSTR("sumie.bmp"), &memDC3, tex_x, tex_y) ) 
	//if ( !LoadBMP4(dc, (char *)LPCTSTR("oil3.bmp"), &memDC3, tex_x, tex_y) ) 
	//if ( !LoadBMP4(dc, (char *)LPCTSTR("crayon.bmp"), &memDC3, tex_x, tex_y) ) 
	//if ( !LoadBMP4(dc, (char *)LPCTSTR("stripe_vert2.bmp"), &memDC3, tex_x, tex_y) ) 
		TRACE("brushRGB.bmp does not exist!\n");
	else TRACE("brushRGB.bmp exists!\n");
	//int tex_x = m_Image.GetWidth();
	//int tex_y = m_Image.GetHeight();
	TRACE("tex_x = %d, tex_y = %d\n", tex_x, tex_y);
	imatrix tex(tex_x, tex_y);
	GetGrayImageFromMemDC(tex_x, tex_y, tex, memDC3);

	//DrawGrayImage(memDC, tex_x, tex_y, tex);
	//dc.BitBlt(0, 0, tex_x, tex_y, &memDC, 0, 0, SRCCOPY);

	matrix G_mag(image_x, image_y);

	//ReplaceStrokeTexture7(G_mag, e, gray, tex);

	///////////////////////////////////////////////////////
	// Initial DoG or FDoG
	double tao = 0.99;
	//GetFDoG(gray, e, 1.0, 3.0, tao); // Initial FDoG. Also works!
	GetFDoGDouble(gray, e, G_mag, 1.0, 3.0, tao);
	//GetDogSepDouble2(gray, 1.0, G_mag, tao);
	//GaussSmoothSepDouble(gray, 2.0, G_mag);
	//GaussSmoothSepDouble2(G_mag, gray, 0.1, G_mag);
	//Binarize(gray, 0.5); // zucker
	NonmaximaSuppressionETF(G_mag, e, gray, 0.7);
	EdgeThinning(dc, gray); // morphological edge thinning
	//GetOffsetLines(dc, gray);
	///*
	imatrix thin;
	thin.copy(gray);
	//GetFDoGDoubleSubpixel(gray, e, G_mag, 1.0, 3.0, tao);
	//GaussSmoothSepDouble2(G_mag, gray, 0.5, G_mag);
	//GaussSmoothSepDouble(gray, 2.0, G_mag);
	GaussSmoothSepDouble3(gray, 1.0, G_mag);
    //GaussSmoothSepDouble2(G_mag, gray, 0.1, G_mag);
	//GetGrayContrastEnhanceDouble(G_mag, 0.01, 0.9); 
	//*/
	e.init(image_x, image_y);
	e.set(gray);
	//e.Smooth(4, 2);
	//e.orient180();
	//DrawETF_LIC(dc, e, 10);
	//bool sumie = true;
	bool sumie = false;
	//DrawETFColor180(dc, e);
	//GetDogSep(gray, 1.0, gray, tao);
	//GetDoGLIC(gray, e, 1.0, 3.0, tao); // fingerprint
	//*/
	
	//GrayThresholding(gray, 0.7); // zucker
	//NonmaximaSuppressionETF(G_mag, e, gray, 0.7);
	//GaussSmoothSep(gray, 1.0); // lena
	//EdgeThinning(dc, gray); // morphological edge thinning
	//ReplaceStrokeTexture(G_mag, e, gray, 0.99);
	//ReplaceStrokeTexture3(G_mag, e, gray);
	//ReplaceStrokeTexture4(G_mag, e, gray, tex);
	//ReplaceStrokeTexture5(G_mag, e, gray, tex);
	//ReplaceStrokeTexture6(G_mag, e, gray, tex);
	//ReplaceStrokeTexture8(G_mag, e, gray, thin, tex, sumie);
	ReplaceStrokeTexture13(G_mag, e, gray, thin, tex, sumie);
	//ReplaceStrokeTexture9(G_mag, e, gray, tex, sumie);
	//ReplaceStrokeTexture10(G_mag, e, gray, tex, sumie);
	//ReplaceStrokeTexture11(G_mag, e, gray, thin, tex, sumie);
	//DilationGray(dc, gray, 3);
	//DilationGraySep(dc, gray, 3);
	//ReplaceTextureWithDilation(dc, thin, e, tex, 5);
	//ReplaceStrokeTexture12(G_mag, e, gray, thin, tex, sumie);
	//ReplaceStrokeTexture2(G_mag, e, gray, 0.99);
	//GrayThresholding(gray, 0.9); // zucker
	//NonmaximaSuppressionETF(G_mag, e, gray, 0.7);
	//NonmaximaSuppressionETF(G_mag, e, gray, 1.0);
	//EdgeThinning(dc, gray); // morphological edge thinning
	//emap.copy(gray2);
	//StoreEdgeStrokes4(IMAGE_X, IMAGE_Y, gray, bstrokes, 0); // Diaz
	//ClearMemDC(&memDC);
	//DrawInterpBStrokesRandCol2(memDC, bstrokes, 3); // interpolating B-spline strokes
	//DrawInterpBStrokes3(memDC, bstrokes, 0, 0, 0, 3); // black lines
	//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.7); // zucker
	//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.8); // zucker
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	/////////////////////////////////////////////////////////
	//*/
	
	///////////////////////////////////////////
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, thin);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//SaveBMPfromMemDC(memDC, IMAGE_X, IMAGE_Y, "_result.bmp");
	TRACE("CLD Texture Replacement completed!\n");
	//printf("Line drawing completed!\n");
	//TRACE("Elapsed Time = %f\n", ElapsedTime());
}

void CCubeView::OnEdgeVideocldtex()
{
	// TODO: Add your command handler code here
		CClientDC dc(this);
	int image_x = IMAGE_X;
	int image_y = IMAGE_Y;

	ETF e;
	
	gray.init(image_x, image_y);
	e.init(image_x, image_y);

	int tex_x, tex_y;
	//if ( !LoadBMP4(dc, (char *)LPCTSTR("watercolor64.bmp"), &memDC3, tex_x, tex_y) ) 
	//if ( !LoadBMP4(dc, (char *)LPCTSTR("pencil.bmp"), &memDC3, tex_x, tex_y) ) 
	//if ( !LoadBMP4(dc, (char *)LPCTSTR("pencil9.bmp"), &memDC3, tex_x, tex_y) ) 
	//if ( !LoadBMP4(dc, (char *)LPCTSTR("signpen.bmp"), &memDC3, tex_x, tex_y) ) 
	//if ( !LoadBMP4(dc, (char *)LPCTSTR("oil2.bmp"), &memDC3, tex_x, tex_y) ) 
	//if ( !LoadBMP4(dc, (char *)LPCTSTR("stripe_vert.bmp"), &memDC3, tex_x, tex_y) ) 
	if ( !LoadBMP4(dc, (char *)LPCTSTR("crayon.bmp"), &memDC3, tex_x, tex_y) ) 
		TRACE("brushRGB.bmp does not exist!\n");
	else TRACE("brushRGB.bmp exists!\n");
	//int tex_x = m_Image.GetWidth();
	//int tex_y = m_Image.GetHeight();
	TRACE("tex_x = %d, tex_y = %d\n", tex_x, tex_y);
	imatrix tex(tex_x, tex_y);
	GetGrayImageFromMemDC(tex_x, tex_y, tex, memDC3);

	matrix G_mag(image_x, image_y);
	
	char s[10], s2[2], s1[10];

	for (int i = 1; i <= 60; i++) {
		strcpy(s, "org");
		sprintf(s2, "%.2d", i);
		strcat(s, s2);
		strcpy(s1, s);
		strcat(s, ".bmp");
		if ( !LoadBMP3(dc, (char *)LPCTSTR(s), &memDC) ) 
			TRACE("%s does not exist!\n", s);

		gray.init(image_x, image_y);
		G_mag.init(image_x, image_y);
	
		GetGrayImageFromMemDC(image_x, image_y, gray, memDC);
		//gray2.copy(gray);
		//GaussSmoothSep(gray, 0.7); // lena
		//GaussSmoothSep(gray, 2.0); // lena
		//////////////////////////////
		//DrawGrayImage(memDC, image_x, image_y, gray);
		//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
		//////////////////////////////////////////////////
		//GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); // used for ETF
		e.init(image_x, image_y);
		e.set(gray);
		e.Smooth(4, 2);
		//e.Smooth(10, 10);
		//e.orient180();
		//////////////////////////////////////////////////////
		//DrawETF_LIC(dc, e, 10);

		///////////////////////////////////////////////////////
		// Initial DoG or FDoG
		double tao = 0.99;
		//GetDOG2(gray, G_mag, gray, 1.0, 0.99);  
		//GetDOG2(gray, G_mag, gray, 1.5, 0.99);  
		GetFDoGDouble(gray, e, G_mag, 1.0, 3.0, tao);
		GaussSmoothSepDouble2(G_mag, gray, 0.5, G_mag);
		e.init(image_x, image_y);
		e.set(gray);
		//GetFDoG(gray, e, 1.0, 3.0, tao); // Initial FDoG. Also works!
		//GetDogSep(gray, 1.0, gray, tao);
		//GetDoGLIC(gray, e, 1.0, 3.0, tao); // fingerprint
		//Binarize(gray, 0.5); // zucker
		bool sumie = false;
		//GrayThresholding(gray, 0.7); // zucker
		//GrayThresholding(gray, 0.5); // zucker
		//ReplaceStrokeTexture4(G_mag, e, gray, tex);
		//ReplaceStrokeTexture8(G_mag, e, gray, tex, sumie);
		ReplaceStrokeTexture9(G_mag, e, gray, tex, sumie);
		//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.7); // zucker
		//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.8); // zucker
		//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
		//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		/////////////////////////////////////////////////////////
		
		/////////////////////////////////////////////////////
		
		///////////////////////////////////////////
		DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
		dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		strcpy(s, "cld_");
		strcat(s, s1);
		strcat(s, ".bmp");
		SaveBMPfromMemDC(memDC, IMAGE_X, IMAGE_Y, s);
		TRACE("Frame %d completed!\n", i);
		//printf("Line drawing completed!\n");
		//TRACE("Elapsed Time = %f\n", ElapsedTime());
	}

	TRACE("\nVideo CLD completed!\n");

}

void CCubeView::OnToonUpsampling()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);

	GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	//////////////////////////////////////////////////////////
	//GaussColSmoothSep(cmap, 1.0);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//GaussSmoothSep(gray, 1.0); // lena
	//////////////////////////////////
	int image_x = gray.getRow();
	int image_y = gray.getCol();

	imatrix gray_s;
	cimatrix cmap_s;

	int image_x_s = image_x / 2;
	int image_y_s = image_y / 2;

	//DownsampleGrayImage(gray, gray_s);
	//DownsampleGrayImage(line, line_s);
	//GetLaplacian6(line_s, 1.0, line_s, 1.0);
	//DrawGrayImage(memDC, image_x_s, image_y_s, gray_s);
	//dc.BitBlt(0, 0, image_x_s, image_y_s, &memDC, 0, 0, SRCCOPY);
	
	//DownsampleColorImage(cmap, cmap_s);

	cimatrix cmap_b;

	//UpsampleGrayImage(gray_s, gray);
	//UpsampleColorImage(cmap_s, cmap);
	UpsampleColorImage(cmap, cmap_b);

	int image_x_b = image_x * 2;
	int image_y_b = image_y * 2;
	
	//DrawGrayImage(memDC, image_x, image_y, gray);
	DrawColorImage(memDC, image_x_b, image_y_b, cmap_b);
	dc.BitBlt(0, 0, image_x_b, image_y_b, &memDC, 0, 0, SRCCOPY);
	//DrawETF_LIC(dc, e, 10);
	//CopyCmap2Membuffer(cmap, Dbuffer);
	//CopyGray2Membuffer(gray, Dbuffer);
	TRACE("Toon Curvature 9 done!\n");
}


void CCubeView::OnToonSegment()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	
	GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	//////////////////////////////////////////////////////////
	//GaussColSmoothSep(cmap, 1.0);
	//GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//GaussSmoothSep(gray, 1.0); // lena
	//GrayQuantization(gray, 7); 
	ColorQuantizationLAB2(cmap, 5, 10, 10); 
	//////////////////////////////////
	int image_x = gray.getRow();
	int image_y = gray.getCol();

	////////////////////////
	//LevelSet(gray, 7); 
	//LevelSet2(gray); 
	//LevelSet3(gray, 50); 
	//Dilation(gray, 1);
	DilationColor(dc, cmap);
	//Closing(gray, 5, 1);
	
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	//DrawGrayImage(memDC, image_x, image_y, gray);
	dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
	//DrawETF_LIC(dc, e, 10);
	//CopyCmap2Membuffer(cmap, Dbuffer);
	//CopyGray2Membuffer(gray, Dbuffer);
	TRACE("Mean Curvature Flow done!\n");
}

void CCubeView::OnToonDot2dot()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);

	GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	//////////////////////////////////////////////////////////
	//GaussColSmoothSep(cmap, 1.0);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//GaussSmoothSep(gray, 2.0); // lena
	//////////////////////////////////
	int image_x = gray.getRow();
	int image_y = gray.getCol();

	//OpeningClosingBlack(dc, gray, 3);

	///////////////////////////////////////////////////////
	// Initial DoG or FDoG
	ETF e;
	e.init(image_x, image_y);
	/////////////////////////
	e.set(gray);
	e.Smooth(4, 2);
	//e.Smooth(10, 10);
	//e.orient180();
	//e.Smooth3(4, 3);
	//e.Smooth3(10, 5);
	//////////////////////////////////////////////////////
	//DrawETF_LIC(dc, e, 10);
	//DrawETFColor360(dc, e);
	//DrawETFColor180(dc, e);
	//DrawETFColorTensor(dc, e);
	GetFlowLineGaussianETF(gray, e, 2.0, 1);
	imatrix line(image_x, image_y);
	line.copy(gray);
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	///////////////////////////////////////////////////////
	// Initial DoG or FDoG
	double tao = 0.99;
	//double tao = 0.995;
	//GetDogSep(line, 1.0, line, tao);
	//GetDogSep(line, 1.0, line, tao);
	GetFDoG(line, e, 1.0, 3.0, tao); // Initial FDoG. Also works!
	//Binarize(line, 0.5); // zucker
	GrayThresholding(line, 0.7); 
	//Binarize(line, 0.7); // zucker
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, line);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	/////////////////////////////////////////////////////
	
	imatrix gray_s, line_s;
	cimatrix cmap_s;

	int image_x_s = image_x / 2;
	int image_y_s = image_y / 2;

	//DownsampleGrayImage(gray, gray_s);
	//DownsampleGrayImage(line, line_s);
	//GetLaplacian6(line_s, 2.0, line_s, 0.99);
	//DrawGrayImage(memDC, image_x_s, image_y_s, line_s);
	//dc.BitBlt(0, 0, image_x_s, image_y_s, &memDC, 0, 0, SRCCOPY);

	//MeanCurvatureFlow(gray, 100);
	//MeanCurvatureFlowSapiro(gray, 10);
	
	//DownsampleColorImage(cmap, cmap_s);
	
	//cimatrix merged_s(image_x_s, image_y_s);
	//cimatrix merged;
	//imatrix merged_s(image_x_s, image_y_s);
	//imatrix merged;

	//matrix G_mag(image_x_s, image_y_s);

	//MeanCurvatureFlow(gray, 10);
	//MeanCurvatureFlow(gray, 128);
	
	for (int i = 0; i < 10; i++) {
		///////////////////////////////
		// smoothing the regions
		//MeanCurvatureFlow(gray_s, 100);
		MeanCurvatureFlow2(gray, line, 10);
		//MeanCurvatureFlowColor(cmap_s, 3);
		//MeanCurvatureFlowColor2(cmap_s, line_s, 3);
		//MeanCurvatureFlowColorLAB2(cmap_s, line_s, 1);
		///////////////////////////////
		//CopyCol2GrayImage(image_x, image_y, cmap, gray); 
		//CopyCol2GrayImage2(cmap_s, gray_s); 
		//TRACE("image_x_s = %d, image_y_s = %d\n", image_x_s, image_y_s);
		e.init(image_x, image_y);
		e.set(gray);
		//e.Smooth(4, 2);
		e.Smooth(4, 2);
		//e.Smooth(5, 3);
		//e.orient180();
		//DrawETF_LIC(dc, e, 10);
		//////////////////////////////////////////////////////
		//ConstructMergedImage(gray, line, merged); // merge with the original image
		//ConstructMergedImageColor(cmap_s, line_s, merged_s); // merge with the original image
		//GaussSmoothSep(line, 10.0); // 
		//GaussSmoothSep(line, 3.0); // smooth out the lines
		//DrawGrayImage(memDC, image_x_s, image_y_s, merged);
		DrawGrayImage(memDC, image_x, image_y, gray);
		//DrawColorImage(memDC, image_x_s, image_y_s, merged_s);
		dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
		/////////////////////////////////
		// smoothing the lines
		//MeanCurvatureFlow(line, 10);
		//MinMaxFlow2(line, 4, 127.5, 10);
		MeanCurvatureFlow3(line, e, 10);
		//GetLaplacian7(line_s, 2.0, line_s, 0.98, 0.2);
		//if (i == 4)	GetLaplacianDouble(line_s, 2.0, G_mag, 0.99, 0.7);
		GetLaplacian7(line, 2.0, line, 0.99, 0.7);
		//ErosionGrayCircle(dc, line_s, 1);
		//////////////////////////////////////
		DrawGrayImage(memDC, image_x, image_y, line);
		//DrawGrayImage(memDC, image_x_s, image_y_s, gray_s);
		dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
		TRACE("curvature flow iteration %d\n", i+1);
	}

	//GaussSmoothSepDouble(line_s, 1.0, G_mag);
	//ErosionGray(dc, line_s, 1);
	//ErosionGrayCircle(dc, line_s, 1);
	//EdgeThinning(dc, line_s);
	//NonmaximaSuppressionETF(G_mag, e, line_s, 1.0);
	//ConstructMergedImageColor(cmap_s, line_s, merged_s); // merge with the original image

	//UpsampleColorImage(cmap_s, cmap); // bilinear interpolation
	//UpsampleColorImage(merged_s, merged); // bilinear interpolation
	//UpsampleColorImageNearest(merged_s, merged);
	//UpsampleGrayImage(gray_s, gray);
	//UpsampleGrayImageNearest(line_s, line);
	//ErosionGrayCircle(dc, line, 2);
	//EdgeThinning(dc, line);
	////////////////////
	//image_x = merged.getRow();
	//image_y = merged.getCol();
	//DrawGrayImage(memDC, image_x, image_y, merged);
	//DrawColorImage(memDC, image_x, image_y, merged);
	//*/
	DrawGrayImage(memDC, image_x, image_y, line);

	//DrawGrayImage(memDC, image_x_s, image_y_s, line_s);
	//DrawColorImage(memDC, image_x, image_y, cmap);
	dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
	//DrawETF_LIC(dc, e, 10);
	//CopyCmap2Membuffer(cmap, Dbuffer);
	//CopyGray2Membuffer(gray, Dbuffer);
	TRACE("Dot2Dot drawing done!\n");
}



void CCubeView::OnToonUpsampling2()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);

	GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	//////////////////////////////////////////////////////////
	//GaussColSmoothSep(cmap, 1.0);
	//GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//GaussSmoothSep(gray, 1.0); // lena
	//////////////////////////////////
	int image_x = cmap.getRow();
	int image_y = cmap.getCol();

	cimatrix cmap_s;

	//int image_x_s = image_x / 2;
	//int image_y_s = image_y / 2;

	//DownsampleGrayImage(gray, gray_s);
	//gray.copy(gray_s);
	//DownsampleGrayImage(gray, gray_s);
	//gray.copy(gray_s);
	//DownsampleGrayImage(gray, gray_s);

	DownsampleColorImage(cmap, cmap_s);
	cmap.copy(cmap_s);
	DownsampleColorImage(cmap, cmap_s);
	cmap.copy(cmap_s);
	DownsampleColorImage(cmap, cmap_s);
	
	UpsampleColorImage(cmap_s, cmap);
	cmap_s.copy(cmap);
	UpsampleColorImage(cmap_s, cmap);
	cmap_s.copy(cmap);
	UpsampleColorImage(cmap_s, cmap);

	//UpsampleGrayImage(gray_s, gray);
	//gray_s.copy(gray);
	//UpsampleGrayImage(gray_s, gray);
	//gray_s.copy(gray);
	//UpsampleGrayImage(gray_s, gray);
	//UpsampleColorImage(cmap_s, cmap);
	//UpsampleColorImage(cmap, cmap_b);

	//int image_x_b = image_x * 2;
	//int image_y_b = image_y * 2;

	image_x = cmap.getRow();
	image_y = cmap.getCol();
	
	//DrawGrayImage(memDC, image_x, image_y, gray);
	DrawColorImage(memDC, image_x, image_y, cmap);
	dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
	//DrawETF_LIC(dc, e, 10);
	//CopyCmap2Membuffer(cmap, Dbuffer);
	//CopyGray2Membuffer(gray, Dbuffer);
	TRACE("Toon Upsampling done!\n");
}

void CCubeView::OnToonCurvature6()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	
	//GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	//////////////////////////////////////////////////////////
	//GaussColSmoothSep(cmap, 1.0);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	GaussSmoothSep(gray, 1.0); // lena
	//////////////////////////////////
	int image_x = gray.getRow();
	int image_y = gray.getCol();

	///////////////////////////////////////////////////////
	// Initial DoG or FDoG
	imatrix line(image_x, image_y);
	line.copy(gray);

	ETF e;
	e.init(image_x, image_y);
	/////////////////////////
	e.set(line);
	//e.set(gray2);
	//e.tensor(gray);
	//e.tensor(gray2);
	e.Smooth(4, 2);
	//e.Smooth(10, 10);
	e.orient180();
	//e.Smooth3(4, 3);
	//e.Smooth3(10, 5);
	//////////////////////////////////////////////////////
	DrawETF_LIC(dc, e, 10);
	//DrawETFColor360(dc, e);
	//DrawETFColor180(dc, e);
	//DrawETFColorTensor(dc, e);
	///////////////////////////////////////////////////////
	// Initial DoG or FDoG
	double tao = 0.97;
	//double tao = 0.995;
	GetDogSep(line, 1.0, line, tao);
	Binarize(line, 0.2); // zucker
	//Binarize(line, 0.7); // zucker
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, line);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	/////////////////////////////////////////////////////

	///*
	tao = 0.99;
	for (int i = 0; i < 3; i++) {
		ConstructMergedImage(gray, line, line); // merge with the original image
		//GaussSmooth5(line, 0.5); // leesy
		//GaussSmoothSep(line, 0.5); // lena
		GetFDoG(line, e, 1.0, 2.0, tao); // Initial FDoG. Also works!
		//GetFDoG(gray, e, 1.5, 3.0, tao); // fingerprint
		Binarize(line, 0.2); 
		DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, line);
		dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	}
	//*/
	//////////////////////////////////////////////////////
	
	imatrix merged(image_x, image_y);
	
	for (int i = 0; i < 30; i++) {
		///////////////////////////////
		// smoothing the regions
		//MeanCurvatureFlow(gray, 10);
		MeanCurvatureFlow2(gray, line, 10);
		///////////////////////////////
		e.set(gray);
		e.Smooth(4, 2);
		e.orient180();
		//DrawETF_LIC(dc, e, 10);
		//////////////////////////////////////////////////////
		ConstructMergedImage(gray, line, merged); // merge with the original image
		//GaussSmoothSep(line, 10.0); // 
		//GaussSmoothSep(line, 3.0); // smooth out the lines
		DrawGrayImage(memDC, image_x, image_y, merged);
		dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
		/////////////////////////////////
		// smoothing the lines
		//MeanCurvatureFlow(line, 10);
		MeanCurvatureFlow3(line, e, 10);
		//MinMaxFlow(line, 1.0, 10);
		//MinMaxFlow2(line, 2, 127.5, 10);
		//MeanCurvatureFlow2(gray, line, 10);
		//DrawGrayImage(memDC, image_x, image_y, gray);
		//dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
		//////////////////////////////////////////
		//Binarize(line, 0.5); 
		GetLaplacian6(line, 2.0, line, 1.0);
		//////////////////////////////////////
		DrawGrayImage(memDC, image_x, image_y, line);
		dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
	}

	////////////////////////
	//GrayQuantization(gray, 7); 
	//GrayQuantization(gray, 2); 
	//DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	ConstructMergedImage(gray, line, merged); // merge with the original image
	DrawGrayImage(memDC, image_x, image_y, merged);
	dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
	//DrawETF_LIC(dc, e, 10);
	//CopyCmap2Membuffer(cmap, Dbuffer);
	//CopyGray2Membuffer(gray, Dbuffer);
	TRACE("Mean Curvature Flow done!\n");
}

void CCubeView::OnToonCurvature9()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);

	GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	//////////////////////////////////////////////////////////
	//GaussColSmoothSep(cmap, 1.0);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//GaussSmoothSep(gray, 1.0); // lena
	//////////////////////////////////
	int image_x = gray.getRow();
	int image_y = gray.getCol();

	//OpeningClosingBlack(dc, gray, 3);

	///////////////////////////////////////////////////////
	// Initial DoG or FDoG
	imatrix line(image_x, image_y);
	line.copy(gray);

	ETF e;
	e.init(image_x, image_y);
	/////////////////////////
	e.set(line);
	e.Smooth(4, 2);
	//e.Smooth(10, 10);
	//e.orient180();
	//e.Smooth3(4, 3);
	//e.Smooth3(10, 5);
	//////////////////////////////////////////////////////
	//DrawETF_LIC(dc, e, 10);
	//DrawETFColor360(dc, e);
	//DrawETFColor180(dc, e);
	//DrawETFColorTensor(dc, e);
	///////////////////////////////////////////////////////
	// Initial DoG or FDoG
	double tao = 0.99;
	//double tao = 0.995;
	//GetDogSep(line, 1.0, line, tao);
	//GetDogSep(line, 1.0, line, tao);
	GetFDoG(line, e, 1.0, 3.0, tao); // Initial FDoG. Also works!
	//Binarize(line, 0.5); // zucker
	//GrayThresholding(gray, 0.7); 
	Binarize(line, 0.7); // zucker
	//Binarize(line, 0.9); // zucker
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, line);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	/////////////////////////////////////////////////////
	
	imatrix gray_s, line_s;
	cimatrix cmap_s;

	int image_x_s = image_x / 2;
	int image_y_s = image_y / 2;

	DownsampleGrayImage(gray, gray_s);
	DownsampleGrayImage(line, line_s);
	//GetLaplacian6(line_s, 2.0, line_s, 0.99);
	DrawGrayImage(memDC, image_x_s, image_y_s, line_s);
	dc.BitBlt(0, 0, image_x_s, image_y_s, &memDC, 0, 0, SRCCOPY);
	
	DownsampleColorImage(cmap, cmap_s);
	
	cimatrix merged_s(image_x_s, image_y_s);
	cimatrix merged;
	
	for (int i = 0; i < 10; i++) {
		///////////////////////////////
		// smoothing the regions
		//MeanCurvatureFlow(gray, 10);
		//MeanCurvatureFlow2(gray, line, 10);
		MeanCurvatureFlowColor2(cmap_s, line_s, 3);
		//MeanCurvatureFlowColorLAB2(cmap_s, line_s, 1);
		///////////////////////////////
		//CopyCol2GrayImage(image_x, image_y, cmap, gray); 
		CopyCol2GrayImage2(cmap_s, gray_s); 
		//TRACE("image_x_s = %d, image_y_s = %d\n", image_x_s, image_y_s);
		e.init(image_x_s, image_y_s);
		e.set(gray_s);
		//e.Smooth(4, 2);
		e.Smooth(5, 1);
		//e.Smooth(5, 3);
		//e.orient180();
		//DrawETF_LIC(dc, e, 10);
		//////////////////////////////////////////////////////
		//ConstructMergedImage(gray, line, merged); // merge with the original image
		ConstructMergedImageColor(cmap_s, line_s, merged_s); // merge with the original image
		//GaussSmoothSep(line, 10.0); // 
		//GaussSmoothSep(line, 3.0); // smooth out the lines
		//DrawGrayImage(memDC, image_x, image_y, merged);
		DrawColorImage(memDC, image_x_s, image_y_s, merged_s);
		dc.BitBlt(0, 0, image_x_s, image_y_s, &memDC, 0, 0, SRCCOPY);
		/////////////////////////////////
		// smoothing the lines
		//MeanCurvatureFlow(line, 10);
		//MinMaxFlow2(line, 4, 127.5, 10);
		MeanCurvatureFlow3(line_s, e, 5);
		//MinMaxFlow(line, 1.0, 10);
		//MinMaxFlow2(line, 2, 127.5, 10);
		//MeanCurvatureFlow2(gray, line, 10);
		//DrawGrayImage(memDC, image_x, image_y, gray);
		//dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
		//////////////////////////////////////////
		//Binarize(line, 0.5); 
		//GetLaplacian6(line_s, 2.0, line_s, 0.98);
		//GetLaplacian7(line_s, 2.0, line_s, 0.98, 0.2);
		GetLaplacian7(line_s, 1.5, line_s, 0.99, 0.7);
		//GetLaplacian7(line_s, 2.0, line_s, 0.99, 0.7);
		//////////////////////////////////////
		DrawGrayImage(memDC, image_x_s, image_y_s, line_s);
		dc.BitBlt(0, 0, image_x_s, image_y_s, &memDC, 0, 0, SRCCOPY);
		TRACE("curvature flow iteration %d\n", i+1);
	}

	//GetFlowDilation(line_s, e, 5, 1);
	//DrawGrayImage(memDC, image_x_s, image_y_s, line_s);
	//dc.BitBlt(0, 0, image_x_s, image_y_s, &memDC, 0, 0, SRCCOPY);

	//DrawETF_LIC(dc, e, 10);

	//ColorQuantizationLAB2(cmap_s, 5, 10, 10);  
	KmeansSegmentColor(dc, cmap_s, 7, 10.0); // duck
	//KmeansSegmentColor(dc, cmap_s, 15, 10.0); // eagle

    //DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	//ConstructMergedImage(gray, line, merged); // merge with the original image
	//GetLaplacian6(line_s, 1.0, line_s, 1.0);
	ConstructMergedImageColor(cmap_s, line_s, merged_s); // merge with the original image

	//UpsampleColorImage(merged_s, merged); // bilinear interpolation
	UpsampleColorImageNearest(merged_s, merged);
	////////////////////
	image_x = merged.getRow();
	image_y = merged.getCol();
	//DrawGrayImage(memDC, image_x, image_y, merged);
	DrawColorImage(memDC, image_x, image_y, merged);
	//*/

	//DrawGrayImage(memDC, image_x_s, image_y_s, line_s);
	//DrawColorImage(memDC, image_x, image_y, cmap);
	dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
	//DrawETF_LIC(dc, e, 10);
	//CopyCmap2Membuffer(cmap, Dbuffer);
	//CopyGray2Membuffer(gray, Dbuffer);
	TRACE("Toon Curvature 9 done!\n");
}

void CCubeView::OnToonCurvature8()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	
	GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	//////////////////////////////////////////////////////////
	//GaussColSmoothSep(cmap, 1.0);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//GaussSmoothSep(gray, 1.0); // lena
	//////////////////////////////////
	int image_x = gray.getRow();
	int image_y = gray.getCol();

	///////////////////////////////////////////////////////
	// Initial DoG or FDoG
	imatrix line(image_x, image_y);
	line.copy(gray);

	ETF e;
	e.init(image_x, image_y);
	/////////////////////////
	e.set(line);
	e.Smooth(4, 2);
	//e.Smooth(10, 10);
	e.orient180();
	//e.Smooth3(4, 3);
	//e.Smooth3(10, 5);
	//////////////////////////////////////////////////////
	DrawETF_LIC(dc, e, 10);
	//DrawETFColor360(dc, e);
	//DrawETFColor180(dc, e);
	//DrawETFColorTensor(dc, e);
	///////////////////////////////////////////////////////
	// Initial DoG or FDoG
	double tao = 0.99;
	//double tao = 0.995;
	//GetDogSep(line, 1.0, line, tao);
	GetFDoG(line, e, 1.0, 3.0, tao); // Initial FDoG. Also works!
	Binarize(line, 0.5); // zucker
	//Binarize(line, 0.7); // zucker
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, line);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	/////////////////////////////////////////////////////

	/*
	tao = 0.995;
	for (int i = 0; i < 3; i++) {
		ConstructMergedImage(gray, line, line); // merge with the original image
		//GaussSmooth5(line, 0.5); // leesy
		//GaussSmoothSep(line, 0.5); // lena
		//GetFDoG(line, e, 1.0, 2.0, tao); // Initial FDoG. Also works!
		GetFDoG(line, e, 1.0, 2.0, tao); // Initial FDoG. Also works!
		//GetFDoG(gray, e, 1.5, 3.0, tao); // fingerprint
		Binarize(line, 0.2); 
		DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, line);
		dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	}
	*/
	//////////////////////////////////////////////////////
	
	cimatrix merged(image_x, image_y);
	
	for (int i = 0; i < 10; i++) {
		///////////////////////////////
		// smoothing the regions
		//MeanCurvatureFlow(gray, 10);
		//MeanCurvatureFlow2(gray, line, 10);
		//MeanCurvatureFlowColor2(cmap, line, 10);
		MeanCurvatureFlowColorLAB2(cmap, line, 3);
		///////////////////////////////
		CopyCol2GrayImage(image_x, image_y, cmap, gray); 
		e.set(gray);
		e.Smooth(4, 2);
		//e.Smooth(5, 3);
		//e.orient180();
		//DrawETF_LIC(dc, e, 10);
		//////////////////////////////////////////////////////
		//ConstructMergedImage(gray, line, merged); // merge with the original image
		ConstructMergedImageColor(cmap, line, merged); // merge with the original image
		//GaussSmoothSep(line, 10.0); // 
		//GaussSmoothSep(line, 3.0); // smooth out the lines
		//DrawGrayImage(memDC, image_x, image_y, merged);
		DrawColorImage(memDC, image_x, image_y, merged);
		dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
		/////////////////////////////////
		// smoothing the lines
		//MeanCurvatureFlow(line, 10);
		//MinMaxFlow2(line, 4, 127.5, 10);
		MeanCurvatureFlow3(line, e, 10);
		//MinMaxFlow(line, 1.0, 10);
		//MinMaxFlow2(line, 2, 127.5, 10);
		//MeanCurvatureFlow2(gray, line, 10);
		//DrawGrayImage(memDC, image_x, image_y, gray);
		//dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
		//////////////////////////////////////////
		//Binarize(line, 0.5); 
		GetLaplacian6(line, 2.0, line, 1.0);
		//GetLaplacian6(line, 1.0, line, 1.0);
		//////////////////////////////////////
		DrawGrayImage(memDC, image_x, image_y, line);
		dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
		TRACE("curvature flow iteration %d\n", i+1);
	}

	////////////////////////
	//GrayQuantization(gray, 7); 
	//GrayQuantization(gray, 2); 
	//ColorQuantization(cmap, 7);
	//ColorQuantizationLAB(cmap, 7); 
	KmeansSegmentColor(dc, cmap, 10, 15.0); // duck
	RemoveSmallRegions(dc, line, 100);
	//DilationColor2(dc, cmap, line, 70, 1.0); // eagle
	//DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	//ConstructMergedImage(gray, line, merged); // merge with the original image
	ConstructMergedImageColor(cmap, line, merged); // merge with the original image
	//DrawGrayImage(memDC, image_x, image_y, merged);
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, merged);
	dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
	//DrawETF_LIC(dc, e, 10);
	//CopyCmap2Membuffer(cmap, Dbuffer);
	//CopyGray2Membuffer(gray, Dbuffer);
	TRACE("Mean Curvature Flow done!\n");
}

void CCubeView::OnToonEtfmotion()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);

	GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	//////////////////////////////////////////////////////////
	//GaussColSmoothSep(cmap, 1.0);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//GaussSmoothSep(gray, 1.0); // lena
	//////////////////////////////////
	int image_x = gray.getRow();
	int image_y = gray.getCol();

	//OpeningClosingBlack(dc, gray, 3);

	///////////////////////////////////////////////////////
	// Initial DoG or FDoG
	//imatrix line(image_x, image_y);
	//line.copy(gray);

	ETF e;
	//e.init(image_x, image_y);
	/////////////////////////
	//e.set(gray);
	//e.Smooth(4, 2);
	//e.Smooth(7, 5);
	/*
	//e.Smooth(10, 10);
	//e.orient180();
	//e.Smooth3(4, 3);
	//e.Smooth3(10, 5);
	//////////////////////////////////////////////////////
	//DrawETF_LIC(dc, e, 10);
	//DrawETFColor360(dc, e);
	//DrawETFColor180(dc, e);
	//DrawETFColorTensor(dc, e);
	///////////////////////////////////////////////////////
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	/////////////////////////////////////////////////////
	*/
	
	for (int i = 0; i < 10; i++) {
		///////////////////////////////
		// smoothing the regions
		//MeanCurvatureFlow(gray, 10);
		//MeanCurvatureFlow2(gray, line, 10);
		//MeanCurvatureFlowColor2(cmap_s, line_s, 3);
		//MeanCurvatureFlowColorLAB2(cmap_s, line_s, 1);
		///////////////////////////////
		//CopyCol2GrayImage(image_x, image_y, cmap, gray); 
		//CopyCol2GrayImage2(cmap, gray); 
		//TRACE("image_x_s = %d, image_y_s = %d\n", image_x_s, image_y_s);
		//e.init(image_x, image_y);
		//e.set(gray);
		//e.Smooth(4, 2);
		//e.Smooth(5, 1);
		//e.Smooth(5, 3);
		//e.orient180();
		//DrawETF_LIC(dc, e, 10);
		//////////////////////////////////////////////////////
		//ConstructMergedImage(gray, line, merged); // merge with the original image
		//ConstructMergedImageColor(cmap_s, line_s, merged_s); // merge with the original image
		//GaussSmoothSep(line, 10.0); // 
		//GaussSmoothSep(line, 3.0); // smooth out the lines
		//DrawGrayImage(memDC, image_x, image_y, merged);
		//DrawColorImage(memDC, image_x_s, image_y_s, merged_s);
		//dc.BitBlt(0, 0, image_x_s, image_y_s, &memDC, 0, 0, SRCCOPY);
		/////////////////////////////////
		///////////////////////////////////////
		e.init(image_x, image_y);
		e.set(gray);
		e.Smooth(4, 2);
		//////////////////////////
		MeanCurvatureFlowColor(cmap, 10);
		//MeanCurvatureFlowColor3(cmap, e, 10);
		CopyCol2GrayImage2(cmap, gray); 
		//GetColShockFast(cmap, gray, 1.0, 1.0, 0.1); 
		//GetColShockFastHSV(cmap, gray, 1.0, 1.0);
		//GetColShockFastMinMax(cmap, gray, 1.0, 1.0);
		GetColShockFastMinMax(cmap, gray, 1.0, 1.0);
		CopyCol2GrayImage2(cmap, gray); 
		////////////////////////////////////
		//DrawGrayImage(memDC, image_x, image_y, gray);
		//dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
		//////////////////////////////////////////
		//////////////////////////////////////
		//DrawGrayImage(memDC, image_x, image_y, gray);
		DrawColorImage(memDC, image_x, image_y, cmap);
		dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
		TRACE("curvature flow iteration %d\n", i+1);
	}

	//GetFlowDilation(line_s, e, 5, 1);
	//DrawGrayImage(memDC, image_x_s, image_y_s, line_s);
	//dc.BitBlt(0, 0, image_x_s, image_y_s, &memDC, 0, 0, SRCCOPY);

    //DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	//ConstructMergedImage(gray, line, merged); // merge with the original image
	//GetLaplacian6(line_s, 1.0, line_s, 1.0);
	//ConstructMergedImageColor(cmap_s, line_s, merged_s); // merge with the original image

	////////////////////
	//image_x = merged.getRow();
	//image_y = merged.getCol();
	//DrawGrayImage(memDC, image_x, image_y, merged);
	//DrawColorImage(memDC, image_x, image_y, gray);

	//DrawGrayImage(memDC, image_x_s, image_y_s, line_s);
	//DrawColorImage(memDC, image_x, image_y, cmap);
	//dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
	TRACE("ETF motion done!\n");
}

void CCubeView::OnEdgeWeickert()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);

	GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	//////////////////////////////////////////////////////////
	//GaussColSmoothSep(cmap, 1.0);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//GaussSmoothSep(gray, 1.0); // lena
	//////////////////////////////////
	int image_x = gray.getRow();
	int image_y = gray.getCol();

	//OpeningClosingBlack(dc, gray, 3);
	///////////////////////////////////////////////////////
	imatrix sign(image_x, image_y);
	imatrix gray2(image_x, image_y);
	gray2.copy(gray);
	
	ETF e;
	//////////////
	e.init(image_x, image_y);
	//e.tensor(gray);
	//e.SmoothTensor(gray, 5.0);
	///*
	//////////////////////////////////////////////////////
	//DrawETF_LIC(dc, e, 10);
	//DrawETFColor360(dc, e);
	//DrawETFColor180(dc, e);
	//DrawETFColorTensor(dc, e);
	///////////////////////////////////////////////////////
	//*/
			
	for (int i = 0; i < 30; i++) {
		///////////////////////////////
		///////////////////////////////////////
		//e.init(image_x, image_y);
		e.tensor(gray);
		e.SmoothTensor(gray, 5.0);
		//e.set(gray);
		//e.Smooth(4, 3);
		//DrawETF_LIC(dc, e, 10);
		//////////////////////////
		//GaussSmoothSep(gray2, 1.0); // 
		//GaussSmoothSep(gray2, 1.5); // Weickert fingerprint: 1.5
		//GaussSmoothSep(gray2, 2.0); // Weickert Mandrill: 2.0
		GaussSmoothSep(gray2, 4.0); // Weickert Mandrill: 4.0
		//BilateralGraySep(gray2, 2.0, 10.0, 3); // Inoue: edge-preserving filtering in getting the sign
		////////////////////////////////////////////////////////////////////////////
		// 2/2/2008: Weickert uses gray to get e, then use gray2 and e to get sign!!!
		GetFlowShockDoGETF2(gray2, e, sign, 0.9, 1.0); // Weickert fingerprint: 0.9
		//GetFlowShockDoGETF2(gray, e, sign, 1.0, 1.0); // Weickert Mandrill: 1.0
		////////////////////////////////////////////////////////
		//GetColShockFastWeickert4(cmap, sign, 100, 1); // Weickert fingerprint: 100, 1
		//GetColShockFastWeickert4(cmap, sign, 1, 1); // 
		//GetWeickertUpwind(cmap, sign, 0.3, 1); // This works!
		GetWeickertUpwind(cmap, sign, 0.4, 1); // This works!
		//GetWeickertUpwind(cmap, sign, 0.7, 1); // This works! 1.0 is overshoot!
		////////////////////////////////////
		//DrawGrayImage(memDC, image_x, image_y, gray);
		//dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
		//////////////////////////////////////////
		//////////////////////////////////////
		//DrawGrayImage(memDC, image_x, image_y, sign);
		DrawColorImage(memDC, image_x, image_y, cmap);
		dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);

		////////////////////////////////////////////////////////////////////
		// 2/2/2008: We don't smooth the original image (see Weickert's paper)!!!!
		// instead, we smooth the original just to get smoothed Tensor!
		CopyCol2GrayImage2(cmap, gray);  // used to get e
		CopyCol2GrayImage2(cmap, gray2);  // used to get sign (directional second derivative)
				
		TRACE("Weickert shock iteration %d\n", i+1);
	}

	////////////////////
	//DrawColorImage(memDC, image_x, image_y, cmap);
	//DrawGrayImage(memDC, image_x, image_y, merged);
	//DrawColorImage(memDC, image_x, image_y, gray);
	//dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
	TRACE("Weickert shock filtering done!\n");
}

void CCubeView::OnEdgeEtf()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	//GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//GaussSmooth5(gray, 0.7); // normal image
	//GaussSmooth5(gray, 3.0); // normal image
	GaussSmoothSep(gray, 2.0);
	//////////////////////////////////////////////////
	int image_x = gray.getRow();
	int image_y = gray.getCol();
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
	//gray2.init(image_x, image_y);
	//G_mag.init(image_x, image_y);
	//GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); // used for ETF
	//////////////////////////////////////////////////

	/*
	InitGradField(IMAGE_X, IMAGE_Y, gfield, gray); // now (gx, gy) is computed from gradient map!
	BilateralGfield11(dc, IMAGE_X, IMAGE_Y, gfield, 1.0, 2);
	DrawGradientField_LIC2(dc, IMAGE_X, IMAGE_Y, gfield, 10); // incorrect version? (looks better)
	*/

	//GetDiff(dc, gray, "_maple_etf_sep_4_2.bmp", "_maple_etf_full_4_2.bmp");
	//GetDiff(dc, gray, "_maple_etf_sep_4_4.bmp", "_maple_etf_full_4_2.bmp");

	///*
	ETF e;
	e.init(image_x, image_y);
	e.set(gray);
	//e.set(gray2);
	//e.tensor(gray);
	//e.SmoothTensor(gray, 5.0);
	//e.tensor(gray2);
	e.Smooth(4, 2);
	//e.Smooth(10, 5);
	//e.SmoothFull(4, 2);
	//e.SmoothFull(10, 5);
	//e.Smooth(4, 3);
	//e.Smooth(10, 5);
	//e.orient180();
	//e.Smooth3(4, 2);
	//e.Smooth3(7, 3);
	//e.Smooth3(10, 5);
	//e.Smooth3(10, 10);
	//////////////////////////////////////////////////////
	DrawETF_LIC(dc, e, 10);
	//DrawETFArrow(dc, e, 255, 0, 0);
	//DrawETFColor360(dc, e);
	//DrawETFColor180(dc, e);
	//DrawETFColorTensor(dc, e);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	////////////////////////////////////////////////////////////
	TRACE("ETF construction done!\n");
	//*/
}


void CCubeView::OnEdgeTensor()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);

	GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	//////////////////////////////////////////////////////////
	//GaussColSmoothSep(cmap, 1.0);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//GaussSmoothSep(gray, 1.0); // lena
	//////////////////////////////////
	int image_x = gray.getRow();
	int image_y = gray.getCol();

	//OpeningClosingBlack(dc, gray, 3);
	///////////////////////////////////////////////////////
	imatrix sign(image_x, image_y);
	
	ETF e;
	//////////////
	e.init(image_x, image_y);
	e.tensor(gray);
	e.SmoothTensor(gray, 5.0);
	///*
	//////////////////////////////////////////////////////
	//DrawETF_LIC(dc, e, 10);
	//DrawETFColor360(dc, e);
	//DrawETFColor180(dc, e);
	//DrawETFColorTensor(dc, e);
	//DrawGradientFieldArrow(dc, e, 255, 0, 0);
	//DrawTangentFieldArrow(dc, gfield, 255, 0, 0);
	DrawETFArrow(dc, e, 255, 0, 0);
	///////////////////////////////////////////////////////
	//*/
			
	////////////////////
	//DrawColorImage(memDC, image_x, image_y, cmap);
	//DrawGrayImage(memDC, image_x, image_y, merged);
	//DrawColorImage(memDC, image_x, image_y, gray);
	//dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
	TRACE("Structure Tensor done!\n");
}

void CCubeView::OnEdgeClditr()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//gray2.copy(gray);
	//GaussSmooth5(gray, 0.7); // lena
	//GaussSmoothSep(gray, 0.7); // lena
	//GaussSmoothSep(gray, 2.0); // lena
	int image_x = gray.getRow();
	int image_y = gray.getCol();
	imatrix input(image_x, image_y);
	input.copy(gray);
	//////////////////////////////
	DrawGrayImage(memDC, image_x, image_y, gray);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
	//////////////////////////////////////////////////
	//GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); // used for ETF
	ETF e;
	e.init(image_x, image_y);
	e.set(gray);
	e.Smooth(4, 2);
	//e.tensor(gray);
	//e.SmoothTensor(gray, 5.0);
	//e.orient180();
	//e.Smooth3(4, 3);
	//e.Smooth3(10, 5);
	//////////////////////////////////////////////////////
	//DrawETF_LIC(dc, e, 10);
	//DrawETFColor360(dc, e);
	//DrawETFColor180(dc, e);
	//DrawETFColorTensor(dc, e);

	///////////////////////////////////////////////////////
	// Initial DoG or FDoG
	double tao = 0.99;
	//GetDOG2(gray, G_mag, gray, 1.0, 0.99);  
	//GetDOG2(gray, G_mag, gray, 1.5, 0.99);  
	//GetFDoG(gray, e, 1.0, 3.0, tao); // Initial FDoG. Also works!
	//GetDogSep(gray, 1.0, gray, tao);
	GetDoGLIC(gray, e, 1.0, 3.0, tao); // fingerprint
	//Binarize(gray, 0.5); // zucker
	//GrayThresholding(gray, 0.7); // zucker
	GrayThresholding(gray, 0.5); // zucker
	//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.7); // zucker
	//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.8); // zucker
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	/////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////
	///*
	tao = 0.99;
	//double tao = 0.995;
	for (int i = 0; i < 4; i++) {
		//ConstructMergedImage(input, gray, gray); // merge with the original image
		ConstructMergedImageMult(input, gray, gray); // merge with the original image
		//GaussSmooth5(gray, 0.5); // leesy
		GaussSmoothSep(gray, 0.5); // lena
		//GetFlowDOG4(gray, gfield, gray, G_mag, 0.9, 2.0, tao); // Initial FDoG. Also works!
		//GetFDoG(gray, e, 0.7, 2.0, tao); // Initial FDoG. Also works!
		//GetFDoG(gray, e, 0.9, 2.0, tao); // Initial FDoG. Also works!
		//GetFDoG(gray, e, 1.0, 0.5, tao); // Initial FDoG. Also works!
		//GetFDoG(gray, e, 3.0, 3.0, tao); // fingerprint
		GetDoGLIC(gray, e, 1.0, 3.0, tao); // fingerprint
		//GetDoGLIC(gray, e, 1.0, 1.0, tao); // fingerprint
		//Binarize(gray, 0.5); 
		GrayThresholding(gray, 0.7); // zucker
		DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
		dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		TRACE("FDOG iteration %d complete.\n", i+1);
	}
	//*/
	
	///////////////////////////////////////////
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//SaveBMPfromMemDC(memDC, IMAGE_X, IMAGE_Y, "_result.bmp");
	TRACE("Line drawing completed!\n");
	//printf("Line drawing completed!\n");
	//TRACE("Elapsed Time = %f\n", ElapsedTime());
}

void CCubeView::OnEdgeCld()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	//GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);
	//BilateralColorSep(IMAGE_X, IMAGE_Y, cmap, 2.0, 10.0, 1);
	//CopyCol2GrayImage(IMAGE_X, IMAGE_Y, cmap, gray); 
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	//gray2.copy(gray);
	//GaussSmoothSep(gray, 0.7); // lena
	//GaussSmoothSep(gray, 2.0); // lena
	//GaussSmoothSep(gray, 3.0);
	GaussSmoothSep(gray, 1.0);

	int image_x = gray.getRow();
	int image_y = gray.getCol();
	imatrix input(image_x, image_y);
	input.copy(gray);

	////////////////////////////////////////
	GaussSmoothSep(input, 3.0); // works for 'X'
	//GaussSmoothSep(input, 10.0); // works for noisy circle
	//////////////////////////////
	//DrawGrayImage(memDC, image_x, image_y, gray);
	DrawGrayImage(memDC, image_x, image_y, input);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
	//////////////////////////////////////////////////
	//gray2.init(image_x, image_y);
	//G_mag.init(image_x, image_y);
	//GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); // used for ETF
	ETF e;
	e.init(image_x, image_y);
	//e.set(gray);
	e.set(input);
	//e.set(gray2);
	//e.tensor(gray);
	//e.tensor(gray2);
	//e.Smooth(1, 2); // works for small-scale texture
	e.Smooth(4, 2);
	//e.Smooth(6, 3); // works for 'X'
	//e.Smooth(10, 5);
	//e.SmoothFull(5, 2);
	//e.SmoothFull(5, 3);
	//e.Smooth(10, 10);
	//e.orient180();
	//////////////////////////////////////////////////////
	//DrawETF_LIC(dc, e, 10);
	//DrawETFColor360(dc, e);
	//DrawETFColor180(dc, e);
	//DrawETFColorTensor(dc, e);

	///////////////////////////////////////////////////////
	// Initial DoG or FDoG
	double tao;
	
	//tao = 0.98; // noisy circle
	//tao = 0.995;
	tao = 1.0; // isolated points
	
	//GetFDoG(gray, e, 1.5, 5.0, tao); // works for 'X'
	//GetFDoG(gray, e, 1.5, 10.0, tao); // Initial FDoG. Also works!
	//GetFDoG(gray, e, 1.0, 3.0, tao); // works for small-scale texture
	//GetFDoG(gray, e, 0.5, 1.0, tao); // works for small-scale texture
	//GetFDoG(gray, e, 0.5, 0.5, tao); // works for small-scale texture
	//GetFDoGDouble(gray, e, G_mag, 1.0, 3.0, tao);
	//GetDogSep(gray, 1.0, gray, tao);
	//GetDoGLIC(gray, e, 0.5, 0.5, tao); // small scale texture
	//GetDoGLIC(gray, e, 1.5, 10.0, tao); // noisy circle!!
	//GetDoGLIC(gray, e, 1.0, 3.0, tao); 
	GetDoGLIC(gray, e, 1.5, 5.0, tao); // isolated points
	//Binarize(gray, 0.5); // 
    Binarize(gray, 1.0); // isolated points
	//GetLaplacian7(gray, 2.0, gray, 0.99, 0.7);
	///EdgeThinning(dc, gray); // morphological edge thinning
	//ErosionGray(dc, gray, 1);
	//RemoveIsolatedRegions(dc, gray, 10); 
	//DilationGray(dc, gray, 1);
	//GrayThresholding(gray, 0.7); // zucker
	//GrayThresholding(gray, 0.2); // zucker
	//GrayThresholding(gray, 0.9); // zucker
	//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.7); // zucker
	//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.8); // zucker
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	/////////////////////////////////////////////////////////
	
	///////////////////////////////////////////
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//SaveBMPfromMemDC(memDC, IMAGE_X, IMAGE_Y, "_result.bmp");
	TRACE("Line drawing completed!\n");
	//printf("Line drawing completed!\n");
	//TRACE("Elapsed Time = %f\n", ElapsedTime());
}


void CCubeView::OnEdgeVideocld()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	int image_x = IMAGE_X;
	int image_y = IMAGE_Y;

	ETF e;

	TRACE("VIDEO CLD \n");
	
	gray.init(image_x, image_y);
	e.init(image_x, image_y);
	
	char s[30], s2[2], s1[30];

	for (int i = 1; i <= 60; i++) {
		//strcpy(s, "org");
		strcpy(s, "org");
		sprintf(s2, "%.2d", i);
		strcat(s, s2);
		strcpy(s1, s);
		strcat(s, ".bmp");
		if ( !LoadBMP3(dc, (char *)LPCTSTR(s), &memDC) ) 
			TRACE("%s does not exist!\n", s);

		gray.init(image_x, image_y);
		GetGrayImageFromMemDC(image_x, image_y, gray, memDC);
		
		//cmap.init(image_x, image_y);
		//GetColorImageFromMemDC(image_x, image_y, cmap, memDC);
		//BilateralColorSep(image_x, image_y, cmap, 2.0, 10.0, 1);
		//CopyCol2GrayImage(image_x, image_y, cmap, gray); 

		//gray2.copy(gray);
		//GaussSmoothSep(gray, 0.7); // lena
		//GaussSmoothSep(gray, 2.0); // lena
		//////////////////////////////
		//DrawGrayImage(memDC, image_x, image_y, gray);
		//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
		//////////////////////////////////////////////////
		//GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); // used for ETF
		e.init(image_x, image_y);
		e.set(gray);
		e.Smooth(4, 2);
		//e.orient180();
		//////////////////////////////////////////////////////
		//DrawETF_LIC(dc, e, 10);

		///////////////////////////////////////////////////////
		// Initial DoG or FDoG
		//double tao = 0.99;
		double tao = 0.99;
		GetFDoG(gray, e, 1.0, 3.0, tao); // Initial FDoG. Also works!
		//GetDogSep(gray, 1.0, gray, tao);
		//GetDoGLIC(gray, e, 1.0, 3.0, tao); // fingerprint
		//Binarize(gray, 0.5); // zucker
		//GrayThresholding(gray, 1.0); // zucker
		//GrayThresholding(gray, 0.9); // zucker
		//GrayThresholding(gray, 0.7); // zucker
		//GrayThresholding(gray, 0.2); // zucker
		Binarize(gray, 0.1); // zucker
		//GetLaplacian7(gray, 2.0, gray, 0.99, 0.7);
		//ErosionGray(dc, gray, 2);
		//DilationGray(dc, gray, 2);
		//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.7); // zucker
		//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.8); // zucker
		//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
		//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		/////////////////////////////////////////////////////////
		
		/////////////////////////////////////////////////////
		
		///////////////////////////////////////////
		DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
		dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		strcpy(s, "cld_");
		strcat(s, s1);
		strcat(s, ".bmp");
		SaveBMPfromMemDC(memDC, IMAGE_X, IMAGE_Y, s);
		TRACE("Frame %d completed!\n", i);
		//printf("Line drawing completed!\n");
		//TRACE("Elapsed Time = %f\n", ElapsedTime());
	}

	TRACE("\nVideo CLD completed!\n");
}

void CCubeView::OnEdgeVideotoon()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	int image_x = IMAGE_X;
	int image_y = IMAGE_Y;

	ETF e;

	TRACE("VIDEO CLD \n");

	cimatrix merged;
	
	gray.init(image_x, image_y);
	e.init(image_x, image_y);
	cmap.init(image_x, image_y);
	merged.init(image_x, image_y);
	
	char s[30], s2[2], s1[30]; // 01 - 99
	//char s[30], s2[3], s1[30]; // 001 - 999

	for (int i = 1; i <= 75; i++) {
		//strcpy(s, "org");
		strcpy(s, "test");
		sprintf(s2, "%.2d", i); // 01 - 99
		//sprintf(s2, "%.3d", i); // 001 - 999
		strcat(s, s2);
		strcpy(s1, s);
		strcat(s, ".bmp");
		if ( !LoadBMP3(dc, (char *)LPCTSTR(s), &memDC) ) 
			TRACE("%s does not exist!\n", s);

		//gray.init(image_x, image_y);
		//GetGrayImageFromMemDC(image_x, image_y, gray, memDC);
		//BilateralGraySep(gray, 2.0, 10.0, 1);
		
		GetColorImageFromMemDC(IMAGE_X, IMAGE_Y, cmap, memDC);
		//BilateralColorSep(image_x, image_y, cmap, 1.0, 20.0, 1);
				
		//cmap.init(image_x, image_y);
		//GetColorImageFromMemDC(image_x, image_y, cmap, memDC);
		//BilateralColorSep(image_x, image_y, cmap, 2.0, 10.0, 1);
		CopyCol2GrayImage(image_x, image_y, cmap, gray); 

		//gray2.copy(gray);
		//GaussSmoothSep(gray, 0.7); // lena
		//GaussSmoothSep(gray, 2.0); // lena
		//////////////////////////////
		//DrawGrayImage(memDC, image_x, image_y, gray);
		//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
		//////////////////////////////////////////////////
		//GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); // used for ETF
		e.init(image_x, image_y);
		e.set(gray);
		e.Smooth(3, 2);
		//e.orient180();
		//////////////////////////////////////////////////////
		//DrawETF_LIC(dc, e, 10);

		///////////////////////////////////////////////////////
		// Initial DoG or FDoG
		//double tao = 0.99;
		double tao = 0.99;
		GetFDoG(gray, e, 1.0, 3.0, tao); // Initial FDoG. Also works!
		//GetDogSep(gray, 1.0, gray, tao);
		//GetDoGLIC(gray, e, 1.0, 1.0, tao); // fingerprint
		//Binarize(gray, 0.5); // zucker
		//GrayThresholding(gray, 1.0); // zucker
		//GrayThresholding(gray, 0.9); // zucker
		//GrayThresholding(gray, 0.7); // zucker
		//GrayThresholding(gray, 0.2); // zucker
		Binarize(gray, 0.5); // zucker
		//GetLaplacian7(gray, 2.0, gray, 0.99, 0.7);
		//ErosionGray(dc, gray, 2);
		//DilationGray(dc, gray, 2);
		//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.7); // zucker
		//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.8); // zucker
		//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
		//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		/////////////////////////////////////////////////////////

		GetFBL(cmap, e, 2.0, 0.5, 30.0, 20.0, 2); // 
		ColorQuantization(cmap, 5); 
		
		ConstructMergedImageColor(cmap, gray, merged); // merge with the original image
		
		/////////////////////////////////////////////////////
		
		///////////////////////////////////////////
		//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
		DrawColorImage(memDC, IMAGE_X, IMAGE_Y, merged);

		dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		strcpy(s, "kang_");
		strcat(s, s1);
		strcat(s, ".bmp");
		SaveBMPfromMemDC(memDC, IMAGE_X, IMAGE_Y, s);
		TRACE("Frame %d completed!\n", i);
		//printf("Line drawing completed!\n");
		//TRACE("Elapsed Time = %f\n", ElapsedTime());
	}

	TRACE("\nVideo CLD completed!\n");
}

void CCubeView::OnEdgeVideotoon2()
// Gooch's video tooning
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	int image_x = IMAGE_X;
	int image_y = IMAGE_Y;

	ETF e;

	TRACE("VIDEO CLD \n");

	cimatrix merged;
	
	gray.init(image_x, image_y);
	//e.init(image_x, image_y);
	cmap.init(image_x, image_y);
	merged.init(image_x, image_y);
	
	char s[30], s2[2], s1[30]; // 01 - 99
	//char s[30], s2[3], s1[30]; // 001 - 999

	for (int i = 1; i <= 75; i++) {
		//strcpy(s, "org");
		strcpy(s, "test");
		sprintf(s2, "%.2d", i); // 01 - 99
		//sprintf(s2, "%.3d", i); // 001 - 999
		strcat(s, s2);
		strcpy(s1, s);
		strcat(s, ".bmp");
		if ( !LoadBMP3(dc, (char *)LPCTSTR(s), &memDC) ) 
			TRACE("%s does not exist!\n", s);

		//gray.init(image_x, image_y);
		//GetGrayImageFromMemDC(image_x, image_y, gray, memDC);
		
		//BilateralGraySep(gray, 2.0, 10.0, 1);
		//GetColorImageFromMemDC(IMAGE_X, IMAGE_Y, cmap, memDC);
		//BilateralColorSep(image_x, image_y, cmap, 2.0, 10.0, 1);
				
		//cmap.init(image_x, image_y);
		GetColorImageFromMemDC(image_x, image_y, cmap, memDC);
		//BilateralColorSep(image_x, image_y, cmap, 2.0, 20.0, 2);
		//BilateralColorSep(image_x, image_y, cmap, 1.0, 20.0, 1);
		CopyCol2GrayImage(image_x, image_y, cmap, gray); 

		//gray2.copy(gray);
		//GaussSmoothSep(gray, 0.7); // lena
		//GaussSmoothSep(gray, 2.0); // lena
		//////////////////////////////
		//DrawGrayImage(memDC, image_x, image_y, gray);
		//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
		//////////////////////////////////////////////////
		//GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); // used for ETF
		//e.init(image_x, image_y);
		//e.set(gray);
		//e.Smooth(4, 2);
		//e.orient180();
		//////////////////////////////////////////////////////
		//DrawETF_LIC(dc, e, 10);

		///////////////////////////////////////////////////////
		// Initial DoG or FDoG
		//double tao = 0.99;
		double tao = 0.99;
		//GetFDoG(gray, e, 1.0, 3.0, tao); // Initial FDoG. Also works!
		GetDogSep(gray, 1.0, gray, tao);
		//GetDoGLIC(gray, e, 1.0, 3.0, tao); // fingerprint
		//Binarize(gray, 0.5); // zucker
		//GrayThresholding(gray, 1.0); // zucker
		//GrayThresholding(gray, 0.9); // zucker
		//GrayThresholding(gray, 0.7); // zucker
		//GrayThresholding(gray, 0.2); // zucker
		Binarize(gray, 0.2); // zucker
		//GetLaplacian7(gray, 2.0, gray, 0.99, 0.7);
		//ErosionGray(dc, gray, 2);
		//DilationGray(dc, gray, 2);
		//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.7); // zucker
		//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.8); // zucker
		//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
		//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		/////////////////////////////////////////////////////////

		//GetFBL(cmap, e, 2.0, 0.5, 30.0, 20.0, 1); // 
		BilateralColorSep(image_x, image_y, cmap, 2.0, 20.0, 2);
		ColorQuantization(cmap, 5); 
		
		ConstructMergedImageColor(cmap, gray, merged); // merge with the original image
		
		/////////////////////////////////////////////////////
		
		///////////////////////////////////////////
		//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
		DrawColorImage(memDC, IMAGE_X, IMAGE_Y, merged);

		dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		strcpy(s, "gooch_");
		strcat(s, s1);
		strcat(s, ".bmp");
		SaveBMPfromMemDC(memDC, IMAGE_X, IMAGE_Y, s);
		TRACE("Frame %d completed!\n", i);
		//printf("Line drawing completed!\n");
		//TRACE("Elapsed Time = %f\n", ElapsedTime());
	}

	TRACE("\nVideo CLD completed!\n");
}

void CCubeView::OnEdgeFbl()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	//GetImage(IMAGE_X, IMAGE_Y, image, Dbuffer);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);

	//GetPSNR(dc, cmap, "tileable64_noise_bl_2.0_5.bmp", "tileable64_noise_fbl_2.0_2.0_20_5.bmp");
	//GetPSNR(dc, cmap, "tileable64_noise_bl_2.0_5.bmp", "tileable64_noise_sbl_2.0_5.bmp");
	//GetPSNR(dc, cmap, "tileable64_noise_sbl_2.0_5.bmp", "tileable64_noise.bmp");
	// For TVCG
	//GetPSNR(dc, cmap, "tileable64_noise2.bmp", "texture64_fbl_2.0_2.0_30_20_5.bmp");
	//GetPSNR(dc, cmap, "tileable64_noise2.bmp", "texture64_bl_2.0_20_5.bmp");
	//GetPSNR(dc, cmap, "tileable64_noise2.bmp", "texture64_sbl_2.0_20_5.bmp");
	//GetPSNR(dc, cmap, "tileable64_noise2.bmp", "texture64_sabl_2.0_2.0_30_20_5.bmp"); // psnr: 21.348507

	int image_x = gray.getRow();
	int image_y = gray.getCol();
	imatrix input(image_x, image_y);
	input.copy(gray);

	////////////////////////////////////////
	//GaussSmoothSep(input, 1.0); // works for 'X'
	
	//GaussSmoothSep(gray, 1.0);
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	////////////////////////////////////////////////
	ETF e;
	e.init(image_x, image_y);
	e.set(input);
	//e.set(gray2);
	//e.tensor(gray);
	//e.tensor(gray2);
	//e.Smooth(1, 2); // works for small-scale texture
	//e.Smooth(2, 2); // works for small-scale texture
	e.Smooth(4, 2);
	//e.Smooth(6, 3); // works for 'X'
	//e.Smooth(10, 5);
	//e.SmoothFull(5, 2);
	//e.SmoothFull(5, 3);
	//e.Smooth(10, 10);
	//e.orient180();
	//////////////////////////////////////////////////////
	//DrawETF_LIC(dc, e, 10);
	//DrawETFColor360(dc, e);
	//DrawETFColor180(dc, e);
	//DrawETFColorTensor(dc, e);
	
	//GetFBL(cmap, e, 1.0, 1.0, 20.0, 20.0, 5); // small-scale texture
	//GetFBL(cmap, e, 2.0, 2.0, 40.0, 40.0, 1); // 
	GetFBL(cmap, e, 2.0, 0.5, 40.0, 20.0, 5); // 
	//BilateralColorSep(image_x, image_y, cmap, 2.0, 20.0, 1);
	//BilateralColor(image_x, image_y, cmap, 1.0, 10, 5);
	//BilateralColorFull(cmap, 2.0, 25, 5);
	//BilateralColorFull(cmap, 2.0, 20, 3);
	
	//ColorQuantization(cmap, 4); 
	ColorQuantizationLAB(cmap, 4); 
	//ColorQuantization(cmap, 10); 
	//ColorQuantization(cmap, 12); 
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//////////////////////////////////////////////////////////////////
	CopyCmap2Membuffer(cmap, Dbuffer);
}


void CCubeView::OnEdgeFabstract()
{
	// TODO: Add your command handler code here
	CClientDC dc(this);
	GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
	GetColorImage(IMAGE_X, IMAGE_Y, cmap, Dbuffer);

	//cmap.init(image_x, image_y);
	//merged.init(image_x, image_y);
	//gray2.copy(gray);
	//GaussSmoothSep(gray, 1.0); // lena
	//GaussSmoothSep(gray, 2.0); // lena
	int image_x = gray.getRow();
	int image_y = gray.getCol();
	imatrix input(image_x, image_y);
	input.copy(gray);
	//////////////////////////////
	DrawGrayImage(memDC, image_x, image_y, gray);
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//InitGradField(IMAGE_X, IMAGE_Y, gfield, gray);
	//////////////////////////////////////////////////
	//GetSobelGradient2(IMAGE_X, IMAGE_Y, gray, gray2, G_mag); // used for ETF
	ETF e;
	e.init(image_x, image_y);
	e.set(gray);
	e.Smooth(4, 2);
	//e.tensor(gray);
	//e.SmoothTensor(gray, 5.0);
	//e.orient180();
	//e.Smooth3(4, 3);
	//e.Smooth3(10, 5);
	//////////////////////////////////////////////////////
	//DrawETF_LIC(dc, e, 10);
	//DrawETFColor360(dc, e);
	//DrawETFColor180(dc, e);
	//DrawETFColorTensor(dc, e);

	///////////////////////////////////////////////////////
	// Initial DoG or FDoG
	double tao = 0.98;
	//GetDogSep(gray, 1.0, gray, tao);
	GetDoGLIC(gray, e, 1.0, 2.0, tao); // fingerprint
	Binarize(gray, 0.2); // zucker
	//GrayThresholding(gray, 0.7); // zucker
	//GrayThresholding(gray, 0.5); // zucker
	//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.7); // zucker
	//Thresholding(IMAGE_X, IMAGE_Y, gray, 0.8); // zucker
	DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	/////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////
	///*
	tao = 0.99;
	//double tao = 0.995;
	for (int i = 0; i < 3; i++) {
		//ConstructMergedImage(input, gray, gray); // merge with the original image
		ConstructMergedImageMult(input, gray, gray); // merge with the original image
		//GaussSmooth5(gray, 0.5); // leesy
		GaussSmoothSep(gray, 0.5); // lena
		//GetFlowDOG4(gray, gfield, gray, G_mag, 0.9, 2.0, tao); // Initial FDoG. Also works!
		//GetFDoG(gray, e, 0.7, 2.0, tao); // Initial FDoG. Also works!
		//GetFDoG(gray, e, 0.9, 2.0, tao); // Initial FDoG. Also works!
		//GetFDoG(gray, e, 1.0, 0.5, tao); // Initial FDoG. Also works!
		GetFDoG(gray, e, 1.0, 3.0, tao); 
		//GetDoGLIC(gray, e, 1.0, 3.0, tao); // fingerprint
		//GetDoGLIC(gray, e, 1.0, 1.0, tao); // fingerprint
		Binarize(gray, 0.2); 
		//GrayThresholding(gray, 0.5); // zucker
		DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
		dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
		TRACE("FDOG iteration %d complete.\n", i+1);
	}
	//*/

	//GetFBL(cmap, e, 2.0, 2.0, 40.0, 40.0, 1); // 
	//GetFBL(cmap, e, 2.0, 0.5, 30.0, 20.0, 5); // 
	//GetFBL(cmap, e, 2.0, 0.5, 40.0, 20.0, 2); // 
	GetFBL(cmap, e, 2.0, 0.5, 40.0, 20.0, 5); // 
	//ColorQuantization(cmap, 4); 
	ColorQuantizationLAB(cmap, 4); 
	ConstructMergedImageColor(cmap, gray, cmap); // merge with the original image
	
	///////////////////////////////////////////
	//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray);
	DrawColorImage(memDC, IMAGE_X, IMAGE_Y, cmap);
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	//SaveBMPfromMemDC(memDC, IMAGE_X, IMAGE_Y, "_result.bmp");
	TRACE("Line drawing completed!\n");
	//printf("Line drawing completed!\n");
	//TRACE("Elapsed Time = %f\n", ElapsedTime());
}
