//#include <stdio.h>
//#include <stdlib.h>
#include "stdafx.h"
#include <cmath>
#include <deque>
#include <iomanip>
#include <fstream>
using namespace std;

#include "Cube.h"
#include "CubeDoc.h"
#include "CubeView.h"
#include "NameDialog.h"
#include "globals.h"
#include "Field.h"

#define TRUE_ 1
#define FALSE_ 0

#define SQRT2	1.414

#define EPS		0.0001
#define EPS2	0.000001

//#define MAX_ELEMENTS 10000 // for EL
#define MAX_ELEMENTS 500000 // for NPR

#define HEAP_FULL(n) (n == MAX_ELEMENTS-1)
#define HEAP_EMPTY(n) (!n)

#define RGB_GETRED(rgb)    ((rgb) & 0xff) 
#define RGB_GETGREEN(rgb)    (((rgb) >> 8) & 0xff) 
#define RGB_GETBLUE(rgb)    (((rgb) >> 16) & 0xff) 

#define ABS(x)	( ((x)>0) ? (x) : (-(x)) )
#define dist2(x1, y1, x2, y2) sqrt( (((double)x1)-((double)x2))*(((double)x1)-((double)x2)) + (((double)y1)-((double)y2))*(((double)y1)-((double)y2)) )

int GLOBAL_CANNY_DONE = 0; // when global canny is called, it is set to 1

inline double gauss(double x, double mean, double sigma)
{
	return ( exp( (-(x-mean)*(x-mean)) / (2*sigma*sigma) ) / sqrt(PI * 2.0 * sigma * sigma) );
	//sqrt(PI * 2.0 * sigma * sigma) is the sum of integral over all x
	//return ( exp( (-x*x) / (2*sigma*sigma) ) / (PI * 2.0 * sigma * sigma) );
}

inline double gauss2(double x, double mean, double sigma)
{
	
	return ( exp( (-(x-mean)*(x-mean)) / (2*sigma*sigma) ) );
	//sqrt(PI * 2.0 * sigma * sigma) is the sum of integral over all x
	//return ( exp( (-x*x) / (2*sigma*sigma) ) / (PI * 2.0 * sigma * sigma) );
}

inline double gauss1D_norm(double x, double mean, double sigma)
// function value is now between [0, 1]	
// incorrect version
{
	
	//return ( exp( (-(x-mean)*(x-mean)) / (2*sigma*sigma) ) );
	//sqrt(PI * 2.0 * sigma * sigma) is the sum of integral over all x
	return ( exp( (-x*x) / (2*sigma*sigma) ) / (PI * 2.0 * sigma * sigma) );
}

inline double gauss1D_norm2(double x, double mean, double sigma)
// function value is now between [0, 1]	
// correct version
{
	
	//return ( exp( (-(x-mean)*(x-mean)) / (2*sigma*sigma) ) );
	//sqrt(PI * 2.0 * sigma * sigma) is the sum of integral over all x
	return ( exp( (-x*x) / (2*sigma*sigma) ) / sqrt(PI * 2.0 * sigma * sigma) );
}

inline double gauss1D_bl(double x, double mean, double sigma)
// used in bilateral filter (no normalization)
{
	
	//return ( exp( (-(x-mean)*(x-mean)) / (2*sigma*sigma) ) );
	//sqrt(PI * 2.0 * sigma * sigma) is the sum of integral over all x
	return ( exp( (-x*x) / (2*sigma*sigma) ) );
}

//double gau[30];

double gau[GAU_MAX];
double gau2[30];
int gau_w = 10;
int gau_w2 = 10;
double max_grad2;
extern NameDialog* dlg;

int MakeGaussMask(double sigma, double* gau)
{
	int i;
	double sum = 0.0;

	gau[0] = gauss((double)0.0, 0.0, sigma);
	sum += gau[0];
	//TRACE("\n%.5f ", gau[0]);
	for (i=1; i < GAU_MAX; i++) {
		gau[i] = gauss((double)i, 0.0, sigma);
		sum += 2 * gau[i];
		//TRACE("%.5f ", gau[i]);
		if (gau[i] < 0.005) {
			gau_w = i+1;
			break;
		}
	}
	//TRACE("\nsum = %.5f ", sum);
	//TRACE("sigma = %f ", sigma);
	//TRACE("gau_w = %d\n", gau_w);
	return gau_w;
}

matrix GAU;
int GAU_W[255];

void MakeGaussMatrix(double factor, matrix& GAU)
// factor is used when converting the index to sigma
{
	int i, j;
	double sum = 0.0;
	double sigma;
	//double factor;
	double max_sigma;
	double threshold;

	//factor = 3.0;

	threshold = 0.001;
	max_sigma = exp(factor) - 0.5;

	///////////////////
	// determine the maximum column number required
	i = 0;
	while(1) {
		i++;
		if ( gauss((double)i, 0.0, max_sigma) < threshold )
			break;
	}
	GAU.init(256, i+1); // size of GAU matrix
	GAU.zero(); 
	TRACE("max_col = %d\n", GAU.getCol());

	for (i = 0; i < 256; i++) {
		sigma = exp(factor * (double)i / 255.0) - 0.5;
		TRACE("sigma[%d] = %f\n", i, sigma);
		//sigma = max_sigma * (double)i / 255.0;
		GAU[i][0] = gauss((double)0.0, 0.0, sigma);
		//TRACE("\n%.5f ", gau[0]);
		for (j = 1; j < GAU.getCol(); j++) {
			GAU[i][j] = gauss((double)j, 0.0, sigma);
			//TRACE("%.5f ", gau[i]);
			if (GAU[i][j] < threshold) {
				GAU_W[i] = j+1;
				break;
			}
		}
	}
	//TRACE("\nsum = %.5f ", sum);
	//TRACE("sigma = %f ", sigma);
	//TRACE("gau_w = %d\n", gau_w);
}

void MakeGaussVector(double sigma, vector& GAU)
// factor is used when converting the index to sigma
{
	int i, j;
	double sum = 0.0;
	//double sigma;
	//double factor;
	//double max_sigma;
	double threshold;

	//factor = 3.0;

	threshold = 0.001;

	///////////////////
	// determine the maximum number of vector elements required
	i = 0;
	while(1) {
		i++;
		if ( gauss((double)i, 0.0, sigma) < threshold )
			break;
	}
	GAU.init(i+1); // size of GAU vector
	GAU.zero(); 
	//TRACE("max_elm = %d\n", GAU.getMax());

	GAU[0] = gauss((double)0.0, 0.0, sigma);
	for (j = 1; j < GAU.getMax(); j++) {
		GAU[j] = gauss((double)j, 0.0, sigma);
	}
}

inline void MakeGaussVectorBL(double sigma, vector& GAU, int max_index)
// used for speeding up bilateral filtering
// use index (instead of threshold value) to cut
{
	int i;
	//double sum = 0.0;
	//double sigma;
	//double factor;
	//double max_sigma;
	//double threshold;

	//factor = 3.0;

	//threshold = 0.001;

	///////////////////
	// determine the maximum number of vector elements required
	i = 0;
	//while(1) {
	//	i++;
	//	if ( gauss((double)i, 0.0, sigma) < threshold )
	//		break;
	//}
	GAU.init(max_index); // size of GAU vector
	GAU.zero(); 
	//TRACE("max_elm = %d\n", GAU.getMax());

	GAU[0] = gauss1D_bl((double)0.0, 0.0, sigma);
	for (i = 1; i < GAU.getMax(); i++) {
		GAU[i] = gauss1D_bl((double)i, 0.0, sigma);
	}
}

//matrix tmp_x, tmp_y;
matrix tmp_x, tmp_y;
matrix G_x, G_y, G_mag;
//matrix thin_edge;
imatrix thin_edge;
matrix scale_map;

void GaussSmooth(int image_x, int image_y, imatrix& image, int gau_w)
{
	int	i, j, k, i1, i2, j1, j2;
	int MAX_GRADIENT = -1;

	imatrix tmp(IMAGE_X, IMAGE_Y);
	double	x, y;
	
	/// copy image to tmp
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			tmp[i][j] = image[i][j];
		}
	}
		
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			x = gau[0] * tmp[i][j];	
			y = gau[0] * tmp[i][j];
			//TRACE("x = %f, y = %f\n", x, y);
			for (k = 1; k < gau_w; k++) {
				i1 = (i+k)%image_x;
				i2 = (i-k+image_x)%image_x;
				x += gau[k] * tmp[i1][j] + gau[k] * tmp[i2][j];
				j1 = (j+k)%image_y;
				j2 = (j-k+image_y)%image_y;
				y += gau[k] * tmp[i][j1] + gau[k] * tmp[i][j2];
			}
			tmp_x[i][j] = x;
			tmp_y[i][j] = y;
			//TRACE("x = %f, y = %f\n", x, y);
			//if (x > 255) x = 255;
			//if (y > 255) y = 255;
			image[i][j] = (int)((x + y)/2);
			if (image[i][j] > 255) image[i][j] = 255;
			//image[i][j] = (int)y;
		}
	}

}

void GaussSmooth2(int image_x, int image_y, imatrix& image, int gau_w)
{
	int	i, j, k, i1, i2, j1, j2;
	int MAX_GRADIENT = -1;
	double g, max_g;

	imatrix tmp(IMAGE_X, IMAGE_Y);
	double	x, y;
	
	/// copy image to tmp
	tmp.copy(image);
		
	max_g = -1;
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			x = gau[0] * tmp[i][j];	
			y = gau[0] * tmp[i][j];
			//TRACE("x = %f, y = %f\n", x, y);
			for (k = 1; k < gau_w; k++) {
				//i1 = (i+k) % image_x;
				//i2 = (i-k+image_x) % image_x;
				i1 = ( i+k <= image_x-1 ) ? i+k : image_x-1;
				i2 = ( i-k >= 0) ? i-k : 0;
				x += gau[k] * tmp[i1][j] + gau[k] * tmp[i2][j];
				//j1 = (j+k)%image_y;
				//j2 = (j-k+image_y)%image_y;
				j1 = ( j+k <= image_y-1 ) ? j+k : image_y-1;
				j2 = ( j-k >= 0) ? j-k : 0;
				y += gau[k] * tmp[i][j1] + gau[k] * tmp[i][j2];
			}
			tmp_x[i][j] = x;
			tmp_y[i][j] = y;
			//TRACE("x = %f, y = %f\n", x, y);
			//if (x > 255) x = 255;
			//if (y > 255) y = 255;
			g = (x + y)/2;
			if (g > max_g) max_g = g;
			image[i][j] = (int)g;
			if (image[i][j] > 255) image[i][j] = 255;
			//image[i][j] = (int)y;
		}
	}

	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			image[i][j] = (int)(255 * (image[i][j] / max_g));
		}
	}
}


void GaussSmooth3(int image_x, int image_y, imatrix& image, int gau_w)
// circular kernel (equivalent to using 2D Gaussian mask)
{
	int	i, j, k;
	int MAX_GRADIENT = -1;
	double g, max_g, min_g;
	int count;
	int s, t;
	int x, y;
	int half = gau_w-1;
	double weight, w_sum;

	//int image_x = image.getRow();
	//int image_y = image.getCol();

	//vector GAU1;
	//MakeGaussVector(sigma, GAU1); 
	//int half = GAU1.getMax()-1;

	imatrix tmp(IMAGE_X, IMAGE_Y);
	
	/// copy image to tmp
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			tmp[i][j] = image[i][j];
		}
	}
		
	max_g = -1;
	min_g = 10000000;
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			count = 0;
			g = 0.0;
			weight = w_sum = 0.0;
			for (s = -half; s <= half; s++) {
				for (t = -half; t <= half; t++) {
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					if ( k > half ) continue; 
					//////////////////////////////////////////////////
					if (x > IMAGE_X-1) x = IMAGE_X-1;
					else if (x < 0) x = 0;
					if (y > IMAGE_Y-1) y = IMAGE_Y-1;
					else if (y < 0) y = 0;
					//count++;					
					weight = gau[k];
					g += weight * tmp[x][y];
					w_sum += weight;
					//TRACE("k = %d\n", k);
					//TRACE("gau[%d] = %f\n", k, gau[k]);
				}
			}
			//TRACE("g = %f\n", g);
			//g /= count;
			//g /= w_sum;
			//TRACE("x = %f, y = %f\n", x, y);
			//if (x > 255) x = 255;
			//if (y > 255) y = 255;
			if (g > max_g) max_g = g;
			if (g < min_g) min_g = g;
			//TRACE("max_g = %f\n", max_g);
			image[i][j] = round(g);
			//if (image[i][j] > 255) image[i][j] = 255;
			//image[i][j] = (int)y;
		}
	}
	
	TRACE("max_g = %f\n", max_g);
	TRACE("min_g = %f\n", min_g);
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			//image[i][j] = (int)(255 * (image[i][j] / max_g));
			image[i][j] = (int)(255 * ((image[i][j]-min_g) / (max_g-min_g)));
			////////////////////////////////////////////////////////////////////
			// level adjustment
			image[i][j] = (int)(255 * pow((double)(image[i][j]/255.0), 5.0));
			//TRACE("image[%d][%d] = %d\n", i, j, image[i][j]);
			//if (image[i][j] > 0) image[i][j] = 255;
			///////////////////////////////////////////////////////////
		}
	}
}

void GaussSmooth5(imatrix& image, double sigma)
// circular kernel (equivalent to using 2D Gaussian mask)
// with normalization!
{
	int	i, j, k;
	int MAX_GRADIENT = -1;
	double g, max_g, min_g;
	int s, t;
	int x, y;
	//int half = gau_w-1;
	double weight, w_sum;

	int image_x = image.getRow();
	int image_y = image.getCol();

	vector GAU1;
	MakeGaussVector(sigma, GAU1); 
	int half = GAU1.getMax()-1;

	imatrix tmp(IMAGE_X, IMAGE_Y);
	
	/// copy image to tmp
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			tmp[i][j] = image[i][j];
		}
	}
		
	max_g = -1;
	min_g = 10000000;
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			//count = 0;
			g = 0.0;
			weight = w_sum = 0.0;
			for (s = -half; s <= half; s++) {
				for (t = -half; t <= half; t++) {
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					if ( k > half ) continue; 
					//////////////////////////////////////////////////
					if (x > IMAGE_X-1) x = IMAGE_X-1;
					else if (x < 0) x = 0;
					if (y > IMAGE_Y-1) y = IMAGE_Y-1;
					else if (y < 0) y = 0;
					//count++;					
					weight = GAU1[k];
					g += weight * tmp[x][y];
					w_sum += weight;
					//TRACE("k = %d\n", k);
					//TRACE("gau[%d] = %f\n", k, gau[k]);
				}
			}
			
			//g /= count;
			g /= w_sum;
			//TRACE("g = %f\n", g);
			//TRACE("x = %f, y = %f\n", x, y);
			//if (x > 255) x = 255;
			//if (y > 255) y = 255;
			if (g > max_g) max_g = g;
			if (g < min_g) min_g = g;
			//TRACE("max_g = %f\n", max_g);
			image[i][j] = round(g);
			//if (image[i][j] > 255) image[i][j] = 255;
			//image[i][j] = (int)y;
		}
	}
	
	TRACE("max_g = %f\n", max_g);
	TRACE("min_g = %f\n", min_g);
	/*
	////////////////////////////////////////////////////////
	// contrast-enhancing blurre intensity! (good for dashed circle!!!)
	// This was also used for creating importance map! (we blurred Canny edge map in this way!)
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			//image[i][j] = (int)(255 * (image[i][j] / max_g));
			image[i][j] = (int)(255 * ((image[i][j]-min_g) / (max_g-min_g)));
			////////////////////////////////////////////////////////////////////
			// level adjustment
			image[i][j] = (int)(255 * pow((double)(image[i][j]/255.0), 5.0));
			//TRACE("image[%d][%d] = %d\n", i, j, image[i][j]);
			//if (image[i][j] > 0) image[i][j] = 255;
			///////////////////////////////////////////////////////////
		}
	}
	*/
}



void GaussColorSmooth5(cimatrix& image, double sigma)
// circular kernel (equivalent to using 2D Gaussian mask)
// with normalization!
{
	int	i, j, k;
	int MAX_GRADIENT = -1;
	double r, g, b, max_g, min_g;
	int s, t;
	int x, y;
	//int half = gau_w-1;
	double weight, w_sum;

	int image_x = image.getRow();
	int image_y = image.getCol();

	vector GAU1;
	MakeGaussVector(sigma, GAU1); 
	int half = GAU1.getMax()-1;

	cimatrix tmp(IMAGE_X, IMAGE_Y);
	
	/// copy image to tmp
	tmp.copy(image);
	/*
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			tmp[i][j] = image[i][j];
		}
	}
	*/
		
	max_g = -1;
	min_g = 10000000;
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			//count = 0;
			r = g = b = 0.0;
			weight = w_sum = 0.0;
			for (s = -half; s <= half; s++) {
				for (t = -half; t <= half; t++) {
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					if ( k > half ) continue; 
					//////////////////////////////////////////////////
					if (x > IMAGE_X-1) x = IMAGE_X-1;
					else if (x < 0) x = 0;
					if (y > IMAGE_Y-1) y = IMAGE_Y-1;
					else if (y < 0) y = 0;
					//count++;					
					weight = GAU1[k];
					r += weight * tmp[x][y].r;
					g += weight * tmp[x][y].g;
					b += weight * tmp[x][y].b;
					w_sum += weight;
					//TRACE("k = %d\n", k);
					//TRACE("gau[%d] = %f\n", k, gau[k]);
				}
			}
			
			//g /= count;
			r /= w_sum;
			g /= w_sum;
			b /= w_sum;
			//TRACE("g = %f\n", g);
			//TRACE("x = %f, y = %f\n", x, y);
			//if (x > 255) x = 255;
			//if (y > 255) y = 255;
			//if (g > max_g) max_g = g;
			//if (g < min_g) min_g = g;
			//TRACE("max_g = %f\n", max_g);
			image[i][j].r = round(r);
			image[i][j].g = round(g);
			image[i][j].b = round(b);
			//if (image[i][j] > 255) image[i][j] = 255;
			//image[i][j] = (int)y;
		}
	}
	
	//TRACE("max_g = %f\n", max_g);
	//TRACE("min_g = %f\n", min_g);
	/*
	////////////////////////////////////////////////////////
	// contrast-enhancing blurre intensity! (good for dashed circle!!!)
	// This was also used for creating importance map! (we blurred Canny edge map in this way!)
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			//image[i][j] = (int)(255 * (image[i][j] / max_g));
			image[i][j] = (int)(255 * ((image[i][j]-min_g) / (max_g-min_g)));
			////////////////////////////////////////////////////////////////////
			// level adjustment
			image[i][j] = (int)(255 * pow((double)(image[i][j]/255.0), 5.0));
			//TRACE("image[%d][%d] = %d\n", i, j, image[i][j]);
			//if (image[i][j] > 0) image[i][j] = 255;
			///////////////////////////////////////////////////////////
		}
	}
	*/
}


void GaussSmooth6(imatrix& image, double sigma)
// circular kernel (equivalent to using 2D Gaussian mask)
// with normalization & CONTRAST STRETCHING!
{
	int	i, j, k;
	int MAX_GRADIENT = -1;
	double g, max_g, min_g;
	int s, t;
	int x, y;
	//int half = gau_w-1;
	double weight, w_sum;

	int image_x = image.getRow();
	int image_y = image.getCol();

	vector GAU1;
	MakeGaussVector(sigma, GAU1); 
	int half = GAU1.getMax()-1;

	imatrix tmp(IMAGE_X, IMAGE_Y);
	
	/// copy image to tmp
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			tmp[i][j] = image[i][j];
		}
	}
		
	max_g = -1;
	min_g = 10000000;
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			//count = 0;
			g = 0.0;
			weight = w_sum = 0.0;
			for (s = -half; s <= half; s++) {
				for (t = -half; t <= half; t++) {
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					if ( k > half ) continue; 
					//////////////////////////////////////////////////
					if (x > IMAGE_X-1) x = IMAGE_X-1;
					else if (x < 0) x = 0;
					if (y > IMAGE_Y-1) y = IMAGE_Y-1;
					else if (y < 0) y = 0;
					//count++;					
					weight = GAU1[k];
					g += weight * tmp[x][y];
					w_sum += weight;
					//TRACE("k = %d\n", k);
					//TRACE("gau[%d] = %f\n", k, gau[k]);
				}
			}
			
			//g /= count;
			g /= w_sum;
			//TRACE("g = %f\n", g);
			//TRACE("x = %f, y = %f\n", x, y);
			//if (x > 255) x = 255;
			//if (y > 255) y = 255;
			if (g > max_g) max_g = g;
			if (g < min_g) min_g = g;
			//TRACE("max_g = %f\n", max_g);
			image[i][j] = round(g);
			//if (image[i][j] > 255) image[i][j] = 255;
			//image[i][j] = (int)y;
		}
	}
	
	TRACE("max_g = %f\n", max_g);
	TRACE("min_g = %f\n", min_g);
	////////////////////////////////////////////////////////
	// contrast-enhancing blurre intensity! (good for dashed circle!!!)
	// This was also used for creating importance map! (we blurred Canny edge map in this way!)
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			//image[i][j] = (int)(255 * (image[i][j] / max_g));
			image[i][j] = (int)(255 * ((image[i][j]-min_g) / (max_g-min_g)));
			////////////////////////////////////////////////////////////////////
			// level adjustment
			image[i][j] = (int)(255 * pow((double)(image[i][j]/255.0), 5.0));
			//TRACE("image[%d][%d] = %d\n", i, j, image[i][j]);
			//if (image[i][j] > 0) image[i][j] = 255;
			///////////////////////////////////////////////////////////
		}
	}
}

void GaussSmooth4(CDC& dc, int image_x, int image_y, double sigma)
// circular kernel (equivalent to using 2D Gaussian mask)
// get it from Dbuffer
{
	int	i, j, k;
	int MAX_GRADIENT = -1;
	double g, max_g, min_g, w_sum;
	int count;
	int s, t;
	int x, y;

	imatrix tmp(image_x, image_y);
	//imatrix image(image_x, image_y);

	int gau_w = MakeGaussMask(sigma, gau);
	int half = gau_w-1;

	GLubyte r;
	
	/// copy image to tmp
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			//tmp[i][j] = image[i][j];
			tmp[i][j] = RGB_GETRED(dc.GetPixel(i, image_y-1-j));
		}
	}
		
	max_g = -1;
	min_g = 10000000;
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			count = 0;
			g = 0.0;
			w_sum = 0.0;
			for (s = -half; s <= half; s++) {
				for (t = -half; t <= half; t++) {
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					if ( k > half ) continue; 
					//////////////////////////////////////////////////
					if (x > IMAGE_X-1) x = IMAGE_X-1;
					else if (x < 0) x = 0;
					if (y > IMAGE_Y-1) y = IMAGE_Y-1;
					else if (y < 0) y = 0;
					//count++;					
					g += gau[k] * tmp[x][y];
					w_sum += gau[k];
					//TRACE("k = %d\n", k);
					//TRACE("gau[%d] = %f\n", k, gau[k]);
				}
			}
			//TRACE("g = %f\n", g);
			g /= w_sum; // weight normalize
			//TRACE("x = %f, y = %f\n", x, y);
			//if (x > 255) x = 255;
			//if (y > 255) y = 255;
			if (g > max_g) max_g = g;
			if (g < min_g) min_g = g;
			//TRACE("max_g = %f\n", max_g);
			//image[i][j] = (int)g;
			r = (GLubyte)g;
			dc.SetPixelV(x, IMAGE_Y-1-y, RGB(r, r, r));
			//if (image[i][j] > 255) image[i][j] = 255;
			//image[i][j] = (int)y;
		}
	}
	
	TRACE("max_g = %f\n", max_g);
	TRACE("min_g = %f\n", min_g);

	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			//image[i][j] = (int)(255 * (image[i][j] / max_g));
			//image[i][j] = (int)(255 * ((image[i][j]-min_g) / (max_g-min_g)));
			////////////////////////////////////////////////////////////////////
			// Level adjustment
			//image[i][j] = (int)(255 * pow((double)(image[i][j]/255.0), 5.0));
			//TRACE("image[%d][%d] = %d\n", i, j, image[i][j]);
			//if (image[i][j] > 0) image[i][j] = 255;
			///////////////////////////////////////////////////////////
		}
	}
}

void FindNearestPoint(imatrix& image, int i, int j, int &x, int &y)
{
	int dir_x[4] = {1, 0, -1, 0};
	int dir_y[4] = {0, 1, 0, -1};
	int cur_x, cur_y;
	int max_step, k;
	int cur_dir_idx;
	double dist, min_dist;
	int min_x, min_y;
	int flag, flag2;

	cur_x = i;
	cur_y = j;
	max_step = 1;
	cur_dir_idx = 0;
	flag = 0;
	flag2 = 0;
	min_dist = 1000000000000000;
	if (image[cur_x][cur_y] == 0) {
		x = cur_x;
		y = cur_y;
		return;
	}
	while(1) {
		for (k = 0; k < max_step; k++) {
			cur_x += dir_x[cur_dir_idx];
			cur_y += dir_y[cur_dir_idx];
			if (cur_x < 0 || cur_x > IMAGE_X-1 || cur_y < 0 || cur_y > IMAGE_Y-1)
				continue;
			if (image[cur_x][cur_y] == 0) {
				flag = 1;
				dist = dist2(i, j, cur_x, cur_y);
				//TRACE("dist = %f\n", dist);
				if ( dist < min_dist ) {
					min_dist = dist;
					min_x = cur_x;
					min_y = cur_y;
				}
			}
		}
		cur_dir_idx = (cur_dir_idx + 1) % 4;
		for (k = 0; k < max_step; k++) {
			cur_x += dir_x[cur_dir_idx];
			cur_y += dir_y[cur_dir_idx];
			if (cur_x < 0 || cur_x > IMAGE_X-1 || cur_y < 0 || cur_y > IMAGE_Y-1)
				continue;
			if (image[cur_x][cur_y] == 0) {
				flag = 1;
				dist = dist2(i, j, cur_x, cur_y);
				if ( dist < min_dist ) {
					min_dist = dist;
					min_x = cur_x;
					min_y = cur_y;
				}
			}
		}
		cur_dir_idx = (cur_dir_idx + 1) % 4;
		if (flag == 1 && flag2 == 0)
			flag2 = 1; // go one more round
		else if (flag == 1 && flag2 == 1) {
			x = min_x;
			y = min_y;
			return;
		}
		max_step++;
	}
}

void FindNearestPoint2(imatrix& image, int i, int j, int &x, int &y)
// Around curved edges, you have to go some more steps to make sure there're no closer points
{
	int dir_x[4] = {1, 0, -1, 0};
	int dir_y[4] = {0, 1, 0, -1};
	int cur_x, cur_y;
	int max_step, k;
	int cur_dir_idx;
	double dist, min_dist, first_dist;
	int min_x, min_y;
	int target_count, count;
	double target_dist;

	cur_x = i;
	cur_y = j;
	max_step = 1;
	cur_dir_idx = 0;
	count = -1;
	min_dist = 1000000000000000;
	first_dist = -1;
	if (image[cur_x][cur_y] == 0) {
		x = cur_x;
		y = cur_y;
		return;
	}
	while(1) {
		for (k = 0; k < max_step; k++) {
			cur_x += dir_x[cur_dir_idx];
			cur_y += dir_y[cur_dir_idx];
			if (cur_x < 0 || cur_x > IMAGE_X-1 || cur_y < 0 || cur_y > IMAGE_Y-1)
				continue;
			if (image[cur_x][cur_y] == 0) {
				dist = dist2(i, j, cur_x, cur_y);
				//TRACE("dist = %f\n", dist);
				if (count < 0) { // this is the first point found
					count = 0;
					target_dist = dist - dist/1.414; 
					target_count = round(2 * (target_dist+1.0) ); // steps to go more
				}
				if ( dist < min_dist ) {
					min_dist = dist;
					min_x = cur_x;
					min_y = cur_y;
				}
			}
		}
		cur_dir_idx = (cur_dir_idx + 1) % 4;
		for (k = 0; k < max_step; k++) {
			cur_x += dir_x[cur_dir_idx];
			cur_y += dir_y[cur_dir_idx];
			if (cur_x < 0 || cur_x > IMAGE_X-1 || cur_y < 0 || cur_y > IMAGE_Y-1)
				continue;
			if (image[cur_x][cur_y] == 0) {
				dist = dist2(i, j, cur_x, cur_y);
				if (count < 0) { // this is the first point found
					count = 0;
					target_dist = dist - dist/1.414; 
					target_count = round(2 * (target_dist+1.0) ); // steps to go more
				}
				if (first_dist < 0)
					first_dist = dist; // this is the first point found
				if ( dist < min_dist ) {
					min_dist = dist;
					min_x = cur_x;
					min_y = cur_y;
				}
			}
		}
		cur_dir_idx = (cur_dir_idx + 1) % 4;
		////////////////////////////////////////
		if (count > target_count) {
			x = min_x;
			y = min_y;
			return;
		}
		///////////////////////////////////////
		if (count >= 0) count++;
		max_step++;
	}
}


void DistanceField(int image_x, int image_y, imatrix& image, double factor)
{
	int	i, j;
	int MAX_GRADIENT = -1;
	double g, max_g, min_g;
	int count;
	int x, y;
	int half = gau_w-1;
	double dist;


	imatrix tmp(IMAGE_X, IMAGE_Y);
	matrix tmp_dist(IMAGE_X, IMAGE_Y);
	
	/// copy image to tmp
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			tmp[i][j] = image[i][j];
		}
	}
		
	max_g = -1;
	min_g = 10000000;
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			count = 0;
			g = 0.0;
			FindNearestPoint2(tmp, i, j, x, y);

			dist = dist2(x, y, i, j);
			if (dist > max_g) max_g = dist;
			if (dist < min_g) min_g = dist;
					
			//image[i][j] = (int)dist;
			tmp_dist[i][j] = dist;
			//if (image[i][j] > 255) image[i][j] = 255;
			//image[i][j] = (int)y;
		}
	}
	
	TRACE("max_g = %f\n", max_g);
	TRACE("min_g = %f\n", min_g);
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			//image[i][j] = (int)(255 * (image[i][j] / max_g));
			//////////////////////////////////////////////////
			tmp_dist[i][j] = 255.0 * ((tmp_dist[i][j]-min_g) / (max_g-min_g));
			//tmp_dist[i][j] += 255.0 * ( sin( PI / 2.0 * (tmp_dist[i][j]-min_g) / (max_g-min_g) ) );
			//if (tmp_dist[i][j] > 255) tmp_dist[i][j] = 255;
			//tmp_dist[i][j] = 55 + 200.0 * ((tmp_dist[i][j]-min_g) / (max_g-min_g));
			////////////////////////////////////////////////////////////////////
			// level adjustment
			image[i][j] = (int)(255.0 * (1.0-pow((double)(1.0-tmp_dist[i][j]/255.0), factor)) );
			//image[i][j] = 255.0 * sin( PI / 2.0 * image[i][j] / 255.0 );
			//if (image[i][j] > 255) image[i][j] = 255;
            //image[i][j] = (int)(255.0 * (1.0-pow((double)(1.0-tmp_dist[i][j]/255.0), factor)) );
			//image[i][j] = (int)(255 * (pow((double)2, (double)image[i][j]/255.0)-1));
			//image[i][j] = (int)(255 * pow((double)(image[i][j]/255.0), 5.0));
			//TRACE("image[%d][%d] = %d\n", i, j, image[i][j]);
			//if (image[i][j] > 0) image[i][j] = 255;
			///////////////////////////////////////////////////////////
		}
	}
}

inline double gauss2D(double x, double y, double mean, double sigma)
// function value is now between [0, 1] 
{
	double g;
	g = exp( -( (x-mean)*(x-mean) + (y-mean)*(y-mean) ) / (2*sigma*sigma) );
	g /= (2 * PI * sigma * sigma); 
	return g;
	//sqrt(PI * 2.0 * sigma * sigma) is the sum of integral over all x
	//return ( exp( (-x*x) / (2*sigma*sigma) ) / (PI * 2.0 * sigma * sigma) );
}

matrix gau_mask;

void Make2DGaussMask(double sigma)
// 2D Gauss mask
{
	int i, j;
	double sum = 0.0;
	int N;
	int half;
	double x, y;
	int size;
	double threshold = 0.0001;

	matrix tmp;

	i = 0;
	while (1) { // compute N (Gaussian mask size)
		//TRACE("[%d] Gauss value = %f\n", i, gauss2D((double)i, 0.0, 0.0, sigma));
		if (gauss2D((double)i, 0.0, 0.0, sigma) < threshold)
			break;
		i++;
	}

	N = i * 2 + 5;
	//TRACE("N = %d\n", N);
	//N = 31;
	half = N / 2;

	tmp.init(N, N);
	tmp.zero();
	
	//gau[0] = gauss((double)0.0, 0.0, sigma);
	//sum += gau[0];
	//TRACE("\n%.5f ", gau[0]);
	for (j = 0; j < N; j++) {
		for (i = 0; i < N; i++) {
			x = i - half; 
			y = j - half; 
			tmp[i][j] = gauss2D(x, y, 0.0, sigma);
			//sum += 2 * gau[i];
			//TRACE("%.5f ", gau[i]);
		}
	}
	for (i = half; i < N; i++) {
		if (tmp[i][half] < threshold) {
			size = 2 * (i - half) + 1;
			break;
		}
	}
	gau_mask.init(size, size);
	gau_mask.zero();

	for (j = 0; j < size; j++) {
		for (i = 0; i < size; i++) {
			gau_mask[i][j] = tmp[half-size/2+i][half-size/2+j];
		}
	}

	TRACE("%dx%d GAUSSIAN MASK\n", size, size);
	
	//TRACE("\nsum = %.5f ", sum);
	//TRACE("sigma = %f ", sigma);
	//TRACE("gau_w = %d\n", gau_w);
}

void GaussBlur(imatrix& image, double sigma)
// using 2D Gaussian mask
{
	int	i, j;
	int MAX_GRADIENT = -1;
	double g, max_g, min_g, w_sum;
	int count;
	int s, t;
	int x, y;
	int half;
	int N;

	int image_x = image.getRow();
	int image_y = image.getCol();

	Make2DGaussMask(sigma);

	N = gau_mask.getRow();
	half = N / 2;

	imatrix tmp(IMAGE_X, IMAGE_Y);
	matrix tmp2(IMAGE_X, IMAGE_Y);
	tmp2.zero();
	
	/// copy image to tmp
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			tmp[i][j] = image[i][j];
		}
	}
		
	max_g = -1;
	min_g = 10000000;
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			count = 0;
			g = 0.0;
			for (s = -half; s <= half; s++) {
				for (t = -half; t <= half; t++) {
					x = i+s; y = j+t;
                    if (x > IMAGE_X-1) x = IMAGE_X-1;
					else if (x < 0) x = 0;
					if (y > IMAGE_Y-1) y = IMAGE_Y-1;
					else if (y < 0) y = 0;
					//count++;					
					g += gau_mask[s+half][t+half] * tmp[x][y];
					//TRACE("k = %d\n", k);
					//TRACE("gau[%d] = %f\n", k, gau[k]);
				}
			}
			//TRACE("g = %f\n", g);
			//g /= count;
			//TRACE("x = %f, y = %f\n", x, y);
			//if (x > 255) x = 255;
			//if (y > 255) y = 255;
			if (g > max_g) max_g = g;
			if (g < min_g) min_g = g;
			//TRACE("max_g = %f\n", max_g);
			tmp2[i][j] = g;
			//if (image[i][j] > 255) image[i][j] = 255;
			//image[i][j] = (int)y;
		}
	}
	
	TRACE("max_g = %f\n", max_g);
	TRACE("min_g = %f\n", min_g);

	////////////////////////////////////
	// Normalization
	w_sum = 0.0;
	for (j = 0; j < N; j++) {
		for (i = 0; i < N; i++) {
			w_sum += gau_mask[i][j];
		}
	}
	//TRACE("N = %d\n", N);
	TRACE("w_sum = %f\n", w_sum);
	//gau_mask.print();

	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			tmp2[i][j] /= w_sum;
			//image[i][j] = (int)(255 * (image[i][j] / max_g));
			image[i][j] = (int)tmp2[i][j];
		}
	}
	////////////////////////////////////////////
}

void GaussBlurMemDC(CDC& dc, int image_x, int image_y, double sigma)
{
	int	i, j;
	int MAX_GRADIENT = -1;
	double g, max_g, min_g, w_sum;
	int count;
	int s, t;
	int x, y;

	Make2DGaussMask(sigma);

	int half = gau_mask.getRow() / 2;

	imatrix tmp(image_x, image_y);
	//imatrix image(image_x, image_y);

	//int gau_w = MakeGaussMask(sigma, gau);
	//int half = gau_w-1;

	GLubyte r;
	
	/// copy image to tmp
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			//tmp[i][j] = image[i][j];
			tmp[i][j] = RGB_GETRED(dc.GetPixel(i, image_y-1-j));
		}
	}
		
	max_g = -1;
	min_g = 10000000;
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			count = 0;
			g = 0.0;
			w_sum = 0.0;
			for (s = -half; s <= half; s++) {
				for (t = -half; t <= half; t++) {
					x = i+s; y = j+t;
                    if (x > image_x-1) x = image_x-1;
					else if (x < 0) x = 0;
					if (y > image_y-1) y = image_y-1;
					else if (y < 0) y = 0;
					//count++;					
					g += gau_mask[s+half][t+half] * tmp[x][y];
					//count++;					
					//g += gau[k] * tmp[x][y];
					w_sum += gau_mask[s+half][t+half];
					//TRACE("k = %d\n", k);
					//TRACE("gau[%d] = %f\n", k, gau[k]);
				}
			}
			//TRACE("g = %f\n", g);
			g /= w_sum; // weight normalize
			//TRACE("x = %f, y = %f\n", x, y);
			//if (x > 255) x = 255;
			//if (y > 255) y = 255;
			if (g > max_g) max_g = g;
			if (g < min_g) min_g = g;
			//TRACE("max_g = %f\n", max_g);
			//image[i][j] = (int)g;
			r = (GLubyte)g;
			dc.SetPixelV(x, IMAGE_Y-1-y, RGB(r, r, r));
			//if (image[i][j] > 255) image[i][j] = 255;
			//image[i][j] = (int)y;
		}
	}
	
	TRACE("max_g = %f\n", max_g);
	TRACE("min_g = %f\n", min_g);

	/*
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			//image[i][j] = (int)(255 * (image[i][j] / max_g));
			//image[i][j] = (int)(255 * ((image[i][j]-min_g) / (max_g-min_g)));
			////////////////////////////////////////////////////////////////////
			// Level adjustment
			//image[i][j] = (int)(255 * pow((double)(image[i][j]/255.0), 5.0));
			//TRACE("image[%d][%d] = %d\n", i, j, image[i][j]);
			//if (image[i][j] > 0) image[i][j] = 255;
			///////////////////////////////////////////////////////////
		}
	}
	*/
}

void GaussBlurBilateral(int image_x, int image_y, imatrix& image, double sigma, double sigma2, int max_itr)
// using 2D Gaussian mask
{
	int	i, j, u, v;
	int MAX_GRADIENT = -1;
	double g, max_g, min_g, w_sum;
	int s, t, k;
	int x, y;
	int half;
	int N;
	double w_sim;

	Make2DGaussMask(sigma);

	N = gau_mask.getRow();
	half = N / 2;

	matrix tmp_mask(N, N);
	tmp_mask.zero();

	imatrix tmp(IMAGE_X, IMAGE_Y);
	tmp.copy(image);

	matrix tmp2(IMAGE_X, IMAGE_Y);
	tmp2.zero();
	
	max_g = -1;
	min_g = 10000000;
	for (k = 0; k < max_itr; k++) {
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				g = 0.0;
				for (s = 0; s < N; s++) {
					for (t = 0; t < N; t++) {
						x = i-half+s; y = j-half+t;
						if (x > IMAGE_X-1) x = IMAGE_X-1;
						else if (x < 0) x = 0;
						if (y > IMAGE_Y-1) y = IMAGE_Y-1;
						else if (y < 0) y = 0;
						//w_sim = gauss2((double)tmp[i][j] - tmp[x][y], 0.0, sigma2);
						w_sim = gauss1D_norm((double)(tmp[i][j] - tmp[x][y])/255.0, 0.0, sigma2);
						//count++;					
						tmp_mask[s][t] = w_sim * gau_mask[s][t];
						g += tmp_mask[s][t] * tmp[x][y];
						//TRACE("k = %d\n", k);
						//TRACE("gau[%d] = %f\n", k, gau[k]);
					}
				}
				//TRACE("i = %d, j = %d\n", i, j);
				//TRACE("g = %f\n", g);
				tmp2[i][j] = g;
				////////////////////////////////////
				// Normalization
				w_sum = 0.0;
				for (v = 0; v < N; v++) {
					for (u = 0; u < N; u++) {
						w_sum += tmp_mask[u][v];
					}
				}
				tmp2[i][j] /= w_sum;
				image[i][j] = round(tmp2[i][j]);
				/////////////////////////////////////
				//TRACE("N = %d\n", N);
				//TRACE("w_sum = %f\n", w_sum);
				//gau_mask.print();
				//if (image[i][j] > 255) image[i][j] = 255;
				//image[i][j] = (int)y;
			}
		}
		tmp.copy(image);
	}
	//TRACE("max_g = %f\n", max_g);
	//TRACE("min_g = %f\n", min_g);
}

#define dist3(x, y, z) sqrt(((double)x)*((double)x) + ((double)y)*((double)y) + ((double)z)*((double)z))

void BilateralColor(int image_x, int image_y, cimatrix& image, double sigma, double sigma2, int max_itr)
{
	int	i, j;
	int MAX_GRADIENT = -1;
	double max_g, min_g;
	int s, t, k;
	int x, y;
	int half;
	int N;
	double weight;
	double val_r, val_g, val_b;
	double c_val_r, c_val_g, c_val_b;
	double w_sum, sum_r, sum_g, sum_b;
	double c_dist;

	Make2DGaussMask(sigma);

	N = gau_mask.getRow();
	half = N / 2;

	cimatrix tmp(IMAGE_X, IMAGE_Y);
	tmp.copy(image);
	
	max_g = -1;
	min_g = 10000000;
	for (k = 0; k < max_itr; k++) {
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				sum_r = sum_g = sum_b = 0.0;
				weight = w_sum = 0.0;
				c_val_r = tmp[i][j].r;
				c_val_g = tmp[i][j].g;
				c_val_b = tmp[i][j].b;
				//c_val = (c_val_r + c_val_g + c_val_b) / 3.0;
				for (s = 0; s < N; s++) {
					for (t = 0; t < N; t++) {
						x = i-half+s; y = j-half+t;
						if (x > IMAGE_X-1) x = IMAGE_X-1;
						else if (x < 0) x = 0;
						if (y > IMAGE_Y-1) y = IMAGE_Y-1;
						else if (y < 0) y = 0;
						//w_sim = gauss2((double)tmp[i][j] - tmp[x][y], 0.0, sigma2);
						val_r = tmp[x][y].r;
						val_g = tmp[x][y].g;
						val_b = tmp[x][y].b;
						//val = (val_r + val_g + val_b) / 3.0;
						//weight = gauss1D_norm((c_val - val)/255.0, 0.0, sigma2);
						c_dist = dist3(c_val_r-val_r, c_val_g-val_g, c_val_b-val_b);
						//weight = gauss1D_norm( c_dist/255.0, 0.0, sigma2);
						weight = gauss1D_norm( c_dist/255.0/1.732, 0.0, sigma2);
						//count++;					
						weight *= gau_mask[s][t];
						sum_r += weight * val_r;
						sum_g += weight * val_g;
						sum_b += weight * val_b;
						//TRACE("k = %d\n", k);
						//TRACE("gau[%d] = %f\n", k, gau[k]);
						w_sum += weight;
					}
				}
				//TRACE("i = %d, j = %d\n", i, j);
				//TRACE("g = %f\n", g);
				//tmp2 = g;
				////////////////////////////////////
				// Normalization
				sum_r /= w_sum;
				sum_g /= w_sum;
				sum_b /= w_sum;
				//image[i][j] = round(tmp2);
				image[i][j].r = round(sum_r);
				image[i][j].g = round(sum_g);
				image[i][j].b = round(sum_b);
				/////////////////////////////////////
				//TRACE("N = %d\n", N);
				//TRACE("w_sum = %f\n", w_sum);
				//gau_mask.print();
				//if (image[i][j] > 255) image[i][j] = 255;
				//image[i][j] = (int)y;
			}
		}
		tmp.copy(image);
	}
	//TRACE("max_g = %f\n", max_g);
	//TRACE("min_g = %f\n", min_g);
}

void BilateralColorTomasi(int image_x, int image_y, cimatrix& image, double sigma, double sigma2, int max_itr)
{
	int	i, j;
	int MAX_GRADIENT = -1;
	double max_g, min_g;
	int s, t, k;
	int x, y;
	int half;
	int N;
	double weight;
	double val_r, val_g, val_b;
	double c_val_r, c_val_g, c_val_b;
	double w_sum, sum_r, sum_g, sum_b;
	double c_dist;

	Make2DGaussMask(sigma);

	N = gau_mask.getRow();
	half = N / 2;

	vector GAU2;

	MakeGaussVectorBL(sigma2, GAU2, 300); // 300 array elements created

	cimatrix tmp(IMAGE_X, IMAGE_Y);
	tmp.copy(image);
	
	max_g = -1;
	min_g = 10000000;
	for (k = 0; k < max_itr; k++) {
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				sum_r = sum_g = sum_b = 0.0;
				weight = w_sum = 0.0;
				c_val_r = tmp[i][j].r;
				c_val_g = tmp[i][j].g;
				c_val_b = tmp[i][j].b;
				//c_val = (c_val_r + c_val_g + c_val_b) / 3.0;
				for (s = 0; s < N; s++) {
					for (t = 0; t < N; t++) {
						x = i-half+s; y = j-half+t;
						if (x > IMAGE_X-1) x = IMAGE_X-1;
						else if (x < 0) x = 0;
						if (y > IMAGE_Y-1) y = IMAGE_Y-1;
						else if (y < 0) y = 0;
						//w_sim = gauss2((double)tmp[i][j] - tmp[x][y], 0.0, sigma2);
						val_r = tmp[x][y].r;
						val_g = tmp[x][y].g;
						val_b = tmp[x][y].b;
						//val = (val_r + val_g + val_b) / 3.0;
						//weight = gauss1D_norm((c_val - val)/255.0, 0.0, sigma2);
						c_dist = dist3(c_val_r-val_r, c_val_g-val_g, c_val_b-val_b);
						//weight = gauss1D_norm( c_dist/255.0, 0.0, sigma2);
						//weight = gauss1D_norm( c_dist/255.0/1.732, 0.0, sigma2);
						//weight = gauss1D_bl( c_dist/1.732, 0.0, sigma2); // sigma2 = 10.0
						weight = GAU2[ (int)(c_dist/1.732) ]; // like Gaussian!
						//count++;					
						weight *= gau_mask[s][t];
						sum_r += weight * val_r;
						sum_g += weight * val_g;
						sum_b += weight * val_b;
						//TRACE("k = %d\n", k);
						//TRACE("gau[%d] = %f\n", k, gau[k]);
						w_sum += weight;
					}
				}
				//TRACE("i = %d, j = %d\n", i, j);
				//TRACE("g = %f\n", g);
				//tmp2 = g;
				////////////////////////////////////
				// Normalization
				sum_r /= w_sum;
				sum_g /= w_sum;
				sum_b /= w_sum;
				//image[i][j] = round(tmp2);
				image[i][j].r = round(sum_r);
				image[i][j].g = round(sum_g);
				image[i][j].b = round(sum_b);
				/////////////////////////////////////
				//TRACE("N = %d\n", N);
				//TRACE("w_sum = %f\n", w_sum);
				//gau_mask.print();
				//if (image[i][j] > 255) image[i][j] = 255;
				//image[i][j] = (int)y;
			}
		}
		tmp.copy(image);
	}
	//TRACE("max_g = %f\n", max_g);
	//TRACE("min_g = %f\n", min_g);
}

void BilateralColorChui(cimatrix& image, double sigma, double sigma2, int max_itr)
{
	int	i, j;
	int MAX_GRADIENT = -1;
	double max_g, min_g;
	int s, t, k;
	int x, y;
	int half;
	int N;
	double weight;
	double val_r, val_g, val_b;
	double c_val_r, c_val_g, c_val_b;
	double w_sum, sum_r, sum_g, sum_b;
	double c_dist, s_dist;

	int image_x = image.getRow();
	int image_y = image.getCol();

	Make2DGaussMask(sigma);

	N = gau_mask.getRow();
	half = N / 2;

	//vector GAU2;

	//MakeGaussVectorBL(sigma2, GAU2, 300); // 300 array elements created

	cimatrix tmp(IMAGE_X, IMAGE_Y);
	tmp.copy(image);
	
	max_g = -1;
	min_g = 10000000;
	for (k = 0; k < max_itr; k++) {
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				sum_r = sum_g = sum_b = 0.0;
				weight = w_sum = 0.0;
				c_val_r = tmp[i][j].r;
				c_val_g = tmp[i][j].g;
				c_val_b = tmp[i][j].b;
				//c_val = (c_val_r + c_val_g + c_val_b) / 3.0;
				for (s = 0; s < N; s++) {
					for (t = 0; t < N; t++) {
						x = i-half+s; y = j-half+t;
						if (x > IMAGE_X-1) x = IMAGE_X-1;
						else if (x < 0) x = 0;
						if (y > IMAGE_Y-1) y = IMAGE_Y-1;
						else if (y < 0) y = 0;
						//w_sim = gauss2((double)tmp[i][j] - tmp[x][y], 0.0, sigma2);
						val_r = tmp[x][y].r;
						val_g = tmp[x][y].g;
						val_b = tmp[x][y].b;
						//val = (val_r + val_g + val_b) / 3.0;
						//weight = gauss1D_norm((c_val - val)/255.0, 0.0, sigma2);
						c_dist = dist3(c_val_r-val_r, c_val_g-val_g, c_val_b-val_b);
						//weight = gauss1D_norm( c_dist/255.0, 0.0, sigma2);
						//weight = gauss1D_norm( c_dist/255.0/1.732, 0.0, sigma2);
						//weight = gauss1D_bl( c_dist/1.732, 0.0, sigma2); // sigma2 = 10.0
						c_dist /= 1.732;
						s_dist = dist2((double)i, (double)j, (double)x, (double)y);
						c_dist *= s_dist;
						weight = gauss1D_bl( c_dist, 0.0, sigma2 ); // sigma2 = 10.0
						//weight = GAU2[ (int)(c_dist/1.732) ]; // like Gaussian!
						//count++;					
						//weight *= gau_mask[s][t];
						sum_r += weight * val_r;
						sum_g += weight * val_g;
						sum_b += weight * val_b;
						//TRACE("k = %d\n", k);
						//TRACE("gau[%d] = %f\n", k, gau[k]);
						w_sum += weight;
					}
				}
				//TRACE("i = %d, j = %d\n", i, j);
				//TRACE("g = %f\n", g);
				//tmp2 = g;
				////////////////////////////////////
				// Normalization
				sum_r /= w_sum;
				sum_g /= w_sum;
				sum_b /= w_sum;
				//image[i][j] = round(tmp2);
				image[i][j].r = round(sum_r);
				image[i][j].g = round(sum_g);
				image[i][j].b = round(sum_b);
				/////////////////////////////////////
				//TRACE("N = %d\n", N);
				//TRACE("w_sum = %f\n", w_sum);
				//gau_mask.print();
				//if (image[i][j] > 255) image[i][j] = 255;
				//image[i][j] = (int)y;
			}
		}
		tmp.copy(image);
	}
	//TRACE("max_g = %f\n", max_g);
	//TRACE("min_g = %f\n", min_g);
}

void BilateralToon(cimatrix& cmap, double sigma, double sigma2, int max_itr)
// use bilateral weight function from smoothed image 
{
	int	i, j;
	int MAX_GRADIENT = -1;
	double max_g, min_g;
	int s, t, k;
	int x, y;
	int half;
	int N;
	double weight;
	double val_r, val_g, val_b;
	double c_val_r, c_val_g, c_val_b;
	double w_sum, sum_r, sum_g, sum_b;
	double c_dist;

	int image_x = cmap.getRow();
	int image_y = cmap.getCol();

	Make2DGaussMask(sigma);

	N = gau_mask.getRow();
	half = N / 2;

	cimatrix tmp(IMAGE_X, IMAGE_Y);
	tmp.copy(cmap);
	
	max_g = -1;
	min_g = 10000000;
	for (k = 0; k < max_itr; k++) {
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				sum_r = sum_g = sum_b = 0.0;
				weight = w_sum = 0.0;
				c_val_r = tmp[i][j].r;
				c_val_g = tmp[i][j].g;
				c_val_b = tmp[i][j].b;
				//c_val = (c_val_r + c_val_g + c_val_b) / 3.0;
				for (s = 0; s < N; s++) {
					for (t = 0; t < N; t++) {
						x = i-half+s; y = j-half+t;
						if (x > IMAGE_X-1) x = IMAGE_X-1;
						else if (x < 0) x = 0;
						if (y > IMAGE_Y-1) y = IMAGE_Y-1;
						else if (y < 0) y = 0;
						//w_sim = gauss2((double)tmp[i][j] - tmp[x][y], 0.0, sigma2);
						val_r = tmp[x][y].r;
						val_g = tmp[x][y].g;
						val_b = tmp[x][y].b;
						//val = (val_r + val_g + val_b) / 3.0;
						//weight = gauss1D_norm((c_val - val)/255.0, 0.0, sigma2);
						c_dist = dist3(c_val_r-val_r, c_val_g-val_g, c_val_b-val_b);
						//weight = gauss1D_norm( c_dist/255.0, 0.0, sigma2);
						//weight = gauss1D_norm( c_dist/255.0/1.732, 0.0, sigma2);
						weight = gauss1D_bl( c_dist/1.732, 0.0, sigma2); // sigma2 = 10.0
						//count++;					
						weight *= gau_mask[s][t];
						sum_r += weight * val_r;
						sum_g += weight * val_g;
						sum_b += weight * val_b;
						//TRACE("k = %d\n", k);
						//TRACE("gau[%d] = %f\n", k, gau[k]);
						w_sum += weight;
					}
				}
				//TRACE("i = %d, j = %d\n", i, j);
				//TRACE("g = %f\n", g);
				//tmp2 = g;
				////////////////////////////////////
				// Normalization
				sum_r /= w_sum;
				sum_g /= w_sum;
				sum_b /= w_sum;
				//image[i][j] = round(tmp2);
				cmap[i][j].r = round(sum_r);
				cmap[i][j].g = round(sum_g);
				cmap[i][j].b = round(sum_b);
				/////////////////////////////////////
				//TRACE("N = %d\n", N);
				//TRACE("w_sum = %f\n", w_sum);
				//gau_mask.print();
				//if (image[i][j] > 255) image[i][j] = 255;
				//image[i][j] = (int)y;
			}
		}
		tmp.copy(cmap);
	}
	//TRACE("max_g = %f\n", max_g);
	//TRACE("min_g = %f\n", min_g);
}

void BilateralColorSep(int image_x, int image_y, cimatrix& cmap, double sigma, double sigma2, int max_itr)
// Separable Bilateral filter
{
	int	i, j;
	int MAX_GRADIENT = -1;
	double max_g, min_g;
	int s, t, k;
	int x, y;
	double weight;
	double val_r, val_g, val_b;
	double c_val_r, c_val_g, c_val_b;
	double w_sum, sum_r, sum_g, sum_b;
	double c_dist;

	vector GAU1;
	MakeGaussVector(sigma, GAU1); // length of the kernel
	//MakeGaussVector(sigma2, GAU2); // width of the kernel
	//MakeGaussVector(sigma3, GAU3); // for similarity function

	//half_l = GAU1.getMax()-1;
	int half_w = GAU1.getMax()-1;

	//Make2DGaussMask(sigma);
	vector GAU2;
	MakeGaussVectorBL(sigma2, GAU2, 300); // 300 array elements created

	//N = gau_mask.getRow();
	//half = N / 2;

	cimatrix tmp(IMAGE_X, IMAGE_Y);
	tmp.copy(cmap);

	max_g = -1;
	min_g = 10000000;
	for (k = 0; k < max_itr; k++) {
		///////////////////////////////
		// x-direction bilateral filter
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				sum_r = sum_g = sum_b = 0.0;
				weight = w_sum = 0.0;
				c_val_r = tmp[i][j].r;
				c_val_g = tmp[i][j].g;
				c_val_b = tmp[i][j].b;
				//c_val = (c_val_r + c_val_g + c_val_b) / 3.0;
				for (s = -half_w; s <= half_w; s++) {
						x = i+s; 
						y = j;
						if (x > IMAGE_X-1) x = IMAGE_X-1;
						else if (x < 0) x = 0;
						if (y > IMAGE_Y-1) y = IMAGE_Y-1;
						else if (y < 0) y = 0;
						//w_sim = gauss2((double)tmp[i][j] - tmp[x][y], 0.0, sigma2);
						val_r = tmp[x][y].r;
						val_g = tmp[x][y].g;
						val_b = tmp[x][y].b;
						//val = (val_r + val_g + val_b) / 3.0;
						weight = GAU1[ABS(s)];
						c_dist = dist3(c_val_r-val_r, c_val_g-val_g, c_val_b-val_b);
						//weight *= gauss1D_bl( c_dist/1.732, 0.0, sigma2);
						weight *= GAU2[ (int)(c_dist/1.732) ]; // like Gaussian!
						//count++;					
						//weight *= gau_mask[s][t];
						sum_r += weight * val_r;
						sum_g += weight * val_g;
						sum_b += weight * val_b;
						//TRACE("k = %d\n", k);
						//TRACE("gau[%d] = %f\n", k, gau[k]);
						w_sum += weight;
				}
				//TRACE("i = %d, j = %d\n", i, j);
				//TRACE("g = %f\n", g);
				//tmp2 = g;
				////////////////////////////////////
				// Normalization
				sum_r /= w_sum;
				sum_g /= w_sum;
				sum_b /= w_sum;
				//image[i][j] = round(tmp2);
				cmap[i][j].r = round(sum_r);
				cmap[i][j].g = round(sum_g);
				cmap[i][j].b = round(sum_b);
				/////////////////////////////////////
				//TRACE("N = %d\n", N);
				//TRACE("w_sum = %f\n", w_sum);
				//gau_mask.print();
				//if (image[i][j] > 255) image[i][j] = 255;
				//image[i][j] = (int)y;
			}
		}
		tmp.copy(cmap);

		///////////////////////////////
		// y-direction bilateral filter
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				sum_r = sum_g = sum_b = 0.0;
				weight = w_sum = 0.0;
				c_val_r = tmp[i][j].r;
				c_val_g = tmp[i][j].g;
				c_val_b = tmp[i][j].b;
				//c_val = (c_val_r + c_val_g + c_val_b) / 3.0;
				for (t = -half_w; t <= half_w; t++) {
						x = i; 
						y = j+t;
						if (x > IMAGE_X-1) x = IMAGE_X-1;
						else if (x < 0) x = 0;
						if (y > IMAGE_Y-1) y = IMAGE_Y-1;
						else if (y < 0) y = 0;
						//w_sim = gauss2((double)tmp[i][j] - tmp[x][y], 0.0, sigma2);
						val_r = tmp[x][y].r;
						val_g = tmp[x][y].g;
						val_b = tmp[x][y].b;
						//val = (val_r + val_g + val_b) / 3.0;
						weight = GAU1[ABS(t)];
						//weight = gauss1D_norm((c_val - val)/255.0, 0.0, sigma2);
						c_dist = dist3(c_val_r-val_r, c_val_g-val_g, c_val_b-val_b);
						//weight *= gauss1D_bl( c_dist/1.732, 0.0, sigma2);
						weight *= GAU2[ (int)(c_dist/1.732) ]; // like Gaussian!
						//count++;					
						//weight *= gau_mask[s][t];
						sum_r += weight * val_r;
						sum_g += weight * val_g;
						sum_b += weight * val_b;
						//TRACE("k = %d\n", k);
						//TRACE("gau[%d] = %f\n", k, gau[k]);
						w_sum += weight;
				}
				//TRACE("i = %d, j = %d\n", i, j);
				//TRACE("g = %f\n", g);
				//tmp2 = g;
				////////////////////////////////////
				// Normalization
				sum_r /= w_sum;
				sum_g /= w_sum;
				sum_b /= w_sum;
				//image[i][j] = round(tmp2);
				cmap[i][j].r = round(sum_r);
				cmap[i][j].g = round(sum_g);
				cmap[i][j].b = round(sum_b);
				/////////////////////////////////////
				//TRACE("N = %d\n", N);
				//TRACE("w_sum = %f\n", w_sum);
				//gau_mask.print();
				//if (image[i][j] > 255) image[i][j] = 255;
				//image[i][j] = (int)y;
			}
		}
		tmp.copy(cmap);
	}
	//TRACE("max_g = %f\n", max_g);
	//TRACE("min_g = %f\n", min_g);
}

void BilateralColorFull(cimatrix& image, double sigma, double sigma2, int max_itr)
// full kernel
// use table for bilateral weight
{
	int	i, j;
	int MAX_GRADIENT = -1;
	double max_g, min_g;
	int s, t, k, z;
	int x, y;
	int half;
	double weight;
	double val_r, val_g, val_b;
	double c_val_r, c_val_g, c_val_b;
	double w_sum, sum_r, sum_g, sum_b;
	double c_dist;

	int image_x = image.getRow();
	int image_y = image.getCol();

	//Make2DGaussMask(sigma);

	//N = gau_mask.getRow();

	//half = N / 2;

	vector GAU1;
	MakeGaussVector(sigma, GAU1);
	half = GAU1.getMax()-1;

	TRACE("half = %d\n", half);

	vector GAU2;
	MakeGaussVectorBL(sigma2, GAU2, 300); // 300 array elements created

	cimatrix tmp(IMAGE_X, IMAGE_Y);
	tmp.copy(image);
	
	max_g = -1;
	min_g = 10000000;
	for (k = 0; k < max_itr; k++) {
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				sum_r = sum_g = sum_b = 0.0;
				weight = w_sum = 0.0;
				c_val_r = tmp[i][j].r;
				c_val_g = tmp[i][j].g;
				c_val_b = tmp[i][j].b;
				//c_val = (c_val_r + c_val_g + c_val_b) / 3.0;
				for (s = -half; s <= half; s++) {
					for (t = -half; t <= half; t++) {
						x = i+s; y = j+t;
						/////////////////////////////////////////////////////////
						// circular kernel
						z = (int)dist2(x, y, i, j);
						//k = round( dist2(x, y, i, j) );
						if ( z > half ) continue; 
						//////////////////////////////////////////////
						if (x > IMAGE_X-1) x = IMAGE_X-1;
						else if (x < 0) x = 0;
						if (y > IMAGE_Y-1) y = IMAGE_Y-1;
						else if (y < 0) y = 0;
						//w_sim = gauss2((double)tmp[i][j] - tmp[x][y], 0.0, sigma2);
						val_r = tmp[x][y].r;
						val_g = tmp[x][y].g;
						val_b = tmp[x][y].b;
						//val = (val_r + val_g + val_b) / 3.0;
						//weight = gauss1D_norm((c_val - val)/255.0, 0.0, sigma2);
						//c_dist = dist3(c_val_r-val_r, c_val_g-val_g, c_val_b-val_b);
						//weight = gauss1D_norm( c_dist/255.0, 0.0, sigma2);
						//weight = gauss1D_norm( c_dist/255.0/1.732, 0.0, sigma2);

						//weight = GAU1[ABS(s)];
						c_dist = dist3(c_val_r-val_r, c_val_g-val_g, c_val_b-val_b);
						//weight *= gauss1D_bl( c_dist/1.732, 0.0, sigma2);
						weight = GAU2[ (int)(c_dist/1.732) ]; // like Gaussian!

						//count++;				
						weight *= GAU1[z];
						//weight *= gau_mask[s][t];
						sum_r += weight * val_r;
						sum_g += weight * val_g;
						sum_b += weight * val_b;
						//TRACE("k = %d\n", k);
						//TRACE("gau[%d] = %f\n", k, gau[k]);
						w_sum += weight;
					}
				}
				//TRACE("i = %d, j = %d\n", i, j);
				//TRACE("g = %f\n", g);
				//tmp2 = g;
				////////////////////////////////////
				// Normalization
				sum_r /= w_sum;
				sum_g /= w_sum;
				sum_b /= w_sum;
				//image[i][j] = round(tmp2);
				image[i][j].r = round(sum_r);
				image[i][j].g = round(sum_g);
				image[i][j].b = round(sum_b);
				/////////////////////////////////////
				//TRACE("N = %d\n", N);
				//TRACE("w_sum = %f\n", w_sum);
				//gau_mask.print();
				//if (image[i][j] > 255) image[i][j] = 255;
				//image[i][j] = (int)y;
			}
		}
		tmp.copy(image);
	}
	//TRACE("max_g = %f\n", max_g);
	//TRACE("min_g = %f\n", min_g);
}



void BilateralGraySep(imatrix& gray, double sigma, double sigma2, int max_itr)
// Separable Bilateral filter
{
	int	i, j;
	int MAX_GRADIENT = -1;
	double max_g, min_g;
	int s, t, k;
	int x, y;
	double weight;
	double val;
	double c_val;
	double w_sum, sum;
	double c_dist;

	int image_x = gray.getRow();
	int image_y = gray.getCol();

	vector GAU1;
	MakeGaussVector(sigma, GAU1); // length of the kernel
	//MakeGaussVector(sigma2, GAU2); // width of the kernel
	//MakeGaussVector(sigma3, GAU3); // for similarity function

	//half_l = GAU1.getMax()-1;
	int half_w = GAU1.getMax()-1;

	//Make2DGaussMask(sigma);
	vector GAU2;
	MakeGaussVectorBL(sigma2, GAU2, 300); // 300 array elements created

	//N = gau_mask.getRow();
	//half = N / 2;

	imatrix tmp(image_x, image_y);
	tmp.copy(gray);

	max_g = -1;
	min_g = 10000000;
	for (k = 0; k < max_itr; k++) {
		///////////////////////////////
		// x-direction bilateral filter
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				sum = 0.0;
				weight = w_sum = 0.0;
				c_val = tmp[i][j];
				//c_val = (c_val_r + c_val_g + c_val_b) / 3.0;
				for (s = -half_w; s <= half_w; s++) {
						x = i+s; 
						y = j;
						if (x > image_x-1) x = image_x-1;
						else if (x < 0) x = 0;
						if (y > image_y-1) y = image_y-1;
						else if (y < 0) y = 0;
						//w_sim = gauss2((double)tmp[i][j] - tmp[x][y], 0.0, sigma2);
						val = tmp[x][y];
						//val = (val_r + val_g + val_b) / 3.0;
						weight = GAU1[ABS(s)];
						c_dist = fabs(c_val-val);
						//c_dist = dist3(c_val_r-val_r, c_val_g-val_g, c_val_b-val_b);
						//weight *= gauss1D_bl( c_dist/1.732, 0.0, sigma2);
						weight *= GAU2[ (int)c_dist ]; // like Gaussian!
						//weight *= GAU2[ (int)(c_dist/1.732) ]; // like Gaussian!
						//count++;					
						//weight *= gau_mask[s][t];
						sum += weight * val;
						//TRACE("k = %d\n", k);
						//TRACE("gau[%d] = %f\n", k, gau[k]);
						w_sum += weight;
				}
				//TRACE("i = %d, j = %d\n", i, j);
				//TRACE("g = %f\n", g);
				//tmp2 = g;
				////////////////////////////////////
				// Normalization
				sum /= w_sum;
				//image[i][j] = round(tmp2);
				gray[i][j] = round(sum);
				/////////////////////////////////////
				//TRACE("N = %d\n", N);
				//TRACE("w_sum = %f\n", w_sum);
				//gau_mask.print();
				//if (image[i][j] > 255) image[i][j] = 255;
				//image[i][j] = (int)y;
			}
		}
		tmp.copy(gray);

		///////////////////////////////
		// y-direction bilateral filter
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				sum = 0.0;
				weight = w_sum = 0.0;
				c_val = tmp[i][j];
				for (t = -half_w; t <= half_w; t++) {
						x = i; 
						y = j+t;
						if (x > image_x-1) x = image_x-1;
						else if (x < 0) x = 0;
						if (y > image_y-1) y = image_y-1;
						else if (y < 0) y = 0;
						//w_sim = gauss2((double)tmp[i][j] - tmp[x][y], 0.0, sigma2);
						val = tmp[x][y];
						//val = (val_r + val_g + val_b) / 3.0;
						weight = GAU1[ABS(t)];
						//weight = gauss1D_norm((c_val - val)/255.0, 0.0, sigma2);
						c_dist = fabs(c_val-val);
						//weight *= gauss1D_bl( c_dist/1.732, 0.0, sigma2);
						weight *= GAU2[ (int)(c_dist) ]; // like Gaussian!
						//count++;					
						//weight *= gau_mask[s][t];
						sum += weight * val;
						//TRACE("k = %d\n", k);
						//TRACE("gau[%d] = %f\n", k, gau[k]);
						w_sum += weight;
				}
				//TRACE("i = %d, j = %d\n", i, j);
				//TRACE("g = %f\n", g);
				//tmp2 = g;
				////////////////////////////////////
				// Normalization
				sum /= w_sum;
				//image[i][j] = round(tmp2);
				gray[i][j] = round(sum);
				/////////////////////////////////////
				//TRACE("N = %d\n", N);
				//TRACE("w_sum = %f\n", w_sum);
				//gau_mask.print();
				//if (image[i][j] > 255) image[i][j] = 255;
				//image[i][j] = (int)y;
			}
		}
		tmp.copy(gray);
	}
	//TRACE("max_g = %f\n", max_g);
	//TRACE("min_g = %f\n", min_g);
}

void LinearInterp(cimatrix& cmap1, cimatrix& cmap2, double t, cimatrix& cmap3)
{
	int i, j;
	GLubyte r, g, b;
	double rd, gd, bd;
	double r1, g1, b1, r2, g2, b2;
	double h1, s1, v1, h2, s2, v2; 
	double v3;

	int image_x = cmap1.getRow();
	int image_y = cmap1.getCol();

	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			r1 = (double)cmap1[i][j].r / 255.0;
			g1 = (double)cmap1[i][j].g / 255.0;
			b1 = (double)cmap1[i][j].b / 255.0;
			RGB2HSV(r1, g1, b1, h1, s1, v1);
			
			r2 = (double)cmap2[i][j].r / 255.0;
			g2 = (double)cmap2[i][j].g / 255.0;
			b2 = (double)cmap2[i][j].b / 255.0;
			RGB2HSV(r2, g2, b2, h2, s2, v2);
			
			//s3 = (1-t) * s1 + t * s2;
			
			//v3 = (1-t) * v1 + t * v2; 

			v3 = v2 + t * (v2 - v1);

			if (v3 > 1.0) v3 = 1.0; if (v3 < 0.0) v3 = 0.0;

			HSV2RGB(h2, s2, v3, rd, gd, bd);

			rd *= 255;
			gd *= 255;
			bd *= 255;

			r = (GLubyte)rd;
			g = (GLubyte)gd;
			b = (GLubyte)bd;
			
			if (r < 0) r = 0; if (r > 255) r = 255;
			if (g < 0) g = 0; if (g > 255) g = 255;
			if (b < 0) b = 0; if (b > 255) b = 255;
			
			cmap3[i][j].r = r;
			cmap3[i][j].g = g;
			cmap3[i][j].b = b;
		}
	}
}

void LinearInterp2(cimatrix& cmap1, cimatrix& cmap2, double t, cimatrix& cmap3)
{
	int i, j;
	GLubyte r, g, b;
	double rd, gd, bd;
	double r1, g1, b1, r2, g2, b2;

	int image_x = cmap1.getRow();
	int image_y = cmap1.getCol();

	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			
			r1 = (double)cmap1[i][j].r;
			g1 = (double)cmap1[i][j].g;
			b1 = (double)cmap1[i][j].b;

			r2 = (double)cmap2[i][j].r;
			g2 = (double)cmap2[i][j].g;
			b2 = (double)cmap2[i][j].b;
			
			//s3 = (1-t) * s1 + t * s2;
			//v3 = (1-t) * v1 + t * v2;
			rd = (1-t) * r1 + t * r2;
			gd = (1-t) * g1 + t * g2;
			bd = (1-t) * b1 + t * b2;

			//if (v3 > 1.0) v3 = 1.0; if (v3 < 0.0) v3 = 0.0;

			//HSV2RGB(h2, s2, v3, rd, gd, bd);

			//rd *= 255;
			//gd *= 255;
			//bd *= 255;

			r = (GLubyte)rd;
			g = (GLubyte)gd;
			b = (GLubyte)bd;
			
			if (r < 0) r = 0; if (r > 255) r = 255;
			if (g < 0) g = 0; if (g > 255) g = 255;
			if (b < 0) b = 0; if (b > 255) b = 255;
			
			cmap3[i][j].r = r;
			cmap3[i][j].g = g;
			cmap3[i][j].b = b;
		}
	}
}

void LinearInterp3(cimatrix& cmap1, cimatrix& cmap2, double t, cimatrix& cmap3)
{
	int i, j;
	GLubyte r, g, b;
	double rd, gd, bd;
	double r1, g1, b1, r2, g2, b2;
	double h1, s1, v1, h2, s2, v2; 
	double v3;

	int image_x = cmap1.getRow();
	int image_y = cmap1.getCol();

	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			r1 = (double)cmap1[i][j].r / 255.0;
			g1 = (double)cmap1[i][j].g / 255.0;
			b1 = (double)cmap1[i][j].b / 255.0;
			RGB2HSV(r1, g1, b1, h1, s1, v1);
			
			r2 = (double)cmap2[i][j].r / 255.0;
			g2 = (double)cmap2[i][j].g / 255.0;
			b2 = (double)cmap2[i][j].b / 255.0;
			RGB2HSV(r2, g2, b2, h2, s2, v2);
			
			//s3 = (1-t) * s1 + t * s2;
			
			//v3 = (1-t) * v1 + t * v2; 
			
			v3 = v2 + 0.5 * (v2 - v1);
			
			//if (v2 - v1 > 0.0) v3 = v2 + (1.0 - v2) * 0.1;	
			//else if (v2 - v1 < 0.0) v3 = v2 - (v2 - 0.0) * 0.1;	
			//v3 = max(v2, v1);

			if (v3 > 1.0) v3 = 1.0; if (v3 < 0.0) v3 = 0.0;

			HSV2RGB(h2, s2, v3, rd, gd, bd);

			rd *= 255;
			gd *= 255;
			bd *= 255;

			r = (GLubyte)rd;
			g = (GLubyte)gd;
			b = (GLubyte)bd;
			
			if (r < 0) r = 0; if (r > 255) r = 255;
			if (g < 0) g = 0; if (g > 255) g = 255;
			if (b < 0) b = 0; if (b > 255) b = 255;
			
			cmap3[i][j].r = r;
			cmap3[i][j].g = g;
			cmap3[i][j].b = b;
		}
	}
}

void BilateralToonSep(CDC& dc, cimatrix& cmap, double sigma, double sigma2, int max_itr)
// Separable Bilateral filter
// Toon version
// Get bilateral weight function from smoothed image 
{
	int	i, j;
	int MAX_GRADIENT = -1;
	double max_g, min_g;
	int s, t, k;
	int x, y;
	double weight;
	double val_r, val_g, val_b;
	double c_val_r, c_val_g, c_val_b;
	double w_sum, sum_r, sum_g, sum_b;
	double c_dist;
	//double z;

	int image_x = cmap.getRow();
	int image_y = cmap.getCol();

	vector GAU1;
	MakeGaussVector(sigma, GAU1); // length of the kernel
	//MakeGaussVector(sigma2, GAU2); // width of the kernel
	//MakeGaussVector(sigma3, GAU3); // for similarity function

	//half_l = GAU1.getMax()-1;
	int half_w = GAU1.getMax()-1;

	//Make2DGaussMask(sigma);

	//N = gau_mask.getRow();
	//half = N / 2;

	cimatrix tmp(image_x, image_y);
	tmp.copy(cmap);

	cimatrix cmap2(image_x, image_y);
	cmap2.copy(cmap);
	//GaussColSmoothSep(cmap2, 2.0);

	max_g = -1;
	min_g = 10000000;
	for (k = 0; k < max_itr; k++) {
		///////////////////////////////
		GaussColSmoothSep(cmap2, 2.0);
		///////////////////////////////
		// x-direction bilateral filter
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				sum_r = sum_g = sum_b = 0.0;
				weight = w_sum = 0.0;
				c_val_r = cmap2[i][j].r;
				c_val_g = cmap2[i][j].g;
				c_val_b = cmap2[i][j].b;
				//c_val = (c_val_r + c_val_g + c_val_b) / 3.0;
				for (s = -half_w; s <= half_w; s++) {
						x = i+s; 
						y = j;
						if (x > image_x-1) x = image_x-1;
						else if (x < 0) x = 0;
						if (y > image_y-1) y = image_y-1;
						else if (y < 0) y = 0;
						//w_sim = gauss2((double)tmp[i][j] - tmp[x][y], 0.0, sigma2);
						val_r = cmap2[x][y].r;
						val_g = cmap2[x][y].g;
						val_b = cmap2[x][y].b;
						//val = (val_r + val_g + val_b) / 3.0;
						weight = GAU1[ABS(s)];
						//weight = gauss1D_norm((c_val - val)/255.0, 0.0, sigma2);
						c_dist = dist3(c_val_r-val_r, c_val_g-val_g, c_val_b-val_b);
						//weight = gauss1D_norm( c_dist/255.0, 0.0, sigma2);
						//weight *= gauss1D_norm( c_dist/255.0/1.732, 0.0, sigma2);
						//weight *= gauss1D_norm( c_dist/255.0/1.732, 0.0, sigma2);
						//weight *= gauss1D_bl( c_dist/255.0/1.732, 0.0, sigma2);
						weight *= gauss1D_bl( c_dist/1.732, 0.0, sigma2);
						//count++;					
						//weight *= gau_mask[s][t];
						sum_r += weight * tmp[x][y].r;
						sum_g += weight * tmp[x][y].g;
						sum_b += weight * tmp[x][y].b;
						//TRACE("k = %d\n", k);
						//TRACE("gau[%d] = %f\n", k, gau[k]);
						w_sum += weight;
				}
				//TRACE("i = %d, j = %d\n", i, j);
				//TRACE("g = %f\n", g);
				//tmp2 = g;
				////////////////////////////////////
				// Normalization
				sum_r /= w_sum;
				sum_g /= w_sum;
				sum_b /= w_sum;
				//image[i][j] = round(tmp2);
				cmap[i][j].r = round(sum_r);
				cmap[i][j].g = round(sum_g);
				cmap[i][j].b = round(sum_b);
				/////////////////////////////////////
				//TRACE("N = %d\n", N);
				//TRACE("w_sum = %f\n", w_sum);
				//gau_mask.print();
				//if (image[i][j] > 255) image[i][j] = 255;
				//image[i][j] = (int)y;
			}
		}
		tmp.copy(cmap);

		///////////////////////////////
		// y-direction bilateral filter
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				sum_r = sum_g = sum_b = 0.0;
				weight = w_sum = 0.0;
				c_val_r = cmap2[i][j].r;
				c_val_g = cmap2[i][j].g;
				c_val_b = cmap2[i][j].b;
				//c_val = (c_val_r + c_val_g + c_val_b) / 3.0;
				for (t = -half_w; t <= half_w; t++) {
						x = i; 
						y = j+t;
						if (x > image_x-1) x = image_x-1;
						else if (x < 0) x = 0;
						if (y > image_y-1) y = image_y-1;
						else if (y < 0) y = 0;
						//w_sim = gauss2((double)tmp[i][j] - tmp[x][y], 0.0, sigma2);
						val_r = cmap2[x][y].r;
						val_g = cmap2[x][y].g;
						val_b = cmap2[x][y].b;
						//val = (val_r + val_g + val_b) / 3.0;
						weight = GAU1[ABS(t)];
						//weight = gauss1D_norm((c_val - val)/255.0, 0.0, sigma2);
						c_dist = dist3(c_val_r-val_r, c_val_g-val_g, c_val_b-val_b);
						//weight = gauss1D_norm( c_dist/255.0, 0.0, sigma2);
						//weight *= gauss1D_norm( c_dist/255.0/1.732, 0.0, sigma2);
						//weight *= gauss1D_bl( c_dist/255.0/1.732, 0.0, sigma2);
						weight *= gauss1D_bl( c_dist/1.732, 0.0, sigma2);
						//count++;					
						//weight *= gau_mask[s][t];
						sum_r += weight * tmp[x][y].r;
						sum_g += weight * tmp[x][y].g;
						sum_b += weight * tmp[x][y].b;
						//TRACE("k = %d\n", k);
						//TRACE("gau[%d] = %f\n", k, gau[k]);
						w_sum += weight;
				}
				//TRACE("i = %d, j = %d\n", i, j);
				//TRACE("g = %f\n", g);
				//tmp2 = g;
				////////////////////////////////////
				// Normalization
				sum_r /= w_sum;
				sum_g /= w_sum;
				sum_b /= w_sum;
				//image[i][j] = round(tmp2);
				cmap[i][j].r = round(sum_r);
				cmap[i][j].g = round(sum_g);
				cmap[i][j].b = round(sum_b);
				/////////////////////////////////////
				//TRACE("N = %d\n", N);
				//TRACE("w_sum = %f\n", w_sum);
				//gau_mask.print();
				//if (image[i][j] > 255) image[i][j] = 255;
				//image[i][j] = (int)y;
			}
		}
		
		//LinearInterp(cmap2, cmap, 1.5, cmap);
		//LinearInterp3(cmap2, cmap, 1.5, cmap);
		DrawColorImage(memDC, image_x, image_y, cmap);
		dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);

		tmp.copy(cmap);
		//LinearInterp2(cmap2, cmap, z, cmap);
	}
	//z = 2.0;
	//LinearInterp(cmap2, cmap, z, cmap);
	//TRACE("max_g = %f\n", max_g);
	//TRACE("min_g = %f\n", min_g);
}

void BilateralGrayToonSep(imatrix& gray, double sigma, double sigma2, int max_itr)
// Separable Bilateral filter
// Toon version: gray image
// Get bilateral weight function from smoothed image 
{
	int	i, j;
	int MAX_GRADIENT = -1;
	double max_g, min_g;
	int s, t, k;
	int x, y;
	double weight;
	double val;
	double c_val;
	double w_sum, sum;
	double c_dist;
	//double z;

	int image_x = gray.getRow();
	int image_y = gray.getCol();

	vector GAU1;
	MakeGaussVector(sigma, GAU1); // length of the kernel
	//MakeGaussVector(sigma2, GAU2); // width of the kernel
	//MakeGaussVector(sigma3, GAU3); // for similarity function

	//half_l = GAU1.getMax()-1;
	int half_w = GAU1.getMax()-1;

	//Make2DGaussMask(sigma);

	//N = gau_mask.getRow();
	//half = N / 2;

	imatrix tmp(image_x, image_y);
	tmp.copy(gray);

	imatrix gray2(image_x, image_y);
	gray2.copy(gray);
	//GaussColSmoothSep(gray2, 2.0);
	GaussSmoothSep(gray2, 2.0);

	max_g = -1;
	min_g = 10000000;
	for (k = 0; k < max_itr; k++) {
		///////////////////////////////
		//////////////////////////////////
		//GaussColSmoothSep(gray2, 1.0);
		/////////////////////////////////
		///////////////////////////////
		// x-direction bilateral filter
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				sum = 0.0;
				weight = w_sum = 0.0;
				c_val = gray2[i][j];
				//c_val = (c_val_r + c_val_g + c_val_b) / 3.0;
				for (s = -half_w; s <= half_w; s++) {
						x = i+s; 
						y = j;
						if (x > image_x-1) x = image_x-1;
						else if (x < 0) x = 0;
						if (y > image_y-1) y = image_y-1;
						else if (y < 0) y = 0;
						//w_sim = gauss2((double)tmp[i][j] - tmp[x][y], 0.0, sigma2);
						val = gray2[x][y];
						//val = (val_r + val_g + val_b) / 3.0;
						weight = GAU1[ABS(s)];
						//weight = gauss1D_norm((c_val - val)/255.0, 0.0, sigma2);
						c_dist = sqrt( (c_val-val) * (c_val-val) );
						//weight = gauss1D_norm( c_dist/255.0, 0.0, sigma2);
						//weight *= gauss1D_norm( c_dist/255.0/1.732, 0.0, sigma2);
						//weight *= gauss1D_norm( c_dist/255.0/1.732, 0.0, sigma2);
						//weight *= gauss1D_bl( c_dist/255.0/1.732, 0.0, sigma2);
						weight *= gauss1D_bl( c_dist/1.732, 0.0, sigma2);
						//count++;					
						//weight *= gau_mask[s][t];
						sum += weight * tmp[x][y];
						//TRACE("k = %d\n", k);
						//TRACE("gau[%d] = %f\n", k, gau[k]);
						w_sum += weight;
				}
				//TRACE("i = %d, j = %d\n", i, j);
				//TRACE("g = %f\n", g);
				//tmp2 = g;
				////////////////////////////////////
				// Normalization
				sum /= w_sum;
				//image[i][j] = round(tmp2);
				gray[i][j] = round(sum);
				/////////////////////////////////////
				//TRACE("N = %d\n", N);
				//TRACE("w_sum = %f\n", w_sum);
				//gau_mask.print();
				//if (image[i][j] > 255) image[i][j] = 255;
				//image[i][j] = (int)y;
			}
		}
		tmp.copy(gray);

		///////////////////////////////
		// y-direction bilateral filter
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				sum = 0.0;
				weight = w_sum = 0.0;
				c_val = gray2[i][j];
				//c_val = (c_val_r + c_val_g + c_val_b) / 3.0;
				for (t = -half_w; t <= half_w; t++) {
						x = i; 
						y = j+t;
						if (x > image_x-1) x = image_x-1;
						else if (x < 0) x = 0;
						if (y > image_y-1) y = image_y-1;
						else if (y < 0) y = 0;
						//w_sim = gauss2((double)tmp[i][j] - tmp[x][y], 0.0, sigma2);
						val = gray2[x][y];
						//val = (val_r + val_g + val_b) / 3.0;
						weight = GAU1[ABS(t)];
						//weight = gauss1D_norm((c_val - val)/255.0, 0.0, sigma2);
						c_dist = sqrt( (c_val-val) * (c_val-val) );
						//c_dist = dist3(c_val_r-val_r, c_val_g-val_g, c_val_b-val_b);
						//weight = gauss1D_norm( c_dist/255.0, 0.0, sigma2);
						//weight *= gauss1D_norm( c_dist/255.0/1.732, 0.0, sigma2);
						//weight *= gauss1D_bl( c_dist/255.0/1.732, 0.0, sigma2);
						weight *= gauss1D_bl( c_dist/1.732, 0.0, sigma2);
						//count++;					
						//weight *= gau_mask[s][t];
						sum += weight * tmp[x][y];
						//TRACE("k = %d\n", k);
						//TRACE("gau[%d] = %f\n", k, gau[k]);
						w_sum += weight;
				}
				//TRACE("i = %d, j = %d\n", i, j);
				//TRACE("g = %f\n", g);
				//tmp2 = g;
				////////////////////////////////////
				// Normalization
				sum /= w_sum;
				//image[i][j] = round(tmp2);
				gray[i][j] = round(sum);
				/////////////////////////////////////
				//TRACE("N = %d\n", N);
				//TRACE("w_sum = %f\n", w_sum);
				//gau_mask.print();
				//if (image[i][j] > 255) image[i][j] = 255;
				//image[i][j] = (int)y;
			}
		}
		
		//LinearInterp(cmap2, cmap, 1.5, cmap);
		//LinearInterp3(cmap2, cmap, 1.5, cmap);

		tmp.copy(gray);
		//LinearInterp2(cmap2, cmap, z, cmap);
	}
	//z = 2.0;
	//LinearInterp(cmap2, cmap, z, cmap);
	//TRACE("max_g = %f\n", max_g);
	//TRACE("min_g = %f\n", min_g);
}

void GetPSNR(CDC& dc, cimatrix& cmap, char* file1, char* file2)
{
	int	x, y;
	double r1, g1, b1, r2, g2, b2;
	double MSE, PSNR;

	int image_x = cmap.getRow();
	int image_y = cmap.getCol();

	LoadBMP(dc, (char *)LPCTSTR(file1), &memDC);

	MSE = 0.0;
	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			r1 = (double)cmap[x][y].r;
			g1 = (double)cmap[x][y].g;
			b1 = (double)cmap[x][y].b;
			r2 = (double)RGB_GETRED(memDC.GetPixel(x, image_y-1-y));
			g2 = (double)RGB_GETGREEN(memDC.GetPixel(x, image_y-1-y));
			b2 = (double)RGB_GETBLUE(memDC.GetPixel(x, image_y-1-y));
			MSE += (r1-r2) * (r1-r2);
			MSE += (g1-g2) * (g1-g2);
			MSE += (b1-b2) * (b1-b2);
		}
	}
	MSE = MSE / (double)( image_x * image_y ) / 3.0;
	PSNR = 20.0 * log10(255.0 / sqrt(MSE));
	
	TRACE("MSE1 = %f\n", MSE);
	TRACE("PSNR1 = %f\n", PSNR);
	
	LoadBMP(dc, (char *)LPCTSTR(file2), &memDC);

	MSE = 0.0;
	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			r1 = (double)cmap[x][y].r;
			g1 = (double)cmap[x][y].g;
			b1 = (double)cmap[x][y].b;
			r2 = (double)RGB_GETRED(memDC.GetPixel(x, image_y-1-y));
			g2 = (double)RGB_GETGREEN(memDC.GetPixel(x, image_y-1-y));
			b2 = (double)RGB_GETBLUE(memDC.GetPixel(x, image_y-1-y));
			MSE += (r1-r2) * (r1-r2);
			MSE += (g1-g2) * (g1-g2);
			MSE += (b1-b2) * (b1-b2);
		}
	}
	MSE = MSE / (double)( image_x * image_y ) / 3.0;
	PSNR = 20.0 * log10(255.0 / sqrt(MSE));
	
	TRACE("MSE2 = %f\n", MSE);
	TRACE("PSNR2 = %f\n\n", PSNR);
}

void GetDiff(CDC& dc, imatrix& gray, char* file1, char* file2)
// Get per pixel color difference value!
{
	int	x, y;
	double r1, g1, b1, r2, g2, b2;
	double MSE;
	int exist;

	int image_x = gray.getRow();
	int image_y = gray.getCol();

	cimatrix cmap(image_x, image_y);
	cimatrix cmap2(image_x, image_y);

	exist = LoadBMP(dc, (char *)LPCTSTR(file1), &memDC);
	if (exist == 0) { TRACE("file1 does not exist!\n"); exit(1); }

	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			cmap[x][y].r = (GLubyte)RGB_GETRED(memDC.GetPixel(x, image_y-1-y));
			cmap[x][y].g = (GLubyte)RGB_GETGREEN(memDC.GetPixel(x, image_y-1-y));
			cmap[x][y].b = (GLubyte)RGB_GETBLUE(memDC.GetPixel(x, image_y-1-y));
		}
	}

	exist = LoadBMP(dc, (char *)LPCTSTR(file2), &memDC);
	if (exist == 0) { TRACE("file2 does not exist!\n"); exit(1); }

	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			cmap2[x][y].r = (GLubyte)RGB_GETRED(memDC.GetPixel(x, image_y-1-y));
			cmap2[x][y].g = (GLubyte)RGB_GETGREEN(memDC.GetPixel(x, image_y-1-y));
			cmap2[x][y].b = (GLubyte)RGB_GETBLUE(memDC.GetPixel(x, image_y-1-y));
		}
	}

	TRACE("image_x = %d\n", image_x);
	TRACE("image_y = %d\n", image_y);

	MSE = 0.0;
	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			r1 = (double)cmap[x][y].r / 256.;
			g1 = (double)cmap[x][y].g / 256.;
			b1 = (double)cmap[x][y].b  / 256.;
			r2 = (double)cmap2[x][y].r / 256.;
			g2 = (double)cmap2[x][y].g / 256.;
			b2 = (double)cmap2[x][y].b / 256.;
			MSE += dist3(r1-r2, g1-g2, b1-b2) / 1.732;
			//TRACE("MSE = %f\n", MSE);
		}
	}
	
	MSE /= (image_x * image_y);
	TRACE("per pixel diff = %f\n", MSE);

}

void GetPSNR_partial(CDC& dc, cimatrix& cmap, char* file1, char* file2)
{
	int	x, y;
	double r1, g1, b1, r2, g2, b2;
	double MSE, PSNR;

	int image_x = cmap.getRow();
	int image_y = cmap.getCol();

	int count;

	LoadBMP(dc, (char *)LPCTSTR(file1), &memDC);

	MSE = 0.0;
	count = 0;
	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			r1 = (double)cmap[x][y].r;
			g1 = (double)cmap[x][y].g;
			b1 = (double)cmap[x][y].b;
			//////////////////////////////////////////
			// red area is ignored!
			if (r1 == 255 && g1 == 0 && b1 == 0) continue;
			////////////////////////////////////////
			count++;
			//////////
			r2 = (double)RGB_GETRED(memDC.GetPixel(x, image_y-1-y));
			g2 = (double)RGB_GETGREEN(memDC.GetPixel(x, image_y-1-y));
			b2 = (double)RGB_GETBLUE(memDC.GetPixel(x, image_y-1-y));
			MSE += (r1-r2) * (r1-r2);
			MSE += (g1-g2) * (g1-g2);
			MSE += (b1-b2) * (b1-b2);
		}
	}
	//MSE = MSE / (double)( image_x * image_y ) / 3.0;
	TRACE("count1 = %d\n", count);
	MSE = MSE / (double)( count ) / 3.0;
	PSNR = 20.0 * log10(255.0 / sqrt(MSE));
	
	TRACE("MSE1 = %f\n", MSE);
	TRACE("PSNR1 = %f\n", PSNR);
	
	LoadBMP(dc, (char *)LPCTSTR(file2), &memDC);

	MSE = 0.0;
	count = 0;
	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			r1 = (double)cmap[x][y].r;
			g1 = (double)cmap[x][y].g;
			b1 = (double)cmap[x][y].b;
			//////////////////////////////////////////
			// red area is ignored!
			if (r1 == 255 && g1 == 0 && b1 == 0) continue;
			////////////////////////////////////////
			count++;
			//////////
			r2 = (double)RGB_GETRED(memDC.GetPixel(x, image_y-1-y));
			g2 = (double)RGB_GETGREEN(memDC.GetPixel(x, image_y-1-y));
			b2 = (double)RGB_GETBLUE(memDC.GetPixel(x, image_y-1-y));
			MSE += (r1-r2) * (r1-r2);
			MSE += (g1-g2) * (g1-g2);
			MSE += (b1-b2) * (b1-b2);
		}
	}
	//MSE = MSE / (double)( image_x * image_y ) / 3.0;
	TRACE("count2 = %d\n", count);
	MSE = MSE / (double)( count ) / 3.0;
	PSNR = 20.0 * log10(255.0 / sqrt(MSE));
	
	TRACE("MSE2 = %f\n", MSE);
	TRACE("PSNR2 = %f\n", PSNR);
}

void BilateralGfield(int image_x, int image_y, Field& gfield, double sigma, double sigma2, int M)
{
	int	i, j, u, v;
	int MAX_GRADIENT = -1;
	double w_sum;
	double gx, gy;
	int s, t;
	int x, y;
	int half;
	int N;
	double w_sim;
	double mag_diff;

	Field gvf; // gvf: result of filtering 

	//////////////////////////////////
	Make2DGaussMask(sigma); // mask for unilateral filtering

	N = gau_mask.getRow();
	half = N / 2;

	matrix tmp_mask(N, N); // mask for bilateral filtering
	tmp_mask.zero();

	//imatrix tmp(IMAGE_X, IMAGE_Y);
	//matrix tmp2(IMAGE_X, IMAGE_Y);
	//tmp2.zero();
	
	gvf.init(gfield.getRow(), gfield.getCol()); // init gvf
	gvf.copy(gfield); // copy gfield to gvf_tmp
	//gvf.zero(); // initialize
	//gvf_tmp.init(gfield.getRow(), gfield.getCol()); // init gvf
	//gvf.copy(gfield); // copy gfield to gvf_tmp
	//gvf_tmp.copy(gfield); // copy gfield to gvf_tmp
		
	//max_g = -1;
	//min_g = 10000000;
	for (int k = 0; k < M; k++) {
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				//if (gfield[i][j].gx > 0.0)
				//	TRACE("gfield[%d][%d].gx = %f\n", i, j, gvf[i][j].gx);
				//if (gfield[i][j].mag > 0.0)
				//	TRACE("gfield[%d][%d].mag = %f\n", i, j, gvf[i][j].mag);
				gx = gy = 0.0;
				for (s = 0; s < N; s++) {
					for (t = 0; t < N; t++) {
						x = i-half+s; y = j-half+t;
						if (x > IMAGE_X-1) x = IMAGE_X-1;
						else if (x < 0) x = 0;
						if (y > IMAGE_Y-1) y = IMAGE_Y-1;
						else if (y < 0) y = 0;
						////////////////////////////////////////
						mag_diff = gfield[x][y].mag - gfield[i][j].mag; 
						//TRACE("mag_diff = %f\n", mag_diff);
						//mag_diff *= 0.001;
						//w_sim = pow( exp(mag_diff), 2.0 );
						w_sim = exp(mag_diff);
						//w_sim = 1.0;
						//TRACE("w_sim = %f\n", w_sim);
						/*
						if (mag_diff >= 0.0)
							w_sim = exp(mag_diff);
						else
							w_sim = 0.0;
						*/
						//if (w_sim > 1.0)
						//	TRACE("w_sim = %f\n", w_sim);
						//if (i == x && j == y)
						//	TRACE("w_sim = %f\n", w_sim);
						/*
						if (mag_diff >= 0.0)
							w_sim = gauss2( exp(-mag_diff), 0.0, sigma2);
						else
							w_sim = 0.0;
						*/
						/*
						if (mag_diff > 0.0) // if magnitude here is bigger than center magnitude
							w_sim = gauss2(1/mag_diff, 0.0, sigma2); // make current direction similar
						if (mag_diff == 0.0) // if magnitudes are the same
							w_sim = gauss2(1/mag_diff, 0.0, sigma2); // make current direction similar
						else
							w_sim = 0.0; // original is stronger, so ignore this one
						*/
						//////////////////////////////////////////
						//count++;					
						tmp_mask[s][t] = w_sim * gau_mask[s][t];
						gx += tmp_mask[s][t] * gfield[x][y].gx;
						gy += tmp_mask[s][t] * gfield[x][y].gy;
						//TRACE("k = %d\n", k);
						//TRACE("gau[%d] = %f\n", k, gau[k]);
					}
				}
				//TRACE("i = %d, j = %d\n", i, j);
				//TRACE("g = %f\n", g);
				//tmp2[i][j] = g;
				////////////////////////////////////
				// Normalization
				w_sum = 0.0;
				for (v = 0; v < N; v++) {
					for (u = 0; u < N; u++) {
						w_sum += tmp_mask[u][v];
					}
				}
				gx /= w_sum;
				gy /= w_sum;
				gvf[i][j].gx = gx;
				gvf[i][j].gy = gy;
				//if (gvf[i][j].gx > 0.0)
				//	TRACE("gvf[%d][%d].gx = %f\n", i, j, gvf[i][j].gx);
				//TRACE("gvf[%d][%d].gy = %f\n", i, j, gvf[i][j].gy);
				/////////////////////////////////////
				//TRACE("N = %d\n", N);
				//TRACE("w_sum = %f\n", w_sum);
				//gau_mask.print();
				//if (image[i][j] > 255) image[i][j] = 255;
				//image[i][j] = (int)y;
			}
		}
		gfield.copy(gvf);
		//TRACE("max_g = %f\n", max_g);
		//TRACE("min_g = %f\n", min_g);
	}
	////////////////////////////////////////////
}

void BilateralGfield5(CDC& dc, int image_x, int image_y, Field& gfield, double sigma, int M)
// non-adaptive version
// uses pow function to make it more affected by bigger magnitude
{
	int	i, j;
	int MAX_GRADIENT = -1;
	double w_sum, w_sim;
	double gx, gy;
	int s, t;
	int x, y;
	int half;
	int N;
	double mag_diff;

	Field gvf; // gvf: result of filtering 

	//////////////////////////////////
	Make2DGaussMask(sigma); // mask for unilateral filtering

	N = gau_mask.getRow();
	half = N / 2;

	//matrix tmp_mask(N, N); // mask for bilateral filtering
	//tmp_mask.zero();
	double tmp;

	//imatrix tmp(IMAGE_X, IMAGE_Y);
	//matrix tmp2(IMAGE_X, IMAGE_Y);
	//tmp2.zero();
	
	gvf.init(gfield.getRow(), gfield.getCol()); // init gvf
	gvf.copy(gfield); // copy gfield to gvf_tmp
	//gvf.zero(); // initialize
	//gvf_tmp.init(gfield.getRow(), gfield.getCol()); // init gvf
	//gvf.copy(gfield); // copy gfield to gvf_tmp
	//gvf_tmp.copy(gfield); // copy gfield to gvf_tmp

	//max_g = -1;
	//min_g = 10000000;
	for (int k = 0; k < M; k++) {
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				//if (gfield[i][j].gx > 0.0)
				//	TRACE("gfield[%d][%d].gx = %f\n", i, j, gvf[i][j].gx);
				//if (gfield[i][j].mag > 0.0)
				//	TRACE("gfield[%d][%d].mag = %f\n", i, j, gvf[i][j].mag);
				gx = gy = 0.0;
				w_sum = 0.0;
				for (s = 0; s < N; s++) {
					for (t = 0; t < N; t++) {
						x = i-half+s; y = j-half+t;
						if (x > IMAGE_X-1) x = IMAGE_X-1;
						else if (x < 0) x = 0;
						if (y > IMAGE_Y-1) y = IMAGE_Y-1;
						else if (y < 0) y = 0;
						////////////////////////////////////////
						mag_diff = gfield[x][y].mag - gfield[i][j].mag; 
						/*
						if (mag_diff > 0.0) {
							//TRACE("mag_diff[%d][%d] = %f\n", i, j, mag_diff);
							//dc.SetPixelV(i, IMAGE_Y-1-j, RGB(255, 0, 0));
						}
						*/
						//mag_diff *= 0.001;
						//mag_diff *= factor;
						//mag_diff *= -1;
						//mag_diff = 0;
						//w_sim = exp(mag_diff);
						w_sim = tanh(mag_diff) + 1; // [0, 2]
							//if (w_sim > 1000)
							//TRACE("w_sim[%d][%d] = %f\n", i, j, w_sim);
						w_sim = exp(w_sim * 10); // [1, 4]
						//w_sim = pow(w_sim, 20);
						//	if (w_sim > 1)
						//	TRACE("Now w_sim[%d][%d] = %f\n", i, j, w_sim);
						//w_sim *= w_sim;
						//w_sim = 1;
						//w_sim = 0;
						//if (mag_diff > 0.0) {
						/*
						if (w_sim < 0.2 || w_sim > 1.8) {
							TRACE("w_sim[%d][%d] = %f\n", i, j, w_sim);
						}
						*/
						//////////////////////////////////////////
						//count++;					
						//tmp_mask[s][t] = w_sim * gau_mask[s][t];
						//gx += tmp_mask[s][t] * gfield[x][y].gx;
						//gy += tmp_mask[s][t] * gfield[x][y].gy;
						tmp = w_sim * gau_mask[s][t];
						//if (tmp > 1.0)
						//	TRACE("tmp[%d][%d] = %f\n", i, j, tmp);
						gx += tmp * gfield[x][y].gx;
						gy += tmp * gfield[x][y].gy;
						w_sum += tmp;
						//TRACE("k = %d\n", k);
						//TRACE("gau[%d] = %f\n", k, gau[k]);
					}
				}
				//TRACE("i = %d, j = %d\n", i, j);
				//TRACE("g = %f\n", g);
				//tmp2[i][j] = g;
				////////////////////////////////////
				// Normalization
				w_sum /= (N*N);
				//TRACE("w_sum[%d][%d] = %f\n", i, j, w_sum);
				/*
				w_sum = 0.0;
				for (v = 0; v < N; v++) {
					for (u = 0; u < N; u++) {
						w_sum += tmp_mask[u][v];
					}
				}
				*/
				gx /= w_sum;
				gy /= w_sum;
				//TRACE("gx[%d][%d] = %f\n", i, j, gx);
				//TRACE("gy[%d][%d] = %f\n", i, j, gy);
				gvf[i][j].gx = gx;
				gvf[i][j].gy = gy;
				//if (gvf[i][j].gx > 0.0)
				//	TRACE("gvf[%d][%d].gx = %f\n", i, j, gvf[i][j].gx);
				//TRACE("gvf[%d][%d].gy = %f\n", i, j, gvf[i][j].gy);
				/////////////////////////////////////
				//TRACE("N = %d\n", N);
				//TRACE("w_sum = %f\n", w_sum);
				//gau_mask.print();
				//if (image[i][j] > 255) image[i][j] = 255;
				//image[i][j] = (int)y;
			}
		}
		gfield.copy(gvf);
		//TRACE("max_g = %f\n", max_g);
		//TRACE("min_g = %f\n", min_g);
	}
	////////////////////////////////////////////
}

void BilateralGfield6(CDC& dc, int image_x, int image_y, Field& gfield, double sigma, int M)
// non-adaptive version
// smoothes only vectors with similar directions!!! (improves the edge connectivity!)
{
	int	i, j;
	int MAX_GRADIENT = -1;
	double w_sum, w_sim;
	double gx, gy;
	int s, t;
	int x, y;
	int half;
	int N;
	double mag_diff;

	Field gvf; // gvf: result of filtering 

	//////////////////////////////////
	Make2DGaussMask(sigma); // mask for unilateral filtering

	N = gau_mask.getRow();
	half = N / 2;

	//matrix tmp_mask(N, N); // mask for bilateral filtering
	//tmp_mask.zero();
	double tmp;

	//imatrix tmp(IMAGE_X, IMAGE_Y);
	//matrix tmp2(IMAGE_X, IMAGE_Y);
	//tmp2.zero();
	
	gvf.init(gfield.getRow(), gfield.getCol()); // init gvf
	gvf.copy(gfield); // copy gfield to gvf_tmp
	//gvf.zero(); // initialize
	//gvf_tmp.init(gfield.getRow(), gfield.getCol()); // init gvf
	//gvf.copy(gfield); // copy gfield to gvf_tmp
	//gvf_tmp.copy(gfield); // copy gfield to gvf_tmp

	vector v(2), w(2);
	double angle;
	bool center_pixel;

	gvf.normalize(); // normalize (gx, gy) vector (to get angle)
		
	//max_g = -1;
	//min_g = 10000000;
	for (int k = 0; k < M; k++) {
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				//if (gfield[i][j].gx > 0.0)
				//	TRACE("gfield[%d][%d].gx = %f\n", i, j, gvf[i][j].gx);
				//if (gfield[i][j].mag > 0.0)
				//	TRACE("gfield[%d][%d].mag = %f\n", i, j, gvf[i][j].mag);
				gx = gy = 0.0;
				w_sum = 0.0;
				v[0] = gfield[i][j].gx;
				v[1] = gfield[i][j].gy;
				//v.make_unit();
				
				for (s = 0; s < N; s++) {
					for (t = 0; t < N; t++) {
						//////////////////////////////////
						center_pixel = false;
						if (s == half && t == half) center_pixel = true;
						////////////////////////////////////////
						x = i-half+s; y = j-half+t;
						if (x > IMAGE_X-1) x = IMAGE_X-1;
						else if (x < 0) x = 0;
						if (y > IMAGE_Y-1) y = IMAGE_Y-1;
						else if (y < 0) y = 0;
						////////////////////////////////////////
						mag_diff = gfield[x][y].mag - gfield[i][j].mag; 
						/*
						if (mag_diff > 0.0) {
							//TRACE("mag_diff[%d][%d] = %f\n", i, j, mag_diff);
							//dc.SetPixelV(i, IMAGE_Y-1-j, RGB(255, 0, 0));
						}
						*/
						w[0] = gfield[x][y].gx;
						w[1] = gfield[x][y].gy;
						//w.make_unit();
						//w.print();
						angle = v * w + 1; // [0, 2]
						//TRACE("angle = %.3f\n", angle);
						/////////////////////////////////////////////////////////
						if (center_pixel) {
							w_sim = 1; // center pixel
							//w_sim = exp(gfield[i][j].mag * 6); // [1, e^6]
						}
						else if (mag_diff > 0.0) {
							w_sim = tanh(mag_diff) + 1; // [0, 2]
							w_sim *= angle; // [0, 4]
						}
						else w_sim = 0; // should not be affected by smaller gradient!
						//////////////////////////////////////////////////////////////
						/*
						if (i == x && j == y) {
							w_sim = 1; // center pixel
						}
						else if (mag_diff > 0.0) {
							w_sim = tanh(mag_diff) + 1; // [1, 2]
							w_sim *= angle; // [1, 4]
						}
						else w_sim = 0; // should not be affected by smaller gradient!
						*/
						//////////////////////////////////////////////////////////////
						//w_sim = exp(w_sim * 10); // [1, 4]
						//w_sim = pow(w_sim, 20);
						//	if (w_sim > 1)
						//	TRACE("Now w_sim[%d][%d] = %f\n", i, j, w_sim);
						//w_sim *= w_sim;
						//w_sim = 1;
						//w_sim = 0;
						//if (mag_diff > 0.0) {
						/*
						if (w_sim < 0.2 || w_sim > 1.8) {
							TRACE("w_sim[%d][%d] = %f\n", i, j, w_sim);
						}
						*/
						//////////////////////////////////////////
						//count++;					
						//tmp_mask[s][t] = w_sim * gau_mask[s][t];
						//gx += tmp_mask[s][t] * gfield[x][y].gx;
						//gy += tmp_mask[s][t] * gfield[x][y].gy;
						tmp = w_sim * gau_mask[s][t];
						//if (tmp > 1.0)
						//	TRACE("tmp[%d][%d] = %f\n", i, j, tmp);
						gx += tmp * gfield[x][y].gx;
						gy += tmp * gfield[x][y].gy;
						w_sum += tmp;
						//TRACE("k = %d\n", k);
						//TRACE("gau[%d] = %f\n", k, gau[k]);
					}
				}
				//TRACE("i = %d, j = %d\n", i, j);
				//TRACE("g = %f\n", g);
				//tmp2[i][j] = g;
				////////////////////////////////////
				// Normalization
				w_sum /= (N*N);
				//TRACE("w_sum[%d][%d] = %f\n", i, j, w_sum);
				/*
				w_sum = 0.0;
				for (v = 0; v < N; v++) {
					for (u = 0; u < N; u++) {
						w_sum += tmp_mask[u][v];
					}
				}
				*/
				gx /= w_sum;
				gy /= w_sum;
				//TRACE("gx[%d][%d] = %f\n", i, j, gx);
				//TRACE("gy[%d][%d] = %f\n", i, j, gy);
				gvf[i][j].gx = gx;
				gvf[i][j].gy = gy;
				//if (gvf[i][j].gx > 0.0)
				//	TRACE("gvf[%d][%d].gx = %f\n", i, j, gvf[i][j].gx);
				//TRACE("gvf[%d][%d].gy = %f\n", i, j, gvf[i][j].gy);
				/////////////////////////////////////
				//TRACE("N = %d\n", N);
				//TRACE("w_sum = %f\n", w_sum);
				//gau_mask.print();
				//if (image[i][j] > 255) image[i][j] = 255;
				//image[i][j] = (int)y;
			}
		}
		gfield.copy(gvf);
		//TRACE("max_g = %f\n", max_g);
		//TRACE("min_g = %f\n", min_g);
	}
	////////////////////////////////////////////
}

void BilateralGfield7(CDC& dc, int image_x, int image_y, Field& gfield, double sigma, int M)
// non-adaptive version
// smoothes only vectors with similar directions!!! (improves the edge connectivity!)
// and we smooth with lower magnitude vectors too!
// And we multiply Gaussian
{
	int	i, j;
	int MAX_GRADIENT = -1;
	double w_sum, w_sim;
	double gx, gy;
	int s, t;
	int x, y;
	int half;
	int N;
	double mag_diff;

	Field gvf; // gvf: result of filtering 

	//////////////////////////////////
	Make2DGaussMask(sigma); // mask for unilateral filtering

	N = gau_mask.getRow();
	half = N / 2;

	//matrix tmp_mask(N, N); // mask for bilateral filtering
	//tmp_mask.zero();

	gvf.init(gfield.getRow(), gfield.getCol()); // init gvf
	gvf.copy(gfield); // copy gfield to gvf_tmp

	vector v(2), w(2);
	double angle;
	bool center_pixel;

	gvf.normalize(); // normalize (gx, gy) vector (to get angle)
		
	//max_g = -1;
	//min_g = 10000000;
	for (int k = 0; k < M; k++) {
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				//if (gfield[i][j].gx > 0.0)
				//	TRACE("gfield[%d][%d].gx = %f\n", i, j, gvf[i][j].gx);
				//if (gfield[i][j].mag > 0.0)
				//	TRACE("gfield[%d][%d].mag = %f\n", i, j, gvf[i][j].mag);
				gx = gy = 0.0;
				w_sum = 0.0;
				v[0] = gfield[i][j].gx;
				v[1] = gfield[i][j].gy;
				//v.make_unit();
				
				for (s = 0; s < N; s++) {
					for (t = 0; t < N; t++) {
						//////////////////////////////////
						center_pixel = false;
						if (s == half && t == half) center_pixel = true;
						////////////////////////////////////////
						x = i-half+s; y = j-half+t;
						if (x > IMAGE_X-1) x = IMAGE_X-1;
						else if (x < 0) x = 0;
						if (y > IMAGE_Y-1) y = IMAGE_Y-1;
						else if (y < 0) y = 0;
						/////////////////////////////////////
						////////////////////////////////////////
						mag_diff = gfield[x][y].mag - gfield[i][j].mag; 
						/*
						if (mag_diff > 0.0) {
							//TRACE("mag_diff[%d][%d] = %f\n", i, j, mag_diff);
							//dc.SetPixelV(i, IMAGE_Y-1-j, RGB(255, 0, 0));
						}
						*/
						w[0] = gfield[x][y].gx;
						w[1] = gfield[x][y].gy;
						//w.make_unit();
						//w.print();
						angle = v * w + 1; // [0, 2]
						//TRACE("angle = %.3f\n", angle);
						/////////////////////////////////////////////////////////
						/*
						if (center_pixel) {
							w_sim = 1; // center pixel
							//w_sim = exp(gfield[i][j].mag * 6); // [1, e^6]
						}
						else if (mag_diff > 0.0) {
							w_sim = tanh(mag_diff) + 1; // [0, 2]
							w_sim *= angle; // [0, 4]
						}
						else w_sim = 0; // should not be affected by smaller gradient!
						*/
						w_sim = tanh(mag_diff) + 1; // [0, 2]
						w_sim *= angle; // [0, 4]
						w_sim *= gau_mask[s][t];
						//////////////////////////////////////////////////////////////
						//////////////////////////////////////////
						//count++;					
						//tmp_mask[s][t] = w_sim * gau_mask[s][t];
						//gx += tmp_mask[s][t] * gfield[x][y].gx;
						//gy += tmp_mask[s][t] * gfield[x][y].gy;
						//tmp = w_sim * gau_mask[s][t];
						//if (tmp > 1.0)
						//	TRACE("tmp[%d][%d] = %f\n", i, j, tmp);
						gx += w_sim * gfield[x][y].gx;
						gy += w_sim * gfield[x][y].gy;
						w_sum += w_sim;
						//TRACE("k = %d\n", k);
						//TRACE("gau[%d] = %f\n", k, gau[k]);
					}
				}
				//TRACE("i = %d, j = %d\n", i, j);
				//TRACE("g = %f\n", g);
				//tmp2[i][j] = g;
				////////////////////////////////////
				// Normalization
				w_sum /= (N*N);
				//TRACE("w_sum[%d][%d] = %f\n", i, j, w_sum);
				gx /= w_sum;
				gy /= w_sum;
				//TRACE("gx[%d][%d] = %f\n", i, j, gx);
				//TRACE("gy[%d][%d] = %f\n", i, j, gy);
				gvf[i][j].gx = gx;
				gvf[i][j].gy = gy;
				//if (gvf[i][j].gx > 0.0)
				//	TRACE("gvf[%d][%d].gx = %f\n", i, j, gvf[i][j].gx);
				//TRACE("gvf[%d][%d].gy = %f\n", i, j, gvf[i][j].gy);
				/////////////////////////////////////
				//TRACE("N = %d\n", N);
				//TRACE("w_sum = %f\n", w_sum);
				//gau_mask.print();
				//if (image[i][j] > 255) image[i][j] = 255;
				//image[i][j] = (int)y;
			}
		}
		gfield.copy(gvf);
		//TRACE("max_g = %f\n", max_g);
		//TRACE("min_g = %f\n", min_g);
	}
	////////////////////////////////////////////
}

void BilateralGfield8(CDC& dc, int image_x, int image_y, Field& gfield, double sigma, int M)
// non-adaptive version
// smoothes only vectors with similar directions!!! (improves the edge connectivity!)
// and we smooth with lower magnitude vectors too!
// Here we don't multiply GAUSSIAN! Faster convergence!
{
	int	i, j;
	int MAX_GRADIENT = -1;
	double w_sum, w_sim;
	double gx, gy;
	int s, t;
	int x, y;
	int half;
	int N;
	double mag_diff;

	Field gvf; // gvf: result of filtering 

	//////////////////////////////////
	Make2DGaussMask(sigma); // mask for unilateral filtering

	N = gau_mask.getRow();
	half = N / 2;

	TRACE("TVF: half_w = %d\n", N);

	//matrix tmp_mask(N, N); // mask for bilateral filtering
	//tmp_mask.zero();

	gvf.init(gfield.getRow(), gfield.getCol()); // init gvf
	gvf.copy(gfield); // copy gfield to gvf_tmp

	vector v(2), w(2);
	double angle;
	double factor;
	//bool center_pixel;

	//gvf.normalize(); // normalize (gx, gy) vector (to get angle)
		
	//max_g = -1;
	//min_g = 10000000;
	for (int k = 0; k < M; k++) {
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				//if (gfield[i][j].gx > 0.0)
				//	TRACE("gfield[%d][%d].gx = %f\n", i, j, gvf[i][j].gx);
				//if (gfield[i][j].mag > 0.0)
				//	TRACE("gfield[%d][%d].mag = %f\n", i, j, gvf[i][j].mag);
				gx = gy = 0.0;
				//mag = 0.0; // also diffuse magnitude!
				w_sum = 0.0;
				v[0] = gfield[i][j].gx;
				v[1] = gfield[i][j].gy;
				v.make_unit();
				
				for (s = 0; s < N; s++) {
					for (t = 0; t < N; t++) {
						//////////////////////////////////
						//center_pixel = false;
						//if (s == half && t == half) center_pixel = true;
						////////////////////////////////////////
						x = i-half+s; y = j-half+t;
						if (x > IMAGE_X-1) x = IMAGE_X-1;
						else if (x < 0) x = 0;
						if (y > IMAGE_Y-1) y = IMAGE_Y-1;
						else if (y < 0) y = 0;
						/////////////////////////////////////
						////////////////////////////////////////
						mag_diff = gfield[x][y].mag - gfield[i][j].mag; 
						//////////////////////////////////////////////////////
						// 1/10/2007: If we remove "* PI", we can make it smoother?
						//mag_diff = mag_diff * PI; // turn it into Radian for tanh
						///////////////////////////////////////////////////
						//TRACE("mag_diff[%d][%d] = %f\n", i, j, mag_diff);
						/*
						if (mag_diff > 0.0) {
							//TRACE("mag_diff[%d][%d] = %f\n", i, j, mag_diff);
							//dc.SetPixelV(i, IMAGE_Y-1-j, RGB(255, 0, 0));
						}
						*/
						w[0] = gfield[x][y].gx;
						w[1] = gfield[x][y].gy;
						w.make_unit();
						//w.print();
						////////////////////////////////
						// Note: 0 is best, also, 360 is best
						// But, note that 180 is also good (exactly opposite direction!!!)
						//angle = v * w + 1; // [0, 2]
						//////////////////////////////////////////////
						// IMPORTANT!!!
						// When call acos(angle), make sure angle is in [0, 1]
						// if it's bigger than 1, then acos returns wrong number!!!
						angle = v * w;
						if (angle > 1.0) angle = 1.0;
						if (angle < -1.0) angle = -1.0;
						//angle += 1;
						///*
						angle = acos(angle) * 180 / PI; // [0, 180]
						factor = 1.0;
						if (angle > 90) {
							factor = -1.0;
						}
						angle = ABS(90 - angle) / 90.0; // [0.0, 1.0]
						//*/
						//angle = ABS(v * w); // [0, 1]
						//if (angle < 0) angle *= -1; 
						//v.print();
						//w.print();
						//TRACE("v * w = %f\n", v * w);
						//TRACE("acos = %f\n", acos(v * w));
						//TRACE("acos(1.0) = %f\n", acos(1.0));
						//TRACE("angle = %f\n", angle);
						/////////////////////////////////////////////////////////
						w_sim = tanh(mag_diff) + 1; // [0, 2]
						//////////////////////////////////////////////////////
						// 12/31/2006: Confirmed! This one makes it MUCH BETTER!
						if (w_sim < 1.0) w_sim = 0.0; // only consider same or bigger magnitude!
						///////////////////////////////////////////////////////////
						//w_sim *= w_sim * w_sim;
						//if (i > 100 && j > 100)
						//	TRACE("w_sim[%d][%d] = %f\n", i, j, w_sim);
						w_sim *= angle; // [0, 2]
						//w_sim *= ABS(angle); // [0, 2]
						//w_sim *= pow(angle, 3.0);
						//w_sim *= angle * angle * angle; // [0, 4]
						//w_sim *= gau_mask[s][t];
						//////////////////////////////////////////////////////////////
						//////////////////////////////////////////
						//gx += w_sim * gfield[x][y].gx;
						//gy += w_sim * gfield[x][y].gy;
						gx += w_sim * gfield[x][y].gx * factor;
						gy += w_sim * gfield[x][y].gy * factor;
						//mag += gfield[x][y].mag; // also diffuse magnitude!
						//gx += w_sim * w[0] * factor; // normalized vector diffusion
						//gy += w_sim * w[1] * factor;
						w_sum += w_sim;
						//TRACE("k = %d\n", k);
						//TRACE("gau[%d] = %f\n", k, gau[k]);
					}
				}
				//TRACE("i = %d, j = %d\n", i, j);
				//TRACE("g = %f\n", g);
				//tmp2[i][j] = g;
				////////////////////////////////////
				// Normalization
				w_sum /= (N*N);
				//TRACE("w_sum[%d][%d] = %f\n", i, j, w_sum);
				gx /= w_sum;
				gy /= w_sum;
				//TRACE("gx[%d][%d] = %f\n", i, j, gx);
				//TRACE("gy[%d][%d] = %f\n", i, j, gy);
				gvf[i][j].gx = gx;
				gvf[i][j].gy = gy;
				//gvf[i][j].mag = mag; // also diffuse magnitude!
				//if (gvf[i][j].gx > 0.0)
				//	TRACE("gvf[%d][%d].gx = %f\n", i, j, gvf[i][j].gx);
				//TRACE("gvf[%d][%d].gy = %f\n", i, j, gvf[i][j].gy);
				/////////////////////////////////////
				//TRACE("N = %d\n", N);
				//TRACE("w_sum = %f\n", w_sum);
				//gau_mask.print();
				//if (image[i][j] > 255) image[i][j] = 255;
				//image[i][j] = (int)y;
			}
		}
		gfield.copy(gvf);
		//TRACE("max_g = %f\n", max_g);
		//TRACE("min_g = %f\n", min_g);
	}
	////////////////////////////////////////////
}

void BilateralGfield9(CDC& dc, int image_x, int image_y, Field& gfield, double sigma, int M)
// non-adaptive version
// smoothes only vectors with similar directions!!! (improves the edge connectivity!)
// and we smooth with lower magnitude vectors too!
// Here we don't multiply GAUSSIAN! Faster convergence!
{
	int	i, j, k;
	int MAX_GRADIENT = -1;
	double w_sum, weight;
	double gx, gy;
	int s, t;
	int x, y;
	int half_w;
	int d1;
	//int N;
	double mag_diff;

	Field gvf; // gvf: result of filtering 

	//////////////////////////////////
	//Make2DGaussMask(sigma); // mask for unilateral filtering
	//N = gau_mask.getRow();
	//half = N / 2;
	vector GAU1;
	MakeGaussVector(sigma, GAU1); // entire inner circle
	half_w = GAU1.getMax()-1;

	TRACE("TVF: half_w = %d\n", half_w);

	//matrix tmp_mask(N, N); // mask for bilateral filtering
	//tmp_mask.zero();

	gvf.init(gfield.getRow(), gfield.getCol()); // init gvf
	gvf.copy(gfield); // copy gfield to gvf_tmp

	vector v(2), w(2);
	double angle;
	double factor;
	//bool center_pixel;

	//gvf.normalize(); // normalize (gx, gy) vector (to get angle)
		
	//max_g = -1;
	//min_g = 10000000;
	for (k = 0; k < M; k++) {
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				//if (gfield[i][j].gx > 0.0)
				//	TRACE("gfield[%d][%d].gx = %f\n", i, j, gvf[i][j].gx);
				//if (gfield[i][j].mag > 0.0)
				//	TRACE("gfield[%d][%d].mag = %f\n", i, j, gvf[i][j].mag);
				gx = gy = 0.0;
				//mag = 0.0; // also diffuse magnitude!
				w_sum = 0.0;
				v[0] = gfield[i][j].gx;
				v[1] = gfield[i][j].gy;
				v.make_unit();
				for (s = -half_w; s <= half_w; s++) {
					for (t = -half_w; t <= half_w; t++) {
						//////////////////////////////////
						//center_pixel = false;
						//if (s == half && t == half) center_pixel = true;
						////////////////////////////////////////
						x = i+s; y = j+t;
						if (x > IMAGE_X-1) x = IMAGE_X-1;
						else if (x < 0) x = 0;
						if (y > IMAGE_Y-1) y = IMAGE_Y-1;
						else if (y < 0) y = 0;
						/////////////////////////////////////////////////////////
						// circular kernel
						d1 = (int)dist2(x, y, i, j);
						if ( d1 > half_w ) continue; 
						/////////////////////////////////////
						////////////////////////////////////////
						mag_diff = gfield[x][y].mag - gfield[i][j].mag; 
						//////////////////////////////////////////////////////
						// 1/10/2007: If we remove "* PI", we can make it smoother?
						//mag_diff = mag_diff * PI; // turn it into Radian for tanh
						///////////////////////////////////////////////////
						//TRACE("mag_diff[%d][%d] = %f\n", i, j, mag_diff);
						w[0] = gfield[x][y].gx;
						w[1] = gfield[x][y].gy;
						w.make_unit();
						////////////////////////////////
						// Note: 0 is best, also, 360 is best
						// But, note that 180 is also good (exactly opposite direction!!!)
						//angle = v * w + 1; // [0, 2]
						//////////////////////////////////////////////
						// IMPORTANT!!!
						// When call acos(angle), make sure angle is in [0, 1]
						// if it's bigger than 1, then acos returns wrong number!!!
						angle = v * w;
						if (angle > 1.0) angle = 1.0;
						if (angle < -1.0) angle = -1.0;
						angle = acos(angle) * 180 / PI; // [0, 180]
						factor = 1.0;
						if (angle > 90) {
							factor = -1.0; // reverse the direction
						}
						angle = ABS(90 - angle) / 90.0; // [0.0, 1.0]
						//*/
						//angle = ABS(v * w); // [0, 1]
						//if (angle < 0) angle *= -1; 
						//v.print();
						//w.print();
						//TRACE("v * w = %f\n", v * w);
						//TRACE("acos = %f\n", acos(v * w));
						//TRACE("acos(1.0) = %f\n", acos(1.0));
						//TRACE("angle = %f\n", angle);
						/////////////////////////////////////////////////////////
						weight = tanh(mag_diff) + 1; // [0, 2]
						//////////////////////////////////////////////////////
						// 12/31/2006: Confirmed! This one makes it MUCH BETTER! (WRONG! 4/7/2007)
						if (weight < 1.0) weight = 0.0; // only consider same or bigger magnitude!
						///////////////////////////////////////////////////////////
						//w_sim *= w_sim * w_sim;
						//if (i > 100 && j > 100)
						//	TRACE("w_sim[%d][%d] = %f\n", i, j, w_sim);
						weight *= angle; // [0, 2]
						//w_sim *= ABS(angle); // [0, 2]
						//w_sim *= pow(angle, 3.0);
						//w_sim *= angle * angle * angle; // [0, 4]
						//w_sim *= gau_mask[s][t];
						//////////////////////////////////////////////////////////////
						//////////////////////////////////////////
						//gx += w_sim * gfield[x][y].gx;
						//gy += w_sim * gfield[x][y].gy;
						gx += weight * gfield[x][y].gx * factor;
						gy += weight * gfield[x][y].gy * factor;
						//mag += gfield[x][y].mag; // also diffuse magnitude!
						//gx += w_sim * w[0] * factor; // normalized vector diffusion
						//gy += w_sim * w[1] * factor;
						w_sum += weight;
						//TRACE("k = %d\n", k);
						//TRACE("gau[%d] = %f\n", k, gau[k]);
					}
				}
				//TRACE("i = %d, j = %d\n", i, j);
				//TRACE("g = %f\n", g);
				//tmp2[i][j] = g;
				////////////////////////////////////
				// Normalization
				//w_sum /= (N*N);
				//TRACE("w_sum[%d][%d] = %f\n", i, j, w_sum);
				gx /= w_sum;
				gy /= w_sum;
				//TRACE("gx[%d][%d] = %f\n", i, j, gx);
				//TRACE("gy[%d][%d] = %f\n", i, j, gy);
				gvf[i][j].gx = gx;
				gvf[i][j].gy = gy;
				//gvf[i][j].mag = mag; // also diffuse magnitude!
				//if (gvf[i][j].gx > 0.0)
				//	TRACE("gvf[%d][%d].gx = %f\n", i, j, gvf[i][j].gx);
				//TRACE("gvf[%d][%d].gy = %f\n", i, j, gvf[i][j].gy);
				/////////////////////////////////////
				//TRACE("N = %d\n", N);
				//TRACE("w_sum = %f\n", w_sum);
				//gau_mask.print();
				//if (image[i][j] > 255) image[i][j] = 255;
				//image[i][j] = (int)y;
			}
		}
		gfield.copy(gvf);
		//TRACE("max_g = %f\n", max_g);
		//TRACE("min_g = %f\n", min_g);
	}
	////////////////////////////////////////////
}

void BilateralGfield10(CDC& dc, int image_x, int image_y, Field& gfield, double sigma, int M)
//////////////////////////////////////////////////////////////////////
// HERE we smooth with lower magnitude vectors too! (This is the BEST!)
// non-adaptive version
// smoothes only vectors with similar directions!!! (improves the edge connectivity!)
// Here we don't multiply GAUSSIAN! Faster convergence!
{
	int	i, j, k;
	int MAX_GRADIENT = -1;
	double w_sum, weight;
	double gx, gy;
	int s, t;
	int x, y;
	int half_w;
	int d1;
	//int N;
	double mag_diff;

	Field gvf; // gvf: result of filtering 

	//////////////////////////////////
	//Make2DGaussMask(sigma); // mask for unilateral filtering
	//N = gau_mask.getRow();
	//half = N / 2;
	vector GAU1;
	MakeGaussVector(sigma, GAU1); // entire inner circle
	half_w = GAU1.getMax()-1;

	TRACE("TVF: half_w = %d\n", half_w);

	//matrix tmp_mask(N, N); // mask for bilateral filtering
	//tmp_mask.zero();

	gvf.init(gfield.getRow(), gfield.getCol()); // init gvf
	gvf.copy(gfield); // copy gfield to gvf_tmp

	vector v(2), w(2);
	double angle;
	double factor;
	//bool center_pixel;

	//gvf.normalize(); // normalize (gx, gy) vector (to get angle)
		
	//max_g = -1;
	//min_g = 10000000;
	for (k = 0; k < M; k++) {
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				//if (gfield[i][j].gx > 0.0)
				//	TRACE("gfield[%d][%d].gx = %f\n", i, j, gvf[i][j].gx);
				//if (gfield[i][j].mag > 0.0)
				//	TRACE("gfield[%d][%d].mag = %f\n", i, j, gvf[i][j].mag);
				gx = gy = 0.0;
				//mag = 0.0; // also diffuse magnitude!
				w_sum = 0.0;
				v[0] = gfield[i][j].gx;
				v[1] = gfield[i][j].gy;
				v.make_unit();
				for (s = -half_w; s <= half_w; s++) {
					for (t = -half_w; t <= half_w; t++) {
						////////////////////////////////////////
						x = i+s; y = j+t;
						if (x > IMAGE_X-1) x = IMAGE_X-1;
						else if (x < 0) x = 0;
						if (y > IMAGE_Y-1) y = IMAGE_Y-1;
						else if (y < 0) y = 0;
						/////////////////////////////////////////////////////////
						// circular kernel
						d1 = (int)dist2(x, y, i, j);
						if ( d1 > half_w ) continue; // this doesn't make any difference in speed
						/////////////////////////////////////
						////////////////////////////////////////
						mag_diff = gfield[x][y].mag - gfield[i][j].mag; 
						//////////////////////////////////////////////////////
						// 1/10/2007: If we remove "* PI", we can make it smoother?
						//mag_diff = mag_diff * PI; // turn it into Radian for tanh
						///////////////////////////////////////////////////
						//TRACE("mag_diff[%d][%d] = %f\n", i, j, mag_diff);
						w[0] = gfield[x][y].gx;
						w[1] = gfield[x][y].gy;
						w.make_unit();
						////////////////////////////////
						// Note: 0 is best, also, 360 is best
						// But, note that 180 is also good (exactly opposite direction!!!)
						//angle = v * w + 1; // [0, 2]
						//////////////////////////////////////////////
						// IMPORTANT!!!
						// When call acos(angle), make sure angle is in [0, 1]
						// if it's bigger than 1, then acos returns wrong number!!!
						// Removing this part can make it about 7 seconds faster!
						angle = v * w;
						if (angle > 1.0) angle = 1.0;
						if (angle < -1.0) angle = -1.0;
						///*
						angle = acos(angle) * 180 / PI; // [0, 180]
						factor = 1.0;
						if (angle > 90) {
							factor = -1.0; // reverse the direction
						}
						angle = ABS(90 - angle) / 90.0; // [0.0, 1.0]
						//*/
						/////////////////////////////////////////////////////////
						weight = tanh(mag_diff) + 1; // [0, 2] // this part takes up 5 seconds more!
						//weight = mag_diff + 1; // [0, 2] // this part takes up 5 seconds more!
						//////////////////////////////////////////////////////
						// 12/31/2006: Confirmed! This one makes it MUCH BETTER!
						//if (weight < 1.0) weight = 0.0; // only consider same or bigger magnitude!
						// 4/7/2007: Confirmed: Don't do this! see NPAR results!
						///////////////////////////////////////////////////////////
						//weight *= angle; // [0, 2]
						//weight *= GAU1[d1]; looks like Gaussian kernel doesn't make it better!
						//gx += weight * gfield[x][y].gx;
						//gy += weight * gfield[x][y].gy;
						//factor = 1.0;
						gx += weight * gfield[x][y].gx * factor;
						gy += weight * gfield[x][y].gy * factor;
						w_sum += weight;
					}
				}
				////////////////////////////////////
				// Normalization
				gx /= w_sum;
				gy /= w_sum;
				//TRACE("gx[%d][%d] = %f\n", i, j, gx);
				//TRACE("gy[%d][%d] = %f\n", i, j, gy);
				gvf[i][j].gx = gx;
				gvf[i][j].gy = gy;
				//gvf[i][j].mag = mag; // also diffuse magnitude!
				//if (gvf[i][j].gx > 0.0)
				//	TRACE("gvf[%d][%d].gx = %f\n", i, j, gvf[i][j].gx);
				//TRACE("gvf[%d][%d].gy = %f\n", i, j, gvf[i][j].gy);
				/////////////////////////////////////
				//TRACE("N = %d\n", N);
				//TRACE("w_sum = %f\n", w_sum);
				//gau_mask.print();
				//if (image[i][j] > 255) image[i][j] = 255;
				//image[i][j] = (int)y;
			}
		}
		gfield.copy(gvf);
		//TRACE("max_g = %f\n", max_g);
		//TRACE("min_g = %f\n", min_g);
	}
	////////////////////////////////////////////
}

void BilateralGfield10_speedcheck(CDC& dc, int image_x, int image_y, Field& gfield, double sigma, int M)
{
	int	i, j, k;
	int MAX_GRADIENT = -1;
	double w_sum, weight;
	double gx, gy;
	int s, t;
	int x, y;
	int half_w;
	int d1;
	//int N;
	double mag_diff;

	Field gvf; // gvf: result of filtering 

	//////////////////////////////////
	//Make2DGaussMask(sigma); // mask for unilateral filtering
	//N = gau_mask.getRow();
	//half = N / 2;
	vector GAU1;
	MakeGaussVector(sigma, GAU1); // entire inner circle
	half_w = GAU1.getMax()-1;

	TRACE("TVF: half_w = %d\n", half_w);

	//matrix tmp_mask(N, N); // mask for bilateral filtering
	//tmp_mask.zero();

	gvf.init(gfield.getRow(), gfield.getCol()); // init gvf
	gvf.copy(gfield); // copy gfield to gvf_tmp

	vector v(2), w(2);
	double angle;
	double factor;
	//bool center_pixel;

	//gvf.normalize(); // normalize (gx, gy) vector (to get angle)
		
	//max_g = -1;
	//min_g = 10000000;
	for (k = 0; k < M; k++) {
		///////////////
		StartTimer();
		///////////////
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				//if (gfield[i][j].gx > 0.0)
				//	TRACE("gfield[%d][%d].gx = %f\n", i, j, gvf[i][j].gx);
				//if (gfield[i][j].mag > 0.0)
				//	TRACE("gfield[%d][%d].mag = %f\n", i, j, gvf[i][j].mag);
				gx = gy = 0.0;
				//mag = 0.0; // also diffuse magnitude!
				w_sum = 0.0;
				v[0] = gfield[i][j].gx;
				v[1] = gfield[i][j].gy;
				v.make_unit();
				for (s = -half_w; s <= half_w; s++) {
					for (t = -half_w; t <= half_w; t++) {
						////////////////////////////////////////
						x = i+s; y = j+t;
						if (x > IMAGE_X-1) x = IMAGE_X-1;
						else if (x < 0) x = 0;
						if (y > IMAGE_Y-1) y = IMAGE_Y-1;
						else if (y < 0) y = 0;
						/////////////////////////////////////////////////////////
						// circular kernel
						d1 = (int)dist2(x, y, i, j);
						if ( d1 > half_w ) continue; // this doesn't make any difference in speed
						/////////////////////////////////////
						////////////////////////////////////////
						mag_diff = gfield[x][y].mag - gfield[i][j].mag; 
						//////////////////////////////////////////////////////
						// 1/10/2007: If we remove "* PI", we can make it smoother?
						//mag_diff = mag_diff * PI; // turn it into Radian for tanh
						///////////////////////////////////////////////////
						//TRACE("mag_diff[%d][%d] = %f\n", i, j, mag_diff);
						w[0] = gfield[x][y].gx;
						w[1] = gfield[x][y].gy;
						w.make_unit();
						////////////////////////////////
						// Note: 0 is best, also, 360 is best
						// But, note that 180 is also good (exactly opposite direction!!!)
						//angle = v * w + 1; // [0, 2]
						//////////////////////////////////////////////
						// IMPORTANT!!!
						// When call acos(angle), make sure angle is in [0, 1]
						// if it's bigger than 1, then acos returns wrong number!!!
						// Removing this part can make it about 7 seconds faster!
						///*
						angle = v * w;
						if (angle > 1.0) angle = 1.0;
						if (angle < -1.0) angle = -1.0;
						///*
						angle = acos(angle) * 180 / PI; // [0, 180]
						factor = 1.0;
						if (angle > 90) {
							factor = -1.0; // reverse the direction
						}
						angle = ABS(90 - angle) / 90.0; // [0.0, 1.0]
						//*/
						//factor = 1.0;
						//angle = 0.5; // [0.0, 1.0]
						/////////////////////////////////////////////////////////
						//weight = tanh(mag_diff) + 1; // [0, 2] // this part takes up 5 seconds more!
						weight = 0.5 * (mag_diff + 1); // [0, 2] // this part takes up 5 seconds more!
						//////////////////////////////////////////////////////
						// 12/31/2006: Confirmed! This one makes it MUCH BETTER!
						//if (weight < 1.0) weight = 0.0; // only consider same or bigger magnitude!
						// 4/7/2007: Confirmed: Don't do this! see NPAR results!
						///////////////////////////////////////////////////////////
						weight *= angle; // [0, 2]
						//weight *= GAU1[d1]; looks like Gaussian kernel doesn't make it better!
						//gx += weight * gfield[x][y].gx;
						//gy += weight * gfield[x][y].gy;
						gx += weight * gfield[x][y].gx * factor;
						gy += weight * gfield[x][y].gy * factor;
						w_sum += weight;
					}
				}
				////////////////////////////////////
				// Normalization
				gx /= w_sum;
				gy /= w_sum;
				//TRACE("gx[%d][%d] = %f\n", i, j, gx);
				//TRACE("gy[%d][%d] = %f\n", i, j, gy);
				gvf[i][j].gx = gx;
				gvf[i][j].gy = gy;
				//gvf[i][j].mag = mag; // also diffuse magnitude!
				//if (gvf[i][j].gx > 0.0)
				//	TRACE("gvf[%d][%d].gx = %f\n", i, j, gvf[i][j].gx);
				//TRACE("gvf[%d][%d].gy = %f\n", i, j, gvf[i][j].gy);
				/////////////////////////////////////
				//TRACE("N = %d\n", N);
				//TRACE("w_sum = %f\n", w_sum);
				//gau_mask.print();
				//if (image[i][j] > 255) image[i][j] = 255;
				//image[i][j] = (int)y;
			}
		}
		//TRACE("Elapsed Time = %f\n", ElapsedTime());
		ofstream outfile;
		outfile.open("Result_ETF.txt", ios::app);
		outfile << fixed << setprecision(1);
		outfile << "half_w = " << half_w << endl;
		outfile << "Elapsed Time = " << ElapsedTime() << endl;
		outfile.close();
		exit(1);
		//////////////////////////////
		gfield.copy(gvf);
		//TRACE("max_g = %f\n", max_g);
		//TRACE("min_g = %f\n", min_g);
	}
	////////////////////////////////////////////
}

void BilateralGfield11(CDC& dc, int image_x, int image_y, Field& gfield, double sigma, int M)
//////////////////////////////////////////////////////////////////////
// Simplified version for IEEE CG&A
{
	int	i, j, k;
	int MAX_GRADIENT = -1;
	double w_sum, weight;
	double gx, gy;
	int s, t;
	int x, y;
	int half_w;
	int d1;
	//int N;
	double mag_diff;

	Field gvf; // gvf: result of filtering 

	//////////////////////////////////
	//Make2DGaussMask(sigma); // mask for unilateral filtering
	//N = gau_mask.getRow();
	//half = N / 2;
	vector GAU1;
	MakeGaussVector(sigma, GAU1); // entire inner circle
	half_w = GAU1.getMax()-1;

	TRACE("TVF: half_w = %d\n", half_w);

	//matrix tmp_mask(N, N); // mask for bilateral filtering
	//tmp_mask.zero();

	gvf.init(gfield.getRow(), gfield.getCol()); // init gvf
	gvf.copy(gfield); // copy gfield to gvf_tmp

	vector v(2), w(2);
	double angle;
	double factor;
	//bool center_pixel;

	//gvf.normalize(); // normalize (gx, gy) vector (to get angle)
		
	//max_g = -1;
	//min_g = 10000000;
	for (k = 0; k < M; k++) {
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				//if (gfield[i][j].gx > 0.0)
				//	TRACE("gfield[%d][%d].gx = %f\n", i, j, gvf[i][j].gx);
				//if (gfield[i][j].mag > 0.0)
				//	TRACE("gfield[%d][%d].mag = %f\n", i, j, gvf[i][j].mag);
				gx = gy = 0.0;
				//mag = 0.0; // also diffuse magnitude!
				w_sum = 0.0;
				v[0] = gfield[i][j].gx;
				v[1] = gfield[i][j].gy;
				v.make_unit();
				for (s = -half_w; s <= half_w; s++) {
					for (t = -half_w; t <= half_w; t++) {
						////////////////////////////////////////
						x = i+s; y = j+t;
						if (x > IMAGE_X-1) x = IMAGE_X-1;
						else if (x < 0) x = 0;
						if (y > IMAGE_Y-1) y = IMAGE_Y-1;
						else if (y < 0) y = 0;
						/////////////////////////////////////////////////////////
						// circular kernel
						d1 = (int)dist2(x, y, i, j);
						if ( d1 > half_w ) continue; // this doesn't make any difference in speed
						/////////////////////////////////////
						////////////////////////////////////////
						mag_diff = gfield[x][y].mag - gfield[i][j].mag; 
						//////////////////////////////////////////////////////
						// 1/10/2007: If we remove "* PI", we can make it smoother?
						//mag_diff = mag_diff * PI; // turn it into Radian for tanh
						///////////////////////////////////////////////////
						//TRACE("mag_diff[%d][%d] = %f\n", i, j, mag_diff);
						w[0] = gfield[x][y].gx;
						w[1] = gfield[x][y].gy;
						w.make_unit();
						////////////////////////////////
						// Note: 0 is best, also, 360 is best
						// But, note that 180 is also good (exactly opposite direction!!!)
						//angle = v * w + 1; // [0, 2]
						//////////////////////////////////////////////
						// IMPORTANT!!!
						// When call acos(angle), make sure angle is in [0, 1]
						// if it's bigger than 1, then acos returns wrong number!!!
						// Removing this part can make it about 7 seconds faster!
						angle = v * w;
						if (angle > 1.0) angle = 1.0;
						if (angle < -1.0) angle = -1.0;
						///*
						angle = acos(angle) * 180 / PI; // [0, 180]
						factor = 1.0;
						if (angle > 90) {
							factor = -1.0; // reverse the direction
						}
						angle = ABS(90 - angle) / 90.0; // [0.0, 1.0]
						//*/
						/////////////////////////////////////////////////////////
						//weight = tanh(mag_diff) + 1; // [0, 2] // this part takes up 5 seconds more!
						weight = mag_diff + 1; // [0, 2] // this part takes up 5 seconds more!
						//////////////////////////////////////////////////////
						// 12/31/2006: Confirmed! This one makes it MUCH BETTER!
						//if (weight < 1.0) weight = 0.0; // only consider same or bigger magnitude!
						// 4/7/2007: Confirmed: Don't do this! see NPAR results!
						///////////////////////////////////////////////////////////
						//weight *= angle; // [0, 2]
						//weight *= GAU1[d1]; looks like Gaussian kernel doesn't make it better!
						//gx += weight * gfield[x][y].gx;
						//gy += weight * gfield[x][y].gy;
						//factor = 1.0;
						gx += weight * gfield[x][y].gx * factor;
						gy += weight * gfield[x][y].gy * factor;
						w_sum += weight;
					}
				}
				////////////////////////////////////
				// Normalization
				gx /= w_sum;
				gy /= w_sum;
				//TRACE("gx[%d][%d] = %f\n", i, j, gx);
				//TRACE("gy[%d][%d] = %f\n", i, j, gy);
				gvf[i][j].gx = gx;
				gvf[i][j].gy = gy;
				//gvf[i][j].mag = mag; // also diffuse magnitude!
				//if (gvf[i][j].gx > 0.0)
				//	TRACE("gvf[%d][%d].gx = %f\n", i, j, gvf[i][j].gx);
				//TRACE("gvf[%d][%d].gy = %f\n", i, j, gvf[i][j].gy);
				/////////////////////////////////////
				//TRACE("N = %d\n", N);
				//TRACE("w_sum = %f\n", w_sum);
				//gau_mask.print();
				//if (image[i][j] > 255) image[i][j] = 255;
				//image[i][j] = (int)y;
			}
		}
		gfield.copy(gvf);
		//TRACE("max_g = %f\n", max_g);
		//TRACE("min_g = %f\n", min_g);
	}
	////////////////////////////////////////////
}

void BilateralGfield12(CDC& dc, int image_x, int image_y, Field& gfield, double sigma, int M)
//////////////////////////////////////////////////////////////////////
// Separated version
{
	int	i, j, k;
	int MAX_GRADIENT = -1;
	double w_sum, weight;
	double gx, gy;
	int s, t;
	int x, y;
	int half_w;
	//int N;
	double mag_diff;

	Field gvf; // gvf: result of filtering 

	//////////////////////////////////
	//Make2DGaussMask(sigma); // mask for unilateral filtering
	//N = gau_mask.getRow();
	//half = N / 2;
	vector GAU1;
	MakeGaussVector(sigma, GAU1); // entire inner circle
	half_w = GAU1.getMax()-1;

	TRACE("TVF: half_w = %d\n", half_w);

	//matrix tmp_mask(N, N); // mask for bilateral filtering
	//tmp_mask.zero();

	gvf.init(gfield.getRow(), gfield.getCol()); // init gvf
	gvf.copy(gfield); // copy gfield to gvf_tmp

	vector v(2), w(2);
	double angle;
	double factor;
	//bool center_pixel;

	//gvf.normalize(); // normalize (gx, gy) vector (to get angle)
		
	//StartTimer();
	//half_w = 10;
	//half_w = 4;
	//max_g = -1;
	//min_g = 10000000;
	for (k = 0; k < M; k++) {
		////////////////////////
		// horizontal
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				gx = gy = 0.0;
				//mag = 0.0; // also diffuse magnitude!
				w_sum = 0.0;
				v[0] = gfield[i][j].gx;
				v[1] = gfield[i][j].gy;
				v.make_unit();
				for (s = -half_w; s <= half_w; s++) {
					////////////////////////////////////////
					x = i+s; y = j;
					if (x > IMAGE_X-1) x = IMAGE_X-1;
					else if (x < 0) x = 0;
					if (y > IMAGE_Y-1) y = IMAGE_Y-1;
					else if (y < 0) y = 0;
					////////////////////////////////////////
					mag_diff = gfield[x][y].mag - gfield[i][j].mag; 
					//////////////////////////////////////////////////////
					w[0] = gfield[x][y].gx;
					w[1] = gfield[x][y].gy;
					w.make_unit();
					////////////////////////////////
					angle = v * w;
					if (angle > 1.0) angle = 1.0;
					if (angle < -1.0) angle = -1.0;
					///*
					angle = acos(angle) * 180 / PI; // [0, 180]
					factor = 1.0;
					if (angle > 90) {
						factor = -1.0; // reverse the direction
					}
					angle = ABS(90 - angle) / 90.0; // [0.0, 1.0]
					//*/
					/////////////////////////////////////////////////////////
					weight = tanh(mag_diff) + 1; // [0, 2] // this part takes up 5 seconds more!
					//weight = mag_diff + 1; // [0, 2] // this part takes up 5 seconds more!
					//////////////////////////////////////////////////////
					gx += weight * gfield[x][y].gx * factor;
					gy += weight * gfield[x][y].gy * factor;
					w_sum += weight;
				}
				////////////////////////////////////
				// Normalization
				gx /= w_sum;
				gy /= w_sum;
				//TRACE("gx[%d][%d] = %f\n", i, j, gx);
				//TRACE("gy[%d][%d] = %f\n", i, j, gy);
				gvf[i][j].gx = gx;
				gvf[i][j].gy = gy;
			}
		}
		gfield.copy(gvf);
		/////////////////////////////////
		// vertical
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				gx = gy = 0.0;
				//mag = 0.0; // also diffuse magnitude!
				w_sum = 0.0;
				v[0] = gfield[i][j].gx;
				v[1] = gfield[i][j].gy;
				v.make_unit();
				for (t = -half_w; t <= half_w; t++) {
					////////////////////////////////////////
					x = i; y = j+t;
					if (x > IMAGE_X-1) x = IMAGE_X-1;
					else if (x < 0) x = 0;
					if (y > IMAGE_Y-1) y = IMAGE_Y-1;
					else if (y < 0) y = 0;
					////////////////////////////////////////
					mag_diff = gfield[x][y].mag - gfield[i][j].mag; 
					//////////////////////////////////////////////////////
					w[0] = gfield[x][y].gx;
					w[1] = gfield[x][y].gy;
					w.make_unit();
					////////////////////////////////
					angle = v * w;
					if (angle > 1.0) angle = 1.0;
					if (angle < -1.0) angle = -1.0;
					///*
					angle = acos(angle) * 180 / PI; // [0, 180]
					factor = 1.0;
					if (angle > 90) {
						factor = -1.0; // reverse the direction
					}
					angle = ABS(90 - angle) / 90.0; // [0.0, 1.0]
					//*/
					/////////////////////////////////////////////////////////
					weight = tanh(mag_diff) + 1; // [0, 2] // this part takes up 5 seconds more!
					//weight = mag_diff + 1; // [0, 2] // this part takes up 5 seconds more!
					//////////////////////////////////////////////////////
					gx += weight * gfield[x][y].gx * factor;
					gy += weight * gfield[x][y].gy * factor;
					w_sum += weight;
				}
				////////////////////////////////////
				// Normalization
				gx /= w_sum;
				gy /= w_sum;
				//TRACE("gx[%d][%d] = %f\n", i, j, gx);
				//TRACE("gy[%d][%d] = %f\n", i, j, gy);
				gvf[i][j].gx = gx;
				gvf[i][j].gy = gy;
			}
		}
		gfield.copy(gvf);
		//TRACE("max_g = %f\n", max_g);
		//TRACE("min_g = %f\n", min_g);
	}
	//EndTimer("_Result_ETF.txt");
	/*
	ofstream outfile;
	outfile.open("Result_ETF.txt", ios::app);
	outfile << fixed << setprecision(1);
	outfile << "half_w = " << half_w << endl;
	outfile << "Elapsed Time = " << ElapsedTime() << endl;
	outfile.close();
	exit(1);
	*/
	////////////////////////////////////////////
}

void BilateralGfield13(CDC& dc, int image_x, int image_y, Field& gfield, double sigma, int M)
//////////////////////////////////////////////////////////////////////
// Separated version (optimized)
{
	int	i, j, k;
	int MAX_GRADIENT = -1;
	double weight;
	//double gx, gy;
	int s, t;
	int x, y;
	int half_w;
	//int N;
	double mag_diff;

	Field gvf; // gvf: result of filtering 

	//////////////////////////////////
	//Make2DGaussMask(sigma); // mask for unilateral filtering
	//N = gau_mask.getRow();
	//half = N / 2;
	vector GAU1;
	MakeGaussVector(sigma, GAU1); // entire inner circle
	half_w = GAU1.getMax()-1;

	TRACE("TVF: half_w = %d\n", half_w);

	//matrix tmp_mask(N, N); // mask for bilateral filtering
	//tmp_mask.zero();

	gvf.init(gfield.getRow(), gfield.getCol()); // init gvf
	gvf.copy(gfield); // copy gfield to gvf_tmp

	vector v(2), w(2), g(2);
	double angle;
	double factor;
	//bool center_pixel;

	//gvf.normalize(); // normalize (gx, gy) vector (to get angle)
		
	//StartTimer();
	//half_w = 25;
	//max_g = -1;
	//min_g = 10000000;
	for (k = 0; k < M; k++) {
		////////////////////////
		// horizontal
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				g[0] = g[1] = 0.0;
				//mag = 0.0; // also diffuse magnitude!
				//w_sum = 0.0;
				v[0] = gfield[i][j].gx;
				v[1] = gfield[i][j].gy;
				//v.make_unit();
				for (s = -half_w; s <= half_w; s++) {
					////////////////////////////////////////
					x = i+s; y = j;
					if (x > IMAGE_X-1) x = IMAGE_X-1;
					else if (x < 0) x = 0;
					if (y > IMAGE_Y-1) y = IMAGE_Y-1;
					else if (y < 0) y = 0;
					////////////////////////////////////////
					mag_diff = gfield[x][y].mag - gfield[i][j].mag; 
					//////////////////////////////////////////////////////
					w[0] = gfield[x][y].gx;
					w[1] = gfield[x][y].gy;
					//w.make_unit();
					////////////////////////////////
					factor = 1.0;
					////////////////////
					angle = v * w;
					//if (angle > 1.0) angle = 1.0;
					//if (angle < -1.0) angle = -1.0;
					///*
					//angle = acos(angle) * 180 / PI; // [0, 180]
					//if (angle > 90) {
					if (angle < 0.0) {
						factor = -1.0; // reverse the direction
					}
					//angle = ABS(90 - angle) / 90.0; // [0.0, 1.0]
					//*/
					/////////////////////////////////////////////////////////
					//weight = tanh(mag_diff) + 1; // [0, 2] // this part takes up 5 seconds more!
					weight = mag_diff + 1; // [0, 2] // this part takes up 5 seconds more!
					//////////////////////////////////////////////////////
					g[0] += weight * gfield[x][y].gx * factor;
					g[1] += weight * gfield[x][y].gy * factor;
					//w_sum += weight;
				}
				////////////////////////////////////
				// Normalization
				//gx /= w_sum;
				//gy /= w_sum;
				//TRACE("gx[%d][%d] = %f\n", i, j, gx);
				//TRACE("gy[%d][%d] = %f\n", i, j, gy);
				g.make_unit();
				gvf[i][j].gx = g[0];
				gvf[i][j].gy = g[1];
			}
		}
		gfield.copy(gvf);
		/////////////////////////////////
		// vertical
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				g[0] = g[1] = 0.0;
				//mag = 0.0; // also diffuse magnitude!
				//w_sum = 0.0;
				v[0] = gfield[i][j].gx;
				v[1] = gfield[i][j].gy;
				//v.make_unit();
				for (t = -half_w; t <= half_w; t++) {
					////////////////////////////////////////
					x = i; y = j+t;
					if (x > IMAGE_X-1) x = IMAGE_X-1;
					else if (x < 0) x = 0;
					if (y > IMAGE_Y-1) y = IMAGE_Y-1;
					else if (y < 0) y = 0;
					////////////////////////////////////////
					mag_diff = gfield[x][y].mag - gfield[i][j].mag; 
					//////////////////////////////////////////////////////
					w[0] = gfield[x][y].gx;
					w[1] = gfield[x][y].gy;
					//w.make_unit();
					////////////////////////////////
					factor = 1.0;
					///////////////////////////////
					angle = v * w;
					//if (angle > 1.0) angle = 1.0;
					//if (angle < -1.0) angle = -1.0;
					///*
					//angle = acos(angle) * 180 / PI; // [0, 180]
					if (angle < 0.0) {
						factor = -1.0; // reverse the direction
					}
					//angle = ABS(90 - angle) / 90.0; // [0.0, 1.0]
					//*/
					/////////////////////////////////////////////////////////
					//weight = tanh(mag_diff) + 1; // [0, 2] // this part takes up 5 seconds more!
					weight = mag_diff + 1; // [0, 2] // this part takes up 5 seconds more!
					//////////////////////////////////////////////////////
					g[0] += weight * gfield[x][y].gx * factor;
					g[1] += weight * gfield[x][y].gy * factor;
					//w_sum += weight;
				}
				////////////////////////////////////
				// Normalization
				//gx /= w_sum;
				//gy /= w_sum;
				//TRACE("gx[%d][%d] = %f\n", i, j, gx);
				//TRACE("gy[%d][%d] = %f\n", i, j, gy);
				g.make_unit();
				gvf[i][j].gx = g[0];
				gvf[i][j].gy = g[1];
			}
		}
		gfield.copy(gvf);
		//TRACE("max_g = %f\n", max_g);
		//TRACE("min_g = %f\n", min_g);
	}
	//EndTimer("_Result_ETF.txt");
	////////////////////////////////////////////
}


void BilateralGfield2(int image_x, int image_y, Field& gfield, double sigma, double sigma2, int M)
// Adaptive version
{
	int	i, j;
	int MAX_GRADIENT = -1;
	double w_sum;
	double gx, gy;
	int s, t;
	int x, y, z;
	int half;
	double w_sim, w_all;
	double mag_diff;
	int gau_w;

	Field gvf; // gvf: result of filtering 

    //////////////////////////////////
	//Make2DGaussMask(sigma); // mask for unilateral filtering

	//N = gau_mask.getRow();
	//half = N / 2;

	//matrix tmp_mask(N, N); // mask for bilateral filtering
	//tmp_mask.zero();

	//imatrix tmp(IMAGE_X, IMAGE_Y);
	//matrix tmp2(IMAGE_X, IMAGE_Y);
	//tmp2.zero();
	
	gvf.init(gfield.getRow(), gfield.getCol()); // init gvf
	gvf.copy(gfield); // copy gfield to gvf_tmp
	//gvf.zero(); // initialize
	//gvf_tmp.init(gfield.getRow(), gfield.getCol()); // init gvf
	//gvf.copy(gfield); // copy gfield to gvf_tmp
	//gvf_tmp.copy(gfield); // copy gfield to gvf_tmp
	//gau_w = MakeGaussMask(3.0, gau);
		
	int k;
	//max_g = -1;
	//min_g = 10000000;
	for (z = 0; z < M; z++) {
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				//if (gfield[i][j].gx > 0.0)
				//	TRACE("gfield[%d][%d].gx = %f\n", i, j, gvf[i][j].gx);
				//if (gfield[i][j].mag > 0.0)
				//	TRACE("gfield[%d][%d].mag = %f\n", i, j, gvf[i][j].mag);
				//sigma = ((double)gray2[i][j] / 255.0) * 10.0 + 0.1;
				//sigma = exp( 4 * (double)gray2[i][j] / 255.0) - 0.9;
				sigma = exp( 3 * (double)gray2[i][j] / 255.0);
				gau_w = MakeGaussMask(sigma, gau);
				gx = gy = 0.0;
				w_sum = 0.0;
				half = gau_w-1;
				for (s = -half; s <= half; s++) {
					for (t = -half; t <= half; t++) {
						x = i+s; y = j+t;
						/////////////////////////////////////////////////////////
						// circular kernel
						k = (int)dist2(x, y, i, j);
						if ( k > half ) continue; 
						//////////////////////////////////////////////////
						if (x > IMAGE_X-1) x = IMAGE_X-1;
						else if (x < 0) x = 0;
						if (y > IMAGE_Y-1) y = IMAGE_Y-1;
						else if (y < 0) y = 0;
						/////////////////////////////////////////////////////
						mag_diff = gfield[x][y].mag - gfield[i][j].mag; 
						//mag_diff *= 0.001;
						w_sim = exp(mag_diff);
						//////////////////////////////////////////
						//tmp_mask[s][t] = w_sim * gau_mask[s][t];
						w_all = w_sim * gau[k];
						gx += w_all * gfield[x][y].gx;
						gy += w_all * gfield[x][y].gy;
						w_sum += w_all;
						//TRACE("k = %d\n", k);
						//TRACE("gau[%d] = %f\n", k, gau[k]);
					}
				}
				//TRACE("i = %d, j = %d\n", i, j);
				//TRACE("g = %f\n", g);
				//tmp2[i][j] = g;
				////////////////////////////////////
				// Normalization
				gx /= w_sum;
				gy /= w_sum;
				gvf[i][j].gx = gx;
				gvf[i][j].gy = gy;
				//if (gvf[i][j].gx > 0.0)
				//	TRACE("gvf[%d][%d].gx = %f\n", i, j, gvf[i][j].gx);
				//TRACE("gvf[%d][%d].gy = %f\n", i, j, gvf[i][j].gy);
				/////////////////////////////////////
				//TRACE("N = %d\n", N);
				//TRACE("w_sum = %f\n", w_sum);
				//gau_mask.print();
				//if (image[i][j] > 255) image[i][j] = 255;
				//image[i][j] = (int)y;
			}
		}
		gfield.copy(gvf);
		//TRACE("max_g = %f\n", max_g);
		//TRACE("min_g = %f\n", min_g);
	}
	////////////////////////////////////////////
}

void BilateralGfield3(int image_x, int image_y, Field& gfield, double factor, double sigma2, int M)
// Adaptive version & FAST
{
	int	i, j;
	int MAX_GRADIENT = -1;
	double w_sum;
	double gx, gy;
	int s, t;
	int x, y, z;
	int half;
	double w_sim, w_all;
	double mag_diff;
	int index;

	Field gvf; // gvf: result of filtering 

    //////////////////////////////////
	//Make2DGaussMask(sigma); // mask for unilateral filtering

	//N = gau_mask.getRow();
	//half = N / 2;

	//matrix tmp_mask(N, N); // mask for bilateral filtering
	//tmp_mask.zero();

	//imatrix tmp(IMAGE_X, IMAGE_Y);
	//matrix tmp2(IMAGE_X, IMAGE_Y);
	//tmp2.zero();
	
	gvf.init(gfield.getRow(), gfield.getCol()); // init gvf
	gvf.copy(gfield); // copy gfield to gvf_tmp
	//gvf.zero(); // initialize
	//gvf_tmp.init(gfield.getRow(), gfield.getCol()); // init gvf
	//gvf.copy(gfield); // copy gfield to gvf_tmp
	//gvf_tmp.copy(gfield); // copy gfield to gvf_tmp
	//gau_w = MakeGaussMask(3.0, gau);
	MakeGaussMatrix(factor, GAU);
		
	int k;
	//max_g = -1;
	//min_g = 10000000;
	for (z = 0; z < M; z++) {
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				//if (gfield[i][j].gx > 0.0)
				//	TRACE("gfield[%d][%d].gx = %f\n", i, j, gvf[i][j].gx);
				//if (gfield[i][j].mag > 0.0)
				//	TRACE("gfield[%d][%d].mag = %f\n", i, j, gvf[i][j].mag);
				//sigma = ((double)gray2[i][j] / 255.0) * 10.0 + 0.1;
				//sigma = exp( 4 * (double)gray2[i][j] / 255.0) - 0.9;
				//sigma = exp( 3 * (double)gray2[i][j] / 255.0);
				//gau_w = MakeGaussMask(sigma, gau);
				gx = gy = 0.0;
				w_sum = 0.0;
				index = gray2[i][j];
				//if (index == 0)
				//	TRACE("GAU_W[%d] = %d\n", index, GAU_W[index]);
				//half = gau_w-1;
				half = GAU_W[index]-1;
				//TRACE("GAU_W[%d] = %d\n", index, GAU_W[index]);
				for (s = -half; s <= half; s++) {
					for (t = -half; t <= half; t++) {
						x = i+s; y = j+t;
						/////////////////////////////////////////////////////
						if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
							continue;
						/////////////////////////////////////////////////////////
						// circular kernel
						k = (int)dist2(x, y, i, j);
						//k = round( dist2(x, y, i, j) );
						if ( k > half ) continue; 
						/////////////////////////////////////////////////////
						mag_diff = gfield[x][y].mag - gfield[i][j].mag; 
						//mag_diff *= 0.001;
						w_sim = exp(mag_diff);
						//////////////////////////////////////////
						//tmp_mask[s][t] = w_sim * gau_mask[s][t];
						//w_all = w_sim * gau[k];
						w_all = w_sim * GAU[index][k];
						//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
						gx += w_all * gfield[x][y].gx;
						gy += w_all * gfield[x][y].gy;
						w_sum += w_all;
						//TRACE("k = %d\n", k);
						//TRACE("gau[%d] = %f\n", k, gau[k]);
					}
				}
				//TRACE("i = %d, j = %d\n", i, j);
				//TRACE("g = %f\n", g);
				//tmp2[i][j] = g;
				////////////////////////////////////
				// Normalization
				gx /= w_sum;
				gy /= w_sum;
				gvf[i][j].gx = gx;
				gvf[i][j].gy = gy;
				//if (gvf[i][j].gx > 0.0)
				//	TRACE("gvf[%d][%d].gx = %f\n", i, j, gvf[i][j].gx);
				//TRACE("gvf[%d][%d].gy = %f\n", i, j, gvf[i][j].gy);
				/////////////////////////////////////
				//TRACE("N = %d\n", N);
				//TRACE("w_sum = %f\n", w_sum);
				//gau_mask.print();
				//if (image[i][j] > 255) image[i][j] = 255;
				//image[i][j] = (int)y;
			}
		}
		gfield.copy(gvf);
		//TRACE("max_g = %f\n", max_g);
		//TRACE("min_g = %f\n", min_g);
	}
	////////////////////////////////////////////
}

void BilateralGfield4(int image_x, int image_y, Field& gfield, double factor, int M)
// Adaptive version & FAST
// This one does not use distance field, but uses the Sobel gradient magnitude
// to determine kernel size at each pixel
{
	int	i, j;
	int MAX_GRADIENT = -1;
	double w_sum;
	double gx, gy;
	int s, t;
	int x, y, z;
	int half;
	double w_sim, w_all;
	double mag_diff;
	int index;

	Field gvf; // gvf: result of filtering 

    gvf.init(gfield.getRow(), gfield.getCol()); // init gvf
	gvf.copy(gfield); // copy gfield to gvf_tmp
	//gvf.zero(); // initialize
	//gvf_tmp.init(gfield.getRow(), gfield.getCol()); // init gvf
	//gvf.copy(gfield); // copy gfield to gvf_tmp
	//gvf_tmp.copy(gfield); // copy gfield to gvf_tmp
	//gau_w = MakeGaussMask(3.0, gau);
	MakeGaussMatrix(factor, GAU);
		
	int k;
	//max_g = -1;
	//min_g = 10000000;
	for (z = 0; z < M; z++) {
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				//if (gfield[i][j].gx > 0.0)
				//	TRACE("gfield[%d][%d].gx = %f\n", i, j, gvf[i][j].gx);
				//if (gfield[i][j].mag > 0.0)
				//	TRACE("gfield[%d][%d].mag = %f\n", i, j, gvf[i][j].mag);
				//sigma = ((double)gray2[i][j] / 255.0) * 10.0 + 0.1;
				//sigma = exp( 4 * (double)gray2[i][j] / 255.0) - 0.9;
				//sigma = exp( 3 * (double)gray2[i][j] / 255.0);
				//gau_w = MakeGaussMask(sigma, gau);
				gx = gy = 0.0;
				w_sum = 0.0;
				//index = gray2[i][j]; // distance field. high intensity -> bigger window
				index = (int)(255 - gfield[i][j].mag * 255); // Sobel gradient. high mag -> small window!
				//if (index == 0)
				//	TRACE("GAU_W[%d] = %d\n", index, GAU_W[index]);
				//half = gau_w-1;
				half = GAU_W[index]-1;
				//TRACE("GAU_W[%d] = %d\n", index, GAU_W[index]);
				for (s = -half; s <= half; s++) {
					for (t = -half; t <= half; t++) {
						x = i+s; y = j+t;
						/////////////////////////////////////////////////////
						if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
							continue;
						/////////////////////////////////////////////////////////
						// circular kernel
						k = (int)dist2(x, y, i, j);
						//k = round( dist2(x, y, i, j) );
						if ( k > half ) continue; 
						/////////////////////////////////////////////////////
						mag_diff = gfield[x][y].mag - gfield[i][j].mag; 
						//mag_diff *= 0.001;
						w_sim = exp(mag_diff);
						//////////////////////////////////////////
						//tmp_mask[s][t] = w_sim * gau_mask[s][t];
						//w_all = w_sim * gau[k];
						w_all = w_sim * GAU[index][k];
						//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
						gx += w_all * gfield[x][y].gx;
						gy += w_all * gfield[x][y].gy;
						w_sum += w_all;
						//TRACE("k = %d\n", k);
						//TRACE("gau[%d] = %f\n", k, gau[k]);
					}
				}
				//TRACE("i = %d, j = %d\n", i, j);
				//TRACE("g = %f\n", g);
				//tmp2[i][j] = g;
				////////////////////////////////////
				// Normalization
				gx /= w_sum;
				gy /= w_sum;
				gvf[i][j].gx = gx;
				gvf[i][j].gy = gy;
				//if (gvf[i][j].gx > 0.0)
				//	TRACE("gvf[%d][%d].gx = %f\n", i, j, gvf[i][j].gx);
				//TRACE("gvf[%d][%d].gy = %f\n", i, j, gvf[i][j].gy);
				/////////////////////////////////////
				//TRACE("N = %d\n", N);
				//TRACE("w_sum = %f\n", w_sum);
				//gau_mask.print();
				//if (image[i][j] > 255) image[i][j] = 255;
				//image[i][j] = (int)y;
			}
		}
		gfield.copy(gvf);
		//TRACE("max_g = %f\n", max_g);
		//TRACE("min_g = %f\n", min_g);
	}
	////////////////////////////////////////////
}


void MarkEdgePixels(int x, int y, imatrix& tmp, Field& gfield)
// following the flow, mark the pixels along the flow
{
	double d_i, d_j, tx, ty, nx, ny;
	int int_i, int_j;
	double t;

	//pnts.clear();
	
	//sum = 0; 
	//count = 1;
	//sum += (int)RGB_GETRED(double_buffer.GetPixel(x, IMAGE_Y-1-y));
	////////////////////////////////////
	t = 1.0;
	////////////////////////////////////////////////
	// One half
	d_i = (double)x; d_j = (double)y; 
	tx = -gfield[x][y].gy;
	ty = gfield[x][y].gx;
	int_i = x;	int_j = y;
	while (1) {
		if (tx == 0.0 && ty == 0.0) break;
		///////////////////////////////////////
		nx = tx / sqrt(tx*tx+ty*ty);  // x component of the unit direction vector 
		ny = ty / sqrt(tx*tx+ty*ty);  // y component of the unit direction vector
		////////////////////////////////
		//////////////////////////////
		d_i += nx * t; // accurate new location x
		d_j += ny * t; // accurate new location y
        ///////////////////////////
		if (round(d_i) == int_i && round(d_j) == int_j) // no change
			continue; // push some more
		/////////////////////////////////////////
		int_i = round(d_i); // integer version of new location x
		int_j = round(d_j); // integer version of new location y
		if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		//////////////////////////////////////////////////
		if (tmp[int_i][int_j] == 0) // already marked!
			break;
		tmp[int_i][int_j] = 0; // mark it!
		/////////////////////////////////
		//d_i = (double)int_i;
		//d_j = (double)int_j;
		//////////////////////////////////
		tx = -gfield[int_i][int_j].gy;
		ty = gfield[int_i][int_j].gx;
	}
	///////////////////////////////////////
	// other half
	///*
	d_i = (double)x; d_j = (double)y; 
	int_i = x;	int_j = y;
	tx = -gfield[x][y].gy;
	ty = gfield[x][y].gx;
	while (1) {
		if (tx == 0.0 && ty == 0.0) break;
		///////////////////////////////////////
		nx = tx / sqrt(tx*tx+ty*ty);  // x component of the direction vector 
		ny = ty / sqrt(tx*tx+ty*ty);  // y component of the direction vector
		////////////////////////////////
		//////////////////////////////
		d_i -= nx * t; // accurate new location x
		d_j -= ny * t; // accurate new location y
		///////////////////////////
		if (round(d_i) == int_i && round(d_j) == int_j) // no change
			continue; // push some more
		//////////////////////////////////////
		int_i = round(d_i); // integer version of new location x
		int_j = round(d_j); // integer version of new location y
		if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		////////////////////////////////////////////////
		if (tmp[int_i][int_j] == 0) // already marked!
			break;
		tmp[int_i][int_j] = 0; // mark it!
		/////////////////////////////////
		//d_i = (double)int_i;
		//d_j = (double)int_j;
		/////////////////////////////////
		tx = -gfield[int_i][int_j].gy;
		ty = gfield[int_i][int_j].gx;
	}
	//*/
		
	
}

		
void FlowConnectEdges(int image_x, int image_y, imatrix& image, Field& gfield)
// Connect edges after Canny's edge detection, based on Gfield
{
	//int	dx, dy;
	int	i, j;
	
	imatrix tmp(IMAGE_X, IMAGE_Y);
	tmp.copy(image);

	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			//gx = gy = 0.0;
			//w_sum = 0.0;
			if (image[i][j] == 0) {
				MarkEdgePixels(i, j, tmp, gfield);
			}
		}
	}

	image.copy(tmp);
	////////////////////////////////////////////
}


void AdaptiveGaussianBlur(CDC& dc, int image_x, int image_y, double factor)
// Adaptive version of Gaussian blur
// and draw the result on dc
{
	int	i, j;
	int MAX_GRADIENT = -1;
	int s, t;
	int x, y;
	int half;
	int index;
	int r, g, b;
	double sum_r, sum_g, sum_b, w_sum;

    //////////////////////////////////
	//Make2DGaussMask(sigma); // mask for unilateral filtering

	//N = gau_mask.getRow();
	//half = N / 2;

	//matrix tmp_mask(N, N); // mask for bilateral filtering
	//tmp_mask.zero();

	ClearMemDC(&dc); // clear the canvas white
	//imatrix tmp(IMAGE_X, IMAGE_Y);
	//matrix tmp2(IMAGE_X, IMAGE_Y);
	//tmp.zero();
	
	//gvf.init(gfield.getRow(), gfield.getCol()); // init gvf
	//gvf.copy(gfield); // copy gfield to gvf_tmp
	//////////////////////////////////////////////
	MakeGaussMatrix(factor, GAU);

	/*
	for (i = 0; i < 256; i++) {
		for (j = 0; j < GAU.getCol(); j++) {
			TRACE("GAU[%d][%d] = %.3f ", i, j, GAU[i][j]);
		}
		TRACE("\n");
	}
	*/
	Backbuffer = new GLubyte [IMAGE_Y * IMAGE_X * 3];
	//////////////////////////////////////////////////////////////
	// Copy memDC2 to Backbuffer
	for (j = 0; j < IMAGE_Y; j++) {
		for (i = 0; i < IMAGE_X; i++) {
			//r = (GLubjte)RGB_GETRED(memDC2.GetPiiel(i, j));
			//g = (GLubjte)RGB_GETGREEN(memDC2.GetPiiel(i, j));
			//b = (GLubjte)RGB_GETBLUE(memDC2.GetPiiel(i, j));
			Backbuffer[(j * IMAGE_X + i) * 3 + 0] = 0;
			Backbuffer[(j * IMAGE_X + i) * 3 + 1] = 0;
			Backbuffer[(j * IMAGE_X + i) * 3 + 2] = 0;
		}
	}

	//gau_w = MakeGaussMask(4.0, gau); // window 20x20
		
	int k;
	//max_g = -1;
	//min_g = 10000000;
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			index = gray2[i][j];
			//if (index > 155)
			//	index = 255; // distant enough, then give it biggest smoothing kernel
			//if (index == 0)
			//	TRACE("GAU_W[%d] = %d\n", index, GAU_W[index]);
			//half = gau_w-1;
			sum_r = sum_g = sum_b = 0.0;
			w_sum = 0.0;
			half = GAU_W[index]-1;
			//half = 8;
			//TRACE("GAU_W[%d] = %d\n", index, GAU_W[index]);
			for (s = -half; s <= half; s++) {
				for (t = -half; t <= half; t++) {
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					//k = round( dist2(x, y, i, j) );
					if ( k > half ) continue; 
					/////////////////////////////////////////////////////
					r = Dbuffer[(y * IMAGE_X + x) * 3 + 0];
					g = Dbuffer[(y * IMAGE_X + x) * 3 + 1];
					b = Dbuffer[(y * IMAGE_X + x) * 3 + 2];
					//////////////////////////////////////////
					//tmp_mask[s][t] = w_sim * gau_mask[s][t];
					//w_all = w_sim * gau[k];
					sum_r += (double)r * GAU[index][k];
					sum_g += (double)g * GAU[index][k];
					sum_b += (double)b * GAU[index][k];
					w_sum += GAU[index][k];
					//sum_r += (double)r * gau[k];
					//sum_g += (double)g * gau[k];
					//sum_b += (double)b * gau[k];
					//w_sum += gau[k];
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			//TRACE("w_sum = %.6f\n", w_sum);
			/*
			if (i == 0 && j == 0) {
				TRACE("i = %d j = %d\n", i, j);
				TRACE("r = %d g = %d b = %d\n", r, g, b);
				TRACE("index = %d\n", index);
				TRACE("sum_r = %.6f w_sum = %.6f sum_r/w_sum = %.6f\n", sum_r, w_sum, sum_r/w_sum);
				TRACE("sum_g = %.6f w_sum = %.6f sum_g/w_sum = %.6f\n", sum_g, w_sum, sum_g/w_sum);
				TRACE("sum_b = %.6f w_sum = %.6f sum_b/w_sum = %.6f\n", sum_b, w_sum, sum_b/w_sum);
			}
			*/
			//TRACE("w_sum = %.6f\n", w_sum);
			//TRACE("w_sum = %.6f\n", w_sum);
			
			sum_r /= w_sum; 
			sum_g /= w_sum; 
			sum_b /= w_sum; 
			/*
			if (i == 0 && j == 0) {
				TRACE("sum_r = %.6f \n", sum_r);
				TRACE("sum_g = %.6f \n", sum_g);
				TRACE("sum_b = %.6f \n", sum_b);
			}
			*/
			//r = (GLubyte)sum_r; 
			//g = (GLubyte)sum_g; 
			//b = (GLubyte)sum_b; 
			Backbuffer[(j * IMAGE_X + i) * 3 + 0] = (GLubyte)sum_r;
			Backbuffer[(j * IMAGE_X + i) * 3 + 1] = (GLubyte)sum_g;
			Backbuffer[(j * IMAGE_X + i) * 3 + 2] = (GLubyte)sum_b;
			//dc.SetPixelV(x, IMAGE_Y-1-y, RGB((GLubyte)sum_r, (GLubyte)sum_g, (GLubyte)sum_b));
		}
	}
	//TRACE("max_g = %f\n", max_g);
	//TRACE("min_g = %f\n", min_g);
	////////////////////////////////////////////
}

void GaussSmoothMemDC(int x, int y, int gau_w, int half, CDC& dc, GLubyte* buffer)
// Blur some region of memDC and put the result in memDC2
{
	int	i, j;
	//int MAX_GRADIENT = -1;
	double g, max_g, min_g;
	int count;
	int u, v;
	int half_gau;
    //int gau_w;
	int l, r, t, b;
	int x2, y2;
	//GLubyte z;
	//Image tmp;
	//Image target;
	    
	//gau_w = MakeGaussMask(4.0, gau); // 20x20 window
	//gau_w = MakeGaussMask(3.0, gau); // 16x16 window
	//gau_w = MakeGaussMask(2.0, gau); // 12x12 window
	//gau_w = MakeGaussMask(1.0, gau); // 6x6 window
	//TRACE("gau_w = %d\n", gau_w);
	half_gau = gau_w-1;

	imatrix tmp(IMAGE_X, IMAGE_Y);

	//Image tmp;
	l = x-half;
	if (l < 0) l = 0;
	r = x+half;
	if (r > IMAGE_X-1) r = IMAGE_X-1;
	t = y+half;
	if (t > IMAGE_Y-1) t = IMAGE_Y-1;
	b = y-half;
	if (b < 0) b = 0;

	/// copy memDC to tmp
	/*
	for (j = b; j <= t; j++) {
		for (i = l; i <= r; i++) {
			tmp[i][j] = (int)RGB_GETRED(memDC.GetPixel(i, IMAGE_Y-1-j));
			//TRACE("tmp[%d][%d] = %d\n", i, j, tmp[i][j]);
		}
	}
	*/
	int k;
	
	max_g = -1;
	min_g = 10000000;
	for (j = b; j <= t; j++) {
		for (i = l; i <= r; i++) {
			count = 0;
			g = 0.0;
			for (u = -half_gau; u <= half_gau; u++) {
				for (v = -half_gau; v <= half_gau; v++) {
					x2 = i+u; y2 = j+v;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x2, y2, i, j);
					if ( k > half_gau ) continue; 
					//////////////////////////////////////////////////
					if (x2 > IMAGE_X-1) x2 = IMAGE_X-1;
					else if (x2 < 0) x2 = 0;
					if (y2 > IMAGE_Y-1) y2 = IMAGE_Y-1;
					else if (y2 < 0) y2 = 0;
					//count++;					
					//g += gau[k] * (double)tmp[x2][y2];
					g += gau[k] * (double)RGB_GETRED(dc.GetPixel(x2, IMAGE_Y-1-y2));
					//TRACE("k = %d\n", k);
					//TRACE("gau[%d] = %f\n", k, gau[k]);
					//TRACE("tmp[%d][%d] = %d\n", x2, y2, tmp[x2][y2]);
				}
			}
			//TRACE("g = %f\n", g);
			//g /= count;
			//TRACE("x = %f, y = %f\n", x, y);
			//if (x > 255) x = 255;
			//if (y > 255) y = 255;
			if (g > max_g) max_g = g;
			if (g < min_g) min_g = g;
			//TRACE("max_g = %f\n", max_g);
			//image[x][y] = (int)g;
			////////////////////////////////////
			// We get the average because this is 2D circular summation!
			//g /= (2 * PI);
			g /= PI;
			//TRACE("g = %f\n", g);
			if (g > 255) g = 255;
			////////////////////////////////////
			buffer[j * IMAGE_X + i] = (GLubyte)g;
			//if (image[i][j] > 255) image[i][j] = 255;
			//image[i][j] = (int)y;
		}
	}
	
	/*
	TRACE("max_g = %f\n", max_g);
	TRACE("min_g = %f\n", min_g);
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			//image[i][j] = (int)(255 * (image[i][j] / max_g));
			image[i][j] = (int)(255 * ((image[i][j]-min_g) / (max_g-min_g)));
			// level adjustment
			//image[i][j] = (int)(255 * (pow((double)2, (double)image[i][j]/255.0)-1));
			image[i][j] = (int)(255 * pow((double)(image[i][j]/255.0), 5.0));
			//TRACE("image[%d][%d] = %d\n", i, j, image[i][j]);
			//if (image[i][j] > 0) image[i][j] = 255;
		}
	}
	*/
}

void GaussSmoothColorMemDC(int x, int y, int gau_w, int half, CDC& dc, GLubyte* buffer)
// Blur some region of color memDC and put the result in memDC2
{
	int	i, j;
	//int MAX_GRADIENT = -1;
	double g, max_g, min_g;
	int count;
	int u, v;
	int half_gau;
    //int gau_w;
	int l, r, t, b;
	int x2, y2;
	//GLubyte z;
	//Image tmp;
	//Image target;
	double rr, gg, bb;
	    
	//gau_w = MakeGaussMask(4.0, gau); // 20x20 window
	//gau_w = MakeGaussMask(3.0, gau); // 16x16 window
	//gau_w = MakeGaussMask(2.0, gau); // 12x12 window
	//gau_w = MakeGaussMask(1.0, gau); // 6x6 window
	//TRACE("gau_w = %d\n", gau_w);
	half_gau = gau_w-1;

	imatrix tmp(IMAGE_X, IMAGE_Y);

	//Image tmp;
	l = x-half;
	if (l < 0) l = 0;
	r = x+half;
	if (r > IMAGE_X-1) r = IMAGE_X-1;
	t = y+half;
	if (t > IMAGE_Y-1) t = IMAGE_Y-1;
	b = y-half;
	if (b < 0) b = 0;

	/// copy memDC to tmp
	/*
	for (j = b; j <= t; j++) {
		for (i = l; i <= r; i++) {
			tmp[i][j] = (int)RGB_GETRED(memDC.GetPixel(i, IMAGE_Y-1-j));
			//TRACE("tmp[%d][%d] = %d\n", i, j, tmp[i][j]);
		}
	}
	*/
	int k;
	
	max_g = -1;
	min_g = 10000000;
	for (j = b; j <= t; j++) {
		for (i = l; i <= r; i++) {
			count = 0;
			g = 0.0;
			for (u = -half_gau; u <= half_gau; u++) {
				for (v = -half_gau; v <= half_gau; v++) {
					x2 = i+u; y2 = j+v;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x2, y2, i, j);
					if ( k > half_gau ) continue; 
					//////////////////////////////////////////////////
					if (x2 > IMAGE_X-1) x2 = IMAGE_X-1;
					else if (x2 < 0) x2 = 0;
					if (y2 > IMAGE_Y-1) y2 = IMAGE_Y-1;
					else if (y2 < 0) y2 = 0;
					//count++;					
					//g += gau[k] * (double)tmp[x2][y2];
					rr = (double)RGB_GETRED(dc.GetPixel(x2, IMAGE_Y-1-y2));
					gg = (double)RGB_GETGREEN(dc.GetPixel(x2, IMAGE_Y-1-y2));
					bb = (double)RGB_GETBLUE(dc.GetPixel(x2, IMAGE_Y-1-y2));
					g += gau[k] * (rr+gg+bb)/3.0;
					//TRACE("k = %d\n", k);
					//TRACE("gau[%d] = %f\n", k, gau[k]);
					//TRACE("tmp[%d][%d] = %d\n", x2, y2, tmp[x2][y2]);
				}
			}
			//TRACE("g = %f\n", g);
			//g /= count;
			//TRACE("x = %f, y = %f\n", x, y);
			//if (x > 255) x = 255;
			//if (y > 255) y = 255;
			if (g > max_g) max_g = g;
			if (g < min_g) min_g = g;
			//TRACE("max_g = %f\n", max_g);
			//image[x][y] = (int)g;
			////////////////////////////////////
			// We get the average because this is 2D circular summation!
			//g /= (2 * PI);
			g /= PI;
			//TRACE("g = %f\n", g);
			if (g > 255) g = 255;
			////////////////////////////////////
			buffer[j * IMAGE_X + i] = (GLubyte)g;
			//if (image[i][j] > 255) image[i][j] = 255;
			//image[i][j] = (int)y;
		}
	}
	

}


void CopyMembuffer(int x, int y, int half, GLubyte* Membuffer, GLubyte* Doublebuffer)
{
	int	i, j;
	//int MAX_GRADIENT = -1;
    //int gau_w;
	int l, r, t, b;
	//GLubyte z;
	//Image tmp;
	//Image target;

	//Image tmp;
	l = x-half;
	if (l < 0) l = 0;
	r = x+half;
	if (r > IMAGE_X-1) r = IMAGE_X-1;
	t = y+half;
	if (t > IMAGE_Y-1) t = IMAGE_Y-1;
	b = y-half;
	if (b < 0) b = 0;

	/// copy memDC to tmp
	for (j = b; j <= t; j++) {
		for (i = l; i <= r; i++) {
			Doublebuffer[j * IMAGE_X + i] = Membuffer[j * IMAGE_X + i];
			//TRACE("tmp[%d][%d] = %d\n", i, j, tmp[i][j]);
		}
	}
	
}

void CopyCmap2Membuffer(cimatrix& cmap, GLubyte* Dbuffer)
{
	int	i, j;

	int image_x = cmap.getRow();
	int image_y = cmap.getCol();

	for (i = 0; i < image_x; i++) {
		for (j = 0; j < image_y; j++) {
			Dbuffer[(j * image_x + i) * 3 + 0] = cmap[i][j].r;
			Dbuffer[(j * image_x + i) * 3 + 1] = cmap[i][j].g;
			Dbuffer[(j * image_x + i) * 3 + 2] = cmap[i][j].b;
		}
	}
	
}

void CopyGray2Membuffer(imatrix& gray, GLubyte* Dbuffer)
{
	int	i, j;

	int image_x = gray.getRow();
	int image_y = gray.getCol();

	for (i = 0; i < image_x; i++) {
		for (j = 0; j < image_y; j++) {
			Dbuffer[(j * image_x + i) * 3 + 0] = gray[i][j];
			Dbuffer[(j * image_x + i) * 3 + 1] = gray[i][j];
			Dbuffer[(j * image_x + i) * 3 + 2] = gray[i][j];
		}
	}
	
}


void BlurImage(int image_x, int image_y, imatrix& image, int size)
{
	int	i, j;
	int MAX_GRADIENT = -1;
	double g;
	int count;
	int s, t;

	imatrix tmp(IMAGE_X, IMAGE_Y);
	
	/// copy image to tmp
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			tmp[i][j] = image[i][j];
		}
	}

	int half = size/2;

	for (j = 0; j < IMAGE_Y; j++) {
		for (i = 0; i < IMAGE_X; i++) {
			count = 0;
			g = 0.0;
			for (s = -half; s <= half; s++) {
				for (t = -half; t <= half; t++) {
					if (i+s > IMAGE_X-1 || i+s < 0 || j+t > IMAGE_Y-1 || j+t < 0)
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					if ( dist2(i+s, j+t, i, j) > half-1 ) continue; 
					//////////////////////////////////////////////////
					count++;					
					g += tmp[i+s][j+t];
				}
			}
			g /= count;
			//image2[i][j] = 0; // thin edge above hi_thres
			if (g > 0.0)
				image[i][j] = 255; // matched pixel
			else
				image[i][j] = 0; // matched pixel
		}
	}
}

void BlurImageCont(int image_x, int image_y, imatrix& image, int size)
// regions is assigned continuous value
{
	int	i, j;
	int MAX_GRADIENT = -1;
	double g;
	int count;
	int s, t;
	double max_g;

	imatrix tmp(IMAGE_X, IMAGE_Y);
	
	/// copy image to tmp
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			tmp[i][j] = image[i][j];
		}
	}

	int half = size/2;

	max_g = -1;
	for (j = 0; j < IMAGE_Y; j++) {
		for (i = 0; i < IMAGE_X; i++) {
			count = 0;
			g = 0.0;
			for (s = -half; s <= half; s++) {
				for (t = -half; t <= half; t++) {
					if (i+s > IMAGE_X-1 || i+s < 0 || j+t > IMAGE_Y-1 || j+t < 0)
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					if ( dist2(i+s, j+t, i, j) > half-1 ) continue; 
					//////////////////////////////////////////////////
					count++;					
					g += tmp[i+s][j+t];
				}
			}
			g /= count;
			if (g > max_g) {
				max_g = g;
			}
			//image2[i][j] = 0; // thin edge above hi_thres
			image[i][j] = (int)g; // matched pixel
			//TRACE("image[%d][%d] = %d\n", i, j, image[i][j]);
			//if (g > 0.0)
			//	image[i][j] = 255; // matched pixel
			//else
			//	image[i][j] = 0; // matched pixel
		}
	}

	////////////////////////////////////
	// Normalize
	for (j = 0; j < IMAGE_Y; j++) {
		for (i = 0; i < IMAGE_X; i++) {
			image[i][j] = (int)(255 * (image[i][j] / max_g));
		}
	}
}


void BlurMatrix(int image_x, int image_y, matrix& image, int size)
{
	int	i, j;
	int MAX_GRADIENT = -1;
	double g;
	int count;
	int s, t;

	matrix tmp(IMAGE_X, IMAGE_Y);
	
	/// copy image to tmp
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			tmp[i][j] = image[i][j];
		}
	}

	int half = size/2;

	for (j = 0; j < IMAGE_Y; j++) {
		for (i = 0; i < IMAGE_X; i++) {
			count = 0;
			g = 0.0;
			for (s = -half; s <= half; s++) {
				for (t = -half; t <= half; t++) {
					if (i+s > IMAGE_X-1 || i+s < 0 || j+t > IMAGE_Y-1 || j+t < 0)
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					if ( dist2(i+s, j+t, i, j) > half-1 ) continue; 
					//////////////////////////////////////////////////
					count++;					
					g += tmp[i+s][j+t];
				}
			}
			g /= count;
			//image2[i][j] = 0; // thin edge above hi_thres
			image[i][j] = g; // matched pixel
		}
	}
}


void OnGlobalCanny(CDC& dc, int image_x, int image_y, imatrix& image, imatrix& image2)
{
	if (file_loaded) {
		//CClientDC dc(this);
		//GetGrayImage(IMAGE_X, IMAGE_Y, gray, Dbuffer);
		gau_w = MakeGaussMask(cur_sigma, gau);
		//cur_sigma = 1.0;
		//dlg->m_Scale_Scroll.SetScrollPos((int)(cur_sigma*10));
		//dlg->m_slider.SetScrollPos(SB_HORZ, (int)(cur_sigma*10), TRUE);
		//dlg->m_scale_val;
		//GaussSmooth(IMAGE_X, IMAGE_Y, image, gau_w);
		max_grad2 = GlobalCanny(IMAGE_X, IMAGE_Y, gray, gray2, gau_w);
		//NonmaxSuppressGray(IMAGE_X, IMAGE_Y);
		DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
		//////////////////////////////
		emap.copy(gray2);
		////////////////////////////////
		/*
		//////////////////////////////////////////////////////
		// blur for stroke area
		//InvertImage(IMAGE_X, IMAGE_Y, gray2);
		//BlurImage(IMAGE_X, IMAGE_Y, gray2, 30);
		//BlurImageCont(IMAGE_X, IMAGE_Y, gray2, 30);
		//gau_w = MakeGaussMask(6.0, gau);
		gau_w = MakeGaussMask(10.0, gau);
		TRACE("gau_w = %d\n", gau_w);
		//GaussSmooth2(IMAGE_X, IMAGE_Y, gray2, gau_w);
		GaussSmooth3(IMAGE_X, IMAGE_Y, gray2, gau_w);
		//InvertImage(IMAGE_X, IMAGE_Y, gray2);
		DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
		///////////////////////////////////////////////////
		*/
		//DrawEdgeStrokes(memDC, IMAGE_X, IMAGE_Y, gray2);
        
		dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);


		
		//dlg.Create(IDD_DIALOG1);
		//dlg.ShowWindow(1);
		//dlg.SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOMOVE);
		//CRect rect;
		//dlg.GetWindowRect(rect); 
		//dlg.MoveWindow(0, 0, rect.right-rect.left, rect.bottom-rect.top, TRUE);
		//status = EDGE_PAINT;
	}
}

double GetCannyGradient(int image_x, int image_y, imatrix& image, int gau_w)
{
	int	i, j, k, i1, i2, j1, j2;
	int MAX_GRADIENT = -1;

	//image2.init(image_x, image_y);
	
	//imatrix tmp(image_x, image_y);
	double	x, y;
	
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			x = gau[0] * image[i][j];	
			y = gau[0] * image[i][j];
			//TRACE("x = %f, y = %f\n", x, y);
			for (k = 1; k < gau_w; k++) {
				i1 = (i+k)%image_x;
				i2 = (i-k+image_x)%image_x;
				x += gau[k] * image[i1][j] + gau[k] * image[i2][j];
				j1 = (j+k)%image_y;
				j2 = (j-k+image_y)%image_y;
				y += gau[k] * image[i][j1] + gau[k] * image[i][j2];
			}
			tmp_x[i][j] = x;
			tmp_y[i][j] = y;
			//TRACE("x = %f, y = %f\n", x, y);
			if (x > 255) x = 255;
			if (y > 255) y = 255;
			//image[i][j] = (int)x;
			//image[i][j] = (int)y;
		}
	}

	for (j = 1; j < image_y - 1; j++) {
		for (i = 1; i < image_x - 1; i++) {
			G_x[i][j] = (tmp_x[i+1][j-1] + 2*tmp_x[i+1][j] + tmp_x[i+1][j+1] 
				- tmp_x[i-1][j-1] - 2*tmp_x[i-1][j] - tmp_x[i-1][j+1]);
			G_y[i][j] = (tmp_y[i-1][j+1] + 2*tmp_y[i][j+1] + tmp_y[i+1][j+1]
				- tmp_y[i-1][j-1] - 2*tmp_y[i][j-1] - tmp_y[i+1][j-1]);
			//G_mag[i][j] = sqrt(G_x[i][j] * G_x[i][j] + G_y[i][j] * G_y[i][j]);
			G_mag[i][j] = norm2(G_x[i][j], G_y[i][j]);

			if (G_mag[i][j] > MAX_GRADIENT) {
				MAX_GRADIENT = round(G_mag[i][j]);
				//TRACE("p[i][j].gx = %01.f\n", p[i][j].gx);
				//TRACE("p[i][j].gy = %01.f\n", p[i][j].gy);
				//TRACE("MAX_GRADIENT = %0.1f\n", MAX_GRADIENT);
			}
		}
	}

	return MAX_GRADIENT;
}


void hyster_visit(int image_x, int image_y, int x0, int y0, imatrix& image2)
{
	int	i, j, x, y;
	int	done_flag;
	double g;

	//image2[x0][y0] = 0; // now marked as edge
	done_flag = 0;
	for (j = -1; j <= 1; j++) {
		for (i = -1; i <= 1; i++) {
			x = x0 + i;
			y = y0 + j;
			if (x <= 0 || x >= image_x-1 || y <= 0 || y >= image_y-1)
				continue;
			if (image2[x][y] == 0) continue; // already marked as edge
			if (!thin_edge[x][y]) continue; // not a thin edge
			g = G_mag[x][y];
			if (g > lo_thres) {
				image2[x][y] = 0; // newly marked as edge pixel
				hyster_visit(image_x, image_y, x, y, image2);
				//done_flag = 1; // found an extending edge pixel
				//break;
			}
		}
		//if (done_flag) break; // found the right neighboring edge pixel. Get out!
	}
}



double prob(double r, double g, double b, double gr, edge_dist& s)
{
	double p_r, p_g, p_b, p_gr;
	double p_val1, p_val2, p_val;

	p_r = gauss2(r, s.r_mean, s.r_std);
	p_g = gauss2(g, s.g_mean, s.g_std);
	p_b = gauss2(b, s.b_mean, s.b_std);
	p_gr = gauss2(gr, s.gr_mean, s.gr_std);

	if (s.r_mean == 0.0 && s.g_mean == 0.0 && s.b_mean == 0.0)
		return 0.0;
	else {
		/*
		TRACE("\n");
		TRACE("r = %f\n", r);
		TRACE("g = %f\n", g);
		TRACE("b = %f\n", b);
		TRACE("gr = %f\n", gr);
		TRACE("r_mean = %f\n", s.r_mean);
		TRACE("g_mean = %f\n", s.g_mean);
		TRACE("b_mean = %f\n", s.b_mean);
		TRACE("gr_mean = %f\n", s.gr_mean);
		TRACE("r_std = %f\n", s.r_std);
		TRACE("g_std = %f\n", s.g_std);
		TRACE("b_std = %f\n", s.b_std);
		TRACE("gr_std = %f\n", s.gr_std);
		TRACE("p_r = %f\n", p_r);
		TRACE("p_g = %f\n", p_g);
		TRACE("p_b = %f\n", p_b);
		TRACE("p_gr = %f\n", p_gr);
		*/
		//p_val = (p_r + p_g + p_b + p_gr) / 4.0; 
		p_val1 = (p_r + p_g + p_b) / 3.0; 
		p_val2 = p_gr;
		p_val = 0.6 * p_val1 + 0.4 * p_val2;
		//TRACE("\ngr = %f\n", gr);
		//TRACE("gr_mean = %f\n", s.gr_mean);
		//TRACE("gr_std = %f\n", s.gr_std);
		//TRACE("p_val = %f\n", p_val);
        
		return p_val;
	}
}

bool prob2(double r, double g, double b, double gr, edge_dist& s, double factor)
{
	//double factor;

	//factor = 3.5;

	//p_r = gauss2(r, s.r_mean, s.r_std);
	//p_g = gauss2(g, s.g_mean, s.g_std);
	//p_b = gauss2(b, s.b_mean, s.b_std);
	//p_gr = gauss2(gr, s.gr_mean, s.gr_std);

	if (s.r_mean == 0.0 && s.g_mean == 0.0 && s.b_mean == 0.0)
		return false;
	else {
		if ( ABS(r-s.r_mean) <= factor * s.r_std 
			&& ABS(g-s.g_mean) <= factor * s.g_std 
			&& ABS(b-s.b_mean) <= factor * s.b_std 
			&& ABS(gr-s.gr_mean) <= factor * s.gr_std)
			return true;
		else return false;
		/*
		TRACE("\n");
		TRACE("r = %f\n", r);
		TRACE("g = %f\n", g);
		TRACE("b = %f\n", b);
		TRACE("gr = %f\n", gr);
		TRACE("r_mean = %f\n", s.r_mean);
		TRACE("g_mean = %f\n", s.g_mean);
		TRACE("b_mean = %f\n", s.b_mean);
		TRACE("gr_mean = %f\n", s.gr_mean);
		TRACE("r_std = %f\n", s.r_std);
		TRACE("g_std = %f\n", s.g_std);
		TRACE("b_std = %f\n", s.b_std);
		TRACE("gr_std = %f\n", s.gr_std);
		*/
	}
}

void off_edge_visit(int image_x, int image_y, int x0, int y0)
{
	int	i, j, x, y;
	double g;
	GLubyte rr, gg, bb;

	off_mark[x0][y0] = 255; // newly marked as edge pixel to be removed
	gray2[x0][y0] = 255; // now marked as non-edge
	for (j = -1; j <= 1; j++) {
		for (i = -1; i <= 1; i++) {
			x = x0 + i;
			y = y0 + j;
			if (x <= 0 || x >= image_x-1 || y <= 0 || y >= image_y-1)
				continue;
			if (off_mark[x][y] == 255) continue; // already marked as edge to be removed
			if (gray2[x][y] == 255) continue; // already marked as non-edge
			//if (!thin_edge[x][y]) continue; // not a thin edge
			//g = G_mag[x][y];
			//if (image2[x][y] == 0 && off_mark[x][y] == 0) { // marked as edge
			rr = Dbuffer[(y * IMAGE_X + x) * 3 + 0];
			gg = Dbuffer[(y * IMAGE_X + x) * 3 + 1];
			bb = Dbuffer[(y * IMAGE_X + x) * 3 + 2];
			g = G_mag[x][y];
			if ( prob2((double)rr, (double)gg, (double)bb, g, off_edge, factor2) ) {
				off_edge_visit(image_x, image_y, x, y);
			}
		}
		//if (done_flag) break; // found the right neighboring edge pixel. Get out!
	}
}

void ConvertThinEdgeMap2GrayImage(int image_x, int image_y, imatrix& thin_edge, imatrix& image)
{
	int i, j;

	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			//TRACE("thin_edge[%d][%d] = %.3f\n", i, j, thin_edge[i][j]);
			//TRACE("thin_edge[%d][%d] = %d\n", i, j, thin_edge[i][j]);
			if (thin_edge[i][j]) {
				//TRACE("I'm thin edge!\n");
				image[i][j] = 0;
			}
			else image[i][j] = 255;
		}
	}
}

double GlobalCanny(int image_x, int image_y, imatrix& image, imatrix& image2, int gau_w)
{
	int	i, j, k, i1, i2, j1, j2;
	double MAX_GRADIENT = -1;
	GLubyte rr, gg, bb;

	//imatrix marked(image_x, image_y);
	//image2.init(image_x, image_y);
	
	//imatrix tmp(image_x, image_y);
	double	x, y;
	
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			x = gau[0] * image[i][j];	
			y = gau[0] * image[i][j];
			//TRACE("x = %f, y = %f\n", x, y);
			for (k = 1; k < gau_w; k++) {
				//i1 = (i+k)%image_x;
				//i2 = (i-k+image_x)%image_x;
				//j1 = (j+k)%image_y;
				//j2 = (j-k+image_y)%image_y;
				i1 = i+k;
				i2 = i-k;
				j1 = j+k;
				j2 = j-k;
				if (i1 > image_x-1) i1 = image_x-1;
				if (i2 < 0) i2 = 0;
				if (j1 > image_y-1) j1 = image_y-1;
				if (j2 < 0) j2 = 0;
				x += gau[k] * image[i1][j] + gau[k] * image[i2][j];
				y += gau[k] * image[i][j1] + gau[k] * image[i][j2];
			}
			tmp_x[i][j] = x;
			tmp_y[i][j] = y;
			//TRACE("x = %f, y = %f\n", x, y);
			if (x > 255) x = 255;
			if (y > 255) y = 255;
			//image[i][j] = (int)x;
			//image[i][j] = (int)y;
		}
	}

	for (j = 1; j < image_y - 1; j++) {
		for (i = 1; i < image_x - 1; i++) {
			G_x[i][j] = (tmp_x[i+1][j-1] + 2*tmp_x[i+1][j] + tmp_x[i+1][j+1] 
				- tmp_x[i-1][j-1] - 2*tmp_x[i-1][j] - tmp_x[i-1][j+1]);
			G_y[i][j] = (tmp_y[i-1][j+1] + 2*tmp_y[i][j+1] + tmp_y[i+1][j+1]
				- tmp_y[i-1][j-1] - 2*tmp_y[i][j-1] - tmp_y[i+1][j-1]);
			//G_mag[i][j] = sqrt(G_x[i][j] * G_x[i][j] + G_y[i][j] * G_y[i][j]);
			G_mag[i][j] = norm2(G_x[i][j], G_y[i][j]);

			/*
			if (G_mag[i][j] > MAX_GRADIENT) {
				MAX_GRADIENT = G_mag[i][j];
				//TRACE("p[i][j].gx = %01.f\n", p[i][j].gx);
				//TRACE("p[i][j].gy = %01.f\n", p[i][j].gy);
				//TRACE("MAX_GRADIENT = %0.1f\n", MAX_GRADIENT);
			}
			*/
		}
	}

	// Normalize each gradient value & init marked image
	//TRACE("MAX_GRADIENT = %f\n", MAX_GRADIENT);
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			if (i == 0 || i == image_x-1 || j == 0 || j == image_y-1) {
				image2[i][j] = 255;
				thin_edge[i][j] = 0; // init thin edge list
				continue;
			}
			G_mag[i][j] = (G_mag[i][j] / max_grad2); // G_mag between [0, 1]
			image2[i][j] = (int)(G_mag[i][j] * 255);

			//marked[i][j] = 0; // init marked image for hysteresis
			thin_edge[i][j] = 0; // init thin edge list
			scale_map[i][j] = cur_sigma; // for adaptive painterly rendering
		}
	}

	double	gx, gy;
	double	g, g1, g2, g3, g4;
	double	t; // interpolation parameter
	
	//////////////////////////////////////////
	// Nonmaxima suppression
	for (j = 1; j < image_y-1; j++) {
		for (i = 1; i < image_x-1; i++) {
			gx = G_x[i][j];
			gy = G_y[i][j];
			g = G_mag[i][j];
			//TRACE("gx = %f, gy = %f, g = %f\n", gx, gy, g);
			//if (gx < 0.01 && gy < 0.01) continue; // not an edge
			if (fabs(gx) >= fabs(gy)) { // close to horizontal (note: gy can be 0)
				t = fabs(gy) / fabs(gx); 
				//TRACE("t = %f\n", t);
				g1 = G_mag[i+1][j]; // right
				g2 = G_mag[i-1][j]; // left
				//TRACE("g1 = %f, g2 = %f\n", g1, g2);
				if (gx*gy >= 0.0) { // 1 or 3 quadrant
					g3 = G_mag[i+1][j+1]; // right up
					g4 = G_mag[i-1][j-1]; // left down
				}
				else { // 2 or 4 quadrant
					g3 = G_mag[i+1][j-1]; // right down
					g4 = G_mag[i-1][j+1]; // left up
				}
			}
			else { // close to vertical (note: gx can be 0)
				t = fabs(gx) / fabs(gy);
				g1 = G_mag[i][j+1]; // up
				g2 = G_mag[i][j-1]; // down
				if (gx*gy >= 0.0) { // 1 or 3 quadrant
					g3 = G_mag[i+1][j+1]; // up right
					g4 = G_mag[i-1][j-1]; // down left
				}
				else { // 2 or 4 quadrant
					g3 = G_mag[i-1][j+1]; // up left
					g4 = G_mag[i+1][j-1]; // down right
				}
			}
			if ( g > ((1-t)*g1 + t*g3) && g > ((1-t)*g2 + t*g4) ) {
				////////////////////////////////////////
				thin_edge[i][j] = 1; // it's a thin edge
				//////////////////////////////////////
				if (g > hi_thres) {
					
					rr = Dbuffer[(j * IMAGE_X + i) * 3 + 0];
					gg = Dbuffer[(j * IMAGE_X + i) * 3 + 1];
					bb = Dbuffer[(j * IMAGE_X + i) * 3 + 2];
					//p_val = prob((double)rr, (double)gg, (double)bb, g, off_edge);
					//TRACE("p_val = %f\n", p_val);
					/*
					if ( prob2((double)rr, (double)gg, (double)bb, g, off_edge) )
						image2[i][j] = 255; // off edge
					else 
						image2[i][j] = 0; // thin edge above hi_thres
					*/
					///*
					image2[i][j] = 0; // thin edge above hi_thres
					if ( prob2((double)rr, (double)gg, (double)bb, g, off_edge, factor1) )
						off_mark[i][j] = 255; // off edge
					//*/
					/*
					if ( p_val > 0.4 )
						image2[i][j] = 255; // off edge
					else 
						image2[i][j] = 0; // thin edge above hi_thres
					*/
				}
				else 
					image2[i][j] = 255; // thin edge below hi_thres
			}
			else { // non-maximum
				image2[i][j] = 255;
			}
			
		}
	}

	//////////////////////////////////////////
	// Hysteresis thresholding
	///*
	for (j = 1; j < image_y-1; j++) {
		for (i = 1; i < image_x-1; i++) {
			if (image2[i][j] == 0) { // computed thinned edges above hi_thres
				hyster_visit(image_x, image_y, i, j, image2); // visit neighboring pixels
			}
		}
	}
	//*/
	//////////////////////////////////////////
	// removing off_edges
	///*
	for (j = 1; j < image_y-1; j++) {
		for (i = 1; i < image_x-1; i++) {
			if (off_mark[i][j] == 255) { // marked off edge
				off_edge_visit(image_x, image_y, i, j); // visit neighboring pixels
			}
		}
	}
	//*/
	///////////////////////////////////////
	// clear the image border
	/*
	for (i = 0; i < image_x; i++) {
		image2[i][0] == 255;
		image2[i][image_y-1] == 255;
	}
	for (j = 0; j < image_y; j++) {
		image2[0][j] == 255;
		image2[image_x-1][j] == 255;
	}
	*/
	GLOBAL_CANNY_DONE = 1;
	
	return max_grad2;
}

void local_hyster_visit(int size, PixeL seed, int image_x, int image_y, int x0, int y0, imatrix& image2)
{
	int	i, j, x, y;
	int	done_flag;
	double g;
	int half;
	
	half = size/2;

	//image2[x0][y0] = 0; // now marked as edge
	done_flag = 0;
	for (j = -1; j <= 1; j++) {
		for (i = -1; i <= 1; i++) {
			x = x0 + i;
			y = y0 + j;
			if (x <= 0 || x >= image_x-1 || y <= 0 || y >= image_y-1)
				continue;
			if (image2[x][y] == 0) continue; // already marked as edge
			if (!thin_edge[x][y]) continue; // not a thin edge
			/////////////////////////////////////////////////////////
			// circular kernel
			if ( dist2(x, y, seed.x, seed.y) > half-1 ) continue; 
			//////////////////////////////////////////////////
			g = G_mag[x][y];
			if (g > lo_thres) {
				image2[x][y] = 0; // newly marked as edge pixel
				local_hyster_visit(size, seed, image_x, image_y, x, y, image2);
				//done_flag = 1; // found an extending edge pixel
				//break;
			}
		}
		//if (done_flag) break; // found the right neighboring edge pixel. Get out!
	}
}

edge_dist on_edge, off_edge, cur_edge;
pixel_dist pix_d[10];
int pix_d_count = -1;

void EdgeColor(CDC& dc, imatrix& gray2, int x0, int y0, GLubyte r, GLubyte g, GLubyte b)
{
	int i, j, x, y;
	GLubyte r1, g1, b1, r2, g2, b2;
	double a = 0.3; // learning rate
	double gr;

	dc.SetPixelV(x0, (IMAGE_Y-1)-y0, RGB(r, g, b));

	r1 = Dbuffer[(y0 * IMAGE_X + x0) * 3 + 0];
	g1 = Dbuffer[(y0 * IMAGE_X + x0) * 3 + 1];
	b1 = Dbuffer[(y0 * IMAGE_X + x0) * 3 + 2];
	gr = G_mag[x0][y0];

	//TRACE("gr = %.5f\n", gr);

	off_mark[x0][y0] = 1; // marked as sampled edge pixel
	//cur_edge.update((double)r1, (double)g1, (double)b1, gr);
	/*
	cur_edge.r_mean = (1-a) * cur_edge.r_mean + a * r1;
	cur_edge.g_mean = (1-a) * cur_edge.g_mean + a * g1;
	cur_edge.b_mean = (1-a) * cur_edge.b_mean + a * b1;
	cur_edge.gr_mean = (1-a) * cur_edge.gr_mean + a * gr;
	cur_edge.r_std = (1-a) * cur_edge.r_std + a * (r1 - cur_edge.r_mean);
	cur_edge.g_std = (1-a) * cur_edge.g_std + a * (g1 - cur_edge.g_mean);
	cur_edge.b_std = (1-a) * cur_edge.b_std + a * (b1 - cur_edge.b_mean);
	cur_edge.gr_std = (1-a) * cur_edge.gr_std + a * (gr - cur_edge.gr_mean);
	*/

	for (j = -1; j <= 1; j++) {
		for (i = -1; i <= 1; i++) {
			x = x0 + i;
			y = y0 + j;
			if (x <= 0 || x >= IMAGE_X-1 || y <= 0 || y >= IMAGE_Y-1)
				continue;
			if (gray2[x][y] == 255) continue; // not an edge pixel
			r2 = (GLubyte)RGB_GETRED(dc.GetPixel(x, (IMAGE_Y-1)-y));
			g2 = (GLubyte)RGB_GETGREEN(dc.GetPixel(x, (IMAGE_Y-1)-y));
			b2 = (GLubyte)RGB_GETBLUE(dc.GetPixel(x, (IMAGE_Y-1)-y));
			if (r2 == r && g2 == g && b2 == b) continue; // already marked as selected
			//if (!thin_edge[x][y]) continue; // not a thin edge
			/////////////////////////////////////////////////////////
			// circular kernel
			//if ( dist2(x, y, seed.x, seed.y) > half-1 ) continue; 
			//////////////////////////////////////////////////
			if (gray2[x][y] == 0) { // edge pixel
				EdgeColor(dc, gray2, x, y, r, g, b);
				//done_flag = 1; // found an extending edge pixel
				//break;
			}
		}
		//if (done_flag) break; // found the right neighboring edge pixel. Get out!
	}
}

void UpdateEdgeDist(edge_dist& edge, imatrix& mark)
{
	int x, y, count;
	GLubyte rr, gg, bb;
	double gr;
	double r_sum, g_sum, b_sum, gr_sum;
	double r_mean, g_mean, b_mean, gr_mean;
	double r_std, g_std, b_std, gr_std;

	count = 0;
	r_sum = g_sum = b_sum = gr_sum = 0;
	r_mean = g_mean = b_mean = gr_mean = 0;
	r_std = g_std = b_std = gr_std = 0;

	/////////////////////////////////////
	// compute mean
	for (y = 1; y < IMAGE_Y-1; y++) {
		for (x = 1; x < IMAGE_X-1; x++) {
			if (mark[x][y] == 1) {
				count++;
				rr = Dbuffer[(y * IMAGE_X + x) * 3 + 0];
				gg = Dbuffer[(y * IMAGE_X + x) * 3 + 1];
				bb = Dbuffer[(y * IMAGE_X + x) * 3 + 2];
				gr = G_mag[x][y];
				r_sum += (double)rr;
				g_sum += (double)gg;
				b_sum += (double)bb;
				gr_sum += (double)gr;
			}
		}
	}
	r_mean = r_sum / count;
	g_mean = g_sum / count;
	b_mean = b_sum / count;
	gr_mean = gr_sum / count;
	////////////////////////////////////
	// compute std dev
	r_sum = g_sum = b_sum = gr_sum = 0;
	for (y = 1; y < IMAGE_Y-1; y++) {
		for (x = 1; x < IMAGE_X-1; x++) {
			if (mark[x][y] == 1) {
				//count++;
				rr = Dbuffer[(y * IMAGE_X + x) * 3 + 0];
				gg = Dbuffer[(y * IMAGE_X + x) * 3 + 1];
				bb = Dbuffer[(y * IMAGE_X + x) * 3 + 2];
				gr = G_mag[x][y];
				r_sum += ABS(r_mean-rr);
				g_sum += ABS(g_mean-gg);
				b_sum += ABS(b_mean-bb);
				gr_sum += ABS(gr_mean-gr);
			}
		}
	}
	r_std = r_sum / count;
	g_std = g_sum / count;
	b_std = b_sum / count;
	gr_std = gr_sum / count;
	
	edge.r_mean = r_mean;
	edge.g_mean = g_mean;
	edge.b_mean = b_mean;
	edge.gr_mean = gr_mean;
	edge.r_std = r_std;
	edge.g_std = g_std;
	edge.b_std = b_std;
	edge.gr_std = gr_std;
	
	//TRACE("r_mean = %.1f, r_std = %.1f\n", r_mean, r_std);
	//TRACE("g_mean = %.1f, g_std = %.1f\n", g_mean, g_std);
	//TRACE("b_mean = %.1f, b_std = %.1f\n", b_mean, b_std);
	//TRACE("gr_mean = %.5f, gr_std = %.5f\n", gr_mean, gr_std);
}

void UpdatePixelDist(pixel_dist& pixel, imatrix& mark)
{
	int x, y, count;
	GLubyte rr, gg, bb;
	double r_sum, g_sum, b_sum;
	double r_mean, g_mean, b_mean;
	double r_std, g_std, b_std;

	count = 0;
	r_sum = g_sum = b_sum = 0;
	r_mean = g_mean = b_mean = 0;
	r_std = g_std = b_std = 0;

	/////////////////////////////////////
	// compute mean
	for (y = 1; y < IMAGE_Y-1; y++) {
		for (x = 1; x < IMAGE_X-1; x++) {
			if (mark[x][y] == 1) {
				count++;
				rr = Dbuffer[(y * IMAGE_X + x) * 3 + 0];
				gg = Dbuffer[(y * IMAGE_X + x) * 3 + 1];
				bb = Dbuffer[(y * IMAGE_X + x) * 3 + 2];
				r_sum += (double)rr;
				g_sum += (double)gg;
				b_sum += (double)bb;
			}
		}
	}
	r_mean = r_sum / count;
	g_mean = g_sum / count;
	b_mean = b_sum / count;
	////////////////////////////////////
	// compute std dev
	r_sum = g_sum = b_sum = 0;
	for (y = 1; y < IMAGE_Y-1; y++) {
		for (x = 1; x < IMAGE_X-1; x++) {
			if (mark[x][y] == 1) {
				//count++;
				rr = Dbuffer[(y * IMAGE_X + x) * 3 + 0];
				gg = Dbuffer[(y * IMAGE_X + x) * 3 + 1];
				bb = Dbuffer[(y * IMAGE_X + x) * 3 + 2];
				r_sum += ABS(r_mean-rr);
				g_sum += ABS(g_mean-gg);
				b_sum += ABS(b_mean-bb);
			}
		}
	}
	r_std = r_sum / count;
	g_std = g_sum / count;
	b_std = b_sum / count;
	
	pixel.r_mean = r_mean;
	pixel.g_mean = g_mean;
	pixel.b_mean = b_mean;
	pixel.r_std = r_std;
	pixel.g_std = g_std;
	pixel.b_std = b_std;
	
	//TRACE("r_mean = %.1f, r_std = %.1f\n", r_mean, r_std);
	//TRACE("g_mean = %.1f, g_std = %.1f\n", g_mean, g_std);
	//TRACE("b_mean = %.1f, b_std = %.1f\n", b_mean, b_std);
	//TRACE("gr_mean = %.5f, gr_std = %.5f\n", gr_mean, gr_std);
}
	
double LocalCanny(int image_x, int image_y, int size, PixeL seed, imatrix& image, 
					   imatrix& image2, int gau_w)
{
	int	i, j, k, i1, i2, j1, j2, s, r;
	//int MAX_GRADIENT = -1;
	int	half = size/2;

	//tmp_x.init(size, size);
	//tmp_y.init(size, size);
	//G_x.init(size, size);
	//G_y.init(size, size);
	//G_mag.init(size, size);

	//imatrix tmp(image_x, image_y);
	double	x, y;

	for (s = 0; s < size; s++) {
		for (r = 0; r < size; r++) {
			
			i = seed.x-half+s;
			j = seed.y-half+r;
			if (i < 0 || i > image_x-1 || j < 0 || j > image_y-1)
				continue;
			x = gau[0] * image[i][j];	
			y = gau[0] * image[i][j];
			for (k = 1; k < gau_w; k++) {
				i1 = (i+k)%image_x;
				i2 = (i-k+image_x)%image_x;
				x += gau[k] * image[i1][j] + gau[k] * image[i2][j];
				j1 = (j+k)%image_y;
				j2 = (j-k+image_y)%image_y;
				y += gau[k] * image[i][j1] + gau[k] * image[i][j2];
			}
			tmp_x[i][j] = x;
			tmp_y[i][j] = y;
			//TRACE("x = %f, y = %f\n", x, y);
			if (x > 255) x = 255;
			if (y > 255) y = 255;
	
		}
	}

	for (s = 1; s < size-1; s++) {
		for (r = 1; r < size-1; r++) {

			i = seed.x-half+s;
			j = seed.y-half+r;
			if (i <= 0 || i >= image_x-1 || j <= 0 || j >= image_y-1)
				continue;
			G_x[i][j] = (tmp_x[i+1][j-1] + 2*tmp_x[i+1][j] + tmp_x[i+1][j+1] 
				- tmp_x[i-1][j-1] - 2*tmp_x[i-1][j] - tmp_x[i-1][j+1]);
			G_y[i][j] = (tmp_y[i-1][j+1] + 2*tmp_y[i][j+1] + tmp_y[i+1][j+1]
				- tmp_y[i-1][j-1] - 2*tmp_y[i][j-1] - tmp_y[i+1][j-1]);
			//G_mag[i][j] = sqrt(G_x[i][j] * G_x[i][j] + G_y[i][j] * G_y[i][j]);
			G_mag[i][j] = norm2(G_x[i][j], G_y[i][j]);

			/*
			if (G_mag[i][j] > max_grad2) {
				max_grad2 = G_mag[i][j];
				//TRACE("p[i][j].gx = %01.f\n", p[i][j].gx);
				//TRACE("p[i][j].gy = %01.f\n", p[i][j].gy);
				//TRACE("MAX_GRADIENT = %0.1f\n", MAX_GRADIENT);
			}
			*/
		}
	}

	//// normalize each gradient value
	TRACE("max_grad2 = %f\n", max_grad2);
	TRACE("hi_thres = %f\n", hi_thres);
	for (s = 1; s < size-1; s++) {
		for (r = 1; r < size-1; r++) {
			i = seed.x-half+s;
			j = seed.y-half+r;
			if (i <= 0 || i >= image_x-1 || j <= 0 || j >= image_y-1)
				continue;
			G_mag[i][j] = (G_mag[i][j] / max_grad2); // G_mag between [0, 1]
			//image2[i][j] = (int)(G_mag[i][j] * 255);
			thin_edge[i][j] = 0; // init thin edge list
		}
	}

	double	gx, gy;
	double	g, g1, g2, g3, g4;
	double	t; // interpolation parameter

	// nonmaxima suppress
	for (s = 1; s < size-1; s++) {
		for (r = 1; r < size-1; r++) {
			/////////////////////////////////////////////////////////
			// circular kernel
			if ( dist2(s, r, half, half) > half-1 ) continue; 
			
			i = seed.x-half+s;
			j = seed.y-half+r;
			if (i <= 0 || i >= image_x-1 || j <= 0 || j >= image_y-1)
				continue;
			gx = G_x[i][j];
			gy = G_y[i][j];
			g = G_mag[i][j];
			//////////////////////////////////////////////////
			// mark pixel image
			pixel_mark[i][j] = 1; // marked
			scale_map[i][j] = cur_sigma;
			/////////////////////////////////////////////
			//TRACE("gx = %f, gy = %f, g = %f\n", gx, gy, g);
			//if (gx < 0.01 && gy < 0.01) continue; // not an edge
			if (fabs(gx) >= fabs(gy)) { // close to horizontal (note: gy can be 0)
				t = fabs(gy) / fabs(gx); 
				//TRACE("t = %f\n", t);
				g1 = G_mag[i+1][j]; // right
				g2 = G_mag[i-1][j]; // left
				//TRACE("g1 = %f, g2 = %f\n", g1, g2);
				if (gx*gy >= 0.0) { // 1 or 3 quadrant
					g3 = G_mag[i+1][j+1]; // right up
					g4 = G_mag[i-1][j-1]; // left down
				}
				else { // 2 or 4 quadrant
					g3 = G_mag[i+1][j-1]; // right down
					g4 = G_mag[i-1][j+1]; // left up
				}
			}
			else { // close to vertical (note: gx can be 0)
				t = fabs(gx) / fabs(gy);
				g1 = G_mag[i][j+1]; // up
				g2 = G_mag[i][j-1]; // down
				if (gx*gy >= 0.0) { // 1 or 3 quadrant
					g3 = G_mag[i+1][j+1]; // up right
					g4 = G_mag[i-1][j-1]; // down left
				}
				else { // 2 or 4 quadrant
					g3 = G_mag[i-1][j+1]; // up left
					g4 = G_mag[i+1][j-1]; // down right
				}
			}
			if ( g > ((1-t)*g1 + t*g3) && g > ((1-t)*g2 + t*g4) ) {
				thin_edge[i][j] = 1; // it's a thin edge
				if (g > hi_thres) 
					image2[i][j] = 0; // thin edge above hi_thres
				else 
					image2[i][j] = 255; // thin edge below hi_thres
			}
			else { // non-maximum
				//image[i][j] = 0;
				image2[i][j] = 255;
			}
			
		}
	}

	//////////////////////////////////////////
	// Hysteresis thresholding
	///*
	for (s = 0; s < size; s++) {
		for (r = 0; r < size; r++) {
			/////////////////////////////////////////////////////////
			// circular kernel
			//if ( dist2(s, r, half, half) > half-1 ) continue; 
			//////////////////////////////////////////////////
			i = seed.x-half+s;
			j = seed.y-half+r;
			if (i <= 0 || i >= image_x-1 || j <= 0 || j >= image_y-1)
				continue;
			if (image2[i][j] == 0) { // computed thinned edges above hi_thres
				local_hyster_visit(size, seed, image_x, image_y, i, j, image2); // visit neighboring pixels
			}
		}			
	}
	//*/

	return max_grad2;
		
}


void NonmaxSuppress(int image_x, int image_y)
{
	int	i, j;
	int MAX_GRADIENT = -1;

	double	gx, gy;
	double	g, g1, g2, g3, g4;
	double	t; // interpolation parameter
	
	for (j = 1; j < image_y-1; j++) {
		for (i = 1; i < image_x-1; i++) {
			gx = G_x[i][j];
			gy = G_y[i][j];
			g = G_mag[i][j];
			//TRACE("gx = %f, gy = %f, g = %f\n", gx, gy, g);
			//if (gx < 0.01 && gy < 0.01) continue; // not an edge
			if (fabs(gx) >= fabs(gy)) { // close to horizontal (note: gy can be 0)
				t = fabs(gy) / fabs(gx); 
				//TRACE("t = %f\n", t);
				g1 = G_mag[i+1][j]; // right
				g2 = G_mag[i-1][j]; // left
				//TRACE("g1 = %f, g2 = %f\n", g1, g2);
				if (gx*gy >= 0.0) { // 1 or 3 quadrant
					g3 = G_mag[i+1][j+1]; // right up
					g4 = G_mag[i-1][j-1]; // left down
				}
				else { // 2 or 4 quadrant
					g3 = G_mag[i+1][j-1]; // right down
					g4 = G_mag[i-1][j+1]; // left up
				}
			}
			else { // close to vertical (note: gx can be 0)
				t = fabs(gx) / fabs(gy);
				g1 = G_mag[i][j+1]; // up
				g2 = G_mag[i][j-1]; // down
				if (gx*gy >= 0.0) { // 1 or 3 quadrant
					g3 = G_mag[i+1][j+1]; // up right
					g4 = G_mag[i-1][j-1]; // down left
				}
				else { // 2 or 4 quadrant
					g3 = G_mag[i-1][j+1]; // up left
					g4 = G_mag[i+1][j-1]; // down right
				}
			}
			if ( g > ((1-t)*g1 + t*g3) && g > ((1-t)*g2 + t*g4) && g > 0.1 ) {
				//image[i][j] = G_mag[i][j]*255;
				//if (g > 0.5)
				//image[i][j] = 255;
				image[i][j] = 0;

			}
			else { // non-maximum
				//image[i][j] = 0;
				image[i][j] = 255;
			}
			
		}
	}
}

void NonmaxSuppressGray(int image_x, int image_y)
{
	int	i, j;
	int MAX_GRADIENT = -1;

	double	gx, gy;
	double	g, g1, g2, g3, g4;
	double	t; // interpolation parameter
	
	for (j = 1; j < image_y-1; j++) {
		for (i = 1; i < image_x-1; i++) {
			gx = G_x[i][j];
			gy = G_y[i][j];
			g = G_mag[i][j];
			//TRACE("gx = %f, gy = %f, g = %f\n", gx, gy, g);
			//if (gx < 0.01 && gy < 0.01) continue; // not an edge
			if (fabs(gx) >= fabs(gy)) { // close to horizontal (note: gy can be 0)
				t = fabs(gy) / fabs(gx); 
				//TRACE("t = %f\n", t);
				g1 = G_mag[i+1][j]; // right
				g2 = G_mag[i-1][j]; // left
				//TRACE("g1 = %f, g2 = %f\n", g1, g2);
				if (gx*gy >= 0.0) { // 1 or 3 quadrant
					g3 = G_mag[i+1][j+1]; // right up
					g4 = G_mag[i-1][j-1]; // left down
				}
				else { // 2 or 4 quadrant
					g3 = G_mag[i+1][j-1]; // right down
					g4 = G_mag[i-1][j+1]; // left up
				}
			}
			else { // close to vertical (note: gx can be 0)
				t = fabs(gx) / fabs(gy);
				g1 = G_mag[i][j+1]; // up
				g2 = G_mag[i][j-1]; // down
				if (gx*gy >= 0.0) { // 1 or 3 quadrant
					g3 = G_mag[i+1][j+1]; // up right
					g4 = G_mag[i-1][j-1]; // down left
				}
				else { // 2 or 4 quadrant
					g3 = G_mag[i-1][j+1]; // up left
					g4 = G_mag[i+1][j-1]; // down right
				}
			}
			if ( g > ((1-t)*g1 + t*g3) && g > ((1-t)*g2 + t*g4) && g > 0.1 ) {
				//image[i][j] = G_mag[i][j]*255;
				//if (g > 0.5)
				//image[i][j] = 255;
				gray[i][j] = 0;

			}
			else { // non-maximum
				//image[i][j] = 0;
				gray[i][j] = 255;
			}
			
			
		}
	}
		
		
}

void GetSobelGradient(int image_x, int image_y, imatrix& image, imatrix& image2, matrix& G_mag) 
// Sobel gradient version
// makes edge lines black (not white)
{
	int i, j;
	double MAX_GRADIENT = -1.;
	//double MAX_VAL = -1.;
	//double MAX_VAL = 255.;
	double MAX_VAL = 1020.; // 255 + 2 * 255 + 255 (Maximum possible Sobel value)

	Field tmp;

	tmp.init(image_x, image_y);

	/*
	for (i = 0; i < Nr; i++) { 
		for (j = 0; j < Nc; j++) {
			if (image[i][j] > MAX_VAL) MAX_VAL = (double)image[i][j];
		}
	}
	TRACE("MAX_VAL = %f\n", MAX_VAL);
	*/
	
	for (i = 1; i < image_x - 1; i++) { 
		for (j = 1; j < image_y - 1; j++) {
			////////////////////////////////////////////////////////////////
			// Important!: the value of image intensity should be normalized to [0,1]
			tmp[i][j].gx = (image[i+1][j-1] + 2*(double)image[i+1][j] + image[i+1][j+1] 
				- image[i-1][j-1] - 2*(double)image[i-1][j] - image[i-1][j+1]) / MAX_VAL;
			tmp[i][j].gy = (image[i-1][j+1] + 2*(double)image[i][j+1] + image[i+1][j+1]
				- image[i-1][j-1] - 2*(double)image[i][j-1] - image[i+1][j-1]) / MAX_VAL;
			/////////////////////////////////////////////
			// Amplify!!!
			//p[i][j].gx = pow(p[i][j].gx, 2); 
			//p[i][j].gy = pow(p[i][j].gy, 2); 
			//p[i][j].gx = pow(p[i][j].gx, 2); 
			//TRACE("p[i][j].gx = %.1f\n", p[i][j].gx);
			//TRACE("p[i][j].gy = %.1f\n", p[i][j].gy);
			tmp[i][j].mag = sqrt(tmp[i][j].gx * tmp[i][j].gx + tmp[i][j].gy * tmp[i][j].gy);

			if (tmp[i][j].mag > MAX_GRADIENT) {
				MAX_GRADIENT = tmp[i][j].mag;
				//TRACE("p[i][j].gx = %01.f\n", p[i][j].gx);
				//TRACE("p[i][j].gy = %01.f\n", p[i][j].gy);
				//TRACE("MAX_GRADIENT = %0.1f\n", MAX_GRADIENT);
			}
		}
	}

	for (i = 1; i <= image_x - 2; i++) {
		tmp[i][0].gx = tmp[i][1].gx;
		tmp[i][0].gy = tmp[i][1].gy;
		tmp[i][0].mag = tmp[i][1].mag;
		tmp[i][image_y - 1].gx = tmp[i][image_y - 2].gx;
		tmp[i][image_y - 1].gy = tmp[i][image_y - 2].gy;
		tmp[i][image_y - 1].mag = tmp[i][image_y - 2].mag;
	}
	
	for (j = 1; j <= image_y - 2; j++) {
		tmp[0][j].gx = tmp[1][j].gx;
		tmp[0][j].gy = tmp[1][j].gy;
		tmp[0][j].mag = tmp[1][j].mag;
		tmp[image_x - 1][j].gx = tmp[image_x - 2][j].gx;
		tmp[image_x - 1][j].gy = tmp[image_x - 2][j].gy;
		tmp[image_x - 1][j].mag = tmp[image_x - 2][j].mag;
	}
	
	tmp[0][0].gx = ( tmp[0][1].gx + tmp[1][0].gx ) / 2;
	tmp[0][0].gy = ( tmp[0][1].gy + tmp[1][0].gy ) / 2;
	tmp[0][0].mag = ( tmp[0][1].mag + tmp[1][0].mag ) / 2;
	tmp[0][image_y-1].gx = ( tmp[0][image_y-2].gx + tmp[1][image_y-1].gx ) / 2;
	tmp[0][image_y-1].gy = ( tmp[0][image_y-2].gy + tmp[1][image_y-1].gy ) / 2;
	tmp[0][image_y-1].mag = ( tmp[0][image_y-2].mag + tmp[1][image_y-1].mag ) / 2;
	tmp[image_x-1][0].gx = ( tmp[image_x-1][1].gx + tmp[image_x-2][0].gx ) / 2;
	tmp[image_x-1][0].gy = ( tmp[image_x-1][1].gy + tmp[image_x-2][0].gy ) / 2;
	tmp[image_x-1][0].mag = ( tmp[image_x-1][1].mag + tmp[image_x-2][0].mag ) / 2;
	tmp[image_x - 1][image_y - 1].gx = ( tmp[image_x - 1][image_y - 2].gx + tmp[image_x - 2][image_y - 1].gx ) / 2;
	tmp[image_x - 1][image_y - 1].gy = ( tmp[image_x - 1][image_y - 2].gy + tmp[image_x - 2][image_y - 1].gy ) / 2;
	tmp[image_x - 1][image_y - 1].mag = ( tmp[image_x - 1][image_y - 2].mag + tmp[image_x - 2][image_y - 1].mag ) / 2;

	TRACE("MAX_GRADIENT = %0.1f\n", MAX_GRADIENT);

	max_grad = round(MAX_GRADIENT);

	// Normalize gradient magnitude
	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			//TRACE("p[%d][%d].mag = %0.3f\n", i, j, p[i][j].mag);
			tmp[i][j].mag = tmp[i][j].mag / (double)MAX_GRADIENT; // place it between [0, 1]
			G_mag[i][j] = tmp[i][j].mag;
			if (tmp[i][j].mag < 0)
				TRACE("tmp[%d][%d].mag = %0.2f\n", i, j, tmp[i][j].mag);

			image2[i][j] = 255 - round(tmp[i][j].mag * 255.);
		}
	}

	//////////////////////////////////////////////////////////////
	/// Amplify the gradients (strong grad -> stronger, weak grad -> weaker)
	/*
	for (i = 0; i < Nr; i++) { 
		for (j = 0; j < Nc; j++) {
			p[i][j].mag = pow(2.0, p[i][j].mag);
		}
	}
	*/
}

void GetSobelGradient2(int image_x, int image_y, imatrix& image, imatrix& image2, matrix& G_mag) 
// Sobel gradient version
// makes edge lines white (not black)
{
	int i, j;
	double MAX_GRADIENT = -1.;
	//double MAX_VAL = -1.;
	//double MAX_VAL = 255.;
	double MAX_VAL = 1020.; // 255 + 2 * 255 + 255 (Maximum possible Sobel value)

	Field tmp;

	tmp.init(image_x, image_y);

	/*
	for (i = 0; i < Nr; i++) { 
		for (j = 0; j < Nc; j++) {
			if (image[i][j] > MAX_VAL) MAX_VAL = (double)image[i][j];
		}
	}
	TRACE("MAX_VAL = %f\n", MAX_VAL);
	*/
	
	for (i = 1; i < image_x - 1; i++) { 
		for (j = 1; j < image_y - 1; j++) {
			////////////////////////////////////////////////////////////////
			// Important!: the value of image intensity should be normalized to [0,1]
			tmp[i][j].gx = (image[i+1][j-1] + 2*(double)image[i+1][j] + image[i+1][j+1] 
				- image[i-1][j-1] - 2*(double)image[i-1][j] - image[i-1][j+1]) / MAX_VAL;
			tmp[i][j].gy = (image[i-1][j+1] + 2*(double)image[i][j+1] + image[i+1][j+1]
				- image[i-1][j-1] - 2*(double)image[i][j-1] - image[i+1][j-1]) / MAX_VAL;
			/////////////////////////////////////////////
			// Amplify!!!
			//p[i][j].gx = pow(p[i][j].gx, 2); 
			//p[i][j].gy = pow(p[i][j].gy, 2); 
			//p[i][j].gx = pow(p[i][j].gx, 2); 
			//TRACE("p[i][j].gx = %.1f\n", p[i][j].gx);
			//TRACE("p[i][j].gy = %.1f\n", p[i][j].gy);
			tmp[i][j].mag = sqrt(tmp[i][j].gx * tmp[i][j].gx + tmp[i][j].gy * tmp[i][j].gy);

			if (tmp[i][j].mag > MAX_GRADIENT) {
				MAX_GRADIENT = tmp[i][j].mag;
				//TRACE("p[i][j].gx = %01.f\n", p[i][j].gx);
				//TRACE("p[i][j].gy = %01.f\n", p[i][j].gy);
				//TRACE("MAX_GRADIENT = %0.1f\n", MAX_GRADIENT);
			}
		}
	}

	for (i = 1; i <= image_x - 2; i++) {
		tmp[i][0].gx = tmp[i][1].gx;
		tmp[i][0].gy = tmp[i][1].gy;
		tmp[i][0].mag = tmp[i][1].mag;
		tmp[i][image_y - 1].gx = tmp[i][image_y - 2].gx;
		tmp[i][image_y - 1].gy = tmp[i][image_y - 2].gy;
		tmp[i][image_y - 1].mag = tmp[i][image_y - 2].mag;
	}
	
	for (j = 1; j <= image_y - 2; j++) {
		tmp[0][j].gx = tmp[1][j].gx;
		tmp[0][j].gy = tmp[1][j].gy;
		tmp[0][j].mag = tmp[1][j].mag;
		tmp[image_x - 1][j].gx = tmp[image_x - 2][j].gx;
		tmp[image_x - 1][j].gy = tmp[image_x - 2][j].gy;
		tmp[image_x - 1][j].mag = tmp[image_x - 2][j].mag;
	}
	
	tmp[0][0].gx = ( tmp[0][1].gx + tmp[1][0].gx ) / 2;
	tmp[0][0].gy = ( tmp[0][1].gy + tmp[1][0].gy ) / 2;
	tmp[0][0].mag = ( tmp[0][1].mag + tmp[1][0].mag ) / 2;
	tmp[0][image_y-1].gx = ( tmp[0][image_y-2].gx + tmp[1][image_y-1].gx ) / 2;
	tmp[0][image_y-1].gy = ( tmp[0][image_y-2].gy + tmp[1][image_y-1].gy ) / 2;
	tmp[0][image_y-1].mag = ( tmp[0][image_y-2].mag + tmp[1][image_y-1].mag ) / 2;
	tmp[image_x-1][0].gx = ( tmp[image_x-1][1].gx + tmp[image_x-2][0].gx ) / 2;
	tmp[image_x-1][0].gy = ( tmp[image_x-1][1].gy + tmp[image_x-2][0].gy ) / 2;
	tmp[image_x-1][0].mag = ( tmp[image_x-1][1].mag + tmp[image_x-2][0].mag ) / 2;
	tmp[image_x - 1][image_y - 1].gx = ( tmp[image_x - 1][image_y - 2].gx + tmp[image_x - 2][image_y - 1].gx ) / 2;
	tmp[image_x - 1][image_y - 1].gy = ( tmp[image_x - 1][image_y - 2].gy + tmp[image_x - 2][image_y - 1].gy ) / 2;
	tmp[image_x - 1][image_y - 1].mag = ( tmp[image_x - 1][image_y - 2].mag + tmp[image_x - 2][image_y - 1].mag ) / 2;

	TRACE("MAX_GRADIENT = %0.1f\n", MAX_GRADIENT);

	max_grad = round(MAX_GRADIENT);

	// Normalize gradient magnitude
	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			//TRACE("p[%d][%d].mag = %0.3f\n", i, j, p[i][j].mag);
			tmp[i][j].mag = tmp[i][j].mag / (double)MAX_GRADIENT; // place it between [0, 1]
			G_mag[i][j] = tmp[i][j].mag;
			if (tmp[i][j].mag < 0)
				TRACE("tmp[%d][%d].mag = %0.2f\n", i, j, tmp[i][j].mag);

			//image2[i][j] = 255 - round(tmp[i][j].mag * 255.);
			image2[i][j] = round(tmp[i][j].mag * 255.);
		}
	}

	//////////////////////////////////////////////////////////////
	/// Amplify the gradients (strong grad -> stronger, weak grad -> weaker)
	/*
	for (i = 0; i < Nr; i++) { 
		for (j = 0; j < Nc; j++) {
			p[i][j].mag = pow(2.0, p[i][j].mag);
		}
	}
	*/
}


void GetDOG(int image_x, int image_y, imatrix& image, matrix& G_mag, imatrix& image2, int index1, int index2,
			double tau) 
// Difference of Gaussians (just awesome!)
// G_mag gets the actual real values in [0, 1]
// image2 gets the integer values in [0, 255]
{
	int	i, j, k;
	double MAX_DOG = -1.0;
	int s, t;
	int x, y;

	int half1, half2; // small window and big window
	//int index1, index2; // index for Gaussian matrix
	double sum1, sum2, w_sum1, w_sum2;

	//////////////////////////////////
	//Make2DGaussMask(sigma); // mask for unilateral filtering

	//N = gau_mask.getRow();
	//half = N / 2;

	//ClearMemDC(&dc); // clear the canvas white
	//////////////////////////////////////////////
	double factor = 2.0;
	MakeGaussMatrix(factor, GAU); // factor controls the Gaussian window size for each index

	//index1 = 30;
	TRACE("GAU_W_1[%d] = %d\n", index1, GAU_W[index1]);
	//index2 = 100;
	TRACE("GAU_W_2[%d] = %d\n", index2, GAU_W[index2]);

	////////////////////////////////////////////////////////
	// sensitivity of edge detector. between [0, 1] 
	// the smaller, less noise
	//double tau = 0.99; 

	matrix tmp(image_x, image_y);
	//tmp.zero();

	/*
	for (i = 0; i < 256; i++) {
		for (j = 0; j < GAU.getCol(); j++) {
			TRACE("GAU[%d][%d] = %.3f ", i, j, GAU[i][j]);
		}
		TRACE("\n");
	}
	*/
	//gau_w = MakeGaussMask(4.0, gau); // window 20x20
		
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//index = gray2[i][j];
			sum1 = 0;
			w_sum1 = 0.0;
			half1 = GAU_W[index1]-1;
			//half = 8;
			//TRACE("GAU_W_1[%d] = %d\n", index1, GAU_W[index1]);
			for (s = -half1; s <= half1; s++) {
				for (t = -half1; t <= half1; t++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					//k = round( dist2(x, y, i, j) );
					if ( k > half1 ) continue; 
					/////////////////////////////////////////////////////
					sum1 += image[x][y] * GAU[index1][k];
					w_sum1 += GAU[index1][k];
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			sum1 /= w_sum1; 
			//TRACE("w_sum = %.6f\n", w_sum);
			//////////////////////////////////////////////
			sum2 = 0;
			w_sum2 = 0.0;
			half2 = GAU_W[index2]-1;
			//TRACE("GAU_W_2[%d] = %d\n", index2, GAU_W[index2]);
			for (s = -half2; s <= half2; s++) {
				for (t = -half2; t <= half2; t++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					//k = round( dist2(x, y, i, j) );
					if ( k > half1 ) continue; 
					/////////////////////////////////////////////////////
					sum2 += image[x][y] * GAU[index2][k];
					w_sum2 += GAU[index2][k];
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			//TRACE("w_sum = %.6f\n", w_sum);
			sum2 /= w_sum2; 
			//////////////////////////////
			if (sum1 - tau * sum2 > 0)
				tmp[i][j] = 1.0;
			else
				tmp[i][j] = 1.0 + tanh(sum1 - tau * sum2);
			//if (tmp[i][j] > MAX_DOG) MAX_DOG = tmp[i][j];
		}
	}
	////////////////////////////////////////////

	// Normalize DOG value (not necessary! - MAX_DOG is always 1)
	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			//TRACE("p[%d][%d].mag = %0.3f\n", i, j, p[i][j].mag);
			//tmp[i][j] = tmp[i][j] / MAX_DOG; // place it between [0, 1]
			G_mag[i][j] = 1-tmp[i][j]; // used for nonmaxima suppression
			//TRACE("G_mag[%d][%d] = %.1f\n", i, j, G_mag[i][j]);
			//TRACE("tmp[%d][%d] = %0.3f\n", i, j, tmp[i][j]);
			//TRACE("G_mag[%d][%d] = %0.3f\n", i, j, G_mag[i][j]);
			if (tmp[i][j] < 0)
				TRACE("tmp[%d][%d] = %0.2f\n", i, j, tmp[i][j]);
			image2[i][j] = round(tmp[i][j] * 255.);
			//image2[i][j] = 255 - round(tmp[i][j] * 255.);
		}
	}
}

void GetDOG2(imatrix& image, matrix& G_mag, imatrix& image2, double sigma, double tau) 
// Difference of Gaussians (just awesome!)
// Find the two indexes from sigma!
// G_mag gets the actual real values in [0, 1]
// image2 gets the integer values in [0, 255]
{
	int	i, j, k;
	double MAX_DOG = -1.0;
	int s, t;
	int x, y;

	int image_x = image.getRow();
	int image_y = image.getCol();

	int half1, half2; // small window and big window
	//int index1, index2; // index for Gaussian matrix
	double sum1, sum2, w_sum1, w_sum2;

	//////////////////////////////////
	//Make2DGaussMask(sigma); // mask for unilateral filtering

	//N = gau_mask.getRow();
	//half = N / 2;

	//ClearMemDC(&dc); // clear the canvas white
	//////////////////////////////////////////////
	//double factor = 2.0;
	//MakeGaussMatrix(factor, GAU); // factor controls the Gaussian window size for each index
	vector GAU1, GAU2;
	MakeGaussVector(sigma, GAU1);
	MakeGaussVector(sigma*1.6, GAU2);
	half1 = GAU1.getMax()-1;
	half2 = GAU2.getMax()-1;

	////////////////////////////////////////////////////////
	matrix tmp(image_x, image_y);
	//tmp.zero();
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//index = gray2[i][j];
			sum1 = 0;
			w_sum1 = 0.0;
			//half1 = GAU_W[index1]-1;
			//half = 8;
			//TRACE("GAU_W_1[%d] = %d\n", index1, GAU_W[index1]);
			for (s = -half1; s <= half1; s++) {
				for (t = -half1; t <= half1; t++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					//k = round( dist2(x, y, i, j) );
					if ( k > half1 ) continue; 
					/////////////////////////////////////////////////////
					sum1 += image[x][y] * GAU1[k];
					w_sum1 += GAU1[k];
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			sum1 /= w_sum1; 
			//TRACE("w_sum = %.6f\n", w_sum);
			//////////////////////////////////////////////
			sum2 = 0;
			w_sum2 = 0.0;
			//half2 = GAU_W[index2]-1;
			//half2 = GAU1.getMax()-1; // Now this was a big mistake!!!
			//TRACE("GAU_W_2[%d] = %d\n", index2, GAU_W[index2]);
			for (s = -half2; s <= half2; s++) {
				for (t = -half2; t <= half2; t++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					//k = round( dist2(x, y, i, j) );
					//if ( k > half1 ) continue; 
					if ( k > half2 ) continue; 
					/////////////////////////////////////////////////////
					sum2 += image[x][y] * GAU2[k];
					w_sum2 += GAU2[k];
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			//TRACE("w_sum = %.6f\n", w_sum);
			sum2 /= w_sum2; 
			//////////////////////////////
			/*
			// to incorporate both sides of the edge!
			if (sum1 - sum2 > 0) // non edge
				tmp[i][j] = ( 1.0 - tanh(sum1 - sum2) ); // [0, 1]
			else
				tmp[i][j] = 1.0 + tanh(sum1 - sum2); // [ 0, 1 ]
			*/
			///* handle only one side of the edge!
			//TRACE("sum1 = %f\n", sum1);
			//TRACE("sum2 = %f\n", sum2);
			//TRACE("sum1 - tau * sum2 = %f\n", sum1 - tau * sum2);
			/////////////////////////////////////////
			// POSITIVE INNTER CIRCLE
			if (sum1 - tau * sum2 > 0) // non edge
				tmp[i][j] = 1.0;
			else
				tmp[i][j] = 1.0 + tanh(sum1 - tau * sum2); // [ 0, 1 ]
				//tmp[i][j] = 1.0 + tanh( (sum1 - tau * sum2)/10 ); // make it darker!
			///////////////////////////////////////////
			// POSITIVE INNTER CIRCLE (opposite)
			/*
			if (sum1 - tau * sum2 < 0) // non edge
				tmp[i][j] = 1.0;
			else
				tmp[i][j] = -1.0 + tanh(sum1 - tau * sum2); // [ 0, 1 ]
				//tmp[i][j] = 1.0 + tanh( (sum1 - tau * sum2)/10 ); // make it darker!
			*/	
			////////////////////////////////////
			// NEGATIVE INNTER CIRCLE
			/*
			if (-sum1 + tau * sum2 > 0) // non edge
				tmp[i][j] = 1.0;
			else
				tmp[i][j] = 1.0 + tanh(-sum1 + tau * sum2); // [ 0, 1 ]
				//tmp[i][j] = 1.0 + tanh( (sum1 - tau * sum2)/10 ); // make it darker!
			*/
			//if (tmp[i][j] > MAX_DOG) MAX_DOG = tmp[i][j];
		}
	}
	////////////////////////////////////////////

	// Normalize DOG value (not necessary! - MAX_DOG is always 1)
	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			//TRACE("p[%d][%d].mag = %0.3f\n", i, j, p[i][j].mag);
			//tmp[i][j] = tmp[i][j] / MAX_DOG; // place it between [0, 1]
			//////////////////////////////////////////////////
			G_mag[i][j] = 1-tmp[i][j]; // [0, 1] used for nonmaxima suppression
			// the higher, the stronger the edgeness!
			///////////////////////////////////////////////////
			//TRACE("G_mag[%d][%d] = %.1f\n", i, j, G_mag[i][j]);
			//TRACE("tmp[%d][%d] = %0.3f\n", i, j, tmp[i][j]);
			//TRACE("G_mag[%d][%d] = %0.3f\n", i, j, G_mag[i][j]);
			if (tmp[i][j] < 0)
				TRACE("tmp[%d][%d] = %0.2f\n", i, j, tmp[i][j]);
			image2[i][j] = round(tmp[i][j] * 255.);
			//image2[i][j] = 255 - round(tmp[i][j] * 255.);
		}
	}
}

void GetShock(imatrix& image, matrix& G_mag, imatrix& image2, double sigma, double tau) 
// Use DOG to approximate Image Laplacian value!
// G_mag gets the actual real values in [0, 1]
// image2 gets the integer values in [0, 255]
{
	int	i, j, k;
	double MAX_DOG = -1.0;
	int s, t;
	int x, y;

	int image_x = image.getRow();
	int image_y = image.getCol();

	int half1, half2; // small window and big window
	//int index1, index2; // index for Gaussian matrix
	double sum1, sum2, w_sum1, w_sum2;

	//////////////////////////////////
	//Make2DGaussMask(sigma); // mask for unilateral filtering

	//N = gau_mask.getRow();
	//half = N / 2;

	//ClearMemDC(&dc); // clear the canvas white
	//////////////////////////////////////////////
	//double factor = 2.0;
	//MakeGaussMatrix(factor, GAU); // factor controls the Gaussian window size for each index
	vector GAU1, GAU2;
	MakeGaussVector(sigma, GAU1);
	MakeGaussVector(sigma*1.6, GAU2);
	half1 = GAU1.getMax()-1;
	half2 = GAU2.getMax()-1;

	////////////////////////////////////////////////////////
	matrix tmp(image_x, image_y);
	//tmp.zero();
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//index = gray2[i][j];
			sum1 = 0;
			w_sum1 = 0.0;
			//half1 = GAU_W[index1]-1;
			//half = 8;
			//TRACE("GAU_W_1[%d] = %d\n", index1, GAU_W[index1]);
			for (s = -half1; s <= half1; s++) {
				for (t = -half1; t <= half1; t++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					//k = round( dist2(x, y, i, j) );
					if ( k > half1 ) continue; 
					/////////////////////////////////////////////////////
					sum1 += image[x][y] * GAU1[k];
					w_sum1 += GAU1[k];
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			sum1 /= w_sum1; 
			//TRACE("w_sum = %.6f\n", w_sum);
			//////////////////////////////////////////////
			sum2 = 0;
			w_sum2 = 0.0;
			//half2 = GAU_W[index2]-1;
			//half2 = GAU1.getMax()-1; // Now this was a big mistake!!!
			//TRACE("GAU_W_2[%d] = %d\n", index2, GAU_W[index2]);
			for (s = -half2; s <= half2; s++) {
				for (t = -half2; t <= half2; t++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					//k = round( dist2(x, y, i, j) );
					//if ( k > half1 ) continue; 
					if ( k > half2 ) continue; 
					/////////////////////////////////////////////////////
					sum2 += image[x][y] * GAU2[k];
					w_sum2 += GAU2[k];
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			//TRACE("w_sum = %.6f\n", w_sum);
			sum2 /= w_sum2; 
			//////////////////////////////
			/*
			// to incorporate both sides of the edge!
			if (sum1 - sum2 > 0) // non edge
				tmp[i][j] = ( 1.0 - tanh(sum1 - sum2) ); // [0, 1]
			else
				tmp[i][j] = 1.0 + tanh(sum1 - sum2); // [ 0, 1 ]
			*/
			///* handle only one side of the edge!
			//TRACE("sum1 = %f\n", sum1);
			//TRACE("sum2 = %f\n", sum2);
			//TRACE("sum1 - tau * sum2 = %f\n", sum1 - tau * sum2);
			/////////////////////////////////////////
			// POSITIVE INNTER CIRCLE
			if (sum1 - tau * sum2 >= 0) // non edge
				tmp[i][j] = 0.0;
			else 
				tmp[i][j] = 1.0;
			/*
			if (sum1 - tau * sum2 > 0) // non edge
				tmp[i][j] = 1.0;
			else
				tmp[i][j] = 1.0 + tanh(sum1 - tau * sum2); // [ 0, 1 ]
				//tmp[i][j] = 1.0 + tanh( (sum1 - tau * sum2)/10 ); // make it darker!
			*/
		}
	}
	////////////////////////////////////////////
	double weight;
	int sign;
	/////////////////////////////////////////
	// Smoothing step!
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//index = gray2[i][j];
			sum1 = 0;
			w_sum1 = 0.0;
			//half1 = GAU_W[index1]-1;
			if (tmp[i][j] == 1.0) sign = 1;
			else sign = 0;
			//half = 8;
			//TRACE("GAU_W_1[%d] = %d\n", index1, GAU_W[index1]);
			for (s = -half1; s <= half1; s++) {
				for (t = -half1; t <= half1; t++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					//k = round( dist2(x, y, i, j) );
					if ( k > half1 ) continue; 
					/////////////////////////////////////////////////////
					if (sign) 
						if (tmp[x][y] == 1.0) weight = 1.0;
						else weight = 0.0;
					else 
						if (tmp[x][y] == 1.0) weight = 0.0;
						else weight = 1.0;
					sum1 += image[x][y] * GAU1[k] * weight;
					w_sum1 += GAU1[k] * weight;
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			sum1 /= w_sum1; 
			//TRACE("w_sum = %.6f\n", w_sum);
			//////////////////////////////////////////////
			///* handle only one side of the edge!
			//TRACE("sum1 = %f\n", sum1);
			//TRACE("sum2 = %f\n", sum2);
			//TRACE("sum1 - tau * sum2 = %f\n", sum1 - tau * sum2);
			/////////////////////////////////////////
			image2[i][j] = round(sum1);
		}
	}
	////////////////////////////////////////////

	// Normalize DOG value (not necessary! because MAX_DOG is always 1)
	/*
	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			//TRACE("p[%d][%d].mag = %0.3f\n", i, j, p[i][j].mag);
			//tmp[i][j] = tmp[i][j] / MAX_DOG; // place it between [0, 1]
			//////////////////////////////////////////////////
			G_mag[i][j] = 1-tmp[i][j]; // [0, 1] used for nonmaxima suppression
			// the higher, the stronger the edgeness!
			///////////////////////////////////////////////////
			//TRACE("G_mag[%d][%d] = %.1f\n", i, j, G_mag[i][j]);
			//TRACE("tmp[%d][%d] = %0.3f\n", i, j, tmp[i][j]);
			//TRACE("G_mag[%d][%d] = %0.3f\n", i, j, G_mag[i][j]);
			if (tmp[i][j] < 0)
				TRACE("tmp[%d][%d] = %0.2f\n", i, j, tmp[i][j]);
			image2[i][j] = round(tmp[i][j] * 255.);
			//image2[i][j] = 255 - round(tmp[i][j] * 255.);
		}
	}
	*/
}

void GetShock2(imatrix& image, matrix& G_mag, imatrix& image2, double sigma, double tau, double z) 
{
	int	i, j, k;
	double MAX_DOG = -1.0;
	int s, t;
	int x, y;

	int image_x = image.getRow();
	int image_y = image.getCol();

	int half1, half2; // small window and big window
	//int index1, index2; // index for Gaussian matrix
	double sum1, sum2, w_sum1, w_sum2;

	//////////////////////////////////
	//Make2DGaussMask(sigma); // mask for unilateral filtering

	//N = gau_mask.getRow();
	//half = N / 2;

	//ClearMemDC(&dc); // clear the canvas white
	//////////////////////////////////////////////
	//double factor = 2.0;
	//MakeGaussMatrix(factor, GAU); // factor controls the Gaussian window size for each index
	vector GAU1, GAU2;
	MakeGaussVector(sigma, GAU1);
	MakeGaussVector(sigma*1.6, GAU2);
	half1 = GAU1.getMax()-1;
	half2 = GAU2.getMax()-1;

	deque<int> vec;
	////////////////////////////////////////////////////////
	matrix tmp(image_x, image_y);
	imatrix tmp2(image_x, image_y);
	//tmp.zero();
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//index = gray2[i][j];
			sum1 = 0;
			w_sum1 = 0.0;
			//half1 = GAU_W[index1]-1;
			//half = 8;
			//TRACE("GAU_W_1[%d] = %d\n", index1, GAU_W[index1]);
			for (s = -half1; s <= half1; s++) {
				for (t = -half1; t <= half1; t++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					//k = round( dist2(x, y, i, j) );
					if ( k > half1 ) continue; 
					/////////////////////////////////////////////////////
					sum1 += image[x][y] * GAU1[k];
					w_sum1 += GAU1[k];
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			sum1 /= w_sum1; 
			//TRACE("w_sum = %.6f\n", w_sum);
			//////////////////////////////////////////////
			sum2 = 0;
			w_sum2 = 0.0;
			//half2 = GAU_W[index2]-1;
			//half2 = GAU1.getMax()-1; // Now this was a big mistake!!!
			//TRACE("GAU_W_2[%d] = %d\n", index2, GAU_W[index2]);
			for (s = -half2; s <= half2; s++) {
				for (t = -half2; t <= half2; t++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					//k = round( dist2(x, y, i, j) );
					//if ( k > half1 ) continue; 
					if ( k > half2 ) continue; 
					/////////////////////////////////////////////////////
					sum2 += image[x][y] * GAU2[k];
					w_sum2 += GAU2[k];
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			//TRACE("w_sum = %.6f\n", w_sum);
			sum2 /= w_sum2; 
			//////////////////////////////
			/////////////////////////////////////////
			// POSITIVE INNTER CIRCLE
			if (sum1 - tau * sum2 >= 0) // non edge
				tmp[i][j] = 1.0; // non edge
			else 
				tmp[i][j] = 0.0; // edge
		}
	}
	////////////////////////////////////////////
	//double weight;
	int sign;
	/////////////////////////////////////////
	// Smoothing step!
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//index = gray2[i][j];
			sum1 = 0;
			w_sum1 = 0.0;
			//half1 = GAU_W[index1]-1;
			if (tmp[i][j] == 1.0) sign = 1; // Non edge region
			else sign = 0; // edge region
			vec.clear();
			//half = 8;
			//TRACE("GAU_W_1[%d] = %d\n", index1, GAU_W[index1]);
			for (s = -half1; s <= half1; s++) {
				for (t = -half1; t <= half1; t++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					//k = round( dist2(x, y, i, j) );
					if ( k > half1 ) continue; 
					/////////////////////////////////////////////////////
					if (sign) { // non edge region
                        if (tmp[x][y] == 1.0) vec.push_back(image[x][y]);
					}
					else { // edge region
						if (tmp[x][y] == 0.0) vec.push_back(image[x][y]);
					}
					//sum1 += image[x][y] * GAU1[k] * weight;
					//w_sum1 += GAU1[k] * weight;
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			//sum1 /= w_sum1; 
			sort(vec.begin(), vec.end()); 
			//flow_median = vec[vec.size()/2]; 
			//double z = 0.3;
			if (sign) // non edge region
				tmp2[i][j] = vec[vec.size()-1]; 
				//image2[i][j] = round( (1-z) * vec[vec.size()-1] + z * 255 ); // brightest value
			else // edge region
				//tmp2[i][j] = vec[0]; 
				tmp2[i][j] = round( (1-z) * vec[0] + z * 0 ); // darkest value
			//TRACE("w_sum = %.6f\n", w_sum);
			//////////////////////////////////////////////
			///* handle only one side of the edge!
			//TRACE("sum1 = %f\n", sum1);
			//TRACE("sum2 = %f\n", sum2);
			//TRACE("sum1 - tau * sum2 = %f\n", sum1 - tau * sum2);
			/////////////////////////////////////////
			//image2[i][j] = round(sum1);
		}
	}
	////////////////////////////////////////////

	// Normalize DOG value (not necessary! because MAX_DOG is always 1)
	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			//TRACE("p[%d][%d].mag = %0.3f\n", i, j, p[i][j].mag);
			//tmp[i][j] = tmp[i][j] / MAX_DOG; // place it between [0, 1]
			//////////////////////////////////////////////////
			//G_mag[i][j] = 1-tmp[i][j]; // [0, 1] used for nonmaxima suppression
			// the higher, the stronger the edgeness!
			///////////////////////////////////////////////////
			//TRACE("G_mag[%d][%d] = %.1f\n", i, j, G_mag[i][j]);
			//TRACE("tmp[%d][%d] = %0.3f\n", i, j, tmp[i][j]);
			//TRACE("G_mag[%d][%d] = %0.3f\n", i, j, G_mag[i][j]);
			//if (tmp[i][j] < 0)
			//	TRACE("tmp[%d][%d] = %0.2f\n", i, j, tmp[i][j]);
			image2[i][j] = tmp2[i][j];
			//image2[i][j] = 255 - round(tmp[i][j] * 255.);
		}
	}
}

void GetColShock(cimatrix& cmap, imatrix& image, double sigma, double tau, double z) 
{
	int	i, j, k;
	double MAX_DOG = -1.0;
	int s, t;
	int x, y;

	int image_x = image.getRow();
	int image_y = image.getCol();

	int half1, half2; // small window and big window
	//int index1, index2; // index for Gaussian matrix
	double sum1, sum2, w_sum1, w_sum2;

	//////////////////////////////////
	//Make2DGaussMask(sigma); // mask for unilateral filtering

	//N = gau_mask.getRow();
	//half = N / 2;

	//ClearMemDC(&dc); // clear the canvas white
	//////////////////////////////////////////////
	//double factor = 2.0;
	//MakeGaussMatrix(factor, GAU); // factor controls the Gaussian window size for each index
	vector GAU1, GAU2;
	MakeGaussVector(sigma, GAU1);
	MakeGaussVector(sigma*1.6, GAU2);
	half1 = GAU1.getMax()-1;
	half2 = GAU2.getMax()-1;

	deque<int> vec[3];
	////////////////////////////////////////////////////////
	matrix tmp(image_x, image_y);
	cimatrix tmp2(image_x, image_y);
	//tmp.zero();
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//index = gray2[i][j];
			sum1 = 0;
			w_sum1 = 0.0;
			//half1 = GAU_W[index1]-1;
			//half = 8;
			//TRACE("GAU_W_1[%d] = %d\n", index1, GAU_W[index1]);
			for (s = -half1; s <= half1; s++) {
				for (t = -half1; t <= half1; t++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					//k = round( dist2(x, y, i, j) );
					if ( k > half1 ) continue; 
					/////////////////////////////////////////////////////
					sum1 += image[x][y] * GAU1[k];
					w_sum1 += GAU1[k];
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			sum1 /= w_sum1; 
			//TRACE("w_sum = %.6f\n", w_sum);
			//////////////////////////////////////////////
			sum2 = 0;
			w_sum2 = 0.0;
			//half2 = GAU_W[index2]-1;
			//half2 = GAU1.getMax()-1; // Now this was a big mistake!!!
			//TRACE("GAU_W_2[%d] = %d\n", index2, GAU_W[index2]);
			for (s = -half2; s <= half2; s++) {
				for (t = -half2; t <= half2; t++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					//k = round( dist2(x, y, i, j) );
					//if ( k > half1 ) continue; 
					if ( k > half2 ) continue; 
					/////////////////////////////////////////////////////
					sum2 += image[x][y] * GAU2[k];
					w_sum2 += GAU2[k];
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			//TRACE("w_sum = %.6f\n", w_sum);
			sum2 /= w_sum2; 
			//////////////////////////////
			/////////////////////////////////////////
			// POSITIVE INNTER CIRCLE
			if (sum1 - tau * sum2 >= 0) // non edge
				tmp[i][j] = 1.0; // non edge
			else 
				tmp[i][j] = 0.0; // edge
		}
	}

	////////////////////////////////////////////
	//double weight;
	int sign;
	/////////////////////////////////////////
	// Smoothing step!
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//index = gray2[i][j];
			sum1 = 0;
			w_sum1 = 0.0;
			//half1 = GAU_W[index1]-1;
			if (tmp[i][j] == 1.0) sign = 1; // Non edge region
			else sign = 0; // edge region
			vec[0].clear();
			vec[1].clear();
			vec[2].clear();
			vec[0].push_back(cmap[i][j].r);
			vec[1].push_back(cmap[i][j].g);
			vec[2].push_back(cmap[i][j].b);
			//half = 8;
			//TRACE("GAU_W_1[%d] = %d\n", index1, GAU_W[index1]);
			for (s = -half1; s <= half1; s++) {
				for (t = -half1; t <= half1; t++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					//k = round( dist2(x, y, i, j) );
					if ( k > half1 ) continue; 
					/////////////////////////////////////////////////////
					if (sign) { // non edge region
						if (tmp[x][y] == 1.0) {
							vec[0].push_back(cmap[x][y].r);
							vec[1].push_back(cmap[x][y].g);
							vec[2].push_back(cmap[x][y].b);
						}
					}
					else { // edge region
						if (tmp[x][y] == 0.0) {
							vec[0].push_back(cmap[x][y].r);
							vec[1].push_back(cmap[x][y].g);
							vec[2].push_back(cmap[x][y].b);
						}
					}
					//sum1 += image[x][y] * GAU1[k] * weight;
					//w_sum1 += GAU1[k] * weight;
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			//sum1 /= w_sum1; 
			sort(vec[0].begin(), vec[0].end()); 
			sort(vec[1].begin(), vec[1].end()); 
			sort(vec[2].begin(), vec[2].end()); 
			//flow_median = vec[vec.size()/2]; 
			//double z = 0.3;
			if (sign) { // non edge region
				//tmp2[i][j].r = vec[0][vec[0].size()-1]; 
				//tmp2[i][j].g = vec[1][vec[1].size()-1]; 
				//tmp2[i][j].b = vec[2][vec[2].size()-1]; 
				tmp2[i][j].r = vec[0][vec[0].size()/2]; 
				tmp2[i][j].g = vec[1][vec[1].size()/2]; 
				tmp2[i][j].b = vec[2][vec[2].size()/2]; 
				//tmp2[i][j].r = round( (1-z) * vec[0][vec[0].size()/2] + z * 255); 
				//tmp2[i][j].g = round( (1-z) * vec[1][vec[1].size()/2] + z * 255); 
				//tmp2[i][j].b = round( (1-z) * vec[2][vec[2].size()/2] + z * 255); 
				//image2[i][j] = round( (1-z) * vec[vec.size()-1] + z * 255 ); // brightest value
			}
			else { // edge region
				//tmp2[i][j] = vec[0]; 
				tmp2[i][j].r = round( (1-z) * vec[0][0] + z * 0 ); // darkest value
				tmp2[i][j].g = round( (1-z) * vec[1][0] + z * 0 ); // darkest value
				tmp2[i][j].b = round( (1-z) * vec[2][0] + z * 0 ); // darkest value
			}
			//TRACE("w_sum = %.6f\n", w_sum);
			//////////////////////////////////////////////
			///* handle only one side of the edge!
			//TRACE("sum1 = %f\n", sum1);
			//TRACE("sum2 = %f\n", sum2);
			//TRACE("sum1 - tau * sum2 = %f\n", sum1 - tau * sum2);
			/////////////////////////////////////////
			//image2[i][j] = round(sum1);
		}
	}
	////////////////////////////////////////////

	// Normalize DOG value (not necessary! because MAX_DOG is always 1)
	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			//TRACE("p[%d][%d].mag = %0.3f\n", i, j, p[i][j].mag);
			//tmp[i][j] = tmp[i][j] / MAX_DOG; // place it between [0, 1]
			//////////////////////////////////////////////////
			//G_mag[i][j] = 1-tmp[i][j]; // [0, 1] used for nonmaxima suppression
			// the higher, the stronger the edgeness!
			///////////////////////////////////////////////////
			//TRACE("G_mag[%d][%d] = %.1f\n", i, j, G_mag[i][j]);
			//TRACE("tmp[%d][%d] = %0.3f\n", i, j, tmp[i][j]);
			//TRACE("G_mag[%d][%d] = %0.3f\n", i, j, G_mag[i][j]);
			//if (tmp[i][j] < 0)
			//	TRACE("tmp[%d][%d] = %0.2f\n", i, j, tmp[i][j]);
			cmap[i][j].r = tmp2[i][j].r;
			cmap[i][j].g = tmp2[i][j].g;
			cmap[i][j].b = tmp2[i][j].b;
			//image2[i][j] = 255 - round(tmp[i][j] * 255.);
		}
	}
}

void GetColShock2(cimatrix& cmap, imatrix& image, double sigma, double tau, double z) 
// Multiply the Shock value with the DOG value!
{
	int	i, j, k;
	double MAX_DOG = -1.0;
	int s, t;
	int x, y;

	int image_x = image.getRow();
	int image_y = image.getCol();

	int half1, half2; // small window and big window
	//int index1, index2; // index for Gaussian matrix
	double sum1, sum2, w_sum1, w_sum2;
	double z2;

	//////////////////////////////////
	//Make2DGaussMask(sigma); // mask for unilateral filtering

	//N = gau_mask.getRow();
	//half = N / 2;

	//ClearMemDC(&dc); // clear the canvas white
	//////////////////////////////////////////////
	//double factor = 2.0;
	//MakeGaussMatrix(factor, GAU); // factor controls the Gaussian window size for each index
	vector GAU1, GAU2;
	MakeGaussVector(sigma, GAU1);
	MakeGaussVector(sigma*1.6, GAU2);
	half1 = GAU1.getMax()-1;
	half2 = GAU2.getMax()-1;

	deque<int> vec[3];
	////////////////////////////////////////////////////////
	matrix tmp(image_x, image_y);
	cimatrix tmp2(image_x, image_y);
	//tmp.zero();
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//index = gray2[i][j];
			sum1 = 0;
			w_sum1 = 0.0;
			//half1 = GAU_W[index1]-1;
			//half = 8;
			//TRACE("GAU_W_1[%d] = %d\n", index1, GAU_W[index1]);
			for (s = -half1; s <= half1; s++) {
				for (t = -half1; t <= half1; t++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					//k = round( dist2(x, y, i, j) );
					if ( k > half1 ) continue; 
					/////////////////////////////////////////////////////
					sum1 += image[x][y] * GAU1[k];
					w_sum1 += GAU1[k];
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			sum1 /= w_sum1; 
			//TRACE("w_sum = %.6f\n", w_sum);
			//////////////////////////////////////////////
			sum2 = 0;
			w_sum2 = 0.0;
			//half2 = GAU_W[index2]-1;
			//half2 = GAU1.getMax()-1; // Now this was a big mistake!!!
			//TRACE("GAU_W_2[%d] = %d\n", index2, GAU_W[index2]);
			for (s = -half2; s <= half2; s++) {
				for (t = -half2; t <= half2; t++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					//k = round( dist2(x, y, i, j) );
					//if ( k > half1 ) continue; 
					if ( k > half2 ) continue; 
					/////////////////////////////////////////////////////
					sum2 += image[x][y] * GAU2[k];
					w_sum2 += GAU2[k];
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			//TRACE("w_sum = %.6f\n", w_sum);
			sum2 /= w_sum2; 
			//////////////////////////////
			/////////////////////////////////////////
			tmp[i][j] = sum1 - tau * sum2;
			//TRACE("tmp[%d][%d] = %f\n", i, j, tmp[i][j]);
			//if (sum1 - tau * sum2 >= 0) // non edge
			//	tmp[i][j] = 1.0; // non edge
			//else 
			//	tmp[i][j] = 0.0; // edge
		}
	}
	////////////////////////////////////////////
	//double weight;
	int sign;
	/////////////////////////////////////////
	// Smoothing step!
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//index = gray2[i][j];
			sum1 = 0;
			w_sum1 = 0.0;
			//half1 = GAU_W[index1]-1;
			///////////////////////////////////
			if (tmp[i][j] >= 0.0) sign = 1; // Non edge region
			else sign = 0; // edge region
			/////////////////////////////////////
			vec[0].clear();
			vec[1].clear();
			vec[2].clear();
			vec[0].push_back(cmap[i][j].r);
			vec[1].push_back(cmap[i][j].g);
			vec[2].push_back(cmap[i][j].b);
			//half = 8;
			//TRACE("GAU_W_1[%d] = %d\n", index1, GAU_W[index1]);
			for (s = -half1; s <= half1; s++) {
				for (t = -half1; t <= half1; t++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					//k = round( dist2(x, y, i, j) );
					if ( k > half1 ) continue; 
					/////////////////////////////////////////////////////
					if (sign) { // non edge region
						if (tmp[x][y] >= 0.0) {
							vec[0].push_back(cmap[x][y].r);
							vec[1].push_back(cmap[x][y].g);
							vec[2].push_back(cmap[x][y].b);
						}
					}
					else { // edge region
						if (tmp[x][y] < 0.0) {
							vec[0].push_back(cmap[x][y].r);
							vec[1].push_back(cmap[x][y].g);
							vec[2].push_back(cmap[x][y].b);
						}
					}
					//sum1 += image[x][y] * GAU1[k] * weight;
					//w_sum1 += GAU1[k] * weight;
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			//sum1 /= w_sum1; 
			sort(vec[0].begin(), vec[0].end()); 
			sort(vec[1].begin(), vec[1].end()); 
			sort(vec[2].begin(), vec[2].end()); 
			//flow_median = vec[vec.size()/2]; 
			//double z = 0.3;
			if (sign) { // non edge region
				//tmp2[i][j].r = vec[0][vec[0].size()-1]; 
				//tmp2[i][j].g = vec[1][vec[1].size()-1]; 
				//tmp2[i][j].b = vec[2][vec[2].size()-1]; 
				tmp2[i][j].r = vec[0][vec[0].size()/2]; 
				tmp2[i][j].g = vec[1][vec[1].size()/2]; 
				tmp2[i][j].b = vec[2][vec[2].size()/2]; 
				//tmp2[i][j].r = round( (1-z) * vec[0][vec[0].size()/2] + z * 255); 
				//tmp2[i][j].g = round( (1-z) * vec[1][vec[1].size()/2] + z * 255); 
				//tmp2[i][j].b = round( (1-z) * vec[2][vec[2].size()/2] + z * 255); 
				//image2[i][j] = round( (1-z) * vec[vec.size()-1] + z * 255 ); // brightest value
				z2 = tmp[i][j]/10.0; // positive
				//TRACE("tmp[%d][%d] = %f\n", i, j, tmp[i][j]);
				tmp2[i][j].r = round( (1-z2) * tmp2[i][j].r + z2 * 255 ); // darkest value
				tmp2[i][j].g = round( (1-z2) * tmp2[i][j].g + z2 * 255 ); // darkest value
				tmp2[i][j].b = round( (1-z2) * tmp2[i][j].b + z2 * 255 ); // darkest value
			
			}
			else { // edge region
				//tmp2[i][j] = vec[0]; 
				tmp2[i][j].r = round( (1-z) * vec[0][0] + z * 0 ); // darkest value
				tmp2[i][j].g = round( (1-z) * vec[1][0] + z * 0 ); // darkest value
				tmp2[i][j].b = round( (1-z) * vec[2][0] + z * 0 ); // darkest value
				z2 = tmp[i][j]/10; // negative
				//TRACE("tmp[%d][%d] = %f\n", i, j, tmp[i][j]);
				tmp2[i][j].r = round( (1-z2) * tmp2[i][j].r + z2 * 0 ); // darkest value
				tmp2[i][j].g = round( (1-z2) * tmp2[i][j].g + z2 * 0 ); // darkest value
				tmp2[i][j].b = round( (1-z2) * tmp2[i][j].b + z2 * 0 ); // darkest value
			}
			//TRACE("w_sum = %.6f\n", w_sum);
			//////////////////////////////////////////////
			///* handle only one side of the edge!
			//TRACE("sum1 = %f\n", sum1);
			//TRACE("sum2 = %f\n", sum2);
			//TRACE("sum1 - tau * sum2 = %f\n", sum1 - tau * sum2);
			/////////////////////////////////////////
			//image2[i][j] = round(sum1);
		}
	}
	////////////////////////////////////////////

	// Normalize DOG value (not necessary! because MAX_DOG is always 1)
	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			//TRACE("p[%d][%d].mag = %0.3f\n", i, j, p[i][j].mag);
			//tmp[i][j] = tmp[i][j] / MAX_DOG; // place it between [0, 1]
			//////////////////////////////////////////////////
			//G_mag[i][j] = 1-tmp[i][j]; // [0, 1] used for nonmaxima suppression
			// the higher, the stronger the edgeness!
			///////////////////////////////////////////////////
			//TRACE("G_mag[%d][%d] = %.1f\n", i, j, G_mag[i][j]);
			//TRACE("tmp[%d][%d] = %0.3f\n", i, j, tmp[i][j]);
			//TRACE("G_mag[%d][%d] = %0.3f\n", i, j, G_mag[i][j]);
			//if (tmp[i][j] < 0)
			//	TRACE("tmp[%d][%d] = %0.2f\n", i, j, tmp[i][j]);
			cmap[i][j].r = tmp2[i][j].r;
			cmap[i][j].g = tmp2[i][j].g;
			cmap[i][j].b = tmp2[i][j].b;
			//image2[i][j] = 255 - round(tmp[i][j] * 255.);
		}
	}
}

void GetColShock3(cimatrix& cmap, imatrix& image, double sigma, double tau, int half, double z) 
// use Min-Max filtering!
{
	int	i, j, k;
	double MAX_DOG = -1.0;
	int s, t;
	int x, y;

	int image_x = image.getRow();
	int image_y = image.getCol();

	int half1, half2; // small window and big window
	//int index1, index2; // index for Gaussian matrix
	double sum1, sum2, w_sum1, w_sum2;

	vector GAU1, GAU2;
	MakeGaussVector(sigma, GAU1);
	MakeGaussVector(sigma*1.6, GAU2);
	half1 = GAU1.getMax()-1;
	half2 = GAU2.getMax()-1;

	deque<int> vec[3];
	////////////////////////////////////////////////////////
	matrix tmp(image_x, image_y);
	cimatrix tmp2(image_x, image_y);
	//tmp.zero();
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//index = gray2[i][j];
			sum1 = 0;
			w_sum1 = 0.0;
			//half1 = GAU_W[index1]-1;
			//half = 8;
			//TRACE("GAU_W_1[%d] = %d\n", index1, GAU_W[index1]);
			for (s = -half1; s <= half1; s++) {
				for (t = -half1; t <= half1; t++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					//k = round( dist2(x, y, i, j) );
					if ( k > half1 ) continue; 
					/////////////////////////////////////////////////////
					sum1 += image[x][y] * GAU1[k];
					w_sum1 += GAU1[k];
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			sum1 /= w_sum1; 
			//TRACE("w_sum = %.6f\n", w_sum);
			//////////////////////////////////////////////
			sum2 = 0;
			w_sum2 = 0.0;
			//half2 = GAU_W[index2]-1;
			//half2 = GAU1.getMax()-1; // Now this was a big mistake!!!
			//TRACE("GAU_W_2[%d] = %d\n", index2, GAU_W[index2]);
			for (s = -half2; s <= half2; s++) {
				for (t = -half2; t <= half2; t++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					//k = round( dist2(x, y, i, j) );
					//if ( k > half1 ) continue; 
					if ( k > half2 ) continue; 
					/////////////////////////////////////////////////////
					sum2 += image[x][y] * GAU2[k];
					w_sum2 += GAU2[k];
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			//TRACE("w_sum = %.6f\n", w_sum);
			sum2 /= w_sum2; 
			//////////////////////////////
			/////////////////////////////////////////
			// POSITIVE INNTER CIRCLE
			if (sum1 - tau * sum2 >= 0) // non edge
				tmp[i][j] = 1.0; // non edge
			else 
				tmp[i][j] = 0.0; // edge
		}
	}

	////////////////////////////////////////////
	//double weight;
	int sign;
	half1 = half;
	/////////////////////////////////////////
	// Smoothing step!
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//index = gray2[i][j];
			sum1 = 0;
			w_sum1 = 0.0;
			//half1 = GAU_W[index1]-1;
			if (tmp[i][j] == 1.0) sign = 1; // Non edge region
			else sign = 0; // edge region
			vec[0].clear();
			vec[1].clear();
			vec[2].clear();
			vec[0].push_back(cmap[i][j].r);
			vec[1].push_back(cmap[i][j].g);
			vec[2].push_back(cmap[i][j].b);
			//half = 8;
			//TRACE("GAU_W_1[%d] = %d\n", index1, GAU_W[index1]);
			for (s = -half1; s <= half1; s++) {
				for (t = -half1; t <= half1; t++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					//k = round( dist2(x, y, i, j) );
					if ( k > half1 ) continue; 
					/////////////////////////////////////////////////////
					if (sign) { // non edge region
						if (tmp[x][y] == 1.0) {
							vec[0].push_back(cmap[x][y].r);
							vec[1].push_back(cmap[x][y].g);
							vec[2].push_back(cmap[x][y].b);
						}
					}
					else { // edge region
						if (tmp[x][y] == 0.0) {
							vec[0].push_back(cmap[x][y].r);
							vec[1].push_back(cmap[x][y].g);
							vec[2].push_back(cmap[x][y].b);
						}
					}
					//sum1 += image[x][y] * GAU1[k] * weight;
					//w_sum1 += GAU1[k] * weight;
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			//sum1 /= w_sum1; 
			sort(vec[0].begin(), vec[0].end()); 
			sort(vec[1].begin(), vec[1].end()); 
			sort(vec[2].begin(), vec[2].end()); 
			//flow_median = vec[vec.size()/2]; 
			//double z = 0.3;
			if (sign) { // non edge region
				//tmp2[i][j].r = vec[0][vec[0].size()-1]; 
				//tmp2[i][j].g = vec[1][vec[1].size()-1]; 
				//tmp2[i][j].b = vec[2][vec[2].size()-1]; 
				tmp2[i][j].r = vec[0][vec[0].size()/2]; 
				tmp2[i][j].g = vec[1][vec[1].size()/2]; 
				tmp2[i][j].b = vec[2][vec[2].size()/2]; 
				//tmp2[i][j].r = round( (1-z) * vec[0][vec[0].size()/2] + z * 255); 
				//tmp2[i][j].g = round( (1-z) * vec[1][vec[1].size()/2] + z * 255); 
				//tmp2[i][j].b = round( (1-z) * vec[2][vec[2].size()/2] + z * 255); 
				//image2[i][j] = round( (1-z) * vec[vec.size()-1] + z * 255 ); // brightest value
			}
			else { // edge region
				//tmp2[i][j].r = vec[0][0];
				//tmp2[i][j].g = vec[1][0];
				//tmp2[i][j].b = vec[2][0];
				tmp2[i][j].r = round( (1-z) * vec[0][0] + z * 0 ); // darkest value
				tmp2[i][j].g = round( (1-z) * vec[1][0] + z * 0 ); // darkest value
				tmp2[i][j].b = round( (1-z) * vec[2][0] + z * 0 ); // darkest value
			}
			//TRACE("w_sum = %.6f\n", w_sum);
			//////////////////////////////////////////////
			///* handle only one side of the edge!
			//TRACE("sum1 = %f\n", sum1);
			//TRACE("sum2 = %f\n", sum2);
			//TRACE("sum1 - tau * sum2 = %f\n", sum1 - tau * sum2);
			/////////////////////////////////////////
			//image2[i][j] = round(sum1);
		}
	}
	////////////////////////////////////////////

	// Normalize DOG value (not necessary! because MAX_DOG is always 1)
	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			//TRACE("p[%d][%d].mag = %0.3f\n", i, j, p[i][j].mag);
			//tmp[i][j] = tmp[i][j] / MAX_DOG; // place it between [0, 1]
			//////////////////////////////////////////////////
			//G_mag[i][j] = 1-tmp[i][j]; // [0, 1] used for nonmaxima suppression
			// the higher, the stronger the edgeness!
			///////////////////////////////////////////////////
			//TRACE("G_mag[%d][%d] = %.1f\n", i, j, G_mag[i][j]);
			//TRACE("tmp[%d][%d] = %0.3f\n", i, j, tmp[i][j]);
			//TRACE("G_mag[%d][%d] = %0.3f\n", i, j, G_mag[i][j]);
			//if (tmp[i][j] < 0)
			//	TRACE("tmp[%d][%d] = %0.2f\n", i, j, tmp[i][j]);
			cmap[i][j].r = tmp2[i][j].r;
			cmap[i][j].g = tmp2[i][j].g;
			cmap[i][j].b = tmp2[i][j].b;
			//image2[i][j] = 255 - round(tmp[i][j] * 255.);
		}
	}
}

void GetColShockFast(cimatrix& cmap, imatrix& image, double sigma, double tau, double z) 
// faster version
{
	int	i, j;
	double MAX_DOG = -1.0;
	int s, t;
	int x, y;

	int image_x = image.getRow();
	int image_y = image.getCol();

	int half1, half2; // small window and big window
	//int index1, index2; // index for Gaussian matrix
	double sum1, w_sum1;

	vector GAU1, GAU2;
	MakeGaussVector(sigma, GAU1);
	MakeGaussVector(sigma*1.6, GAU2);
	half1 = GAU1.getMax()-1;
	half2 = GAU2.getMax()-1;

	deque<int> vec[3];
	////////////////////////////////////////////////////////
	//matrix tmp(image_x, image_y);
	cimatrix tmp2(image_x, image_y);
	
	matrix inner(image_x, image_y);
	GaussSmoothSepDouble(image, sigma, inner);

	matrix outer(image_x, image_y);
	GaussSmoothSepDouble(image, sigma*1.6, outer);

	imatrix tmp(image_x, image_y);

	double dog;
	//deque<int> vec[3];
	//////////////////////////////
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			dog = inner[i][j] - tau * outer[i][j];
			if (dog >= 0) tmp[i][j] = 1; 
			//if (dog >= thres) lap[i][j] = 255; 
			//else if (tanh(dog) + 1 > thres) lap[i][j] = 255; 
			//else if (tanh(dog) + 1 > 0.1) lap[i][j] = 255; 
			else tmp[i][j] = 0; 
		}
	}

	////////////////////////////////////////////
	//double weight;
	int sign;
	//half1 = half;
	/////////////////////////////////////////
	// Smoothing step!
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//index = gray2[i][j];
			sum1 = 0;
			w_sum1 = 0.0;
			//half1 = GAU_W[index1]-1;
			if (tmp[i][j] == 1) sign = 1; // Non edge region
			else sign = 0; // edge region
			vec[0].clear();
			vec[1].clear();
			vec[2].clear();
			vec[0].push_back(cmap[i][j].r);
			vec[1].push_back(cmap[i][j].g);
			vec[2].push_back(cmap[i][j].b);
			//half = 8;
			//TRACE("GAU_W_1[%d] = %d\n", index1, GAU_W[index1]);
			for (s = -half1; s <= half1; s++) {
				////////////////////////
				x = i+s; y = j;
				/////////////////////////////////////////////////////
				if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) 
					continue;
				/////////////////////////////////////////////////////////
				// circular kernel
				//k = (int)dist2(x, y, i, j);
				//k = round( dist2(x, y, i, j) );
				//if ( k > half1 ) continue; 
				/////////////////////////////////////////////////////
				if (sign) { // non edge region
					if (tmp[x][y] == 1) {
						vec[0].push_back(cmap[x][y].r);
						vec[1].push_back(cmap[x][y].g);
						vec[2].push_back(cmap[x][y].b);
					}
				}
				else { // edge region
					if (tmp[x][y] == 0) {
						vec[0].push_back(cmap[x][y].r);
						vec[1].push_back(cmap[x][y].g);
						vec[2].push_back(cmap[x][y].b);
					}
				}
				//sum1 += image[x][y] * GAU1[k] * weight;
				//w_sum1 += GAU1[k] * weight;
				//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
				//TRACE("k = %d\n", k);
			}
			for (t = -half1; t <= half1; t++) {
				////////////////////////
				x = i; y = j+t;
				/////////////////////////////////////////////////////
				if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) 
					continue;
				/////////////////////////////////////////////////////////
				// circular kernel
				//k = (int)dist2(x, y, i, j);
				//k = round( dist2(x, y, i, j) );
				//if ( k > half1 ) continue; 
				/////////////////////////////////////////////////////
				if (sign) { // non edge region
					if (tmp[x][y] == 1) {
						vec[0].push_back(cmap[x][y].r);
						vec[1].push_back(cmap[x][y].g);
						vec[2].push_back(cmap[x][y].b);
					}
				}
				else { // edge region
					if (tmp[x][y] == 0) {
						vec[0].push_back(cmap[x][y].r);
						vec[1].push_back(cmap[x][y].g);
						vec[2].push_back(cmap[x][y].b);
					}
				}
				//sum1 += image[x][y] * GAU1[k] * weight;
				//w_sum1 += GAU1[k] * weight;
				//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
				//TRACE("k = %d\n", k);
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			//sum1 /= w_sum1; 
			sort(vec[0].begin(), vec[0].end()); 
			sort(vec[1].begin(), vec[1].end()); 
			sort(vec[2].begin(), vec[2].end()); 
			//flow_median = vec[vec.size()/2]; 
			//double z = 0.3;
			if (sign) { // non edge region
				tmp2[i][j].r = vec[0][vec[0].size()-1]; 
				tmp2[i][j].g = vec[1][vec[1].size()-1]; 
				tmp2[i][j].b = vec[2][vec[2].size()-1]; 
				//tmp2[i][j].r = vec[0][vec[0].size()/2]; 
				//tmp2[i][j].g = vec[1][vec[1].size()/2]; 
				//tmp2[i][j].b = vec[2][vec[2].size()/2]; 
				//tmp2[i][j].r = round( (1-z) * vec[0][vec[0].size()/2] + z * 255); 
				//tmp2[i][j].g = round( (1-z) * vec[1][vec[1].size()/2] + z * 255); 
				//tmp2[i][j].b = round( (1-z) * vec[2][vec[2].size()/2] + z * 255); 
				//image2[i][j] = round( (1-z) * vec[vec.size()-1] + z * 255 ); // brightest value
			}
			else { // edge region
				tmp2[i][j].r = vec[0][0];
				tmp2[i][j].g = vec[1][0];
				tmp2[i][j].b = vec[2][0];
				//tmp2[i][j].r = round( (1-z) * vec[0][0] + z * 0 ); // darkest value
				//tmp2[i][j].g = round( (1-z) * vec[1][0] + z * 0 ); // darkest value
				//tmp2[i][j].b = round( (1-z) * vec[2][0] + z * 0 ); // darkest value
			}
			//TRACE("w_sum = %.6f\n", w_sum);
			//////////////////////////////////////////////
			///* handle only one side of the edge!
			//TRACE("sum1 = %f\n", sum1);
			//TRACE("sum2 = %f\n", sum2);
			//TRACE("sum1 - tau * sum2 = %f\n", sum1 - tau * sum2);
			/////////////////////////////////////////
			//image2[i][j] = round(sum1);
		}
	}
	////////////////////////////////////////////

	// Normalize DOG value (not necessary! because MAX_DOG is always 1)
	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			//TRACE("p[%d][%d].mag = %0.3f\n", i, j, p[i][j].mag);
			//tmp[i][j] = tmp[i][j] / MAX_DOG; // place it between [0, 1]
			//////////////////////////////////////////////////
			//G_mag[i][j] = 1-tmp[i][j]; // [0, 1] used for nonmaxima suppression
			// the higher, the stronger the edgeness!
			///////////////////////////////////////////////////
			//TRACE("G_mag[%d][%d] = %.1f\n", i, j, G_mag[i][j]);
			//TRACE("tmp[%d][%d] = %0.3f\n", i, j, tmp[i][j]);
			//TRACE("G_mag[%d][%d] = %0.3f\n", i, j, G_mag[i][j]);
			//if (tmp[i][j] < 0)
			//	TRACE("tmp[%d][%d] = %0.2f\n", i, j, tmp[i][j]);
			cmap[i][j].r = tmp2[i][j].r;
			cmap[i][j].g = tmp2[i][j].g;
			cmap[i][j].b = tmp2[i][j].b;
			//image2[i][j] = 255 - round(tmp[i][j] * 255.);
		}
	}
}


void GetColShockFastHSV(cimatrix& cmap, imatrix& image, double sigma, double tau) 
// faster version
{
	int	i, j;
	double MAX_DOG = -1.0;
	int ss, t;
	int x, y;

	int image_x = image.getRow();
	int image_y = image.getCol();

	int half1; // small window and big window
	//int index1, index2; // index for Gaussian matrix
	double sum1, w_sum1;

	vector GAU1, GAU2;
	MakeGaussVector(sigma, GAU1);
	//MakeGaussVector(sigma*1.6, GAU2);
	half1 = GAU1.getMax()-1;
	//half2 = GAU2.getMax()-1;

	deque<double> vec;
	////////////////////////////////////////////////////////
	//matrix tmp(image_x, image_y);
	cimatrix tmp2(image_x, image_y);
	
	matrix inner(image_x, image_y);
	GaussSmoothSepDouble(image, sigma, inner);

	matrix outer(image_x, image_y);
	GaussSmoothSepDouble(image, sigma*1.6, outer);

	imatrix tmp(image_x, image_y);

	double dog;
	//deque<int> vec[3];
	//////////////////////////////
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			dog = inner[i][j] - tau * outer[i][j];
			if (dog >= 0) tmp[i][j] = 1; 
			//if (dog >= thres) lap[i][j] = 255; 
			//else if (tanh(dog) + 1 > thres) lap[i][j] = 255; 
			//else if (tanh(dog) + 1 > 0.1) lap[i][j] = 255; 
			else tmp[i][j] = 0; 
		}
	}

	////////////////////////////////////////////
	//double weight;
	int sign;
	double r, g, b, h, s, v, h1, s1, v1;
	//half1 = half;
	/////////////////////////////////////////
	// Smoothing step!
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//index = gray2[i][j];
			sum1 = 0;
			w_sum1 = 0.0;
			//half1 = GAU_W[index1]-1;
			if (tmp[i][j] == 1) sign = 1; // Non edge region
			else sign = 0; // edge region
			
			r = (double)cmap[i][j].r/255.;
			g = (double)cmap[i][j].g/255.;
			b = (double)cmap[i][j].b/255.;
			RGB2HSV(r, g, b, h1, s1, v1);

			vec.clear();
			//vec.push_back(v);
			//half = 8;
			//TRACE("GAU_W_1[%d] = %d\n", index1, GAU_W[index1]);
			for (ss = -half1; ss <= half1; ss++) {
				////////////////////////
				x = i+ss; y = j;
				/////////////////////////////////////////////////////
				if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) 
					continue;
				/////////////////////////////////////////////////////////
				/////////////////////////////////////////////////////
				r = (double)cmap[x][y].r/255.;
				g = (double)cmap[x][y].g/255.;
				b = (double)cmap[x][y].b/255.;
				RGB2HSV(r, g, b, h, s, v);
				vec.push_back(v);
				//sum1 += image[x][y] * GAU1[k] * weight;
				//w_sum1 += GAU1[k] * weight;
				//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
				//TRACE("k = %d\n", k);
			}
			for (t = -half1; t <= half1; t++) {
				////////////////////////
				x = i; y = j+t;
				/////////////////////////////////////////////////////
				if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) 
					continue;
				/////////////////////////////////////////////////////
				r = (double)cmap[x][y].r/255.;
				g = (double)cmap[x][y].g/255.;
				b = (double)cmap[x][y].b/255.;
				RGB2HSV(r, g, b, h, s, v);
				vec.push_back(v);
			}
			////////////////////////////////////
			sort(vec.begin(), vec.end()); 
			//double z = 0.3;
			if (sign) { // non edge region
				v1 = vec[vec.size()-1];
			}
			else { // edge region
				v1 = vec[0];
			}
			HSV2RGB(h1, s1, v1, r, g, b);
			tmp2[i][j].r = (GLubyte)(r*255);
			tmp2[i][j].g = (GLubyte)(g*255);
			tmp2[i][j].b = (GLubyte)(b*255);
			//TRACE("w_sum = %.6f\n", w_sum);
			//////////////////////////////////////////////
		}
	}
	////////////////////////////////////////////

	// Normalize DOG value (not necessary! because MAX_DOG is always 1)
	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			//TRACE("p[%d][%d].mag = %0.3f\n", i, j, p[i][j].mag);
			//tmp[i][j] = tmp[i][j] / MAX_DOG; // place it between [0, 1]
			//////////////////////////////////////////////////
			//G_mag[i][j] = 1-tmp[i][j]; // [0, 1] used for nonmaxima suppression
			// the higher, the stronger the edgeness!
			///////////////////////////////////////////////////
			//TRACE("G_mag[%d][%d] = %.1f\n", i, j, G_mag[i][j]);
			//TRACE("tmp[%d][%d] = %0.3f\n", i, j, tmp[i][j]);
			//TRACE("G_mag[%d][%d] = %0.3f\n", i, j, G_mag[i][j]);
			//if (tmp[i][j] < 0)
			//	TRACE("tmp[%d][%d] = %0.2f\n", i, j, tmp[i][j]);
			cmap[i][j].r = tmp2[i][j].r;
			cmap[i][j].g = tmp2[i][j].g;
			cmap[i][j].b = tmp2[i][j].b;
			//image2[i][j] = 255 - round(tmp[i][j] * 255.);
		}
	}
}

void GetColShockFastMinMax(cimatrix& cmap, imatrix& image, double sigma, double tau) 
// we find min and max in terms of R + G + B
{
	int	i, j;
	double MAX_DOG = -1.0;
	int ss, t;
	int x, y;

	int image_x = image.getRow();
	int image_y = image.getCol();

	int half1; // small window and big window
	//int index1, index2; // index for Gaussian matrix
	double sum1, w_sum1;

	vector GAU1, GAU2;
	MakeGaussVector(sigma, GAU1);
	//MakeGaussVector(sigma*1.6, GAU2);
	half1 = GAU1.getMax()-1;
	//half2 = GAU2.getMax()-1;

	//deque<double> vec;
	////////////////////////////////////////////////////////
	//matrix tmp(image_x, image_y);
	cimatrix tmp2(image_x, image_y);
	
	matrix inner(image_x, image_y);
	GaussSmoothSepDouble(image, sigma, inner);

	matrix outer(image_x, image_y);
	GaussSmoothSepDouble(image, sigma*1.6, outer);

	imatrix tmp(image_x, image_y);

	double dog;
	//deque<int> vec[3];
	//double thres = 0.7;
	//////////////////////////////
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			dog = inner[i][j] - tau * outer[i][j];
			if (dog >= 0.0) tmp[i][j] = 1; 
			//if (dog >= thres) tmp[i][j] = 1; 
			//else if (tanh(dog) + 1 > thres) tmp[i][j] = 1; 
			//else if (tanh(dog) + 1 > 0.1) lap[i][j] = 255; 
			else tmp[i][j] = 0; 
		}
	}

	////////////////////////////////////////////
	//double weight;
	int sign;
	int r, g, b;
	int min, max, sum;
	GLubyte min_r, min_g, min_b, max_r, max_g, max_b;
	//half1 = half;
	half1 = 1;
	/////////////////////////////////////////
	// Smoothing step!
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//index = gray2[i][j];
			sum1 = 0;
			w_sum1 = 0.0;
			//half1 = GAU_W[index1]-1;
			if (tmp[i][j] == 1) sign = 1; // Non edge region
			else sign = 0; // edge region

			max = -1;
			min = 1000000;
			
			for (ss = -half1; ss <= half1; ss++) {
				////////////////////////
				x = i+ss; y = j;
				/////////////////////////////////////////////////////
				if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) 
					continue;
				/////////////////////////////////////////////////////////
				/////////////////////////////////////////////////////
				if (sign == tmp[x][y]) {
					r = cmap[x][y].r;
					g = cmap[x][y].g;
					b = cmap[x][y].b;
					sum = r + g + b;
					if (sum > max) { 
						max = sum; 
						max_r = r; max_g = g; max_b = b;
					}
					if (r + g + b < min) { 
						min = sum; 
						min_r = r; min_g = g; min_b = b;
					}
					//TRACE("k = %d\n", k)
				}
			}
			////////////////////////////////////
			if (sign) { // non edge region
				tmp2[i][j].r = max_r;
				tmp2[i][j].g = max_g;
				tmp2[i][j].b = max_b;
			}
			else { // edge region
				tmp2[i][j].r = min_r;
				tmp2[i][j].g = min_g;
				tmp2[i][j].b = min_b;
			}

		}
	}
	////////////////////////////////////////////
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//index = gray2[i][j];
			sum1 = 0;
			w_sum1 = 0.0;
			//half1 = GAU_W[index1]-1;
			if (tmp[i][j] == 1) sign = 1; // Non edge region
			else sign = 0; // edge region

			max = -1;
			min = 1000000;
			
			for (t = -half1; t <= half1; t++) {
				////////////////////////
				x = i; y = j+t;
				/////////////////////////////////////////////////////
				if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) 
					continue;
				/////////////////////////////////////////////////////
				if (sign == tmp[x][y]) {
					r = tmp2[x][y].r;
					g = tmp2[x][y].g;
					b = tmp2[x][y].b;
					sum = r + g + b;
					if (sum > max) { 
						max = sum; 
						max_r = r; max_g = g; max_b = b;
					}
					if (r + g + b < min) { 
						min = sum; 
						min_r = r; min_g = g; min_b = b;
					}
				}
			}
			////////////////////////////////////
			if (sign) { // non edge region
				cmap[i][j].r = max_r;
				cmap[i][j].g = max_g;
				cmap[i][j].b = max_b;
			}
			else { // edge region
				cmap[i][j].r = min_r;
				cmap[i][j].g = min_g;
				cmap[i][j].b = min_b;
			}

		}
	}
	////////////////////////////////////////////

}

void GetColShockFastWeickert(cimatrix& cmap, ETF& e, double sigma, double tau) 
// using Tensor flow to get the Laplacian sign
// we find min and max in terms of R + G + B
{
	int	i, j;
	double MAX_DOG = -1.0;
	int ss, t;
	int x, y;

	int image_x = cmap.getRow();
	int image_y = cmap.getCol();

	imatrix image(image_x, image_y);

	CopyCol2GrayImage2(cmap, image); 

	int half1; // small window and big window
	//int index1, index2; // index for Gaussian matrix
	double sum1, w_sum1;

	vector GAU1, GAU2;
	MakeGaussVector(sigma, GAU1);
	MakeGaussVector(sigma*1.6, GAU2);
	half1 = GAU1.getMax()-1;
	//half2 = GAU2.getMax()-1;

	//deque<double> vec;
	////////////////////////////////////////////////////////
	//matrix tmp(image_x, image_y);
	cimatrix tmp2(image_x, image_y);

	matrix dog(image_x, image_y);
	
	imatrix tmp(image_x, image_y);

	GetFlowShockDoGETF(image, e, dog, GAU1, GAU2, tau);

	//double dog;
	//deque<int> vec[3];
	//double thres = 0.7;
	//////////////////////////////
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//TRACE("dog[%d][%d] = %f\n", i, j, dog[i][j]);
			if (dog[i][j] >= 0.0) tmp[i][j] = 1; 
			//if (dog >= thres) tmp[i][j] = 1; 
			//else if (tanh(dog) + 1 > thres) tmp[i][j] = 1; 
			//else if (tanh(dog) + 1 > 0.1) lap[i][j] = 255; 
			else tmp[i][j] = 0; 
		}
	}

	////////////////////////////////////////////
	//double weight;
	int sign;
	int r, g, b;
	int min, max, sum;
	GLubyte min_r, min_g, min_b, max_r, max_g, max_b;
	//half1 = half;
	
	/////////////////////////////
	half1 = 50;
	/////////////////////////////////////////
	// Smoothing step!
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//index = gray2[i][j];
			sum1 = 0;
			w_sum1 = 0.0;
			//half1 = GAU_W[index1]-1;
			if (tmp[i][j] == 1) sign = 1; // Non edge region
			else sign = 0; // edge region

			max = -1;
			min = 1000000;
			
			for (ss = -half1; ss <= half1; ss++) {
				////////////////////////
				x = i+ss; y = j;
				/////////////////////////////////////////////////////
				if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) 
					continue;
				/////////////////////////////////////////////////////////
				/////////////////////////////////////////////////////
				if (sign == tmp[x][y]) {
					r = cmap[x][y].r;
					g = cmap[x][y].g;
					b = cmap[x][y].b;
					sum = r + g + b;
					if (sum > max) { 
						max = sum; 
						max_r = r; max_g = g; max_b = b;
					}
					if (r + g + b < min) { 
						min = sum; 
						min_r = r; min_g = g; min_b = b;
					}
					//TRACE("k = %d\n", k)
				}
			}
			////////////////////////////////////
			if (sign) { // non edge region
				tmp2[i][j].r = max_r;
				tmp2[i][j].g = max_g;
				tmp2[i][j].b = max_b;
			}
			else { // edge region
				tmp2[i][j].r = min_r;
				tmp2[i][j].g = min_g;
				tmp2[i][j].b = min_b;
			}

		}
	}
	////////////////////////////////////////////
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//index = gray2[i][j];
			sum1 = 0;
			w_sum1 = 0.0;
			//half1 = GAU_W[index1]-1;
			if (tmp[i][j] == 1) sign = 1; // Non edge region
			else sign = 0; // edge region

			max = -1;
			min = 1000000;
			
			for (t = -half1; t <= half1; t++) {
				////////////////////////
				x = i; y = j+t;
				/////////////////////////////////////////////////////
				if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) 
					continue;
				/////////////////////////////////////////////////////
				if (sign == tmp[x][y]) {
					r = tmp2[x][y].r;
					g = tmp2[x][y].g;
					b = tmp2[x][y].b;
					sum = r + g + b;
					if (sum > max) { 
						max = sum; 
						max_r = r; max_g = g; max_b = b;
					}
					if (r + g + b < min) { 
						min = sum; 
						min_r = r; min_g = g; min_b = b;
					}
				}
			}
			////////////////////////////////////
			if (sign) { // non edge region
				cmap[i][j].r = max_r;
				cmap[i][j].g = max_g;
				cmap[i][j].b = max_b;
			}
			else { // edge region
				cmap[i][j].r = min_r;
				cmap[i][j].g = min_g;
				cmap[i][j].b = min_b;
			}

		}
	}
	////////////////////////////////////////////

}

void GetColShockFastWeickert2(cimatrix& cmap, ETF& e, double sigma, double tau, int itr) 
// Separate the Laplacian part and MinMax part
// using Tensor flow to get the Laplacian sign
// we find min and max in terms of R + G + B
{
	int	i, j;
	double MAX_DOG = -1.0;
	int ss, t;
	int x, y;

	int image_x = cmap.getRow();
	int image_y = cmap.getCol();

	imatrix image(image_x, image_y);

	CopyCol2GrayImage2(cmap, image); 

	int half1; // small window and big window
	//int index1, index2; // index for Gaussian matrix

	vector GAU1, GAU2;
	MakeGaussVector(sigma, GAU1);
	MakeGaussVector(sigma*1.6, GAU2);
	half1 = GAU1.getMax()-1;
	//half2 = GAU2.getMax()-1;

	//deque<double> vec;
	////////////////////////////////////////////////////////
	//matrix tmp(image_x, image_y);
	cimatrix tmp2(image_x, image_y);

	matrix dog(image_x, image_y);
	
	imatrix tmp(image_x, image_y);

	GetFlowShockDoGETF(image, e, dog, GAU1, GAU2, tau);

	//double dog;
	//deque<int> vec[3];
	//double thres = 0.7;
	//////////////////////////////
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//TRACE("dog[%d][%d] = %f\n", i, j, dog[i][j]);
			if (dog[i][j] >= 0.0) tmp[i][j] = 1; 
			//if (dog >= thres) tmp[i][j] = 1; 
			//else if (tanh(dog) + 1 > thres) tmp[i][j] = 1; 
			//else if (tanh(dog) + 1 > 0.1) lap[i][j] = 255; 
			else tmp[i][j] = 0; 
		}
	}

	////////////////////////////////////////////
	//double weight;
	int sign, m;
	int r, g, b;
	int min, max, sum;
	GLubyte min_r, min_g, min_b, max_r, max_g, max_b;
	//half1 = half;
	
	/////////////////////////////
	half1 = 1;
	/////////////////////////////////////////
	// Smoothing step!
	for (m = 0; m < itr; m++) {
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				////////////////////////////
				//half1 = GAU_W[index1]-1;
				if (tmp[i][j] == 1) sign = 1; // Non edge region
				else sign = 0; // edge region

				max = -1;
				min = 1000000;
				
				for (ss = -half1; ss <= half1; ss++) {
					////////////////////////
					x = i+ss; y = j;
					/////////////////////////////////////////////////////
					if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					/////////////////////////////////////////////////////
					//TRACE("tmp[%d][%d] = %d, sign = %d\n", x, y, tmp[x][y], sign);
					if (tmp[x][y] == 1 && sign == 1) {
						r = cmap[x][y].r;
						g = cmap[x][y].g;
						b = cmap[x][y].b;
						sum = r + g + b;
						if (sum > max) { 
							max = sum; 
							max_r = r; max_g = g; max_b = b;
						}
						//TRACE("k = %d\n", k)
					}
					else if (tmp[x][y] == 0 && sign == 0) {
						r = cmap[x][y].r;
						g = cmap[x][y].g;
						b = cmap[x][y].b;
						sum = r + g + b;
						if (sum < min) { 
							min = sum; 
							min_r = r; min_g = g; min_b = b;
						}
						//TRACE("k = %d\n", k)
					}
				}
				////////////////////////////////////
				if (sign) { // non edge region
					tmp2[i][j].r = max_r;
					tmp2[i][j].g = max_g;
					tmp2[i][j].b = max_b;
				}
				else { // edge region
					tmp2[i][j].r = min_r;
					tmp2[i][j].g = min_g;
					tmp2[i][j].b = min_b;
				}

			}
		}
		////////////////////////////////////////////
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				////////////////////////////
				//index = gray2[i][j];
				if (tmp[i][j] == 1) sign = 1; // Non edge region
				else sign = 0; // edge region

				max = -1;
				min = 1000000;
				
				for (t = -half1; t <= half1; t++) {
					////////////////////////
					x = i; y = j+t;
					/////////////////////////////////////////////////////
					if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////
					if (tmp[x][y] == 1 && sign == 1) {
						r = tmp2[x][y].r;
						g = tmp2[x][y].g;
						b = tmp2[x][y].b;
						sum = r + g + b;
						if (sum > max) { 
							max = sum; 
							max_r = r; max_g = g; max_b = b;
						}
						//TRACE("k = %d\n", k)
					}
					else if (tmp[x][y] == 0 && sign == 0) {
						r = tmp2[x][y].r;
						g = tmp2[x][y].g;
						b = tmp2[x][y].b;
						sum = r + g + b;
						if (sum < min) { 
							min = sum; 
							min_r = r; min_g = g; min_b = b;
						}
						//TRACE("k = %d\n", k)
					}
				}
				////////////////////////////////////
				if (sign) { // non edge region
					cmap[i][j].r = max_r;
					cmap[i][j].g = max_g;
					cmap[i][j].b = max_b;
				}
				else { // edge region
					cmap[i][j].r = min_r;
					cmap[i][j].g = min_g;
					cmap[i][j].b = min_b;
				}

			}
		}
	}
	////////////////////////////////////////////

}

void GetColShockFastWeickert3(cimatrix& cmap, imatrix& sign, int itr) 
// Separate the Laplacian part and MinMax part
// using Tensor flow to get the Laplacian sign
// we find min and max in terms of R + G + B
{
	int	i, j;
	double MAX_DOG = -1.0;
	int ss, t;
	int x, y;

	int image_x = cmap.getRow();
	int image_y = cmap.getCol();

	cimatrix tmp2(image_x, image_y);
	
	////////////////////////////////////////////
	//double weight;
	int m;
	int r, g, b;
	int min, max, sum;
	GLubyte min_r, min_g, min_b, max_r, max_g, max_b;
	//half1 = half;
	
	/////////////////////////////
	int half1 = 1;
	/////////////////////////////////////////
	// Smoothing step!
	for (m = 0; m < itr; m++) {
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				////////////////////////////
				
				max = -1;
				min = 1000000;
				
				for (ss = -half1; ss <= half1; ss++) {
					////////////////////////
					x = i+ss; y = j;
					/////////////////////////////////////////////////////
					if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					/////////////////////////////////////////////////////
					//TRACE("tmp[%d][%d] = %d, sign = %d\n", x, y, tmp[x][y], sign);
					if (sign[i][j] == 255 && sign[x][y] == 255) {
						r = cmap[x][y].r;
						g = cmap[x][y].g;
						b = cmap[x][y].b;
						sum = r + g + b;
						if (sum > max) { 
							max = sum; 
							max_r = r; max_g = g; max_b = b;
						}
						//TRACE("k = %d\n", k)
					}
					else if (sign[i][j] == 0 && sign[x][y] == 0) {
						r = cmap[x][y].r;
						g = cmap[x][y].g;
						b = cmap[x][y].b;
						sum = r + g + b;
						if (sum < min) { 
							min = sum; 
							min_r = r; min_g = g; min_b = b;
						}
						//TRACE("k = %d\n", k)
					}
				}
				////////////////////////////////////
				if (sign[i][j]) { // non edge region
					tmp2[i][j].r = max_r;
					tmp2[i][j].g = max_g;
					tmp2[i][j].b = max_b;
				}
				else { // edge region
					tmp2[i][j].r = min_r;
					tmp2[i][j].g = min_g;
					tmp2[i][j].b = min_b;
				}

			}
		}
		////////////////////////////////////////////
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				////////////////////////////
				//index = gray2[i][j];
				max = -1;
				min = 1000000;
				
				for (t = -half1; t <= half1; t++) {
					////////////////////////
					x = i; y = j+t;
					/////////////////////////////////////////////////////
					if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////
					if (sign[i][j] == 255 && sign[x][y] == 255) {
						r = tmp2[x][y].r;
						g = tmp2[x][y].g;
						b = tmp2[x][y].b;
						sum = r + g + b;
						if (sum > max) { 
							max = sum; 
							max_r = r; max_g = g; max_b = b;
						}
						//TRACE("k = %d\n", k)
					}
					else if (sign[i][j] == 0 && sign[x][y] == 0) {
						r = tmp2[x][y].r;
						g = tmp2[x][y].g;
						b = tmp2[x][y].b;
						sum = r + g + b;
						if (sum < min) { 
							min = sum; 
							min_r = r; min_g = g; min_b = b;
						}
						//TRACE("k = %d\n", k)
					}
				}
				////////////////////////////////////
				if (sign[i][j]) { // non edge region
					cmap[i][j].r = max_r;
					cmap[i][j].g = max_g;
					cmap[i][j].b = max_b;
				}
				else { // edge region
					cmap[i][j].r = min_r;
					cmap[i][j].g = min_g;
					cmap[i][j].b = min_b;
				}

			}
		}
	}
	////////////////////////////////////////////

}

void GetColShockFastWeickert4(cimatrix& cmap, imatrix& sign, int half1, int itr) 
// Separate the Laplacian part and MinMax part
// using Tensor flow to get the Laplacian sign
// we find min and max in terms of R + G + B
// control the half window size, not iteration number
{
	int	i, j;
	double MAX_DOG = -1.0;
	int ss, t;
	int x, y;

	int image_x = cmap.getRow();
	int image_y = cmap.getCol();

	cimatrix tmp2(image_x, image_y);
	
	////////////////////////////////////////////
	//double weight;
	int m;
	int r, g, b;
	int min, max, sum;
	GLubyte min_r, min_g, min_b, max_r, max_g, max_b;
	//half1 = half;
	
	/////////////////////////////
	//int half1 = 1;
	/////////////////////////////////////////
	// Smoothing step!
	for (m = 0; m < itr; m++) {
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				////////////////////////////
				
				max = -1;
				min = 1000000;
				
				for (ss = -half1; ss <= half1; ss++) {
					////////////////////////
					x = i+ss; y = j;
					/////////////////////////////////////////////////////
					if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					/////////////////////////////////////////////////////
					//TRACE("tmp[%d][%d] = %d, sign = %d\n", x, y, tmp[x][y], sign);
					if (sign[i][j] == 255 && sign[x][y] == 255) {
						r = cmap[x][y].r;
						g = cmap[x][y].g;
						b = cmap[x][y].b;
						sum = r + g + b;
						if (sum > max) { 
							max = sum; 
							max_r = r; max_g = g; max_b = b;
						}
						//TRACE("k = %d\n", k)
					}
					else if (sign[i][j] == 0 && sign[x][y] == 0) {
						r = cmap[x][y].r;
						g = cmap[x][y].g;
						b = cmap[x][y].b;
						sum = r + g + b;
						if (sum < min) { 
							min = sum; 
							min_r = r; min_g = g; min_b = b;
						}
						//TRACE("k = %d\n", k)
					}
				}
				////////////////////////////////////
				if (sign[i][j]) { // non edge region
					tmp2[i][j].r = max_r;
					tmp2[i][j].g = max_g;
					tmp2[i][j].b = max_b;
				}
				else { // edge region
					tmp2[i][j].r = min_r;
					tmp2[i][j].g = min_g;
					tmp2[i][j].b = min_b;
				}

			}
		}
		////////////////////////////////////////////
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				////////////////////////////
				//index = gray2[i][j];
				max = -1;
				min = 1000000;
				
				for (t = -half1; t <= half1; t++) {
					////////////////////////
					x = i; y = j+t;
					/////////////////////////////////////////////////////
					if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////
					if (sign[i][j] == 255 && sign[x][y] == 255) {
						r = tmp2[x][y].r;
						g = tmp2[x][y].g;
						b = tmp2[x][y].b;
						sum = r + g + b;
						if (sum > max) { 
							max = sum; 
							max_r = r; max_g = g; max_b = b;
						}
						//TRACE("k = %d\n", k)
					}
					else if (sign[i][j] == 0 && sign[x][y] == 0) {
						r = tmp2[x][y].r;
						g = tmp2[x][y].g;
						b = tmp2[x][y].b;
						sum = r + g + b;
						if (sum < min) { 
							min = sum; 
							min_r = r; min_g = g; min_b = b;
						}
						//TRACE("k = %d\n", k)
					}
				}
				////////////////////////////////////
				if (sign[i][j]) { // non edge region
					cmap[i][j].r = max_r;
					cmap[i][j].g = max_g;
					cmap[i][j].b = max_b;
				}
				else { // edge region
					cmap[i][j].r = min_r;
					cmap[i][j].g = min_g;
					cmap[i][j].b = min_b;
				}

			}
		}
	}
	////////////////////////////////////////////

}

#define min3(x, y, z) ((x) < (y))? (((x) < (z))? (x) : (z)) : (((y) < (z))? (y) : (z))
#define max3(x, y, z) ((x) > (y))? (((x) > (z))? (x) : (z)) : (((y) > (z))? (y) : (z))

void GetWeickertUpwind(cimatrix& cmap, imatrix& sign, double h, int itr) 
// Use Inoue's upwind scheme to do MinMax
// using Tensor flow to get the Laplacian sign
// we find min and max in terms of R + G + B
// control both the half window size and iteration number
{
	int	i, j;
	double MAX_DOG = -1.0;

	int image_x = cmap.getRow();
	int image_y = cmap.getCol();

	cimatrix tmp2(image_x, image_y);
	
	////////////////////////////////////////////
	//double weight;
	int m;
	int x_r, x_l, y_t, y_b;
	int rx, gx, bx, ry, gy, by;
	//half1 = half;
	
	/////////////////////////////
	//int half1 = 1;
	//double h = 0.3; // step size (must be smaller than 0.5)
	/////////////////////////////////////////
	for (m = 0; m < itr; m++) {
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				////////////////////////////
				
				if (sign[i][j] == 255) {
					x_r = i+1; if (x_r > image_x-1) x_r = image_x-1;
					x_l = i-1; if (x_l < 0) x_l = 0;
					rx = max3(cmap[x_r][j].r - cmap[i][j].r, cmap[x_l][j].r - cmap[i][j].r, 0);
					gx = max3(cmap[x_r][j].g - cmap[i][j].g, cmap[x_l][j].g - cmap[i][j].g, 0);
					bx = max3(cmap[x_r][j].b - cmap[i][j].b, cmap[x_l][j].b - cmap[i][j].b, 0);

					y_t = j+1; if (y_t > image_y-1) y_t = image_y-1;
					y_b = j-1; if (y_b < 0) y_b = 0;
					ry = max3(cmap[i][y_t].r - cmap[i][j].r, cmap[i][y_b].r - cmap[i][j].r, 0);
					gy = max3(cmap[i][y_t].g - cmap[i][j].g, cmap[i][y_b].g - cmap[i][j].g, 0);
					by = max3(cmap[i][y_t].b - cmap[i][j].b, cmap[i][y_b].b - cmap[i][j].b, 0);
				
					tmp2[i][j].r = (GLubyte)( cmap[i][j].r + h * sqrt( (double) rx*rx + ry*ry ) );
					tmp2[i][j].g = (GLubyte)( cmap[i][j].g + h * sqrt( (double) gx*gx + gy*gy ) );
					tmp2[i][j].b = (GLubyte)( cmap[i][j].b + h * sqrt( (double) bx*bx + by*by ) );

				}
				else { // sign[i][j] == 0
					x_r = i+1; if (x_r > image_x-1) x_r = image_x-1;
					x_l = i-1; if (x_l < 0) x_l = 0;
					rx = min3(cmap[x_r][j].r - cmap[i][j].r, cmap[x_l][j].r - cmap[i][j].r, 0);
					gx = min3(cmap[x_r][j].g - cmap[i][j].g, cmap[x_l][j].g - cmap[i][j].g, 0);
					bx = min3(cmap[x_r][j].b - cmap[i][j].b, cmap[x_l][j].b - cmap[i][j].b, 0);

					y_t = j+1; if (y_t > image_y-1) y_t = image_y-1;
					y_b = j-1; if (y_b < 0) y_b = 0;
					ry = min3(cmap[i][y_t].r - cmap[i][j].r, cmap[i][y_b].r - cmap[i][j].r, 0);
					gy = min3(cmap[i][y_t].g - cmap[i][j].g, cmap[i][y_b].g - cmap[i][j].g, 0);
					by = min3(cmap[i][y_t].b - cmap[i][j].b, cmap[i][y_b].b - cmap[i][j].b, 0);
				
					tmp2[i][j].r = (GLubyte)( cmap[i][j].r - h * sqrt( (double) rx*rx + ry*ry ) );
					tmp2[i][j].g = (GLubyte)( cmap[i][j].g - h * sqrt( (double) gx*gx + gy*gy ) );
					tmp2[i][j].b = (GLubyte)( cmap[i][j].b - h * sqrt( (double) bx*bx + by*by ) );
				}
			}
				
		}
		cmap.copy(tmp2);
	}
	////////////////////////////////////////////
}

void GetColContrastEnhance(cimatrix& cmap, double pivot, double adjust) 
{
	int	i, j;

	int image_x = cmap.getRow();
	int image_y = cmap.getCol();

	double r, g, b;
	double h, s, v;
	double new_v;

	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			r = cmap[i][j].r / 255.;
			g = cmap[i][j].g / 255.;
			b = cmap[i][j].b / 255.;
			//TRACE("r = %f\n", r);
			//TRACE("g = %f\n", g);
			//TRACE("b = %f\n", b);
			RGB2HSV(r, g, b, h, s, v);
			///////////////////////////////
			if (v < pivot) {
				new_v = (adjust / pivot) * v;
			}
			else {
				new_v = ( (1-adjust) / (1-pivot) ) * (v - 1.0) + 1.0;
			}
			if (new_v > 1.0) new_v = 1.0;
			if (new_v < 0.0) new_v = 0.0;
			///////////////////////////////
			HSV2RGB(h, s, new_v, r, g, b);
			cmap[i][j].r = (GLubyte)(r*255);
			cmap[i][j].g = (GLubyte)(g*255);
			cmap[i][j].b = (GLubyte)(b*255);
			//TRACE("r2 = %f\n", r);
			//TRACE("g2 = %f\n", g);
			//TRACE("b2 = %f\n", b);
		}			
	}
}

void GetGrayContrastEnhanceDouble(matrix& map, double pivot, double adjust) 
{
	int	i, j;

	int image_x = cmap.getRow();
	int image_y = cmap.getCol();

	double v;
	double new_v;

	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			v = map[i][j];
			///////////////////////////////
			if (v < pivot) {
				new_v = (adjust / pivot) * v;
			}
			else {
				new_v = ( (1-adjust) / (1-pivot) ) * (v - 1.0) + 1.0;
			}
			if (new_v > 1.0) new_v = 1.0;
			if (new_v < 0.0) new_v = 0.0;
			///////////////////////////////
			map[i][j] = new_v;
		}			
	}
}

int GetPointFlowShock(int i, int j, imatrix& image, Field& gfield, 
							vector& GAU1, vector& GAU2, vector& GAU3, double tau)
// following the flow, compute the DOG
// but do not adjust GVF directions! Just follow it!
{
	vector vn(2), vt(2), vt_old(2);
	double x, y, d_x, d_y;
	double weight1, weight2, w_sum1, sum1, sum2, w_sum2;

	int s, i_x, i_y, k;
	int x1, y1;
	//int x2, y2;
	//double lb, lt, rb, rt;
	//double uu, vv, bb, tt;
	int dd;
	double val, c_val;

	int half_w1, half_w2, half_l;
	half_w1 = GAU1.getMax()-1;
	half_w2 = GAU2.getMax()-1;
	half_l = GAU3.getMax()-1;
	
	int flow_DOG_sign = 0; 
	
	//double angle, angle_thres1, angle_thres2;
	//angle_thres1 = 90;
	//angle_thres2 = 180 - angle_thres1;

	double step_size, step_size1; 
	//double t;

	step_size = 1.0;
	//step_size = 2.0;
	step_size1 = step_size;
	/////////////////////////////////////////////////
	// INSIDE and OUTSIDE FLOW DOG
	////////////////////////////////////
	//count = 0; // number of pixels traversed
	sum1 = sum2 = 0.0;
	w_sum1 = w_sum2 = 0.0;
	weight1 = weight2 = 0.0;
	////////////////////////////////////////////////
	// One half
	d_x = (double)i; d_y = (double)j; 
	i_x = i; i_y = j;
	//////////////////////////
	c_val = image[i_x][i_y];
	weight1 = GAU1[0];
	weight1 *= GAU3[0];
	sum1 += c_val * weight1;
	w_sum1 += weight1;
	weight2 = GAU2[0];
	weight2 *= GAU3[0];
	sum2 += c_val * weight2;
	w_sum2 += weight2;
	////////////////////////////
	for (k = 0; k < half_l; k++) {
		vn[0] = gfield[i_x][i_y].gx;
		vn[1] = gfield[i_x][i_y].gy;
		if (vn[0] == 0.0 && vn[1] == 0.0) break;
		vn.make_unit();
		vt[0] = -gfield[i_x][i_y].gy;
		vt[1] = gfield[i_x][i_y].gx;
		vt.make_unit();
		////////////////////////////////////////
		for (s = -half_w2; s <= half_w2; s++) { // width of Gaussian kernel
			////////////////////////
			x = d_x + vn[0] * s;
			y = d_y + vn[1] * s;
			/////////////////////////////////////////////////////
			if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
				continue;
			x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
			y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
			val = image[x1][y1];
			/////////////////////////////////////////////////////////
			dd = ABS(s);
			if (dd > half_w1) weight1 = 0.0;
			else weight1 = GAU1[dd];
			//////////////////////////////////
			// The following Gaussian smoothing along main axis is essential for good quality!
			weight1 *= GAU3[k]; 
			////////////////////
			sum1 += val * weight1;
			w_sum1 += weight1;
			//d3 = round( ABS(val - c_val) );
			/////////////////////////////////////////////////////
			weight2 = GAU2[dd];
			weight2 *= GAU3[k];
			sum2 += val * weight2;
			w_sum2 += weight2;
		}
		/////////////////////////////////////////
		d_x += vt[0] * step_size1; // accurate new location x
		d_y += vt[1] * step_size1; // accurate new location y
		/////////////////////////////////////////
		i_x = round(d_x); // integer version of new location x
		i_y = round(d_y); // integer version of new location y
		//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
		/////////////////////////
	}
	////////////////////////////////////////////////
	// Other half
	d_x = (double)i; d_y = (double)j; 
	i_x = i; i_y = j;
	for (k = 0; k < half_l; k++) {
		vn[0] = gfield[i_x][i_y].gx;
		vn[1] = gfield[i_x][i_y].gy;
		if (vn[0] == 0.0 && vn[1] == 0.0) break;
		vn.make_unit();
		vt[0] = gfield[i_x][i_y].gy;
		vt[1] = -gfield[i_x][i_y].gx;
		vt.make_unit();
		////////////////////////////////////
		for (s = -half_w2; s <= half_w2; s++) { // width of Gaussian kernel
			////////////////////////
			x = d_x + vn[0] * s;
			y = d_y + vn[1] * s;
			/////////////////////////////////////////////////////
			if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
				continue;
			x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
			y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
			val = image[x1][y1];
			/////////////////////////////////////////////////////////
			dd = ABS(s);
			if (dd > half_w1) weight1 = 0.0;
			else weight1 = GAU1[dd];
			weight1 *= GAU3[k];
			sum1 += val * weight1;
			w_sum1 += weight1;
			//d3 = round( ABS(val - c_val) );
			/////////////////////////////////////////////////////
			weight2 = GAU2[dd];
			weight2 *= GAU3[k];
			sum2 += val * weight2;
			w_sum2 += weight2;
		}
		/////////////////////////////////////////
		d_x += vt[0] * step_size1; // accurate new location x
		d_y += vt[1] * step_size1; // accurate new location y
		/////////////////////////////////////////
		i_x = round(d_x); // integer version of new location x
		i_y = round(d_y); // integer version of new location y
		//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
		/////////////////////////
	}
	sum1 /= w_sum1; // normalize
	sum2 /= w_sum2; // normalize
	////////////////////////////////////////////////////
	if (sum1 == 0.0 && sum2 == 0.0)
		sum1 = 1.0; // make it a non-edge
	//////////////////////////////////////
	if (sum1 - tau * sum2 >= 0) // non edge
		flow_DOG_sign = 1; // non edge
	else  // edge
		flow_DOG_sign = 0; // edge
	//if (sum1 - tau * sum2 > 0) // non edge
	//	flow_DOG = 1.0; 
	//else // edge!
	//	flow_DOG = 1.0 + tanh(sum1 - tau * sum2);

	return flow_DOG_sign;
	
}

double GetPointFlowShock2(int i, int j, imatrix& image, Field& gfield, 
							vector& GAU1, vector& GAU2, vector& GAU3, imatrix& sign, double z)
// following the flow, compute the DOG
// but do not adjust GVF directions! Just follow it!
{
	vector vn(2), vt(2), vt_old(2);
	double x, y, d_x, d_y;
	double weight1, weight2, w_sum1, sum1, sum2, w_sum2;

	int s, i_x, i_y, k;
	int x1, y1;
	//int x2, y2;
	//double lb, lt, rb, rt;
	//double uu, vv, bb, tt;
	double val, c_val;

	int half_w1, half_w2, half_l;
	half_w1 = GAU1.getMax()-1;
	half_w2 = GAU2.getMax()-1;
	half_l = GAU3.getMax()-1;
	
	double shock_val = 0.0; // flow-based gradient magnitude

	///////////////////////////
	deque<int> vec;
	vec.clear();

	int c_sign;

	if (sign[i][j] == 1) c_sign = 1;
	else c_sign = 0;
		
	//double angle, angle_thres1, angle_thres2;
	//angle_thres1 = 90;
	//angle_thres2 = 180 - angle_thres1;

	double step_size, step_size1; 
	//double t;

	step_size = 1.0;
	//step_size = 2.0;
	step_size1 = step_size;
	/////////////////////////////////////////////////
	// INSIDE and OUTSIDE FLOW DOG
	////////////////////////////////////
	//count = 0; // number of pixels traversed
	sum1 = sum2 = 0.0;
	w_sum1 = w_sum2 = 0.0;
	weight1 = weight2 = 0.0;
	////////////////////////////////////////////////
	// One half
	d_x = (double)i; d_y = (double)j; 
	i_x = i; i_y = j;
	//////////////////////////
	c_val = image[i_x][i_y];
	weight1 = GAU1[0];
	weight1 *= GAU3[0];
	sum1 += c_val * weight1;
	w_sum1 += weight1;
	weight2 = GAU2[0];
	weight2 *= GAU3[0];
	sum2 += c_val * weight2;
	w_sum2 += weight2;
	////////////////////////////
	for (k = 0; k < half_l; k++) {
		vn[0] = gfield[i_x][i_y].gx;
		vn[1] = gfield[i_x][i_y].gy;
		if (vn[0] == 0.0 && vn[1] == 0.0) break;
		vn.make_unit();
		vt[0] = -gfield[i_x][i_y].gy;
		vt[1] = gfield[i_x][i_y].gx;
		vt.make_unit();
		////////////////////////////////////////
		for (s = -half_w2; s <= half_w2; s++) { // width of Gaussian kernel
			////////////////////////
			x = d_x + vn[0] * s;
			y = d_y + vn[1] * s;
			/////////////////////////////////////////////////////
			if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
				continue;
			x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
			y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
			val = image[x1][y1];
			/////////////////////////////////////////////////////////
			if (c_sign) { // non edge region
                if (sign[x1][y1] == 1) vec.push_back(image[x1][y1]);
			}
			else { // edge region
				if (sign[x1][y1] == 0) vec.push_back(image[x1][y1]);
			}
		}
		/////////////////////////////////////////
		d_x += vt[0] * step_size1; // accurate new location x
		d_y += vt[1] * step_size1; // accurate new location y
		/////////////////////////////////////////
		i_x = round(d_x); // integer version of new location x
		i_y = round(d_y); // integer version of new location y
		//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
		/////////////////////////
	}
	////////////////////////////////////////////////
	// Other half
	d_x = (double)i; d_y = (double)j; 
	i_x = i; i_y = j;
	for (k = 0; k < half_l; k++) {
		vn[0] = gfield[i_x][i_y].gx;
		vn[1] = gfield[i_x][i_y].gy;
		if (vn[0] == 0.0 && vn[1] == 0.0) break;
		vn.make_unit();
		vt[0] = gfield[i_x][i_y].gy;
		vt[1] = -gfield[i_x][i_y].gx;
		vt.make_unit();
		////////////////////////////////////
		for (s = -half_w2; s <= half_w2; s++) { // width of Gaussian kernel
			////////////////////////
			x = d_x + vn[0] * s;
			y = d_y + vn[1] * s;
			/////////////////////////////////////////////////////
			if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
				continue;
			x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
			y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
			val = image[x1][y1];
			/////////////////////////////////////////////////////////
			/////////////////////////////////////////////////////////
			if (c_sign) { // non edge region
                if (sign[x1][y1] == 1) vec.push_back(image[x1][y1]);
			}
			else { // edge region
				if (sign[x1][y1] == 0) vec.push_back(image[x1][y1]);
			}
		}
		/////////////////////////////////////////
		d_x += vt[0] * step_size1; // accurate new location x
		d_y += vt[1] * step_size1; // accurate new location y
		/////////////////////////////////////////
		i_x = round(d_x); // integer version of new location x
		i_y = round(d_y); // integer version of new location y
		//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
		/////////////////////////
	}
	//sum1 /= w_sum1; // normalize
	//sum2 /= w_sum2; // normalize
	sort(vec.begin(), vec.end()); 
	//flow_median = vec[vec.size()/2]; 
	//double z = 0.3;
	if (vec.size() == 0)
		return round(c_val); 
	if (c_sign) // non edge region
		shock_val = vec[vec.size()-1]; 
		//image2[i][j] = round( (1-z) * vec[vec.size()-1] + z * 255 ); // brightest value
	else // edge region
		//image2[i][j] = vec[0]; 
		shock_val = round( (1-z) * vec[0] + z * 0 ); // darkest value
	////////////////////////////////////////////////////
	return shock_val;
}

void GetFlowShockDoG(imatrix& image, Field& gfield, matrix& dog, vector& GAU1, vector& GAU2, double tau)
// For each pixel, compute the directional DOG
{
	vector vn(2), vt(2), vt_old(2);
	double x, y, d_x, d_y;
	double weight1, weight2, w_sum1, sum1, sum2, w_sum2;

	int s;
	int x1, y1;
	int i, j;
	//int x2, y2;
	//double lb, lt, rb, rt;
	//double uu, vv, bb, tt;
	int dd;
	double val;

	int half_w1, half_w2;
	half_w1 = GAU1.getMax()-1;
	half_w2 = GAU2.getMax()-1;

	int image_x, image_y;

	image_x = image.getRow();
	image_y = image.getCol();
	
	int flow_DOG_sign = 0; 
	
	//double angle, angle_thres1, angle_thres2;
	//angle_thres1 = 90;
	//angle_thres2 = 180 - angle_thres1;

	/////////////////////////////////////////////////
	// INSIDE and OUTSIDE FLOW DOG
	////////////////////////////
	for (i = 0; i < image_x; i++) {
		for (j = 0; j < image_y; j++) {
			sum1 = sum2 = 0.0;
			w_sum1 = w_sum2 = 0.0;
			weight1 = weight2 = 0.0;
	
			vn[0] = gfield[i][j].gx;
			vn[1] = gfield[i][j].gy;
			if (vn[0] == 0.0 && vn[1] == 0.0) {
				sum1 = 1.0;
				sum2 = 1.0;
				dog[i][j] = sum1 - tau * sum2;
				continue;
			}
			vn.make_unit();
			d_x = i; d_y = j;
			////////////////////////////////////////
			for (s = -half_w2; s <= half_w2; s++) { // width of Gaussian kernel
				////////////////////////
				x = d_x + vn[0] * s;
				y = d_y + vn[1] * s;
				/////////////////////////////////////////////////////
				if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
					continue;
				x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				val = image[x1][y1];
				/////////////////////////////////////////////////////////
				dd = ABS(s);
				if (dd > half_w1) weight1 = 0.0;
				else weight1 = GAU1[dd];
				//////////////////////////////////
				sum1 += val * weight1;
				w_sum1 += weight1;
				//d3 = round( ABS(val - c_val) );
				/////////////////////////////////////////////////////
				weight2 = GAU2[dd];
				sum2 += val * weight2;
				w_sum2 += weight2;
			}
			/////////////////////////
			sum1 /= w_sum1; // normalize
			sum2 /= w_sum2; // normalize
			////////////////////////////////////////////////////
			//////////////////////////////////////
			dog[i][j] = sum1 - tau * sum2;
			//if (sum1 - tau * sum2 > 0) dog[i][j] = 1.0;
			//else dog[i][j] = 1.0 + tanh(sum1 - tau * sum2);
		}
	}

}

void GetFlowShockDoGETF(imatrix& image, ETF& e, matrix& dog, vector& GAU1, vector& GAU2, double tau)
// For each pixel, compute the directional DOG from ETF
{
	vector vn(2), vt(2), vt_old(2);
	double x, y, d_x, d_y;
	double weight1, weight2, w_sum1, sum1, sum2, w_sum2;

	int s;
	int x1, y1;
	int i, j;
	//int x2, y2;
	//double lb, lt, rb, rt;
	//double uu, vv, bb, tt;
	int dd;
	double val;

	int half_w1, half_w2;
	half_w1 = GAU1.getMax()-1;
	half_w2 = GAU2.getMax()-1;

	int image_x, image_y;

	image_x = image.getRow();
	image_y = image.getCol();
	
	int flow_DOG_sign = 0; 
	
	//double angle, angle_thres1, angle_thres2;
	//angle_thres1 = 90;
	//angle_thres2 = 180 - angle_thres1;

	/////////////////////////////////////////////////
	// INSIDE and OUTSIDE FLOW DOG
	////////////////////////////
	for (i = 0; i < image_x; i++) {
		for (j = 0; j < image_y; j++) {
			sum1 = sum2 = 0.0;
			w_sum1 = w_sum2 = 0.0;
			weight1 = weight2 = 0.0;
	
			vn[0] = -e[i][j].ty;
			vn[1] = e[i][j].tx;
			if (vn[0] == 0.0 && vn[1] == 0.0) {
				sum1 = 1.0;
				sum2 = 1.0;
				dog[i][j] = sum1 - tau * sum2;
				continue;
			}
			//vn.make_unit();
			d_x = i; d_y = j;
			////////////////////////////////////////
			for (s = -half_w2; s <= half_w2; s++) { // width of Gaussian kernel
				////////////////////////
				x = d_x + vn[0] * s;
				y = d_y + vn[1] * s;
				/////////////////////////////////////////////////////
				if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
					continue;
				x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				val = image[x1][y1];
				/////////////////////////////////////////////////////////
				dd = ABS(s);
				if (dd > half_w1) weight1 = 0.0;
				else weight1 = GAU1[dd];
				//////////////////////////////////
				sum1 += val * weight1;
				w_sum1 += weight1;
				//d3 = round( ABS(val - c_val) );
				/////////////////////////////////////////////////////
				weight2 = GAU2[dd];
				sum2 += val * weight2;
				w_sum2 += weight2;
			}
			/////////////////////////
			sum1 /= w_sum1; // normalize
			sum2 /= w_sum2; // normalize
			////////////////////////////////////////////////////
			//////////////////////////////////////
			dog[i][j] = sum1 - tau * sum2;
			//TRACE("sum1[%d][%d] = %f\n", i, j, sum1);
			//TRACE("sum2[%d][%d] = %f\n", i, j, sum2);
			//TRACE("tau = %f\n", tau);
			//TRACE("sum1 - tau * sum2 = %f\n", sum1 - tau * sum2);
			//TRACE("dog[%d][%d] = %f\n", i, j, dog[i][j]);
			//if (sum1 - tau * sum2 > 0) dog[i][j] = 1.0;
			//else dog[i][j] = 1.0 + tanh(sum1 - tau * sum2);
		}
	}

}

void GetFlowShockDoGETF2(imatrix& image, ETF& e, imatrix& sign, double sigma, double tau)
// For each pixel, compute the directional DOG from ETF
// Use sigma, and sign
{
	vector vn(2), vt(2), vt_old(2);
	double x, y, d_x, d_y;
	double weight1, weight2, w_sum1, sum1, sum2, w_sum2;

	int s;
	int x1, y1;
	int i, j;
	//int x2, y2;
	//double lb, lt, rb, rt;
	//double uu, vv, bb, tt;
	int dd;
	double val;

	int half_w1, half_w2;

	vector GAU1, GAU2;
	MakeGaussVector(sigma, GAU1);
	MakeGaussVector(sigma*1.6, GAU2);

	half_w1 = GAU1.getMax()-1;
	half_w2 = GAU2.getMax()-1;

	int image_x, image_y;

	image_x = image.getRow();
	image_y = image.getCol();
	
	//int flow_DOG_sign = 0; 
	double dog;
	
	//double angle, angle_thres1, angle_thres2;
	//angle_thres1 = 90;
	//angle_thres2 = 180 - angle_thres1;

	/////////////////////////////////////////////////
	// INSIDE and OUTSIDE FLOW DOG
	////////////////////////////
	for (i = 0; i < image_x; i++) {
		for (j = 0; j < image_y; j++) {
			sum1 = sum2 = 0.0;
			w_sum1 = w_sum2 = 0.0;
			weight1 = weight2 = 0.0;
	
			vn[0] = -e[i][j].ty;
			vn[1] = e[i][j].tx;
			if (vn[0] == 0.0 && vn[1] == 0.0) {
				//sum1 = 1.0;
				//sum2 = 1.0;
				//dog = sum1 - tau * sum2;
				//continue;
				vn[0] = 1.0; vn[1] = 0.0; // assign horizontal unit vector
			}
			//vn.make_unit();
			d_x = i; d_y = j;
			////////////////////////////////////////
			for (s = -half_w2; s <= half_w2; s++) { // width of Gaussian kernel
				////////////////////////
				x = d_x + vn[0] * s;
				y = d_y + vn[1] * s;
				/////////////////////////////////////////////////////
				if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
					continue;
				x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				val = image[x1][y1];
				/////////////////////////////////////////////////////////
				dd = ABS(s);
				if (dd > half_w1) weight1 = 0.0;
				else weight1 = GAU1[dd];
				//////////////////////////////////
				sum1 += val * weight1;
				w_sum1 += weight1;
				//d3 = round( ABS(val - c_val) );
				/////////////////////////////////////////////////////
				weight2 = GAU2[dd];
				sum2 += val * weight2;
				w_sum2 += weight2;
			}
			/////////////////////////
			sum1 /= w_sum1; // normalize
			sum2 /= w_sum2; // normalize
			////////////////////////////////////////////////////
			//////////////////////////////////////
			dog = sum1 - tau * sum2;
			//TRACE("sum1[%d][%d] = %f\n", i, j, sum1);
			//TRACE("sum2[%d][%d] = %f\n", i, j, sum2);
			//TRACE("tau = %f\n", tau);
			//TRACE("sum1 - tau * sum2 = %f\n", sum1 - tau * sum2);
			//TRACE("dog[%d][%d] = %f\n", i, j, dog[i][j]);
			if (dog > 0) sign[i][j] = 255;
			else sign[i][j] = 0;
			//else dog[i][j] = 1.0 + tanh(sum1 - tau * sum2);
		}
	}

}


void GetFlowShockDoGETF3(imatrix& image, ETF& e, imatrix& sign)
// For each pixel, compute the directional second derivative from ETF
// Use sigma, and sign
{
	vector vn(2);
	double d_x, d_y;
	double x_r, y_r, x_l, y_l;
	double val_r, val_l, val;

	int x1, y1;
	int i, j;

	int image_x, image_y;

	image_x = image.getRow();
	image_y = image.getCol();
	
	//int flow_DOG_sign = 0; 
	double dog;
	
	for (i = 0; i < image_x; i++) {
		for (j = 0; j < image_y; j++) {
			vn[0] = -e[i][j].ty;
			vn[1] = e[i][j].tx;
			if (vn[0] == 0.0 && vn[1] == 0.0) {
				vn[0] = 1.0; vn[1] = 0.0; // assign horizontal unit vector
			}
			//vn.make_unit();
			d_x = (double)i; d_y = (double)j;

			val = (double)image[i][j];

			x_r = d_x + vn[0];
			y_r = d_y + vn[1];
			x1 = round(x_r);	if (x1 < 0) x1 = 0; if (x1 > image_x-1) x1 = image_x-1;
			y1 = round(y_r);	if (y1 < 0) y1 = 0; if (y1 > image_y-1) y1 = image_y-1;
			val_r = (double)image[x1][y1];
			
			x_l = d_x - vn[0];
			y_l = d_y - vn[1];
			x1 = round(x_l);	if (x1 < 0) x1 = 0; if (x1 > image_x-1) x1 = image_x-1;
			y1 = round(y_l);	if (y1 < 0) y1 = 0; if (y1 > image_y-1) y1 = image_y-1;
			val_l = (double)image[x1][y1];
			
			//////////////////////////////////////
			dog = (val_r - val) - (val - val_l);
			if (dog >= 0) sign[i][j] = 255;
			else sign[i][j] = 0;
		}
	}

}

void GetLaplacian2(imatrix& image, imatrix& lap)
// For each pixel, compute Laplacian value
{
	int x, y;
	int i, j;
	int lapla;

	int image_x, image_y;

	image_x = image.getRow();
	image_y = image.getCol();
	
	for (i = 0; i < image_x; i++) {
		for (j = 0; j < image_y; j++) {
			////////////////////////////
			lapla = 0;
			////////////////////////////////////////
			x = i;
			y = j;
			lapla = 4 * image[x][y];
			////////////////////////////////
			x = i + 1;	if (x < 0) x = 0; if (x > image_x-1) x = image_x-1;
			y = j;		if (y < 0) y = 0; if (y > image_y-1) y = image_y-1;
			lapla -= image[x][y];
			/////////////////////////////////
			x = i - 1;	if (x < 0) x = 0; if (x > image_x-1) x = image_x-1;
			y = j;		if (y < 0) y = 0; if (y > image_y-1) y = image_y-1;
            lapla -= image[x][y];
			//////////////////////////////////
			x = i;	if (x < 0) x = 0; if (x > image_x-1) x = image_x-1;
			y = j + 1;		if (y < 0) y = 0; if (y > image_y-1) y = image_y-1;
            lapla -= image[x][y];
			//////////////////////////////////
			x = i;	if (x < 0) x = 0; if (x > image_x-1) x = image_x-1;
			y = j - 1;		if (y < 0) y = 0; if (y > image_y-1) y = image_y-1;
            lapla -= image[x][y];
			//////////////////////////////////
			//////////////////////////////////////
			lap[i][j] = lapla;
		}
	}

}

void GetLaplacian3(imatrix& image, double sigma, imatrix& lap)
// For each pixel, compute Laplacian value (using DoG)
{
	int	i, j, k;
	double MAX_DOG = -1.0;
	int s, t;
	int x, y;

	int image_x = image.getRow();
	int image_y = image.getCol();

	int half1, half2; // small window and big window
	//int index1, index2; // index for Gaussian matrix
	double sum1, sum2, w_sum1, w_sum2;

	vector GAU1, GAU2;
	MakeGaussVector(sigma, GAU1);
	MakeGaussVector(sigma*1.6, GAU2);
	half1 = GAU1.getMax()-1;
	half2 = GAU2.getMax()-1;

	//deque<int> vec[3];
	////////////////////////////////////////////////////////
	//matrix tmp(image_x, image_y);
	//cimatrix tmp2(image_x, image_y);
	//tmp.zero();
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			sum1 = 0;
			w_sum1 = 0.0;
			//TRACE("GAU_W_1[%d] = %d\n", index1, GAU_W[index1]);
			for (s = -half1; s <= half1; s++) {
				for (t = -half1; t <= half1; t++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					//k = round( dist2(x, y, i, j) );
					if ( k > half1 ) continue; 
					/////////////////////////////////////////////////////
					sum1 += image[x][y] * GAU1[k];
					w_sum1 += GAU1[k];
				}
			}
			////////////////////////////////////
			// Normalization
			sum1 /= w_sum1; 
			//////////////////////////////////////////////
			sum2 = 0;
			w_sum2 = 0.0;
			for (s = -half2; s <= half2; s++) {
				for (t = -half2; t <= half2; t++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					if ( k > half2 ) continue; 
					/////////////////////////////////////////////////////
					sum2 += image[x][y] * GAU2[k];
					w_sum2 += GAU2[k];
				}
			}
			////////////////////////////////////
			sum2 /= w_sum2; 
			/////////////////////////////////////////
			// POSITIVE INNTER CIRCLE
			//if (sum1 - tau * sum2 >= 0) // non edge
			if (sum1 - 1.0 * sum2 >= 0) // non edge
				lap[i][j] = 255; // non edge
			else 
				lap[i][j] = 0; // edge
		}
	}

}

void GetLaplacian4(imatrix& image, double sigma, imatrix& lap)
// For each pixel, compute Laplacian value (using DoG)
// Faster version!
{
	int	i, j;

	int image_x = image.getRow();
	int image_y = image.getCol();

	//vector GAU1, GAU2;
	//MakeGaussVector(sigma, GAU1);
	//MakeGaussVector(sigma*1.6, GAU2);
	//half1 = GAU1.getMax()-1;
	//half2 = GAU2.getMax()-1;

	matrix inner(image_x, image_y);
	//inner.zero();
	//GaussSmoothSep(inner, sigma);
	GaussSmoothSepDouble(image, sigma, inner);

	matrix outer(image_x, image_y);
	//outer.zero();
	GaussSmoothSepDouble(image, sigma*1.6, outer);

	//deque<int> vec[3];
	////////////////////////////////////////////////////////
	//matrix tmp(image_x, image_y);
	//cimatrix tmp2(image_x, image_y);
	//tmp.zero();
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			if (inner[i][j] - 1.0 * outer[i][j] >= 0) 
				lap[i][j] = 255; 
			else 
				lap[i][j] = 0; 
		}
	}

}

void GetLaplacian5(imatrix& image, double sigma, imatrix& lap, double tau, double thres)
// For each pixel, compute Laplacian value (using DoG)
// Faster version!
// use tau
{
	int	i, j;
	double dog;

	int image_x = image.getRow();
	int image_y = image.getCol();

	//vector GAU1, GAU2;
	//MakeGaussVector(sigma, GAU1);
	//MakeGaussVector(sigma*1.6, GAU2);
	//half1 = GAU1.getMax()-1;
	//half2 = GAU2.getMax()-1;

	matrix inner(image_x, image_y);
	//inner.zero();
	//GaussSmoothSep(inner, sigma);
	GaussSmoothSepDouble(image, sigma, inner);

	matrix outer(image_x, image_y);
	//outer.zero();
	GaussSmoothSepDouble(image, sigma*1.6, outer);

	//deque<int> vec[3];
	////////////////////////////////////////////////////////
	//matrix tmp(image_x, image_y);
	//cimatrix tmp2(image_x, image_y);
	//tmp.zero();
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			dog = inner[i][j] - tau * outer[i][j];
			if (dog >= 0) lap[i][j] = 255; 
			else if (tanh(dog) + 1 > thres) lap[i][j] = 255; 
			else lap[i][j] = 0; 
		}
	}

}

void GetLaplacian6(imatrix& image, double sigma, imatrix& lap, double tau)
// For each pixel, compute Laplacian value (using DoG)
// Faster version!
// use tau
{
	int	i, j;
	double dog;

	int image_x = image.getRow();
	int image_y = image.getCol();

	//vector GAU1, GAU2;
	//MakeGaussVector(sigma, GAU1);
	//MakeGaussVector(sigma*1.6, GAU2);
	//half1 = GAU1.getMax()-1;
	//half2 = GAU2.getMax()-1;

	matrix inner(image_x, image_y);
	//inner.zero();
	//GaussSmoothSep(inner, sigma);
	GaussSmoothSepDouble(image, sigma, inner);

	matrix outer(image_x, image_y);
	//outer.zero();
	GaussSmoothSepDouble(image, sigma*1.6, outer);

	//deque<int> vec[3];
	////////////////////////////////////////////////////////
	//matrix tmp(image_x, image_y);
	//cimatrix tmp2(image_x, image_y);
	//tmp.zero();
	//double thres = -0.000001;
	double thres;
	//thres = -0.0;
	//thres = -0.000001;
	thres = 0.5;
	//////////////////////////////
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			dog = inner[i][j] - tau * outer[i][j];
			if (dog >= 0) lap[i][j] = 255; 
			//if (dog >= thres) lap[i][j] = 255; 
			else if (tanh(dog) + 1 > thres) lap[i][j] = 255; 
			//else if (tanh(dog) + 1 > 0.1) lap[i][j] = 255; 
			else lap[i][j] = 0; 
		}
	}

}

void GetLaplacian7(imatrix& image, double sigma, imatrix& lap, double tau, double thres)
// For each pixel, compute Laplacian value (using DoG)
// Faster version!
// use tau
{
	int	i, j;
	double dog;

	int image_x = image.getRow();
	int image_y = image.getCol();

	//vector GAU1, GAU2;
	//MakeGaussVector(sigma, GAU1);
	//MakeGaussVector(sigma*1.6, GAU2);
	//half1 = GAU1.getMax()-1;
	//half2 = GAU2.getMax()-1;

	matrix inner(image_x, image_y);
	//inner.zero();
	//GaussSmoothSep(inner, sigma);
	GaussSmoothSepDouble(image, sigma, inner);

	matrix outer(image_x, image_y);
	//outer.zero();
	GaussSmoothSepDouble(image, sigma*1.6, outer);

	//deque<int> vec[3];
	////////////////////////////////////////////////////////
	//matrix tmp(image_x, image_y);
	//cimatrix tmp2(image_x, image_y);
	//tmp.zero();
	//double thres = -0.000001;
	//double thres;
	//thres = -0.0;
	//thres = -0.000001;
	//thres = 0.5;
	//////////////////////////////
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			dog = inner[i][j] - tau * outer[i][j];
			if (dog >= 0) lap[i][j] = 255; 
			//if (dog >= thres) lap[i][j] = 255; 
			else if (tanh(dog) + 1 > thres) lap[i][j] = 255; 
			//else if (tanh(dog) + 1 > 0.1) lap[i][j] = 255; 
			else lap[i][j] = 0; 
		}
	}
}

void GetLaplacianDouble(imatrix& image, double sigma, matrix& G_map, double tau, double thres)
// For each pixel, compute Laplacian value (using DoG)
// Faster version!
// use tau
{
	int	i, j;
	double dog;

	int image_x = image.getRow();
	int image_y = image.getCol();

	//vector GAU1, GAU2;
	//MakeGaussVector(sigma, GAU1);
	//MakeGaussVector(sigma*1.6, GAU2);
	//half1 = GAU1.getMax()-1;
	//half2 = GAU2.getMax()-1;

	matrix inner(image_x, image_y);
	//inner.zero();
	//GaussSmoothSep(inner, sigma);
	GaussSmoothSepDouble(image, sigma, inner);

	matrix outer(image_x, image_y);
	//outer.zero();
	GaussSmoothSepDouble(image, sigma*1.6, outer);

	//////////////////////////////
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			dog = inner[i][j] - tau * outer[i][j];
			if (dog >= 0) G_map[i][j] = 1.0; 
			else G_map[i][j] = tanh(dog) + 1; 
		}
	}
}

void GetDogSep(imatrix& image, double sigma, imatrix& lap, double tau)
// For each pixel, compute DoG
// Faster version!
// use tau
{
	int	i, j;
	double dog;

	int image_x = image.getRow();
	int image_y = image.getCol();

	matrix inner(image_x, image_y);
	//inner.zero();
	//GaussSmoothSep(inner, sigma);
	GaussSmoothSepDouble(image, sigma, inner);

	matrix outer(image_x, image_y);
	//outer.zero();
	GaussSmoothSepDouble(image, sigma*1.6, outer);

	//deque<int> vec[3];
	////////////////////////////////////////////////////////
	//matrix tmp(image_x, image_y);
	//cimatrix tmp2(image_x, image_y);
	//tmp.zero();
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			dog = inner[i][j] - tau * outer[i][j];
			if (dog > 0) lap[i][j] = 255; 
			else lap[i][j] = round( (tanh(dog) + 1.0) * 255.0 ); 
		}
	}
}

void GetDogSepDouble(imatrix& image, double sigma, mymatrix& dog, double tau)
// used for DOGLIC!
// For each pixel, compute DoG
// Faster version!
// use tau
{
	int	i, j;
	//double dog;

	int image_x = image.getRow();
	int image_y = image.getCol();

	matrix inner(image_x, image_y);
	//inner.zero();
	//GaussSmoothSep(inner, sigma);
	GaussSmoothSepDouble(image, sigma, inner);

	matrix outer(image_x, image_y);
	//outer.zero();
	GaussSmoothSepDouble(image, sigma*1.6, outer);

	//deque<int> vec[3];
	////////////////////////////////////////////////////////
	//matrix tmp(image_x, image_y);
	//cimatrix tmp2(image_x, image_y);
	//tmp.zero();
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			dog[i][j] = inner[i][j] - tau * outer[i][j];
			//if (dog > 0) lap[i][j] = 255; 
			//else lap[i][j] = round( (tanh(dog) + 1.0) * 255.0 ); 
		}
	}
}

void GetDogSepDouble2(imatrix& image, double sigma, matrix& dog, double tau)
// Faster version!
// normalized to [0,1]
{
	int	i, j;
	//double dog;

	int image_x = image.getRow();
	int image_y = image.getCol();

	matrix inner(image_x, image_y);
	//inner.zero();
	//GaussSmoothSep(inner, sigma);
	GaussSmoothSepDouble(image, sigma, inner);

	matrix outer(image_x, image_y);
	//outer.zero();
	GaussSmoothSepDouble(image, sigma*1.6, outer);

	//deque<int> vec[3];
	////////////////////////////////////////////////////////
	//matrix tmp(image_x, image_y);
	//cimatrix tmp2(image_x, image_y);
	//tmp.zero();
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			dog[i][j] = inner[i][j] - tau * outer[i][j];
			if (dog[i][j] >= 0) dog[i][j] = 1.0; 
			else dog[i][j] = tanh(dog[i][j]) + 1.0; 
		}
	}
}


void GetFlowShockInfluence(Field& gfield, matrix& dog, imatrix& sign, vector& GAU3)
// following the flow, compute the DOG
// FASTER version!
{
	vector vt(2), vt_old(2);
	double x, y, d_x, d_y;
	double weight1, w_sum1, sum1;

	int i_x, i_y, k;
	int x1, y1;
	//int x2, y2;
	//double lb, lt, rb, rt;
	//double uu, vv, bb, tt;
	double val;

	int image_x = sign.getRow();
	int image_y = sign.getCol();

	int half_l;
	//half_w1 = GAU1.getMax()-1;
	//half_w2 = GAU2.getMax()-1;
	half_l = GAU3.getMax()-1;
	
	int flow_DOG_sign = 0; 
	
	//double angle, angle_thres1, angle_thres2;
	//angle_thres1 = 90;
	//angle_thres2 = 180 - angle_thres1;

	double step_size, step_size1; 
	//double t;

	step_size = 1.0;
	//step_size = 2.0;
	step_size1 = step_size;

	int i, j;

	for (i = 0; i < image_x; i++) {
		for (j = 0; j < image_y; j++) {
	
			/////////////////////////////////////////////////
			// INSIDE and OUTSIDE FLOW DOG
			////////////////////////////////////
			//count = 0; // number of pixels traversed
			sum1 = 0.0;
			w_sum1 = 0.0;
			weight1 = 0.0;
			/////////////////////////////////
			val = dog[i][j];
			weight1 = GAU3[0]; 
			//weight1 = 1.0; 
			sum1 = val * weight1;
			w_sum1 += weight1;
			////////////////////////////////////////////////
			// One half
			d_x = (double)i; d_y = (double)j; 
			i_x = i; i_y = j;
			////////////////////////////
			for (k = 0; k < half_l; k++) {
				vt[0] = -gfield[i_x][i_y].gy;
				vt[1] = gfield[i_x][i_y].gx;
				if (vt[0] == 0.0 && vt[1] == 0.0) {
					break;
				}
				vt.make_unit();
				x = d_x;
				y = d_y;
				/////////////////////////////////////////////////////
				if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
					break;
				x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				val = dog[x1][y1];
				//////////////////////////////
				weight1 = GAU3[k]; 
				//weight1 = 1.0; // uniform weight
				////////////////////
				sum1 += val * weight1;
				w_sum1 += weight1;
				/////////////////////////////////////////
				d_x += vt[0] * step_size1; // accurate new location x
				d_y += vt[1] * step_size1; // accurate new location y
				/////////////////////////////////////////
				i_x = round(d_x); // integer version of new location x
				i_y = round(d_y); // integer version of new location y
				//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
				if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
				/////////////////////////
			}
			////////////////////////////////////////////////
			// Other half
			d_x = (double)i; d_y = (double)j; 
			i_x = i; i_y = j;
			for (k = 0; k < half_l; k++) {
				vt[0] = gfield[i_x][i_y].gy;
				vt[1] = -gfield[i_x][i_y].gx;
				if (vt[0] == 0.0 && vt[1] == 0.0) {
					break;
				}
				vt.make_unit();
				x = d_x;
				y = d_y;
				/////////////////////////////////////////////////////
				if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
					break;
				x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				val = dog[x1][y1];
				//////////////////////////////
				weight1 = GAU3[k]; 
				//weight1 = 1.0; // uniform weight
				////////////////////
				sum1 += val * weight1;
				w_sum1 += weight1;
				/////////////////////////////////////////
				d_x += vt[0] * step_size1; // accurate new location x
				d_y += vt[1] * step_size1; // accurate new location y
				/////////////////////////////////////////
				i_x = round(d_x); // integer version of new location x
				i_y = round(d_y); // integer version of new location y
				//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
				if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
				/////////////////////////
			}
			////////////////////////////////////////
			sum1 /= w_sum1; // normalize
			//////////////////////////////////////
			if (sum1 >= 0) // non edge
				sign[i][j] = 1; // non edge
			else  // edge
				sign[i][j] = 0; // edge
			//if (sum1 - tau * sum2 > 0) // non edge
			//	flow_DOG = 1.0; 
			//else // edge!
			//	flow_DOG = 1.0 + tanh(sum1 - tau * sum2);
		}
	}
	
}

void GetFlowDoGMainAxis(Field& gfield, matrix& dog, matrix& tmp, vector& GAU3)
// following the flow, get the Gaussian of DOG values
{
	vector vt(2), vt_old(2);
	double x, y, d_x, d_y;
	double weight1, w_sum1, sum1;

	int i_x, i_y, k;
	int x1, y1;
	//int x2, y2;
	//double lb, lt, rb, rt;
	//double uu, vv, bb, tt;
	double val;

	int image_x = dog.getRow();
	int image_y = dog.getCol();

	int half_l;
	//half_w1 = GAU1.getMax()-1;
	//half_w2 = GAU2.getMax()-1;
	half_l = GAU3.getMax()-1;
	
	int flow_DOG_sign = 0; 
	
	//double angle, angle_thres1, angle_thres2;
	//angle_thres1 = 90;
	//angle_thres2 = 180 - angle_thres1;

	double step_size, step_size1; 
	//double t;

	step_size = 1.0;
	//step_size = 2.0;
	step_size1 = step_size;

	int i, j;

	for (i = 0; i < image_x; i++) {
		for (j = 0; j < image_y; j++) {
	
			/////////////////////////////////////////////////
			// INSIDE and OUTSIDE FLOW DOG
			////////////////////////////////////
			//count = 0; // number of pixels traversed
			sum1 = 0.0;
			w_sum1 = 0.0;
			weight1 = 0.0;
			/////////////////////////////////
			val = dog[i][j];
			weight1 = GAU3[0]; 
			//weight1 = 1.0; 
			sum1 = val * weight1;
			w_sum1 += weight1;
			////////////////////////////////////////////////
			// One half
			d_x = (double)i; d_y = (double)j; 
			i_x = i; i_y = j;
			////////////////////////////
			for (k = 0; k < half_l; k++) {
				vt[0] = -gfield[i_x][i_y].gy;
				vt[1] = gfield[i_x][i_y].gx;
				if (vt[0] == 0.0 && vt[1] == 0.0) {
					break;
				}
				vt.make_unit();
				x = d_x;
				y = d_y;
				/////////////////////////////////////////////////////
				if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
					break;
				x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				val = dog[x1][y1];
				//////////////////////////////
				weight1 = GAU3[k]; 
				//weight1 = 1.0; // uniform weight
				////////////////////
				sum1 += val * weight1;
				w_sum1 += weight1;
				/////////////////////////////////////////
				d_x += vt[0] * step_size1; // accurate new location x
				d_y += vt[1] * step_size1; // accurate new location y
				/////////////////////////////////////////
				i_x = round(d_x); // integer version of new location x
				i_y = round(d_y); // integer version of new location y
				//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
				if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
				/////////////////////////
			}
			////////////////////////////////////////////////
			// Other half
			d_x = (double)i; d_y = (double)j; 
			i_x = i; i_y = j;
			for (k = 0; k < half_l; k++) {
				vt[0] = gfield[i_x][i_y].gy;
				vt[1] = -gfield[i_x][i_y].gx;
				if (vt[0] == 0.0 && vt[1] == 0.0) {
					break;
				}
				vt.make_unit();
				x = d_x;
				y = d_y;
				/////////////////////////////////////////////////////
				if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
					break;
				x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				val = dog[x1][y1];
				//////////////////////////////
				weight1 = GAU3[k]; 
				//weight1 = 1.0; // uniform weight
				////////////////////
				sum1 += val * weight1;
				w_sum1 += weight1;
				/////////////////////////////////////////
				d_x += vt[0] * step_size1; // accurate new location x
				d_y += vt[1] * step_size1; // accurate new location y
				/////////////////////////////////////////
				i_x = round(d_x); // integer version of new location x
				i_y = round(d_y); // integer version of new location y
				//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
				if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
				/////////////////////////
			}
			////////////////////////////////////////
			sum1 /= w_sum1; // normalize
			//////////////////////////////////////
			//if (sum1 == 0.0 && sum2 == 0.0)
			//	sum1 = 1.0; // make it a non-edge
			//////////////////////////////////////
			if (sum1 > 0) // non edge
				tmp[i][j] = 1.0; 
			else // edge!
				tmp[i][j] = 1.0 + tanh(sum1);
			
		}
	}
	
}

void GetFlowShockDoG2(imatrix& image, Field& gfield, matrix& dog, vector& GAU1, vector& GAU2, double tau)
// For each pixel, compute the directional DOG
// Optimized!
{
	vector vn(2), vt(2), vt_old(2);
	double x, y, d_x, d_y;
	double weight1, weight2, w_sum1, sum1, sum2, w_sum2;

	int s;
	int x1, y1;
	int i, j;
	//int x2, y2;
	//double lb, lt, rb, rt;
	//double uu, vv, bb, tt;
	int dd;
	double val;

	int half_w1, half_w2;
	half_w1 = GAU1.getMax()-1;
	half_w2 = GAU2.getMax()-1;

	int image_x, image_y;

	image_x = image.getRow();
	image_y = image.getCol();
	
	int flow_DOG_sign = 0; 
	
	//double angle, angle_thres1, angle_thres2;
	//angle_thres1 = 90;
	//angle_thres2 = 180 - angle_thres1;

	//half_w1 = half_w2 = 25; // for TVCG

	/////////////////////////////////////////////////
	// INSIDE and OUTSIDE FLOW DOG
	////////////////////////////
	for (i = 0; i < image_x; i++) {
		for (j = 0; j < image_y; j++) {
			sum1 = sum2 = 0.0;
			w_sum1 = w_sum2 = 0.0;
			weight1 = weight2 = 0.0;
	
			vn[0] = gfield[i][j].gx;
			vn[1] = gfield[i][j].gy;
			if (vn[0] == 0.0 && vn[1] == 0.0) {
				sum1 = 1.0;
				sum2 = 1.0;
				dog[i][j] = sum1 - tau * sum2;
				continue;
			}
			//vn.make_unit();
			d_x = i; d_y = j;
			////////////////////////////////////////
			for (s = -half_w2; s <= half_w2; s++) { // width of Gaussian kernel
				////////////////////////
				x = d_x + vn[0] * s;
				y = d_y + vn[1] * s;
				/////////////////////////////////////////////////////
				if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
					continue;
				x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				val = image[x1][y1];
				/////////////////////////////////////////////////////////
				dd = ABS(s);
				if (dd > half_w1) weight1 = 0.0;
				else weight1 = GAU1[dd];
				//////////////////////////////////
				sum1 += val * weight1;
				w_sum1 += weight1;
				//d3 = round( ABS(val - c_val) );
				/////////////////////////////////////////////////////
				weight2 = GAU2[dd];
				sum2 += val * weight2;
				w_sum2 += weight2;
			}
			/////////////////////////
			sum1 /= w_sum1; // normalize
			sum2 /= w_sum2; // normalize
			////////////////////////////////////////////////////
			//////////////////////////////////////
			dog[i][j] = sum1 - tau * sum2;
			//if (sum1 - tau * sum2 > 0) dog[i][j] = 1.0;
			//else dog[i][j] = 1.0 + tanh(sum1 - tau * sum2);
		}
	}

}

void GetFlowDoGMainAxis2(Field& gfield, matrix& dog, matrix& tmp, vector& GAU3)
// following the flow, get the Gaussian of DOG values
// optimized!
{
	vector vt(2), vt_old(2);
	double x, y, d_x, d_y;
	double weight1, w_sum1, sum1;

	int i_x, i_y, k;
	int x1, y1;
	//int x2, y2;
	//double lb, lt, rb, rt;
	//double uu, vv, bb, tt;
	double val;
	int i, j;

	int image_x = dog.getRow();
	int image_y = dog.getCol();

	int half_l;
	//half_w1 = GAU1.getMax()-1;
	//half_w2 = GAU2.getMax()-1;
	half_l = GAU3.getMax()-1;
	
	int flow_DOG_sign = 0; 
	
	//double angle, angle_thres1, angle_thres2;
	//angle_thres1 = 90;
	//angle_thres2 = 180 - angle_thres1;

	double step_size, step_size1; 
	//double t;

	step_size = 1.0;
	//step_size = 2.0;
	step_size1 = step_size;
	
	//half_l = 25; // for TVCG

	for (i = 0; i < image_x; i++) {
		for (j = 0; j < image_y; j++) {
	
			/////////////////////////////////////////////////
			// INSIDE and OUTSIDE FLOW DOG
			////////////////////////////////////
			//count = 0; // number of pixels traversed
			sum1 = 0.0;
			w_sum1 = 0.0;
			weight1 = 0.0;
			/////////////////////////////////
			val = dog[i][j];
			weight1 = GAU3[0]; 
			//weight1 = 1.0; 
			sum1 = val * weight1;
			w_sum1 += weight1;
			////////////////////////////////////////////////
			// One half
			d_x = (double)i; d_y = (double)j; 
			i_x = i; i_y = j;
			////////////////////////////
			for (k = 0; k < half_l; k++) {
				vt[0] = -gfield[i_x][i_y].gy;
				vt[1] = gfield[i_x][i_y].gx;
				if (vt[0] == 0.0 && vt[1] == 0.0) {
					break;
				}
				//vt.make_unit();
				x = d_x;
				y = d_y;
				/////////////////////////////////////////////////////
				if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
					break;
				x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				val = dog[x1][y1];
				//////////////////////////////
				weight1 = GAU3[k]; 
				//weight1 = 1.0; // uniform weight
				////////////////////
				sum1 += val * weight1;
				w_sum1 += weight1;
				/////////////////////////////////////////
				d_x += vt[0] * step_size1; // accurate new location x
				d_y += vt[1] * step_size1; // accurate new location y
				/////////////////////////////////////////
				i_x = round(d_x); // integer version of new location x
				i_y = round(d_y); // integer version of new location y
				//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
				if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
				/////////////////////////
			}
			////////////////////////////////////////////////
			// Other half
			d_x = (double)i; d_y = (double)j; 
			i_x = i; i_y = j;
			for (k = 0; k < half_l; k++) {
				vt[0] = gfield[i_x][i_y].gy;
				vt[1] = -gfield[i_x][i_y].gx;
				if (vt[0] == 0.0 && vt[1] == 0.0) {
					break;
				}
				//vt.make_unit();
				x = d_x;
				y = d_y;
				/////////////////////////////////////////////////////
				if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
					break;
				x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				val = dog[x1][y1];
				//////////////////////////////
				weight1 = GAU3[k]; 
				//weight1 = 1.0; // uniform weight
				////////////////////
				sum1 += val * weight1;
				w_sum1 += weight1;
				/////////////////////////////////////////
				d_x += vt[0] * step_size1; // accurate new location x
				d_y += vt[1] * step_size1; // accurate new location y
				/////////////////////////////////////////
				i_x = round(d_x); // integer version of new location x
				i_y = round(d_y); // integer version of new location y
				//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
				if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
				/////////////////////////
			}
			////////////////////////////////////////
			sum1 /= w_sum1; // normalize
			//////////////////////////////////////
			//if (sum1 == 0.0 && sum2 == 0.0)
			//	sum1 = 1.0; // make it a non-edge
			//////////////////////////////////////
			if (sum1 > 0) // non edge
				tmp[i][j] = 1.0; 
			else // edge!
				tmp[i][j] = 1.0 + tanh(sum1);
			
		}
	}
	
}


void GetPointFlowColShockMinMax(int i, int j, cimatrix& cmap, Field& gfield, cimatrix& tmp, 
						  vector& GAU1, vector& GAU3, imatrix& sign, double z)
{
	vector vn(2), vt(2), vt_old(2);
	double x, y, d_x, d_y;
	//double weight1, weight2, w_sum1, sum1, sum2, w_sum2;

	int s, i_x, i_y, k;
	int x1, y1;
	//int x2, y2;
	//double lb, lt, rb, rt;
	//double uu, vv, bb, tt;
	//double val_r, val_g, val_b;
	GLubyte c_val_r, c_val_g, c_val_b;

	int half_w1, half_l;
	half_w1 = GAU1.getMax()-1;
	//half_w2 = GAU2.getMax()-1;
	half_l = GAU3.getMax()-1;
	
	//double shock_val = 0.0; // flow-based gradient magnitude

	///////////////////////////
	deque<int> vec[3];
	vec[0].clear();
	vec[1].clear();
	vec[2].clear();

	int c_sign;

	if (sign[i][j] == 1) c_sign = 1;
	else c_sign = 0;
	//TRACE("sign[%d][%d] = %d\n", i, j, sign[i][j]);

	double step_size, step_size1; 
	//double t;

	step_size = 1.0;
	//step_size = 2.0;
	step_size1 = step_size;
	/////////////////////////////////////////////////
	// INSIDE and OUTSIDE FLOW DOG
	////////////////////////////////////
	//count = 0; // number of pixels traversed

	
	////////////////////////////////////////////////
	// One half
	d_x = (double)i; d_y = (double)j; 
	i_x = i; i_y = j;
	//////////////////////////
	c_val_r = cmap[i_x][i_y].r;
	c_val_g = cmap[i_x][i_y].g;
	c_val_b = cmap[i_x][i_y].b;
	vec[0].push_back(c_val_r);
	vec[1].push_back(c_val_g);
	vec[2].push_back(c_val_b);
	////////////////////////////
	for (k = 0; k < half_l; k++) {
		vn[0] = gfield[i_x][i_y].gx;
		vn[1] = gfield[i_x][i_y].gy;
		if (vn[0] == 0.0 && vn[1] == 0.0) break;
		vn.make_unit();
		vt[0] = -gfield[i_x][i_y].gy;
		vt[1] = gfield[i_x][i_y].gx;
		vt.make_unit();
		////////////////////////////////////////
		for (s = -half_w1; s <= half_w1; s++) { // width of Gaussian kernel
			////////////////////////
			x = d_x + vn[0] * s;
			y = d_y + vn[1] * s;
			/////////////////////////////////////////////////////
			if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
				continue;
			x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
			y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
			//val = image[x1][y1];
			/////////////////////////////////////////////////////////
			if (c_sign) { // non edge region
				if (sign[x1][y1] == 1) {
					vec[0].push_back(cmap[x1][y1].r);
					vec[1].push_back(cmap[x1][y1].g);
					vec[2].push_back(cmap[x1][y1].b);
				}
			}
			else { // edge region
				if (sign[x1][y1] == 0) {
					vec[0].push_back(cmap[x1][y1].r);
					vec[1].push_back(cmap[x1][y1].g);
					vec[2].push_back(cmap[x1][y1].b);
				}
			}
		}
		/////////////////////////////////////////
		d_x += vt[0] * step_size1; // accurate new location x
		d_y += vt[1] * step_size1; // accurate new location y
		/////////////////////////////////////////
		i_x = round(d_x); // integer version of new location x
		i_y = round(d_y); // integer version of new location y
		//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
		/////////////////////////
	}
	////////////////////////////////////////////////
	// Other half
	d_x = (double)i; d_y = (double)j; 
	i_x = i; i_y = j;
	for (k = 0; k < half_l; k++) {
		vn[0] = gfield[i_x][i_y].gx;
		vn[1] = gfield[i_x][i_y].gy;
		if (vn[0] == 0.0 && vn[1] == 0.0) break;
		vn.make_unit();
		vt[0] = gfield[i_x][i_y].gy;
		vt[1] = -gfield[i_x][i_y].gx;
		vt.make_unit();
		////////////////////////////////////
		for (s = -half_w1; s <= half_w1; s++) { // width of Gaussian kernel
			////////////////////////
			x = d_x + vn[0] * s;
			y = d_y + vn[1] * s;
			/////////////////////////////////////////////////////
			if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
				continue;
			x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
			y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
			//val = image[x1][y1];
			/////////////////////////////////////////////////////////
			if (c_sign) { // non edge region
				if (sign[x1][y1] == 1) {
					vec[0].push_back(cmap[x1][y1].r);
					vec[1].push_back(cmap[x1][y1].g);
					vec[2].push_back(cmap[x1][y1].b);
				}
			}
			else { // edge region
				if (sign[x1][y1] == 0) {
					vec[0].push_back(cmap[x1][y1].r);
					vec[1].push_back(cmap[x1][y1].g);
					vec[2].push_back(cmap[x1][y1].b);
				}
			}
		}
		/////////////////////////////////////////
		d_x += vt[0] * step_size1; // accurate new location x
		d_y += vt[1] * step_size1; // accurate new location y
		/////////////////////////////////////////
		i_x = round(d_x); // integer version of new location x
		i_y = round(d_y); // integer version of new location y
		//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
		/////////////////////////
	}
	//sum1 /= w_sum1; // normalize
	//sum2 /= w_sum2; // normalize
	sort(vec[0].begin(), vec[0].end()); 
	sort(vec[1].begin(), vec[1].end()); 
	sort(vec[2].begin(), vec[2].end()); 
	//flow_median = vec[vec.size()/2]; 
	//double z = 0.3;
	//if (vec[0].size() == 0 || vec[1].size() == 0 || vec[2].size() == 0) {
	//	shock_val.r = c_val_r;
	//	shock_val.g = c_val_g;
	//	shock_val.b = c_val_b;
	//	return shock_val; 
	//}
	if (c_sign) { // non edge region
		tmp[i][j].r = vec[0][vec[0].size()-1]; 
		tmp[i][j].g = vec[1][vec[1].size()-1]; 
		tmp[i][j].b = vec[2][vec[2].size()-1]; 
		//tmp[i][j].r = vec[0][vec[0].size()/2]; 
		//tmp[i][j].g = vec[1][vec[1].size()/2]; 
		//tmp[i][j].b = vec[2][vec[2].size()/2]; 
		//tmp[i][j].r = round( (1-z) * vec[0][vec[0].size()/2] + z * 255); 
		//tmp[i][j].g = round( (1-z) * vec[1][vec[1].size()/2] + z * 255); 
		//tmp[i][j].b = round( (1-z) * vec[2][vec[2].size()/2] + z * 255); 
		//image2[i][j] = round( (1-z) * vec[vec.size()-1] + z * 255 ); // brightest value
	}
	else {// edge region
		//image2[i][j] = vec[0]; 
		tmp[i][j].r = vec[0][0]; // darkest value
		tmp[i][j].g = vec[1][0];
		tmp[i][j].b = vec[2][0];
		//tmp[i][j].r = round( (1-z) * vec[0][0] + z * 0 ); // darkest value
		//tmp[i][j].g = round( (1-z) * vec[1][0] + z * 0 ); // darkest value
		//tmp[i][j].b = round( (1-z) * vec[2][0] + z * 0 ); // darkest value
	}
	////////////////////////////////////////////////////
	//return shock_val;
}

void GetColShockMinMax(cimatrix& cmap, vector& GAU1, cimatrix& tmp, imatrix& sign, int half, double z)
{
	//double x, y, d_x, d_y;
	//double weight1, weight2, w_sum1, sum1, sum2, w_sum2;

	int x, y;
	int s, t;
	//int x1, y1;
	int i, j, k;
	//int x2, y2;
	//double lb, lt, rb, rt;
	//double uu, vv, bb, tt;
	//double val_r, val_g, val_b;
	//GLubyte c_val_r, c_val_g, c_val_b;

	int image_x = cmap.getRow();
	int image_y = cmap.getCol();

	int half1;
	//half1 = GAU1.getMax()-1;
	//half_w2 = GAU2.getMax()-1;
	//half_l = GAU3.getMax()-1;
	half1 = half;
	
	//double shock_val = 0.0; // flow-based gradient magnitude

	///////////////////////////
	deque<int> vec[3];
	
	int c_sign;

	//TRACE("sign[%d][%d] = %d\n", i, j, sign[i][j]);

	double step_size, step_size1; 
	//double t;

	step_size = 1.0;
	//step_size = 2.0;
	step_size1 = step_size;
	/////////////////////////////////////////////////
	// INSIDE and OUTSIDE FLOW DOG
	////////////////////////////////////
	//count = 0; // number of pixels traversed

	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			if (sign[i][j] == 1) c_sign = 1;
			else c_sign = 0;
			vec[0].clear();
			vec[1].clear();
			vec[2].clear();
			///////////////////////////////////////////
			for (s = -half1; s <= half1; s++) {
				for (t = -half1; t <= half1; t++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					//k = round( dist2(x, y, i, j) );
					if ( k > half1 ) continue; 
					/////////////////////////////////////////////////////
					if (c_sign) { // non edge region
						if (sign[x][y] == 1) {
							vec[0].push_back(cmap[x][y].r);
							vec[1].push_back(cmap[x][y].g);
							vec[2].push_back(cmap[x][y].b);
						}
					}
					else { // edge region
						if (sign[x][y] == 0) {
							vec[0].push_back(cmap[x][y].r);
							vec[1].push_back(cmap[x][y].g);
							vec[2].push_back(cmap[x][y].b);
						}
					}
					//sum1 += image[x][y] * GAU1[k] * weight;
					//w_sum1 += GAU1[k] * weight;
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}

			//sum1 /= w_sum1; // normalize
			//sum2 /= w_sum2; // normalize
			sort(vec[0].begin(), vec[0].end()); 
			sort(vec[1].begin(), vec[1].end()); 
			sort(vec[2].begin(), vec[2].end()); 
			//flow_median = vec[vec.size()/2]; 
			//double z = 0.3;
			//if (vec[0].size() == 0 || vec[1].size() == 0 || vec[2].size() == 0) {
			//	shock_val.r = c_val_r;
			//	shock_val.g = c_val_g;
			//	shock_val.b = c_val_b;
			//	return shock_val; 
			//}
			if (c_sign) { // non edge region
				//tmp[i][j].r = vec[0][vec[0].size()-1]; 
				//tmp[i][j].g = vec[1][vec[1].size()-1]; 
				//tmp[i][j].b = vec[2][vec[2].size()-1]; 
				tmp[i][j].r = vec[0][vec[0].size()/2]; 
				tmp[i][j].g = vec[1][vec[1].size()/2]; 
				tmp[i][j].b = vec[2][vec[2].size()/2]; 
				//tmp[i][j].r = round( (1-z) * vec[0][vec[0].size()/2] + z * 255); 
				//tmp[i][j].g = round( (1-z) * vec[1][vec[1].size()/2] + z * 255); 
				//tmp[i][j].b = round( (1-z) * vec[2][vec[2].size()/2] + z * 255); 
				//image2[i][j] = round( (1-z) * vec[vec.size()-1] + z * 255 ); // brightest value
			}
			else {// edge region
				//image2[i][j] = vec[0]; 
				//tmp[i][j].r = vec[0][0]; // darkest value
				//tmp[i][j].g = vec[1][0];
				//tmp[i][j].b = vec[2][0];
				tmp[i][j].r = round( (1-z) * vec[0][0] + z * 0 ); // darkest value
				tmp[i][j].g = round( (1-z) * vec[1][0] + z * 0 ); // darkest value
				tmp[i][j].b = round( (1-z) * vec[2][0] + z * 0 ); // darkest value
			}

			
		}
	}
	////////////////////////////////////////////////////
	//return shock_val;
}

void Get1DFlowColShockMinMax(cimatrix& cmap, Field& gfield, cimatrix& tmp, imatrix& sign, vector& GAU3, double z)
// following the flow, compute the MinMax
// Faster version!
{
	vector vt(2), vt_old(2);
	double x, y, d_x, d_y;
	//double weight1, w_sum1, sum1;
	//double r, g, b, h, s, v;

	int i_x, i_y, k;
	int x1, y1;
	//int x2, y2;
	//double lb, lt, rb, rt;
	//double uu, vv, bb, tt;
	//double val;
	int c_sign;
	deque<int> vec[3];
	int R, G, B;
	int inc_col, dec_col;

	int image_x = sign.getRow();
	int image_y = sign.getCol();

	int half_l;
	//half_w1 = GAU1.getMax()-1;
	//half_w2 = GAU2.getMax()-1;
	half_l = GAU3.getMax()-1;
	
	int flow_DOG_sign = 0; 
	
	//double angle, angle_thres1, angle_thres2;
	//angle_thres1 = 90;
	//angle_thres2 = 180 - angle_thres1;

	double step_size, step_size1; 
	//double t;

	step_size = 1.0;
	//step_size = 2.0;
	step_size1 = step_size;

	int i, j;

	for (i = 0; i < image_x; i++) {
		for (j = 0; j < image_y; j++) {
			//sum1 = 0.0;
			//w_sum1 = 0.0;
			//weight1 = 0.0;
			if (sign[i][j] == 1) c_sign = 1;
			else c_sign = 0;
			vec[0].clear();
			vec[1].clear();
			vec[2].clear();
			vec[0].push_back(cmap[i][j].r);
			vec[1].push_back(cmap[i][j].g);
			vec[2].push_back(cmap[i][j].b);
			/////////////////////////////////
			//val = dog[i][j];
			//weight1 = GAU3[0]; 
			//sum1 = val * weight1;
			//w_sum1 += weight1;
			////////////////////////////////////////////////
			// One half
			d_x = (double)i; d_y = (double)j; 
			i_x = i; i_y = j;
			////////////////////////////
			for (k = 0; k < half_l; k++) {
				vt[0] = -gfield[i_x][i_y].gy;
				vt[1] = gfield[i_x][i_y].gx;
				if (vt[0] == 0.0 && vt[1] == 0.0) {
					break;
				}
				vt.make_unit();
				x = d_x;
				y = d_y;
				/////////////////////////////////////////////////////
				if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
					break;
				x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				/////////////////////////////////////////////////////
				if (c_sign) { // non edge region
					if (sign[x1][y1] == 1) {
						vec[0].push_back(cmap[x1][y1].r);
						vec[1].push_back(cmap[x1][y1].g);
						vec[2].push_back(cmap[x1][y1].b);
					}
				}
				else { // edge region
					if (sign[x1][y1] == 0) {
						vec[0].push_back(cmap[x1][y1].r);
						vec[1].push_back(cmap[x1][y1].g);
						vec[2].push_back(cmap[x1][y1].b);
					}
				}
				//val = dog[x1][y1];
				//////////////////////////////
				//weight1 *= GAU3[k]; 
				////////////////////
				//sum1 += val * weight1;
				//w_sum1 += weight1;
				/////////////////////////////////////////
				d_x += vt[0] * step_size1; // accurate new location x
				d_y += vt[1] * step_size1; // accurate new location y
				/////////////////////////////////////////
				i_x = round(d_x); // integer version of new location x
				i_y = round(d_y); // integer version of new location y
				//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
				if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
				/////////////////////////
			}
			////////////////////////////////////////////////
			// Other half
			d_x = (double)i; d_y = (double)j; 
			i_x = i; i_y = j;
			for (k = 0; k < half_l; k++) {
				vt[0] = gfield[i_x][i_y].gy;
				vt[1] = -gfield[i_x][i_y].gx;
				if (vt[0] == 0.0 && vt[1] == 0.0) {
					break;
				}
				vt.make_unit();
				x = d_x;
				y = d_y;
				/////////////////////////////////////////////////////
				if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
					break;
				x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				/////////////////////////////////////////////////////
				if (c_sign) { // non edge region
					if (sign[x1][y1] == 1) {
						vec[0].push_back(cmap[x1][y1].r);
						vec[1].push_back(cmap[x1][y1].g);
						vec[2].push_back(cmap[x1][y1].b);
					}
				}
				else { // edge region
					if (sign[x1][y1] == 0) {
						vec[0].push_back(cmap[x1][y1].r);
						vec[1].push_back(cmap[x1][y1].g);
						vec[2].push_back(cmap[x1][y1].b);
					}
				}
				//val = dog[x1][y1];
				//////////////////////////////
				//weight1 *= GAU3[k]; 
				////////////////////
				//sum1 += val * weight1;
				//w_sum1 += weight1;
				/////////////////////////////////////////
				d_x += vt[0] * step_size1; // accurate new location x
				d_y += vt[1] * step_size1; // accurate new location y
				/////////////////////////////////////////
				i_x = round(d_x); // integer version of new location x
				i_y = round(d_y); // integer version of new location y
				//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
				if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
				/////////////////////////
			}
			//sum1 /= w_sum1; // normalize
			//////////////////////////////////////
			//if (sum1 >= 0) // non edge
			//	sign[i][j] = 1; // non edge
			//else  // edge
			//	sign[i][j] = 0; // edge
			sort(vec[0].begin(), vec[0].end()); 
			sort(vec[1].begin(), vec[1].end()); 
			sort(vec[2].begin(), vec[2].end()); 
			//flow_median = vec[vec.size()/2]; 
			//double z = 0.3;
			//if (vec[0].size() == 0 || vec[1].size() == 0 || vec[2].size() == 0) {
			//	shock_val.r = c_val_r;
			//	shock_val.g = c_val_g;
			//	shock_val.b = c_val_b;
			//	return shock_val; 
			//}
			if (c_sign) { // non edge region
				//tmp[i][j].r = vec[0][vec[0].size()-1]; 
				//tmp[i][j].g = vec[1][vec[1].size()-1]; 
				//tmp[i][j].b = vec[2][vec[2].size()-1]; 
				tmp[i][j].r = vec[0][vec[0].size()/2]; 
				tmp[i][j].g = vec[1][vec[1].size()/2]; 
				tmp[i][j].b = vec[2][vec[2].size()/2]; 
				//tmp[i][j].r = round( (1-z) * vec[0][vec[0].size()/2] + z * 255); 
				//tmp[i][j].g = round( (1-z) * vec[1][vec[1].size()/2] + z * 255); 
				//tmp[i][j].b = round( (1-z) * vec[2][vec[2].size()/2] + z * 255); 
				//image2[i][j] = round( (1-z) * vec[vec.size()-1] + z * 255 ); // brightest value
				//////////////////////////////////////////////////
				inc_col = 7;
				R = tmp[i][j].r; G = tmp[i][j].g; B = tmp[i][j].b;
				R += inc_col; if (R > 255) R = 255;
				G += inc_col; if (G > 255) G = 255;
				B += inc_col; if (B > 255) B = 255;
				tmp[i][j].r = (GLubyte)R;
				tmp[i][j].g = (GLubyte)G;
				tmp[i][j].b = (GLubyte)B;
				//////////////////////////////////////////
				/*
				r = tmp[i][j].r / 255.;
				g = tmp[i][j].g / 255.;
				b = tmp[i][j].b / 255.;
				RGB2HSV(r, g, b, h, s, v);
				///////////////////////////////
				//v = (1 - z) * v + z * 1.0;
				v += 0.05; if (v > 1.0) v = 1.0;
				///////////////////////////////
				HSV2RGB(h, s, v, r, g, b);
				tmp[i][j].r = (GLubyte)(r*255);
				tmp[i][j].g = (GLubyte)(g*255);
				tmp[i][j].b = (GLubyte)(b*255);
				////////////////////////////////////
				*/
			}
			else {// edge region
				tmp[i][j].r = vec[0][0]; // darkest value
				tmp[i][j].g = vec[1][0];
				tmp[i][j].b = vec[2][0];
				//tmp[i][j].r = round( (1-z) * vec[0][vec[0].size()/2] + z * 0 ); // darkest value
				//tmp[i][j].g = round( (1-z) * vec[1][vec[0].size()/2] + z * 0 ); // darkest value
				//tmp[i][j].b = round( (1-z) * vec[2][vec[0].size()/2] + z * 0 ); // darkest value
				//tmp[i][j].r = round( (1-z) * vec[0][0] + z * 0 ); // darkest value
				//tmp[i][j].g = round( (1-z) * vec[1][0] + z * 0 ); // darkest value
				//tmp[i][j].b = round( (1-z) * vec[2][0] + z * 0 ); // darkest value
				//////////////////////////////////////
				dec_col = 2;
				R = tmp[i][j].r; G = tmp[i][j].g; B = tmp[i][j].b;
				R -= dec_col; if (R < 0) R = 0;
				G -= dec_col; if (G < 0) G = 0;
				B -= dec_col; if (B < 0) B = 0;
				tmp[i][j].r = (GLubyte)R;
				tmp[i][j].g = (GLubyte)G;
				tmp[i][j].b = (GLubyte)B;
				//////////////////////////////////////////
				/*
				r = tmp[i][j].r / 255.;
				g = tmp[i][j].g / 255.;
				b = tmp[i][j].b / 255.;
				RGB2HSV(r, g, b, h, s, v);
				///////////////////////////////
				//v = (1 - z) * v + z * 0.0;
				v -= 0.001; if (v < 0.0) v = 0.0;
				///////////////////////////////
				HSV2RGB(h, s, v, r, g, b);
				tmp[i][j].r = (GLubyte)(r*255);
				tmp[i][j].g = (GLubyte)(g*255);
				tmp[i][j].b = (GLubyte)(b*255);
				////////////////////////////////////
				*/
			}
		}
	}
	
}


void Get1DPerpFlowShockMinmax(cimatrix& cmap, Field& gfield, cimatrix& tmp, imatrix& sign, vector& GAU2, double z)
// For each pixel, compute the directional MinMax in the perpendicular direction to the flow
{
	vector vn(2), vt(2), vt_old(2);
	double x, y, d_x, d_y;
	//double r, g, b, h, s, v;

	int ss;
	int x1, y1;
	int i, j;
	//int x2, y2;
	//double lb, lt, rb, rt;
	//double uu, vv, bb, tt;
	//int dd;
	//double val;

	int half_w2;
	//half_w1 = GAU1.getMax()-1;
	half_w2 = GAU2.getMax()-1;

	int image_x, image_y;

	image_x = sign.getRow();
	image_y = sign.getCol();
	
	int c_sign;
	deque<int> vec[3];
	int R, G, B;
	int inc_col, dec_col;
	
	////////////////////////////
	for (i = 0; i < image_x; i++) {
		for (j = 0; j < image_y; j++) {
			if (sign[i][j] == 1) c_sign = 1;
			else c_sign = 0;
			vec[0].clear();
			vec[1].clear();
			vec[2].clear();
			vec[0].push_back(cmap[i][j].r);
			vec[1].push_back(cmap[i][j].g);
			vec[2].push_back(cmap[i][j].b);
			
			vn[0] = gfield[i][j].gx;
			vn[1] = gfield[i][j].gy;
			//if (vn[0] == 0.0 && vn[1] == 0.0) {
			//	continue;
			//}
			vn.make_unit();
			d_x = i; d_y = j;
			////////////////////////////////////////
			for (ss = -half_w2; ss <= half_w2; ss++) { // width of Gaussian kernel
				////////////////////////
				x = d_x + vn[0] * ss;
				y = d_y + vn[1] * ss;
				/////////////////////////////////////////////////////
				if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
					continue;
				x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				//val = image[x1][y1];
				/////////////////////////////////////////////////////////
				/////////////////////////////////////////////////////
				if (c_sign) { // non edge region
					if (sign[x1][y1] == 1) {
						vec[0].push_back(cmap[x1][y1].r);
						vec[1].push_back(cmap[x1][y1].g);
						vec[2].push_back(cmap[x1][y1].b);
					}
				}
				else { // edge region
					if (sign[x1][y1] == 0) {
						vec[0].push_back(cmap[x1][y1].r);
						vec[1].push_back(cmap[x1][y1].g);
						vec[2].push_back(cmap[x1][y1].b);
					}
				}
			}
			sort(vec[0].begin(), vec[0].end()); 
			sort(vec[1].begin(), vec[1].end()); 
			sort(vec[2].begin(), vec[2].end()); 
			if (c_sign) { // non edge region
				//tmp[i][j].r = vec[0][vec[0].size()-1]; 
				//tmp[i][j].g = vec[1][vec[1].size()-1]; 
				//tmp[i][j].b = vec[2][vec[2].size()-1]; 
				tmp[i][j].r = vec[0][vec[0].size()/2]; 
				tmp[i][j].g = vec[1][vec[1].size()/2]; 
				tmp[i][j].b = vec[2][vec[2].size()/2]; 
				//tmp[i][j].r = round( (1-z) * vec[0][vec[0].size()/2] + z * 255); 
				//tmp[i][j].g = round( (1-z) * vec[1][vec[1].size()/2] + z * 255); 
				//tmp[i][j].b = round( (1-z) * vec[2][vec[2].size()/2] + z * 255); 
				//image2[i][j] = round( (1-z) * vec[vec.size()-1] + z * 255 ); // brightest value
				//////////////////////////////////////////////////
				inc_col = 7;
				R = tmp[i][j].r; G = tmp[i][j].g; B = tmp[i][j].b;
				R += inc_col; if (R > 255) R = 255;
				G += inc_col; if (G > 255) G = 255;
				B += inc_col; if (B > 255) B = 255;
				tmp[i][j].r = (GLubyte)R;
				tmp[i][j].g = (GLubyte)G;
				tmp[i][j].b = (GLubyte)B;
				//////////////////////////////////////////
				/*
				//////////////////////////////////////////
				r = tmp[i][j].r / 255.;
				g = tmp[i][j].g / 255.;
				b = tmp[i][j].b / 255.;
				RGB2HSV(r, g, b, h, s, v);
				///////////////////////////////
				//v = (1 - z) * v + z * 1.0;
				v += 0.05; if (v > 1.0) v = 1.0;
				///////////////////////////////
				HSV2RGB(h, s, v, r, g, b);
				tmp[i][j].r = (GLubyte)(r*255);
				tmp[i][j].g = (GLubyte)(g*255);
				tmp[i][j].b = (GLubyte)(b*255);
				////////////////////////////////////
				*/
			}
			else {// edge region
				tmp[i][j].r = vec[0][0]; // darkest value
				tmp[i][j].g = vec[1][0];
				tmp[i][j].b = vec[2][0];
				//tmp[i][j].r = round( (1-z) * vec[0][vec[0].size()/2] + z * 0 ); // darkest value
				//tmp[i][j].g = round( (1-z) * vec[1][vec[0].size()/2] + z * 0 ); // darkest value
				//tmp[i][j].b = round( (1-z) * vec[2][vec[0].size()/2] + z * 0 ); // darkest value
				//tmp[i][j].r = round( (1-z) * vec[0][0] + z * 0 ); // darkest value
				//tmp[i][j].g = round( (1-z) * vec[1][0] + z * 0 ); // darkest value
				//tmp[i][j].b = round( (1-z) * vec[2][0] + z * 0 ); // darkest value
				//////////////////////////////////////
				dec_col = 2;
				R = tmp[i][j].r; G = tmp[i][j].g; B = tmp[i][j].b;
				R -= dec_col; if (R < 0) R = 0;
				G -= dec_col; if (G < 0) G = 0;
				B -= dec_col; if (B < 0) B = 0;
				tmp[i][j].r = (GLubyte)R;
				tmp[i][j].g = (GLubyte)G;
				tmp[i][j].b = (GLubyte)B;
				//////////////////////////////////////////
				/*
				//////////////////////////////////////////
				r = tmp[i][j].r / 255.;
				g = tmp[i][j].g / 255.;
				b = tmp[i][j].b / 255.;
				RGB2HSV(r, g, b, h, s, v);
				///////////////////////////////
				//v = (1 - z) * v + z * 0.0;
				v -= 0.001; if (v < 0.0) v = 0.0;
				///////////////////////////////
				HSV2RGB(h, s, v, r, g, b);
				tmp[i][j].r = (GLubyte)(r*255);
				tmp[i][j].g = (GLubyte)(g*255);
				tmp[i][j].b = (GLubyte)(b*255);
				////////////////////////////////////
				*/
			}
		}
	}

}


void Get1DFlowColShockAverage(cimatrix& cmap, Field& gfield, cimatrix& tmp, imatrix& sign, vector& GAU3, double z)
// following the flow, compute the average
// Faster version!
{
	vector vt(2), vt_old(2);
	double x, y, d_x, d_y;
	double weight, w_sum, sum_r, sum_g, sum_b;
	double val_r, val_g, val_b;

	int i_x, i_y, k;
	int x1, y1;
	//int x2, y2;
	//double lb, lt, rb, rt;
	//double uu, vv, bb, tt;
	//double val;
	int c_sign;
	deque<int> vec[3];

	int image_x = sign.getRow();
	int image_y = sign.getCol();

	int half_l;
	//half_w1 = GAU1.getMax()-1;
	//half_w2 = GAU2.getMax()-1;
	half_l = GAU3.getMax()-1;
	
	int flow_DOG_sign = 0; 
	
	//double angle, angle_thres1, angle_thres2;
	//angle_thres1 = 90;
	//angle_thres2 = 180 - angle_thres1;

	double step_size, step_size1; 
	//double t;

	step_size = 1.0;
	//step_size = 2.0;
	step_size1 = step_size;

	int i, j;

	for (i = 0; i < image_x; i++) {
		for (j = 0; j < image_y; j++) {
			sum_r = 0.0; sum_g = 0.0; sum_b = 0.0;
			w_sum = 0.0; 
			weight = 0.0; 
			///////////////////////////////
			if (sign[i][j] == 1) c_sign = 1;
			else c_sign = 0;
			/////////////////////////////////
			val_r = cmap[i][j].r;
			val_g = cmap[i][j].g;
			val_b = cmap[i][j].b;
			weight = GAU3[0]; 
			sum_r += val_r * weight;
			sum_g += val_g * weight;
			sum_b += val_b * weight;
			w_sum += weight;
			//w_sum1 += weight1;
			////////////////////////////////////////////////
			// One half
			d_x = (double)i; d_y = (double)j; 
			i_x = i; i_y = j;
			////////////////////////////
			for (k = 0; k < half_l; k++) {
				vt[0] = -gfield[i_x][i_y].gy;
				vt[1] = gfield[i_x][i_y].gx;
				if (vt[0] == 0.0 && vt[1] == 0.0) {
					break;
				}
				vt.make_unit();
				x = d_x;
				y = d_y;
				/////////////////////////////////////////////////////
				if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
					break;
				x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				/////////////////////////////////////////////////////
				if (c_sign) { // non edge region
					if (sign[x1][y1] == 1) {
						val_r = cmap[x1][y1].r;
						val_g = cmap[x1][y1].g;
						val_b = cmap[x1][y1].b;
						weight = GAU3[k]; 
						sum_r += val_r * weight;
						sum_g += val_g * weight;
						sum_b += val_b * weight;
						w_sum += weight;
					}
				}
				else { // edge region
					if (sign[x1][y1] == 0) {
						val_r = cmap[x1][y1].r;
						val_g = cmap[x1][y1].g;
						val_b = cmap[x1][y1].b;
						weight = GAU3[k]; 
						sum_r += val_r * weight;
						sum_g += val_g * weight;
						sum_b += val_b * weight;
						w_sum += weight;
					}
				}
				/////////////////////////////////////////
				d_x += vt[0] * step_size1; // accurate new location x
				d_y += vt[1] * step_size1; // accurate new location y
				/////////////////////////////////////////
				i_x = round(d_x); // integer version of new location x
				i_y = round(d_y); // integer version of new location y
				//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
				if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
				/////////////////////////
			}
			////////////////////////////////////////////////
			// Other half
			d_x = (double)i; d_y = (double)j; 
			i_x = i; i_y = j;
			for (k = 0; k < half_l; k++) {
				vt[0] = gfield[i_x][i_y].gy;
				vt[1] = -gfield[i_x][i_y].gx;
				if (vt[0] == 0.0 && vt[1] == 0.0) {
					break;
				}
				vt.make_unit();
				x = d_x;
				y = d_y;
				/////////////////////////////////////////////////////
				if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
					break;
				x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				/////////////////////////////////////////////////////
				if (c_sign) { // non edge region
					if (sign[x1][y1] == 1) {
						val_r = cmap[x1][y1].r;
						val_g = cmap[x1][y1].g;
						val_b = cmap[x1][y1].b;
						weight = GAU3[k]; 
						sum_r += val_r * weight;
						sum_g += val_g * weight;
						sum_b += val_b * weight;
						w_sum += weight;
					}
				}
				else { // edge region
					if (sign[x1][y1] == 0) {
						val_r = cmap[x1][y1].r;
						val_g = cmap[x1][y1].g;
						val_b = cmap[x1][y1].b;
						weight = GAU3[k]; 
						sum_r += val_r * weight;
						sum_g += val_g * weight;
						sum_b += val_b * weight;
						w_sum += weight;
					}
				}
				/////////////////////////////////////////
				d_x += vt[0] * step_size1; // accurate new location x
				d_y += vt[1] * step_size1; // accurate new location y
				/////////////////////////////////////////
				i_x = round(d_x); // integer version of new location x
				i_y = round(d_y); // integer version of new location y
				//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
				if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
				/////////////////////////
			}
			sum_r /= w_sum; // normalize
			sum_g /= w_sum; // normalize
			sum_b /= w_sum; // normalize
			//////////////////////////////////////
			if (c_sign) { // non edge region
				tmp[i][j].r = round(sum_r);
				tmp[i][j].g = round(sum_g); 
				tmp[i][j].b = round(sum_b); 
				//tmp[i][j].r = round( (1-z) * sum_r + z * 255 );
				//tmp[i][j].g = round( (1-z) * sum_g + z * 255 ); 
				//tmp[i][j].b = round( (1-z) * sum_b + z * 255 ); 
			}
			else {// edge region
				//tmp[i][j].r = round( (1-z) * sum_r + z * 0 ); // darkest value
				//tmp[i][j].g = round( (1-z) * sum_g + z * 0 ); // darkest value
				//tmp[i][j].b = round( (1-z) * sum_b + z * 0 ); // darkest value
				tmp[i][j].r = round( (1-z) * sum_r + z * 0 ); // darkest value
				tmp[i][j].g = round( (1-z) * sum_g + z * 0 ); // darkest value
				tmp[i][j].b = round( (1-z) * sum_b + z * 0 ); // darkest value
			}
		}
	}
}

void Get1DFlowColShockAverageHSV(cimatrix& cmap, Field& gfield, cimatrix& tmp, imatrix& sign, vector& GAU3, 
								 double z1, double z2)
// Faster version!
{
	vector vt(2), vt_old(2);
	double x, y, d_x, d_y;
	//double weight1, w_sum1, sum1;
	double r, g, b, h, s, v;
	double ave_r, ave_g, ave_b, min_r, min_g, min_b;
	int count;

	int i_x, i_y, k;
	int x1, y1;
	//int x2, y2;
	//double lb, lt, rb, rt;
	//double uu, vv, bb, tt;
	//double val;
	int c_sign;
	deque<int> vec[3];

	int image_x = sign.getRow();
	int image_y = sign.getCol();

	int half_l;
	//half_w1 = GAU1.getMax()-1;
	//half_w2 = GAU2.getMax()-1;
	half_l = GAU3.getMax()-1;
	
	int flow_DOG_sign = 0; 
	
	//double angle, angle_thres1, angle_thres2;
	//angle_thres1 = 90;
	//angle_thres2 = 180 - angle_thres1;

	double step_size, step_size1; 
	//double t;

	step_size = 1.0;
	//step_size = 2.0;
	step_size1 = step_size;

	int i, j;

	for (i = 0; i < image_x; i++) {
		for (j = 0; j < image_y; j++) {
			//sum1 = 0.0;
			//w_sum1 = 0.0;
			//weight1 = 0.0;
			if (sign[i][j] == 1) c_sign = 1;
			else c_sign = 0;
			//vec[0].clear();
			//vec[1].clear();
			//vec[2].clear();
			//vec[0].push_back(cmap[i][j].r);
			//vec[1].push_back(cmap[i][j].g);
			//vec[2].push_back(cmap[i][j].b);
			ave_r = ave_g = ave_b = 0.0;
			min_r = min_g = min_b = 1000.0;
			count = 0;

			ave_r += cmap[i][j].r;
			ave_g += cmap[i][j].g;
			ave_b += cmap[i][j].b;
			count++;
			/////////////////////////////////
			//val = dog[i][j];
			//weight1 = GAU3[0]; 
			//sum1 = val * weight1;
			//w_sum1 += weight1;
			////////////////////////////////////////////////
			// One half
			d_x = (double)i; d_y = (double)j; 
			i_x = i; i_y = j;
			////////////////////////////
			for (k = 0; k < half_l; k++) {
				vt[0] = -gfield[i_x][i_y].gy;
				vt[1] = gfield[i_x][i_y].gx;
				if (vt[0] == 0.0 && vt[1] == 0.0) {
					break;
				}
				vt.make_unit();
				x = d_x;
				y = d_y;
				/////////////////////////////////////////////////////
				if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
					break;
				x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				/////////////////////////////////////////////////////
				if (c_sign) { // non edge region
					if (sign[x1][y1] == 1) {
						//vec[0].push_back(cmap[x1][y1].r);
						//vec[1].push_back(cmap[x1][y1].g);
						//vec[2].push_back(cmap[x1][y1].b);
						ave_r += cmap[x1][y1].r;
						ave_g += cmap[x1][y1].g;
						ave_b += cmap[x1][y1].b;
						count++;
					}
				}
				else { // edge region
					if (sign[x1][y1] == 0) {
						if (cmap[x1][y1].r < min_r) min_r = cmap[x1][y1].r;
						if (cmap[x1][y1].g < min_g) min_g = cmap[x1][y1].g;
						if (cmap[x1][y1].b < min_b) min_b = cmap[x1][y1].b;
					}
				}
				//val = dog[x1][y1];
				//////////////////////////////
				//weight1 *= GAU3[k]; 
				////////////////////
				//sum1 += val * weight1;
				//w_sum1 += weight1;
				/////////////////////////////////////////
				d_x += vt[0] * step_size1; // accurate new location x
				d_y += vt[1] * step_size1; // accurate new location y
				/////////////////////////////////////////
				i_x = round(d_x); // integer version of new location x
				i_y = round(d_y); // integer version of new location y
				//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
				if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
				/////////////////////////
			}
			////////////////////////////////////////////////
			// Other half
			d_x = (double)i; d_y = (double)j; 
			i_x = i; i_y = j;
			for (k = 0; k < half_l; k++) {
				vt[0] = gfield[i_x][i_y].gy;
				vt[1] = -gfield[i_x][i_y].gx;
				if (vt[0] == 0.0 && vt[1] == 0.0) {
					break;
				}
				vt.make_unit();
				x = d_x;
				y = d_y;
				/////////////////////////////////////////////////////
				if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
					break;
				x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				/////////////////////////////////////////////////////
				if (c_sign) { // non edge region
					if (sign[x1][y1] == 1) {
						ave_r += cmap[x1][y1].r;
						ave_g += cmap[x1][y1].g;
						ave_b += cmap[x1][y1].b;
						count++;
					}
				}
				else { // edge region
					if (sign[x1][y1] == 0) {
						if (cmap[x1][y1].r < min_r) min_r = cmap[x1][y1].r;
						if (cmap[x1][y1].g < min_g) min_g = cmap[x1][y1].g;
						if (cmap[x1][y1].b < min_b) min_b = cmap[x1][y1].b;
					}
				}
				//val = dog[x1][y1];
				//////////////////////////////
				//weight1 *= GAU3[k]; 
				////////////////////
				//sum1 += val * weight1;
				//w_sum1 += weight1;
				/////////////////////////////////////////
				d_x += vt[0] * step_size1; // accurate new location x
				d_y += vt[1] * step_size1; // accurate new location y
				/////////////////////////////////////////
				i_x = round(d_x); // integer version of new location x
				i_y = round(d_y); // integer version of new location y
				//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
				if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
				/////////////////////////
			}
			//sort(vec[0].begin(), vec[0].end()); 
			//sort(vec[1].begin(), vec[1].end()); 
			//sort(vec[2].begin(), vec[2].end()); 
			if (c_sign) { // non edge region
				//tmp[i][j].r = vec[0][vec[0].size()/2]; 
				//tmp[i][j].g = vec[1][vec[1].size()/2]; 
				//tmp[i][j].b = vec[2][vec[2].size()/2]; 
				tmp[i][j].r = (GLubyte)(ave_r / count); 
				tmp[i][j].g = (GLubyte)(ave_g / count);  
				tmp[i][j].b = (GLubyte)(ave_b / count);  
				//////////////////////////////////////////
				r = tmp[i][j].r / 255.;
				g = tmp[i][j].g / 255.;
				b = tmp[i][j].b / 255.;
				RGB2HSV(r, g, b, h, s, v);
				///////////////////////////////
				//v = (1 - z) * v + z * 1.0;
				//v += 0.05; if (v > 1.0) v = 1.0;
				v += z1; if (v > 1.0) v = 1.0;
				//v += 0.5; if (v > 1.0) v = 1.0;
				//s += 0.5; if (s > 1.0) s = 1.0;
				///////////////////////////////
				HSV2RGB(h, s, v, r, g, b);
				tmp[i][j].r = (GLubyte)(r*255);
				tmp[i][j].g = (GLubyte)(g*255);
				tmp[i][j].b = (GLubyte)(b*255);
				////////////////////////////////////
			}
			else {// edge region
				tmp[i][j].r = (GLubyte)min_r; // darkest value
				tmp[i][j].g = (GLubyte)min_g;
				tmp[i][j].b = (GLubyte)min_b;
				//////////////////////////////////////////
				r = tmp[i][j].r / 255.;
				g = tmp[i][j].g / 255.;
				b = tmp[i][j].b / 255.;
				RGB2HSV(r, g, b, h, s, v);
				///////////////////////////////
				//v = (1 - z) * v + z * 0.0;
				v -= z2; if (v < 0.0) v = 0.0;
				//v -= 0.001; if (v < 0.0) v = 0.0;
				//v -= 0.1; if (v < 0.0) v = 0.0;
				///////////////////////////////
				HSV2RGB(h, s, v, r, g, b);
				tmp[i][j].r = (GLubyte)(r*255);
				tmp[i][j].g = (GLubyte)(g*255);
				tmp[i][j].b = (GLubyte)(b*255);
				////////////////////////////////////
			}
		}
	}
	
}


void Get1DPerpFlowShockAverageHSV(cimatrix& cmap, Field& gfield, cimatrix& tmp, imatrix& sign, 
								  vector& GAU2, double z1, double z2)
// For each pixel, compute the directional MinMax in the perpendicular direction to the flow
{
	vector vn(2), vt(2), vt_old(2);
	double x, y, d_x, d_y;
	double r, g, b, h, s, v;
	double ave_r, ave_g, ave_b, min_r, min_g, min_b;
	int count;

	int ss;
	int x1, y1;
	int i, j;
	//int x2, y2;
	//double lb, lt, rb, rt;
	//double uu, vv, bb, tt;
	//int dd;
	//double val;

	int half_w2;
	//half_w1 = GAU1.getMax()-1;
	half_w2 = GAU2.getMax()-1;

	int image_x, image_y;

	image_x = sign.getRow();
	image_y = sign.getCol();
	
	int c_sign;
	deque<int> vec[3];
	
	////////////////////////////
	for (i = 0; i < image_x; i++) {
		for (j = 0; j < image_y; j++) {
			if (sign[i][j] == 1) c_sign = 1;
			else c_sign = 0;

			ave_r = ave_g = ave_b = 0.0;
			min_r = min_g = min_b = 1000.0;
			count = 0;

			ave_r += cmap[i][j].r;
			ave_g += cmap[i][j].g;
			ave_b += cmap[i][j].b;
			count++;
			
			vn[0] = gfield[i][j].gx;
			vn[1] = gfield[i][j].gy;
			//if (vn[0] == 0.0 && vn[1] == 0.0) {
			//	continue;
			//}
			vn.make_unit();
			d_x = i; d_y = j;
			////////////////////////////////////////
			for (ss = -half_w2; ss <= half_w2; ss++) { // width of Gaussian kernel
				////////////////////////
				x = d_x + vn[0] * ss;
				y = d_y + vn[1] * ss;
				/////////////////////////////////////////////////////
				if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
					continue;
				x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				//val = image[x1][y1];
				/////////////////////////////////////////////////////////
				/////////////////////////////////////////////////////
				if (c_sign) { // non edge region
					if (sign[x1][y1] == 1) {
						ave_r += cmap[x1][y1].r;
						ave_g += cmap[x1][y1].g;
						ave_b += cmap[x1][y1].b;
						count++;
					}
				}
				else { // edge region
					if (sign[x1][y1] == 0) {
						if (cmap[x1][y1].r < min_r) min_r = cmap[x1][y1].r;
						if (cmap[x1][y1].g < min_g) min_g = cmap[x1][y1].g;
						if (cmap[x1][y1].b < min_b) min_b = cmap[x1][y1].b;
					}
				}
			}
			sort(vec[0].begin(), vec[0].end()); 
			sort(vec[1].begin(), vec[1].end()); 
			sort(vec[2].begin(), vec[2].end()); 
			if (c_sign) { // non edge region
				r = (ave_r / count)  / 255.; 
				g = (ave_g / count) / 255.; 
				b = (ave_b / count) / 255.; 
				//tmp[i][j].r = round( (1-z) * vec[0][vec[0].size()/2] + z * 255); 
				//tmp[i][j].g = round( (1-z) * vec[1][vec[1].size()/2] + z * 255); 
				//tmp[i][j].b = round( (1-z) * vec[2][vec[2].size()/2] + z * 255); 
				//image2[i][j] = round( (1-z) * vec[vec.size()-1] + z * 255 ); // brightest value
				//////////////////////////////////////////
				RGB2HSV(r, g, b, h, s, v);
				///////////////////////////////
				//v = (1 - z) * v + z * 1.0;
				v += z1; if (v > 1.0) v = 1.0;
				//v += 0.5; if (v > 1.0) v = 1.0;
				//s += 0.5; if (s > 1.0) s = 1.0;
				///////////////////////////////
				HSV2RGB(h, s, v, r, g, b);
				tmp[i][j].r = (GLubyte)(r*255);
				tmp[i][j].g = (GLubyte)(g*255);
				tmp[i][j].b = (GLubyte)(b*255);
				////////////////////////////////////
			}
			else {// edge region
				r = min_r / 255.; // darkest value
				g = min_g / 255.;
				b = min_b / 255.;
				//tmp[i][j].r = round( (1-z) * vec[0][vec[0].size()/2] + z * 0 ); // darkest value
				//tmp[i][j].g = round( (1-z) * vec[1][vec[0].size()/2] + z * 0 ); // darkest value
				//tmp[i][j].b = round( (1-z) * vec[2][vec[0].size()/2] + z * 0 ); // darkest value
				//tmp[i][j].r = round( (1-z) * vec[0][0] + z * 0 ); // darkest value
				//tmp[i][j].g = round( (1-z) * vec[1][0] + z * 0 ); // darkest value
				//tmp[i][j].b = round( (1-z) * vec[2][0] + z * 0 ); // darkest value
				//////////////////////////////////////
				RGB2HSV(r, g, b, h, s, v);
				///////////////////////////////
				//v = (1 - z) * v + z * 0.0;
				v -= z2; if (v < 0.0) v = 0.0;
				//v -= 0.001; if (v < 0.0) v = 0.0;
				//v -= 0.1; if (v < 0.0) v = 0.0;
				///////////////////////////////
				HSV2RGB(h, s, v, r, g, b);
				tmp[i][j].r = (GLubyte)(r*255);
				tmp[i][j].g = (GLubyte)(g*255);
				tmp[i][j].b = (GLubyte)(b*255);
				////////////////////////////////////
			}
		}
	}
}

void Get1DFlowColShockMinMaxHSV(cimatrix& cmap, Field& gfield, cimatrix& tmp, imatrix& sign, vector& GAU3, double z)
// following the flow, compute the MinMax
// Faster version!
{
	vector vt(2), vt_old(2);
	double x, y, d_x, d_y;
	//double weight1, w_sum1, sum1;
	double r, g, b, h, s, v;

	int i_x, i_y, k;
	int x1, y1;
	//int x2, y2;
	//double lb, lt, rb, rt;
	//double uu, vv, bb, tt;
	//double val;
	int c_sign;
	deque<int> vec[3];

	int image_x = sign.getRow();
	int image_y = sign.getCol();

	int half_l;
	//half_w1 = GAU1.getMax()-1;
	//half_w2 = GAU2.getMax()-1;
	half_l = GAU3.getMax()-1;
	
	int flow_DOG_sign = 0; 
	
	//double angle, angle_thres1, angle_thres2;
	//angle_thres1 = 90;
	//angle_thres2 = 180 - angle_thres1;

	double step_size, step_size1; 
	//double t;

	step_size = 1.0;
	//step_size = 2.0;
	step_size1 = step_size;

	int i, j;

	for (i = 0; i < image_x; i++) {
		for (j = 0; j < image_y; j++) {
			//sum1 = 0.0;
			//w_sum1 = 0.0;
			//weight1 = 0.0;
			if (sign[i][j] == 1) c_sign = 1;
			else c_sign = 0;
			vec[0].clear();
			vec[1].clear();
			vec[2].clear();
			vec[0].push_back(cmap[i][j].r);
			vec[1].push_back(cmap[i][j].g);
			vec[2].push_back(cmap[i][j].b);
			/////////////////////////////////
			//val = dog[i][j];
			//weight1 = GAU3[0]; 
			//sum1 = val * weight1;
			//w_sum1 += weight1;
			////////////////////////////////////////////////
			// One half
			d_x = (double)i; d_y = (double)j; 
			i_x = i; i_y = j;
			////////////////////////////
			for (k = 0; k < half_l; k++) {
				vt[0] = -gfield[i_x][i_y].gy;
				vt[1] = gfield[i_x][i_y].gx;
				if (vt[0] == 0.0 && vt[1] == 0.0) {
					break;
				}
				vt.make_unit();
				x = d_x;
				y = d_y;
				/////////////////////////////////////////////////////
				if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
					break;
				x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				/////////////////////////////////////////////////////
				if (c_sign) { // non edge region
					if (sign[x1][y1] == 1) {
						vec[0].push_back(cmap[x1][y1].r);
						vec[1].push_back(cmap[x1][y1].g);
						vec[2].push_back(cmap[x1][y1].b);
					}
				}
				else { // edge region
					if (sign[x1][y1] == 0) {
						vec[0].push_back(cmap[x1][y1].r);
						vec[1].push_back(cmap[x1][y1].g);
						vec[2].push_back(cmap[x1][y1].b);
					}
				}
				//val = dog[x1][y1];
				//////////////////////////////
				//weight1 *= GAU3[k]; 
				////////////////////
				//sum1 += val * weight1;
				//w_sum1 += weight1;
				/////////////////////////////////////////
				d_x += vt[0] * step_size1; // accurate new location x
				d_y += vt[1] * step_size1; // accurate new location y
				/////////////////////////////////////////
				i_x = round(d_x); // integer version of new location x
				i_y = round(d_y); // integer version of new location y
				//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
				if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
				/////////////////////////
			}
			////////////////////////////////////////////////
			// Other half
			d_x = (double)i; d_y = (double)j; 
			i_x = i; i_y = j;
			for (k = 0; k < half_l; k++) {
				vt[0] = gfield[i_x][i_y].gy;
				vt[1] = -gfield[i_x][i_y].gx;
				if (vt[0] == 0.0 && vt[1] == 0.0) {
					break;
				}
				vt.make_unit();
				x = d_x;
				y = d_y;
				/////////////////////////////////////////////////////
				if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
					break;
				x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				/////////////////////////////////////////////////////
				if (c_sign) { // non edge region
					if (sign[x1][y1] == 1) {
						vec[0].push_back(cmap[x1][y1].r);
						vec[1].push_back(cmap[x1][y1].g);
						vec[2].push_back(cmap[x1][y1].b);
					}
				}
				else { // edge region
					if (sign[x1][y1] == 0) {
						vec[0].push_back(cmap[x1][y1].r);
						vec[1].push_back(cmap[x1][y1].g);
						vec[2].push_back(cmap[x1][y1].b);
					}
				}
				//val = dog[x1][y1];
				//////////////////////////////
				//weight1 *= GAU3[k]; 
				////////////////////
				//sum1 += val * weight1;
				//w_sum1 += weight1;
				/////////////////////////////////////////
				d_x += vt[0] * step_size1; // accurate new location x
				d_y += vt[1] * step_size1; // accurate new location y
				/////////////////////////////////////////
				i_x = round(d_x); // integer version of new location x
				i_y = round(d_y); // integer version of new location y
				//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
				if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
				/////////////////////////
			}
			sort(vec[0].begin(), vec[0].end()); 
			sort(vec[1].begin(), vec[1].end()); 
			sort(vec[2].begin(), vec[2].end()); 
			if (c_sign) { // non edge region
				//tmp[i][j].r = vec[0][vec[0].size()-1]; 
				//tmp[i][j].g = vec[1][vec[1].size()-1]; 
				//tmp[i][j].b = vec[2][vec[2].size()-1]; 
				tmp[i][j].r = vec[0][vec[0].size()/2]; 
				tmp[i][j].g = vec[1][vec[1].size()/2]; 
				tmp[i][j].b = vec[2][vec[2].size()/2]; 
				//tmp[i][j].r = round( (1-z) * vec[0][vec[0].size()/2] + z * 255); 
				//tmp[i][j].g = round( (1-z) * vec[1][vec[1].size()/2] + z * 255); 
				//tmp[i][j].b = round( (1-z) * vec[2][vec[2].size()/2] + z * 255); 
				//image2[i][j] = round( (1-z) * vec[vec.size()-1] + z * 255 ); // brightest value
				//////////////////////////////////////////
				r = tmp[i][j].r / 255.;
				g = tmp[i][j].g / 255.;
				b = tmp[i][j].b / 255.;
				RGB2HSV(r, g, b, h, s, v);
				///////////////////////////////
				//v = (1 - z) * v + z * 1.0;
				v += 0.05; if (v > 1.0) v = 1.0;
				//v += 0.5; if (v > 1.0) v = 1.0;
				//s += 0.5; if (s > 1.0) s = 1.0;
				///////////////////////////////
				HSV2RGB(h, s, v, r, g, b);
				tmp[i][j].r = (GLubyte)(r*255);
				tmp[i][j].g = (GLubyte)(g*255);
				tmp[i][j].b = (GLubyte)(b*255);
				////////////////////////////////////
			}
			else {// edge region
				tmp[i][j].r = vec[0][0]; // darkest value
				tmp[i][j].g = vec[1][0];
				tmp[i][j].b = vec[2][0];
				//tmp[i][j].r = round( (1-z) * vec[0][vec[0].size()/2] + z * 0 ); // darkest value
				//tmp[i][j].g = round( (1-z) * vec[1][vec[0].size()/2] + z * 0 ); // darkest value
				//tmp[i][j].b = round( (1-z) * vec[2][vec[0].size()/2] + z * 0 ); // darkest value
				//tmp[i][j].r = round( (1-z) * vec[0][0] + z * 0 ); // darkest value
				//tmp[i][j].g = round( (1-z) * vec[1][0] + z * 0 ); // darkest value
				//tmp[i][j].b = round( (1-z) * vec[2][0] + z * 0 ); // darkest value
				//////////////////////////////////////////
				r = tmp[i][j].r / 255.;
				g = tmp[i][j].g / 255.;
				b = tmp[i][j].b / 255.;
				RGB2HSV(r, g, b, h, s, v);
				///////////////////////////////
				//v = (1 - z) * v + z * 0.0;
				v -= 0.001; if (v < 0.0) v = 0.0;
				//v -= 0.1; if (v < 0.0) v = 0.0;
				///////////////////////////////
				HSV2RGB(h, s, v, r, g, b);
				tmp[i][j].r = (GLubyte)(r*255);
				tmp[i][j].g = (GLubyte)(g*255);
				tmp[i][j].b = (GLubyte)(b*255);
				////////////////////////////////////
			}
		}
	}
	
}


void Get1DPerpFlowShockMinmaxHSV(cimatrix& cmap, Field& gfield, cimatrix& tmp, imatrix& sign, vector& GAU2, double z)
// For each pixel, compute the directional MinMax in the perpendicular direction to the flow
{
	vector vn(2), vt(2), vt_old(2);
	double x, y, d_x, d_y;
	double r, g, b, h, s, v;

	int ss;
	int x1, y1;
	int i, j;
	//int x2, y2;
	//double lb, lt, rb, rt;
	//double uu, vv, bb, tt;
	//int dd;
	//double val;

	int half_w2;
	//half_w1 = GAU1.getMax()-1;
	half_w2 = GAU2.getMax()-1;

	int image_x, image_y;

	image_x = sign.getRow();
	image_y = sign.getCol();
	
	int c_sign;
	deque<int> vec[3];
	
	////////////////////////////
	for (i = 0; i < image_x; i++) {
		for (j = 0; j < image_y; j++) {
			if (sign[i][j] == 1) c_sign = 1;
			else c_sign = 0;
			vec[0].clear();
			vec[1].clear();
			vec[2].clear();
			vec[0].push_back(cmap[i][j].r);
			vec[1].push_back(cmap[i][j].g);
			vec[2].push_back(cmap[i][j].b);
			
			vn[0] = gfield[i][j].gx;
			vn[1] = gfield[i][j].gy;
			//if (vn[0] == 0.0 && vn[1] == 0.0) {
			//	continue;
			//}
			vn.make_unit();
			d_x = i; d_y = j;
			////////////////////////////////////////
			for (ss = -half_w2; ss <= half_w2; ss++) { // width of Gaussian kernel
				////////////////////////
				x = d_x + vn[0] * ss;
				y = d_y + vn[1] * ss;
				/////////////////////////////////////////////////////
				if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
					continue;
				x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				//val = image[x1][y1];
				/////////////////////////////////////////////////////////
				/////////////////////////////////////////////////////
				if (c_sign) { // non edge region
					if (sign[x1][y1] == 1) {
						vec[0].push_back(cmap[x1][y1].r);
						vec[1].push_back(cmap[x1][y1].g);
						vec[2].push_back(cmap[x1][y1].b);
					}
				}
				else { // edge region
					if (sign[x1][y1] == 0) {
						vec[0].push_back(cmap[x1][y1].r);
						vec[1].push_back(cmap[x1][y1].g);
						vec[2].push_back(cmap[x1][y1].b);
					}
				}
			}
			sort(vec[0].begin(), vec[0].end()); 
			sort(vec[1].begin(), vec[1].end()); 
			sort(vec[2].begin(), vec[2].end()); 
			if (c_sign) { // non edge region
				//tmp[i][j].r = vec[0][vec[0].size()-1]; 
				//tmp[i][j].g = vec[1][vec[1].size()-1]; 
				//tmp[i][j].b = vec[2][vec[2].size()-1]; 
				r = vec[0][vec[0].size()/2] / 255.; 
				g = vec[1][vec[1].size()/2] / 255.; 
				b = vec[2][vec[2].size()/2] / 255.; 
				//tmp[i][j].r = round( (1-z) * vec[0][vec[0].size()/2] + z * 255); 
				//tmp[i][j].g = round( (1-z) * vec[1][vec[1].size()/2] + z * 255); 
				//tmp[i][j].b = round( (1-z) * vec[2][vec[2].size()/2] + z * 255); 
				//image2[i][j] = round( (1-z) * vec[vec.size()-1] + z * 255 ); // brightest value
				//////////////////////////////////////////
				RGB2HSV(r, g, b, h, s, v);
				///////////////////////////////
				//v = (1 - z) * v + z * 1.0;
				v += 0.05; if (v > 1.0) v = 1.0;
				//v += 0.5; if (v > 1.0) v = 1.0;
				//s += 0.5; if (s > 1.0) s = 1.0;
				///////////////////////////////
				HSV2RGB(h, s, v, r, g, b);
				tmp[i][j].r = (GLubyte)(r*255);
				tmp[i][j].g = (GLubyte)(g*255);
				tmp[i][j].b = (GLubyte)(b*255);
				////////////////////////////////////
			}
			else {// edge region
				r = vec[0][0] / 255.; // darkest value
				g = vec[1][0] / 255.;
				b = vec[2][0] / 255.;
				//tmp[i][j].r = round( (1-z) * vec[0][vec[0].size()/2] + z * 0 ); // darkest value
				//tmp[i][j].g = round( (1-z) * vec[1][vec[0].size()/2] + z * 0 ); // darkest value
				//tmp[i][j].b = round( (1-z) * vec[2][vec[0].size()/2] + z * 0 ); // darkest value
				//tmp[i][j].r = round( (1-z) * vec[0][0] + z * 0 ); // darkest value
				//tmp[i][j].g = round( (1-z) * vec[1][0] + z * 0 ); // darkest value
				//tmp[i][j].b = round( (1-z) * vec[2][0] + z * 0 ); // darkest value
				//////////////////////////////////////
				RGB2HSV(r, g, b, h, s, v);
				///////////////////////////////
				//v = (1 - z) * v + z * 0.0;
				v -= 0.001; if (v < 0.0) v = 0.0;
				//v -= 0.1; if (v < 0.0) v = 0.0;
				///////////////////////////////
				HSV2RGB(h, s, v, r, g, b);
				tmp[i][j].r = (GLubyte)(r*255);
				tmp[i][j].g = (GLubyte)(g*255);
				tmp[i][j].b = (GLubyte)(b*255);
				////////////////////////////////////
			}
		}
	}
}

void GetFlowColShock2(cimatrix& cmap, Field& gfield, imatrix& gray, 
			  double sigma, double sigma3, double tau, double z1, double z2) 
// Faster version!
{
	//int	i, j;
	double MAX_DOG = -1.0;
	//int s, t;
	//int x, y;

    int image_x = gray.getRow();
	int image_y = gray.getCol();

	//int half1, half2; // small window and big window
	//int index1, index2; // index for Gaussian matrix
	//double sum1, sum2, w_sum1, w_sum2;

	//////////////////////////////////////////////
	//double factor = 2.0;
	//MakeGaussMatrix(factor, GAU); // factor controls the Gaussian window size for each index
	vector GAU1, GAU2, GAU3;
	MakeGaussVector(sigma, GAU1); // entire inner circle
	MakeGaussVector(sigma*1.6, GAU2); // entire outer circle

	int half_w1, half_w2, half_l;
	half_w1 = GAU1.getMax()-1;
	half_w2 = GAU2.getMax()-1;
	
	//double factor = 3.0;
	//MakeGaussVector(sigma*factor, GAU3); // flow length
	MakeGaussVector(sigma3, GAU3); // flow length
	half_l = GAU3.getMax()-1;
	
	//int half_l = round( half_w1 * factor );

	TRACE("half_w1 = %d\n", half_w1);
	TRACE("half_w2 = %d\n", half_w2);
	TRACE("half_l = %d\n", half_l);

	imatrix sign(image_x, image_y);
	cimatrix tmp(image_x, image_y);
	matrix dog(image_x, image_y);
	//tmp.zero();

	//StartTimer();

	GetFlowShockDoG(gray, gfield, dog, GAU1, GAU2, tau);
	//TRACE("DoG computation ended\n");
	GetFlowShockInfluence(gfield, dog, sign, GAU3);
	//TRACE("Influence computation ended\n");

	//Get1DFlowColShockMinMaxHSV(cmap, gfield, tmp, sign, GAU3, 0.05);
	//Get1DPerpFlowShockMinmaxHSV(tmp, gfield, cmap, sign, GAU2, 0.05);
	Get1DFlowColShockAverageHSV(cmap, gfield, tmp, sign, GAU3, z1, z2);
	//Get1DPerpFlowShockAverageHSV(tmp, gfield, cmap, sign, GAU2, 0.05);
	Get1DPerpFlowShockAverageHSV(tmp, gfield, cmap, sign, GAU1, z1, z2);
	
	/*
	outfile.open("_FShock.txt", ios::app);
	outfile << fixed << setprecision(1);
	outfile << "Elapsed Time2 = " << ElapsedTime() << endl;
	outfile.close();
	
	exit(1);
	*/
}

void GetColMinMaxHSV(cimatrix& cmap, imatrix& lap)
// inspect 5 pixel neighborhood
{
	double r, g, b, h, s, v;
	double max_r, max_g, max_b;
	double min_r, min_g, min_b;
	double min_v, max_v;
	int i, j, x, y;

	int image_x = cmap.getRow();
	int image_y = cmap.getCol();

	cimatrix tmp(image_x, image_y);
	tmp.copy(cmap);

	for (i = 0; i < image_x; i++) {
		for (j = 0; j < image_y; j++) {
			//////////////////////////
			if (lap[i][j] > 0) {
				r = tmp[i][j].r / 255.0;
				g = tmp[i][j].g / 255.0;
				b = tmp[i][j].b / 255.0;
				RGB2HSV(r, g, b, h, s, v);
				max_v = v;
				max_r = r; max_g = g; max_b = b;
				/////////////////////////////////////////////////////
				x = i + 1;	if (x < 0) x = 0; if (x > image_x-1) x = image_x-1;
				y = j;		if (y < 0) y = 0; if (y > image_y-1) y = image_y-1;
				if (lap[x][y] > 0) {
					//////////////////////////////////////////////
					r = tmp[x][y].r / 255.0;
					g = tmp[x][y].g / 255.0;
					b = tmp[x][y].b / 255.0;
					RGB2HSV(r, g, b, h, s, v);
					if (v > max_v) { max_v = v; max_r = r; max_g = g; max_b = b; }
				}
                /////////////////////////////////////////////////////
				x = i - 1;	if (x < 0) x = 0; if (x > image_x-1) x = image_x-1;
				y = j;		if (y < 0) y = 0; if (y > image_y-1) y = image_y-1;
				if (lap[x][y] > 0) {
					r = tmp[x][y].r / 255.0;
					g = tmp[x][y].g / 255.0;
					b = tmp[x][y].b / 255.0;
					RGB2HSV(r, g, b, h, s, v);
					if (v > max_v) { max_v = v; max_r = r; max_g = g; max_b = b; }
				}
				/////////////////////////////////////////////////////
				x = i;	if (x < 0) x = 0; if (x > image_x-1) x = image_x-1;
				y = j + 1;		if (y < 0) y = 0; if (y > image_y-1) y = image_y-1;
				if (lap[x][y] > 0) {
					r = tmp[x][y].r / 255.0;
					g = tmp[x][y].g / 255.0;
					b = tmp[x][y].b / 255.0;
					RGB2HSV(r, g, b, h, s, v);
					if (v > max_v) { max_v = v; max_r = r; max_g = g; max_b = b; }
				}
				/////////////////////////////////////////////////////
				x = i;	if (x < 0) x = 0; if (x > image_x-1) x = image_x-1;
				y = j - 1;		if (y < 0) y = 0; if (y > image_y-1) y = image_y-1;
				if (lap[x][y] > 0) {
					r = tmp[x][y].r / 255.0;
					g = tmp[x][y].g / 255.0;
					b = tmp[x][y].b / 255.0;
					RGB2HSV(r, g, b, h, s, v);
					if (v > max_v) { max_v = v; max_r = r; max_g = g; max_b = b; }
				}
				/////////////////////////////////////////////////////
				cmap[i][j].r = round(max_r * 255.0);
				cmap[i][j].g = round(max_g * 255.0);
				cmap[i][j].b = round(max_b * 255.0);
			}
			///////////////////////////
			/////////////////////////////
			else { // lap[i][j] == 0
				r = tmp[i][j].r / 255.0;
				g = tmp[i][j].g / 255.0;
				b = tmp[i][j].b / 255.0;
				RGB2HSV(r, g, b, h, s, v);
				min_v = v;
				min_r = r; min_g = g; min_b = b;
				/////////////////////////////////////////////////////
				x = i + 1;	if (x < 0) x = 0; if (x > image_x-1) x = image_x-1;
				y = j;		if (y < 0) y = 0; if (y > image_y-1) y = image_y-1;
				if (lap[x][y] == 0) {
					//////////////////////////////////////////////
					r = tmp[x][y].r / 255.0;
					g = tmp[x][y].g / 255.0;
					b = tmp[x][y].b / 255.0;
					RGB2HSV(r, g, b, h, s, v);
					if (v < min_v) { min_v = v; min_r = r; min_g = g; min_b = b; }
				}
                /////////////////////////////////////////////////////
				x = i - 1;	if (x < 0) x = 0; if (x > image_x-1) x = image_x-1;
				y = j;		if (y < 0) y = 0; if (y > image_y-1) y = image_y-1;
				if (lap[x][y] == 0) {
					r = tmp[x][y].r / 255.0;
					g = tmp[x][y].g / 255.0;
					b = tmp[x][y].b / 255.0;
					RGB2HSV(r, g, b, h, s, v);
					if (v < min_v) { min_v = v; min_r = r; min_g = g; min_b = b; }
				}
				/////////////////////////////////////////////////////
				x = i;	if (x < 0) x = 0; if (x > image_x-1) x = image_x-1;
				y = j + 1;		if (y < 0) y = 0; if (y > image_y-1) y = image_y-1;
				if (lap[x][y] == 0) {
					r = tmp[x][y].r / 255.0;
					g = tmp[x][y].g / 255.0;
					b = tmp[x][y].b / 255.0;
					RGB2HSV(r, g, b, h, s, v);
					if (v < min_v) { min_v = v; min_r = r; min_g = g; min_b = b; }
				}
				/////////////////////////////////////////////////////
				x = i;	if (x < 0) x = 0; if (x > image_x-1) x = image_x-1;
				y = j - 1;		if (y < 0) y = 0; if (y > image_y-1) y = image_y-1;
				if (lap[x][y] == 0) {
					r = tmp[x][y].r / 255.0;
					g = tmp[x][y].g / 255.0;
					b = tmp[x][y].b / 255.0;
					RGB2HSV(r, g, b, h, s, v);
					if (v < min_v) { min_v = v; min_r = r; min_g = g; min_b = b; }
				}
				/////////////////////////////////////////////////////
				cmap[i][j].r = round(min_r * 255.0);
				cmap[i][j].g = round(min_g * 255.0);
				cmap[i][j].b = round(min_b * 255.0);
			}

			
		}
	}
	
}

void GetMinMax(imatrix& gray, imatrix& lap)
// gray version
// inspect 5 pixel neighborhood
{
	double min_v, max_v, v;
	int i, j, x, y;

	int image_x = gray.getRow();
	int image_y = gray.getCol();

	imatrix tmp(image_x, image_y);
	tmp.copy(gray);

	max_v = -0.1;
	min_v = 1.1;
	////////////////////////////////////
	for (i = 0; i < image_x; i++) {
		for (j = 0; j < image_y; j++) {
			//////////////////////////
			if (lap[i][j] > 0) {
				v = tmp[i][j] / 255.0;
				max_v = v;
				/////////////////////////////////////////////////////
				x = i + 1;	if (x < 0) x = 0; if (x > image_x-1) x = image_x-1;
				y = j;		if (y < 0) y = 0; if (y > image_y-1) y = image_y-1;
				if (lap[x][y] > 0) {
					//////////////////////////////////////////////
					v = tmp[x][y] / 255.0;
					if (v > max_v) { max_v = v; }
				}
                /////////////////////////////////////////////////////
				x = i - 1;	if (x < 0) x = 0; if (x > image_x-1) x = image_x-1;
				y = j;		if (y < 0) y = 0; if (y > image_y-1) y = image_y-1;
				if (lap[x][y] > 0) {
					//////////////////////////////////////////////
					v = tmp[x][y] / 255.0;
					if (v > max_v) { max_v = v; }
				}
				/////////////////////////////////////////////////////
				x = i;	if (x < 0) x = 0; if (x > image_x-1) x = image_x-1;
				y = j + 1;		if (y < 0) y = 0; if (y > image_y-1) y = image_y-1;
				if (lap[x][y] > 0) {
					//////////////////////////////////////////////
					v = tmp[x][y] / 255.0;
					if (v > max_v) { max_v = v; }
				}
				/////////////////////////////////////////////////////
				x = i;	if (x < 0) x = 0; if (x > image_x-1) x = image_x-1;
				y = j - 1;		if (y < 0) y = 0; if (y > image_y-1) y = image_y-1;
				if (lap[x][y] > 0) {
					//////////////////////////////////////////////
					v = tmp[x][y] / 255.0;
					if (v > max_v) { max_v = v; }
				}
				/////////////////////////////////////////////////////
				gray[i][j] = round(max_v * 255.0);
			}
			///////////////////////////
			/////////////////////////////
			else { // lap[i][j] == 0
				v = tmp[i][j] / 255.0;
				min_v = v;
				/////////////////////////////////////////////////////
				x = i + 1;	if (x < 0) x = 0; if (x > image_x-1) x = image_x-1;
				y = j;		if (y < 0) y = 0; if (y > image_y-1) y = image_y-1;
				if (lap[x][y] == 0) {
					//////////////////////////////////////////////
					v = tmp[x][y] / 255.0;
					if (v < min_v) { min_v = v; }
				}
                /////////////////////////////////////////////////////
				x = i - 1;	if (x < 0) x = 0; if (x > image_x-1) x = image_x-1;
				y = j;		if (y < 0) y = 0; if (y > image_y-1) y = image_y-1;
				if (lap[x][y] == 0) {
					//////////////////////////////////////////////
					v = tmp[x][y] / 255.0;
					if (v < min_v) { min_v = v; }
				}
				/////////////////////////////////////////////////////
				x = i;	if (x < 0) x = 0; if (x > image_x-1) x = image_x-1;
				y = j + 1;		if (y < 0) y = 0; if (y > image_y-1) y = image_y-1;
				if (lap[x][y] == 0) {
					//////////////////////////////////////////////
					v = tmp[x][y] / 255.0;
					if (v < min_v) { min_v = v; }
				}
				/////////////////////////////////////////////////////
				x = i;	if (x < 0) x = 0; if (x > image_x-1) x = image_x-1;
				y = j - 1;		if (y < 0) y = 0; if (y > image_y-1) y = image_y-1;
				if (lap[x][y] == 0) {
					//////////////////////////////////////////////
					v = tmp[x][y] / 255.0;
					if (v < min_v) { min_v = v; }
				}
				/////////////////////////////////////////////////////
				gray[i][j] = round(min_v * 255.0);
			}
		}
	}
	
}


void GetColMinMaxHSV2(cimatrix& cmap, imatrix& lap)
// inspect 3x3 pixel neighborhood
{
	double r, g, b, h, s, v;
	double max_r, max_g, max_b;
	double min_r, min_g, min_b;
	double min_v, max_v;
	int i, j, x, y, t, u;

	int image_x = cmap.getRow();
	int image_y = cmap.getCol();

	cimatrix tmp(image_x, image_y);
	tmp.copy(cmap);

	for (i = 0; i < image_x; i++) {
		for (j = 0; j < image_y; j++) {
			////////////////////////////////
			max_v = -0.1;
			min_v = 1.1;
			//////////////////////////
			for (u = -1; u <= 1; u++) {
				for (t = -1; t <= 1; t++) {
					/////////////////////////
					x = i + u;
					y = j + t;
					if (x < 0) x = 0; if (x > image_x-1) x = image_x-1;
					if (y < 0) y = 0; if (y > image_y-1) y = image_y-1;
					/////////////////////////////////////////
					if (lap[i][j] > 0 && lap[x][y] == 0) continue;
					else if (lap[i][j] == 0 && lap[x][y] > 0) continue;
					////////////////////////////////////////
					r = tmp[x][y].r / 255.0;
					g = tmp[x][y].g / 255.0;
					b = tmp[x][y].b / 255.0;
					RGB2HSV(r, g, b, h, s, v);
					/////////////////////////////////
					if (lap[x][y] > 0) {
						if (v > max_v) { max_v = v; max_r = r; max_g = g; max_b = b; }
					}
					else {
						if (v < min_v) { min_v = v; min_r = r; min_g = g; min_b = b; }
					}
					
				}
			}
			/////////////////////////////////////////////////////
			if (lap[i][j] > 0) {
				cmap[i][j].r = round(max_r * 255.0);
				cmap[i][j].g = round(max_g * 255.0);
				cmap[i][j].b = round(max_b * 255.0);
			}
			else {
				cmap[i][j].r = round(min_r * 255.0);
				cmap[i][j].g = round(min_g * 255.0);
				cmap[i][j].b = round(min_b * 255.0);
			}
			
		}
	}
}

void GetColMaxMin(CDC& dc, cimatrix& cmap, double sigma, int itr) 
// Faster version!
{
	//int	i, j;
	double MAX_DOG = -1.0;

    int image_x = gray.getRow();
	int image_y = gray.getCol();

	//////////////////////////////////////////////
	//imatrix sign(image_x, image_y);
	//cimatrix tmp(image_x, image_y);
	imatrix lap(image_x, image_y);
	imatrix gray(image_x, image_y);
	
	CopyCol2GrayImage(image_x, image_y, cmap, gray); 

	//GetLaplacian2(gray, lap);
	//GetLaplacian3(gray, sigma, lap);
	//GetLaplacian4(gray, sigma, lap);
	double tau = 0.99;
	double thres = 0.5;
	GetLaplacian5(gray, sigma, lap, tau, thres);

	for (int k = 0; k < itr; k++) {
		/////////////////////////////
		/*
		for (int i = 0; i < image_x; i++) {
			for (int j = 0; j < image_y; j++) {
				if (lap[i][j] >= 0) lap[i][j] = 255;
				else lap[i][j] = 0;
			}
		}
		*/
		//GetFlowShockDoG(gray, gfield, dog, GAU1, GAU2, tau);
		//GetFlowShockInfluence(gfield, dog, sign, GAU3);
		GetColMinMaxHSV(cmap, lap);
		//GetColMinMaxHSV2(cmap, lap);
	}

	DrawGrayImage(memDC, image_x, image_y, lap);
	dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
	//CopyGray2Membuffer(lap, Dbuffer);
	//Get1DFlowColShockAverageHSV(cmap, gfield, tmp, sign, GAU3, z1, z2);
	//Get1DPerpFlowShockAverageHSV(tmp, gfield, cmap, sign, GAU1, z1, z2);
}

void GetColMaxMin2(CDC& dc, cimatrix& cmap, double sigma, double tau, int itr) 
// Faster version!
// use tau
{
	//int	i, j;
	double MAX_DOG = -1.0;

    int image_x = gray.getRow();
	int image_y = gray.getCol();

	//////////////////////////////////////////////
	//imatrix sign(image_x, image_y);
	//cimatrix tmp(image_x, image_y);
	imatrix lap(image_x, image_y);
	imatrix gray(image_x, image_y);
	
	CopyCol2GrayImage(image_x, image_y, cmap, gray); 

	//GetLaplacian2(gray, lap);
	//GetLaplacian3(gray, sigma, lap);
	//GetLaplacian4(gray, sigma, lap);
	//double tau = 0.99;
	double thres = 0.2;
	GetLaplacian5(gray, sigma, lap, tau, thres);

	for (int k = 0; k < itr; k++) {
		/////////////////////////////
		/*
		for (int i = 0; i < image_x; i++) {
			for (int j = 0; j < image_y; j++) {
				if (lap[i][j] >= 0) lap[i][j] = 255;
				else lap[i][j] = 0;
			}
		}
		*/
		//GetFlowShockDoG(gray, gfield, dog, GAU1, GAU2, tau);
		//GetFlowShockInfluence(gfield, dog, sign, GAU3);
		GetColMinMaxHSV(cmap, lap);
		//GetColMinMaxHSV2(cmap, lap);
	}

	DrawGrayImage(memDC, image_x, image_y, lap);
	dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
	//CopyGray2Membuffer(lap, Dbuffer);
	//Get1DFlowColShockAverageHSV(cmap, gfield, tmp, sign, GAU3, z1, z2);
	//Get1DPerpFlowShockAverageHSV(tmp, gfield, cmap, sign, GAU1, z1, z2);
}

void GetShockFlow(CDC& dc, imatrix& gray, double sigma, double tau, int itr) 
// non-ETF version
{
	//int	i, j;
	double MAX_DOG = -1.0;

    int image_x = gray.getRow();
	int image_y = gray.getCol();

	//////////////////////////////////////////////
	//imatrix sign(image_x, image_y);
	//cimatrix tmp(image_x, image_y);
	imatrix lap(image_x, image_y);
	//imatrix gray(image_x, image_y);
	
	//CopyCol2GrayImage(image_x, image_y, cmap, gray); 

	//GetLaplacian2(gray, lap);
	//GetLaplacian3(gray, sigma, lap);
	//GetLaplacian4(gray, sigma, lap);
	//double tau = 0.99;
	//double thres = 0.2;
	//double thres = 0.5;
	//GetLaplacian5(gray, sigma, lap, tau, thres);
	GetLaplacian6(gray, sigma, lap, tau);
	
	DrawGrayImage(memDC, image_x, image_y, lap);
	dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);

	for (int k = 0; k < itr; k++) {
		/////////////////////////////
		//GetFlowShockDoG(gray, gfield, dog, GAU1, GAU2, tau);
		//GetFlowShockInfluence(gfield, dog, sign, GAU3);
		//GetColMinMaxHSV(cmap, lap);
		GetMinMax(gray, lap);
		//GetColMinMaxHSV2(cmap, lap);
	}

	
	//CopyGray2Membuffer(lap, Dbuffer);
	//Get1DFlowColShockAverageHSV(cmap, gfield, tmp, sign, GAU3, z1, z2);
	//Get1DPerpFlowShockAverageHSV(tmp, gfield, cmap, sign, GAU1, z1, z2);
}

void GetFlowColMaxMin(CDC& dc, cimatrix& cmap, ETF& e, double sigma, double sigma3, double tau, int itr) 
// Faster version!
// use tau
{
	double MAX_DOG = -1.0;

    int image_x = gray.getRow();
	int image_y = gray.getCol();

	//////////////////////////////////////////////
	//imatrix sign(image_x, image_y);
	//cimatrix tmp(image_x, image_y);
	imatrix lap(image_x, image_y);
	imatrix gray(image_x, image_y);
	
	CopyCol2GrayImage(image_x, image_y, cmap, gray); 

	int	i, j;

    //int image_x = image.getRow();
	//int image_y = image.getCol();

	myvec GAU1, GAU2, GAU3;
	MakeGaussianVector(sigma, GAU1); 
	MakeGaussianVector(sigma*1.6, GAU2); 

	int half_w1, half_w2, half_l;
	half_w1 = GAU1.getMax()-1;
	half_w2 = GAU2.getMax()-1;
	
	MakeGaussianVector(sigma3, GAU3); 
	half_l = GAU3.getMax()-1;
	
	mymatrix tmp(image_x, image_y);
	mymatrix dog(image_x, image_y);

	GetDirectionalDoG(gray, e, dog, GAU1, GAU2, tau);
	GetFlowInfluence(e, dog, tmp, GAU3);

	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			if (tmp[i][j] == 1.0) lap[i][j] = 255;
			else lap[i][j] = 0;
		}
	}
	/*
	GetFlowDoG(e, dog, tmp, GAU3);

	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			image[i][j] = round(tmp[i][j] * 255.);
		}
	}
	*/

	//GetLaplacian2(gray, lap);
	//GetLaplacian3(gray, sigma, lap);
	//GetLaplacian4(gray, sigma, lap);
	//double tau = 0.99;
	//GetLaplacian5(gray, sigma, lap, tau);

	for (int k = 0; k < itr; k++) {
		/////////////////////////////
		/*
		for (int i = 0; i < image_x; i++) {
			for (int j = 0; j < image_y; j++) {
				if (lap[i][j] >= 0) lap[i][j] = 255;
				else lap[i][j] = 0;
			}
		}
		*/
		//GetFlowShockDoG(gray, gfield, dog, GAU1, GAU2, tau);
		//GetFlowShockInfluence(gfield, dog, sign, GAU3);
		GetColMinMaxHSV(cmap, lap);
	}

	DrawGrayImage(memDC, image_x, image_y, lap);
	dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
	//CopyGray2Membuffer(lap, Dbuffer);
	//Get1DFlowColShockAverageHSV(cmap, gfield, tmp, sign, GAU3, z1, z2);
	//Get1DPerpFlowShockAverageHSV(tmp, gfield, cmap, sign, GAU1, z1, z2);
}

void GetColShockWeickert(cimatrix& cmap, Field& gfield, imatrix& gray, 
			  double sigma, double sigma3, double tau, double z1, double z2) 
// Faster version!
{
	//int	i, j;
	double MAX_DOG = -1.0;
	//int s, t;
	//int x, y;

    int image_x = gray.getRow();
	int image_y = gray.getCol();

	//////////////////////////////////////////////
	//double factor = 2.0;
	//MakeGaussMatrix(factor, GAU); // factor controls the Gaussian window size for each index
	vector GAU1, GAU2, GAU3;
	MakeGaussVector(sigma, GAU1); // entire inner circle
	MakeGaussVector(sigma*1.6, GAU2); // entire outer circle

	int half_w1, half_w2, half_l;
	half_w1 = GAU1.getMax()-1;
	half_w2 = GAU2.getMax()-1;
	
	//double factor = 3.0;
	//MakeGaussVector(sigma*factor, GAU3); // flow length
	MakeGaussVector(sigma3, GAU3); // flow length
	half_l = GAU3.getMax()-1;
	
	//int half_l = round( half_w1 * factor );

	TRACE("half_w1 = %d\n", half_w1);
	TRACE("half_w2 = %d\n", half_w2);
	TRACE("half_l = %d\n", half_l);

	imatrix sign(image_x, image_y);
	cimatrix tmp(image_x, image_y);
	matrix dog(image_x, image_y);
	//tmp.zero();

	//StartTimer();

	GetFlowShockDoG(gray, gfield, dog, GAU1, GAU2, 1.0);
	//TRACE("DoG computation ended\n");
	GetFlowShockInfluence(gfield, dog, sign, GAU3);
	//TRACE("Influence computation ended\n");

	//Get1DFlowColShockMinMaxHSV(cmap, gfield, tmp, sign, GAU3, 0.05);
	//Get1DPerpFlowShockMinmaxHSV(tmp, gfield, cmap, sign, GAU2, 0.05);
	Get1DFlowColShockAverageHSV(cmap, gfield, tmp, sign, GAU3, z1, z2);
	//Get1DPerpFlowShockAverageHSV(tmp, gfield, cmap, sign, GAU2, 0.05);
	Get1DPerpFlowShockAverageHSV(tmp, gfield, cmap, sign, GAU1, z1, z2);
	
}

void Get1DFlowColShockMinMaxLAB(cimatrix& cmap, Field& gfield, cimatrix& tmp, imatrix& sign, vector& GAU3, double z)
// following the flow, compute the MinMax
// Faster version!
{
	vector vt(2), vt_old(2);
	double x, y, d_x, d_y;
	//double weight1, w_sum1, sum1;
	//double r, g, b, h, s, v;
	int L;

	int i_x, i_y, k;
	int x1, y1;
	//int x2, y2;
	//double lb, lt, rb, rt;
	//double uu, vv, bb, tt;
	//double val;
	int c_sign;
	deque<int> vec[3];

	int image_x = sign.getRow();
	int image_y = sign.getCol();

	int half_l;
	//half_w1 = GAU1.getMax()-1;
	//half_w2 = GAU2.getMax()-1;
	half_l = GAU3.getMax()-1;
	
	int flow_DOG_sign = 0; 
	
	//double angle, angle_thres1, angle_thres2;
	//angle_thres1 = 90;
	//angle_thres2 = 180 - angle_thres1;

	double step_size, step_size1; 
	//double t;

	step_size = 1.0;
	//step_size = 2.0;
	step_size1 = step_size;

	int i, j;

	for (i = 0; i < image_x; i++) {
		for (j = 0; j < image_y; j++) {
			//sum1 = 0.0;
			//w_sum1 = 0.0;
			//weight1 = 0.0;
			if (sign[i][j] == 1) c_sign = 1;
			else c_sign = 0;
			vec[0].clear();
			vec[1].clear();
			vec[2].clear();
			vec[0].push_back(cmap[i][j].r);
			vec[1].push_back(cmap[i][j].g);
			vec[2].push_back(cmap[i][j].b);
			/////////////////////////////////
			//val = dog[i][j];
			//weight1 = GAU3[0]; 
			//sum1 = val * weight1;
			//w_sum1 += weight1;
			////////////////////////////////////////////////
			// One half
			d_x = (double)i; d_y = (double)j; 
			i_x = i; i_y = j;
			////////////////////////////
			for (k = 0; k < half_l; k++) {
				vt[0] = -gfield[i_x][i_y].gy;
				vt[1] = gfield[i_x][i_y].gx;
				if (vt[0] == 0.0 && vt[1] == 0.0) {
					break;
				}
				vt.make_unit();
				x = d_x;
				y = d_y;
				/////////////////////////////////////////////////////
				if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
					break;
				x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				/////////////////////////////////////////////////////
				if (c_sign) { // non edge region
					if (sign[x1][y1] == 1) {
						vec[0].push_back(cmap[x1][y1].r);
						vec[1].push_back(cmap[x1][y1].g);
						vec[2].push_back(cmap[x1][y1].b);
					}
				}
				else { // edge region
					if (sign[x1][y1] == 0) {
						vec[0].push_back(cmap[x1][y1].r);
						vec[1].push_back(cmap[x1][y1].g);
						vec[2].push_back(cmap[x1][y1].b);
					}
				}
				//val = dog[x1][y1];
				//////////////////////////////
				//weight1 *= GAU3[k]; 
				////////////////////
				//sum1 += val * weight1;
				//w_sum1 += weight1;
				/////////////////////////////////////////
				d_x += vt[0] * step_size1; // accurate new location x
				d_y += vt[1] * step_size1; // accurate new location y
				/////////////////////////////////////////
				i_x = round(d_x); // integer version of new location x
				i_y = round(d_y); // integer version of new location y
				//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
				if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
				/////////////////////////
			}
			////////////////////////////////////////////////
			// Other half
			d_x = (double)i; d_y = (double)j; 
			i_x = i; i_y = j;
			for (k = 0; k < half_l; k++) {
				vt[0] = gfield[i_x][i_y].gy;
				vt[1] = -gfield[i_x][i_y].gx;
				if (vt[0] == 0.0 && vt[1] == 0.0) {
					break;
				}
				vt.make_unit();
				x = d_x;
				y = d_y;
				/////////////////////////////////////////////////////
				if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
					break;
				x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				/////////////////////////////////////////////////////
				if (c_sign) { // non edge region
					if (sign[x1][y1] == 1) {
						vec[0].push_back(cmap[x1][y1].r);
						vec[1].push_back(cmap[x1][y1].g);
						vec[2].push_back(cmap[x1][y1].b);
					}
				}
				else { // edge region
					if (sign[x1][y1] == 0) {
						vec[0].push_back(cmap[x1][y1].r);
						vec[1].push_back(cmap[x1][y1].g);
						vec[2].push_back(cmap[x1][y1].b);
					}
				}
				//val = dog[x1][y1];
				//////////////////////////////
				//weight1 *= GAU3[k]; 
				////////////////////
				//sum1 += val * weight1;
				//w_sum1 += weight1;
				/////////////////////////////////////////
				d_x += vt[0] * step_size1; // accurate new location x
				d_y += vt[1] * step_size1; // accurate new location y
				/////////////////////////////////////////
				i_x = round(d_x); // integer version of new location x
				i_y = round(d_y); // integer version of new location y
				//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
				if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
				/////////////////////////
			}
			//sum1 /= w_sum1; // normalize
			//////////////////////////////////////
			//if (sum1 >= 0) // non edge
			//	sign[i][j] = 1; // non edge
			//else  // edge
			//	sign[i][j] = 0; // edge
			sort(vec[0].begin(), vec[0].end()); 
			sort(vec[1].begin(), vec[1].end()); 
			sort(vec[2].begin(), vec[2].end()); 
			//flow_median = vec[vec.size()/2]; 
			//double z = 0.3;
			//if (vec[0].size() == 0 || vec[1].size() == 0 || vec[2].size() == 0) {
			//	shock_val.r = c_val_r;
			//	shock_val.g = c_val_g;
			//	shock_val.b = c_val_b;
			//	return shock_val; 
			//}
			if (c_sign) { // non edge region
				//tmp[i][j].r = vec[0][vec[0].size()-1]; 
				//tmp[i][j].g = vec[1][vec[1].size()-1]; 
				//tmp[i][j].b = vec[2][vec[2].size()-1]; 
				tmp[i][j].r = vec[0][vec[0].size()/2]; 
				tmp[i][j].g = vec[1][vec[1].size()/2]; 
				tmp[i][j].b = vec[2][vec[2].size()/2]; 
				//tmp[i][j].r = round( (1-z) * vec[0][vec[0].size()/2] + z * 255); 
				//tmp[i][j].g = round( (1-z) * vec[1][vec[1].size()/2] + z * 255); 
				//tmp[i][j].b = round( (1-z) * vec[2][vec[2].size()/2] + z * 255); 
				//image2[i][j] = round( (1-z) * vec[vec.size()-1] + z * 255 ); // brightest value
				//tmp[i][j].r += 15; if (tmp[i][j].r > 255) tmp[i][j].r = 255;
				L = (int)tmp[i][j].r;
				L += 15; if (L > 255) L = 255;
				tmp[i][j].r = (GLubyte)L;
			}
			else {// edge region
				tmp[i][j].r = vec[0][0]; // darkest value
				tmp[i][j].g = vec[1][0];
				tmp[i][j].b = vec[2][0];
				//tmp[i][j].r = round( (1-z) * vec[0][vec[0].size()/2] + z * 0 ); // darkest value
				//tmp[i][j].g = round( (1-z) * vec[1][vec[0].size()/2] + z * 0 ); // darkest value
				//tmp[i][j].b = round( (1-z) * vec[2][vec[0].size()/2] + z * 0 ); // darkest value
				//tmp[i][j].r = round( (1-z) * vec[0][0] + z * 0 ); // darkest value
				//tmp[i][j].g = round( (1-z) * vec[1][0] + z * 0 ); // darkest value
				//tmp[i][j].b = round( (1-z) * vec[2][0] + z * 0 ); // darkest value
				//////////////////////////////////////////
				//tmp[i][j].r -= 3; if (tmp[i][j].r < 0) tmp[i][j].r = 0;
				L = (int)tmp[i][j].r;
				L -= 3; if (L < 0) L = 0;
				tmp[i][j].r = (GLubyte)L;
				////////////////////////////////////
			}
		}
	}
	
}

void Get1DPerpFlowShockMinmaxLAB(cimatrix& cmap, Field& gfield, cimatrix& tmp, imatrix& sign, vector& GAU2, double z)
// For each pixel, compute the directional MinMax in the perpendicular direction to the flow
{
	vector vn(2), vt(2), vt_old(2);
	double x, y, d_x, d_y;
	//double r, g, b, h, s, v;

	int ss;
	int x1, y1;
	int i, j;
	//int x2, y2;
	//double lb, lt, rb, rt;
	//double uu, vv, bb, tt;
	//int dd;
	//double val;
	int L;

	int half_w2;
	//half_w1 = GAU1.getMax()-1;
	half_w2 = GAU2.getMax()-1;

	int image_x, image_y;

	image_x = sign.getRow();
	image_y = sign.getCol();
	
	int c_sign;
	deque<int> vec[3];
	
	////////////////////////////
	for (i = 0; i < image_x; i++) {
		for (j = 0; j < image_y; j++) {
			if (sign[i][j] == 1) c_sign = 1;
			else c_sign = 0;
			vec[0].clear();
			vec[1].clear();
			vec[2].clear();
			vec[0].push_back(cmap[i][j].r);
			vec[1].push_back(cmap[i][j].g);
			vec[2].push_back(cmap[i][j].b);
			
			vn[0] = gfield[i][j].gx;
			vn[1] = gfield[i][j].gy;
			//if (vn[0] == 0.0 && vn[1] == 0.0) {
			//	continue;
			//}
			vn.make_unit();
			d_x = i; d_y = j;
			////////////////////////////////////////
			for (ss = -half_w2; ss <= half_w2; ss++) { // width of Gaussian kernel
				////////////////////////
				x = d_x + vn[0] * ss;
				y = d_y + vn[1] * ss;
				/////////////////////////////////////////////////////
				if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
					continue;
				x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				//val = image[x1][y1];
				/////////////////////////////////////////////////////////
				/////////////////////////////////////////////////////
				if (c_sign) { // non edge region
					if (sign[x1][y1] == 1) {
						vec[0].push_back(cmap[x1][y1].r);
						vec[1].push_back(cmap[x1][y1].g);
						vec[2].push_back(cmap[x1][y1].b);
					}
				}
				else { // edge region
					if (sign[x1][y1] == 0) {
						vec[0].push_back(cmap[x1][y1].r);
						vec[1].push_back(cmap[x1][y1].g);
						vec[2].push_back(cmap[x1][y1].b);
					}
				}
			}
			sort(vec[0].begin(), vec[0].end()); 
			sort(vec[1].begin(), vec[1].end()); 
			sort(vec[2].begin(), vec[2].end()); 
			if (c_sign) { // non edge region
				//tmp[i][j].r = vec[0][vec[0].size()-1]; 
				//tmp[i][j].g = vec[1][vec[1].size()-1]; 
				//tmp[i][j].b = vec[2][vec[2].size()-1]; 
				tmp[i][j].r = vec[0][vec[0].size()/2]; 
				tmp[i][j].g = vec[1][vec[1].size()/2]; 
				tmp[i][j].b = vec[2][vec[2].size()/2]; 
				//tmp[i][j].r = round( (1-z) * vec[0][vec[0].size()/2] + z * 255); 
				//tmp[i][j].g = round( (1-z) * vec[1][vec[1].size()/2] + z * 255); 
				//tmp[i][j].b = round( (1-z) * vec[2][vec[2].size()/2] + z * 255); 
				//image2[i][j] = round( (1-z) * vec[vec.size()-1] + z * 255 ); // brightest value
				//////////////////////////////////////////
				L = (int)tmp[i][j].r;
				L += 15; if (L > 255) L = 255;
				tmp[i][j].r = (GLubyte)L;
				////////////////////////////////////
			}
			else {// edge region
				tmp[i][j].r = vec[0][0]; // darkest value
				tmp[i][j].g = vec[1][0];
				tmp[i][j].b = vec[2][0];
				//tmp[i][j].r = round( (1-z) * vec[0][vec[0].size()/2] + z * 0 ); // darkest value
				//tmp[i][j].g = round( (1-z) * vec[1][vec[0].size()/2] + z * 0 ); // darkest value
				//tmp[i][j].b = round( (1-z) * vec[2][vec[0].size()/2] + z * 0 ); // darkest value
				//tmp[i][j].r = round( (1-z) * vec[0][0] + z * 0 ); // darkest value
				//tmp[i][j].g = round( (1-z) * vec[1][0] + z * 0 ); // darkest value
				//tmp[i][j].b = round( (1-z) * vec[2][0] + z * 0 ); // darkest value
				//////////////////////////////////////////
				L = (int)tmp[i][j].r;
				L -= 3; if (L < 0) L = 0;
				tmp[i][j].r = (GLubyte)L;
				////////////////////////////////////
			}
		}
	}

}

void GetFlowColShock3(cimatrix& cmap, Field& gfield, imatrix& gray, 
			  double sigma, double sigma3, double tau, int half, double z) 
// Faster version!
{
	//int	i, j;
	double MAX_DOG = -1.0;
	//int s, t;
	//int x, y;

    int image_x = gray.getRow();
	int image_y = gray.getCol();

	//int half1, half2; // small window and big window
	//int index1, index2; // index for Gaussian matrix
	//double sum1, sum2, w_sum1, w_sum2;

	//////////////////////////////////////////////
	//double factor = 2.0;
	//MakeGaussMatrix(factor, GAU); // factor controls the Gaussian window size for each index
	vector GAU1, GAU2, GAU3;
	MakeGaussVector(sigma, GAU1); // entire inner circle
	MakeGaussVector(sigma*1.6, GAU2); // entire outer circle

	int half_w1, half_w2, half_l;
	half_w1 = GAU1.getMax()-1;
	half_w2 = GAU2.getMax()-1;
	
	//double factor = 3.0;
	//MakeGaussVector(sigma*factor, GAU3); // flow length
	MakeGaussVector(sigma3, GAU3); // flow length
	half_l = GAU3.getMax()-1;
	
	//int half_l = round( half_w1 * factor );

	TRACE("half_w1 = %d\n", half_w1);
	TRACE("half_w2 = %d\n", half_w2);
	TRACE("half_l = %d\n", half_l);

	imatrix sign(image_x, image_y);
	cimatrix tmp(image_x, image_y);
	matrix dog(image_x, image_y);
	//tmp.zero();

	GetFlowShockDoG(gray, gfield, dog, GAU1, GAU2, tau);
	//TRACE("DoG computation ended\n");
	GetFlowShockInfluence(gfield, dog, sign, GAU3);
	//TRACE("Influence computation ended\n");

	//Get1DFlowColShockMinMax(cmap, gfield, tmp, sign, GAU3, 0.05);
	//Get1DPerpFlowShockMinmax(tmp, gfield, cmap, sign, GAU2, 0.05);
	Get1DFlowColShockMinMaxLAB(cmap, gfield, tmp, sign, GAU3, 0.05);
	Get1DPerpFlowShockMinmaxLAB(tmp, gfield, cmap, sign, GAU2, 0.05);
}

void GetPointFlowColShock(int i, int j, cimatrix& cmap, Field& gfield, cimatrix& tmp, 
						  vector& GAU1, vector& GAU2, vector& GAU3, imatrix& sign, double z)
{
	vector vn(2), vt(2), vt_old(2);
	double x, y, d_x, d_y;
	//double weight1, weight2, w_sum1, sum1, sum2, w_sum2;

	int s, i_x, i_y, k;
	int x1, y1;
	//int x2, y2;
	//double lb, lt, rb, rt;
	//double uu, vv, bb, tt;
	//double val_r, val_g, val_b;
	GLubyte c_val_r, c_val_g, c_val_b;

	int half_w1, half_w2, half_l;
	half_w1 = GAU1.getMax()-1;
	half_w2 = GAU2.getMax()-1;
	half_l = GAU3.getMax()-1;
	
	//double shock_val = 0.0; // flow-based gradient magnitude

	///////////////////////////
	deque<int> vec[3];
	vec[0].clear();
	vec[1].clear();
	vec[2].clear();

	int c_sign;

	if (sign[i][j] == 1) c_sign = 1;
	else c_sign = 0;

	//iRGB shock_val;
		
	//double angle, angle_thres1, angle_thres2;
	//angle_thres1 = 90;
	//angle_thres2 = 180 - angle_thres1;

	double step_size, step_size1; 
	//double t;

	step_size = 1.0;
	//step_size = 2.0;
	step_size1 = step_size;
	/////////////////////////////////////////////////
	// INSIDE and OUTSIDE FLOW DOG
	////////////////////////////////////
	//count = 0; // number of pixels traversed
	////////////////////////////////////////////////
	// One half
	d_x = (double)i; d_y = (double)j; 
	i_x = i; i_y = j;
	//////////////////////////
	c_val_r = cmap[i_x][i_y].r;
	c_val_g = cmap[i_x][i_y].g;
	c_val_b = cmap[i_x][i_y].b;
	vec[0].push_back(c_val_r);
	vec[1].push_back(c_val_g);
	vec[2].push_back(c_val_b);
	////////////////////////////
	for (k = 0; k < half_l; k++) {
		vn[0] = gfield[i_x][i_y].gx;
		vn[1] = gfield[i_x][i_y].gy;
		if (vn[0] == 0.0 && vn[1] == 0.0) break;
		vn.make_unit();
		vt[0] = -gfield[i_x][i_y].gy;
		vt[1] = gfield[i_x][i_y].gx;
		vt.make_unit();
		////////////////////////////////////////
		for (s = -half_w2; s <= half_w2; s++) { // width of Gaussian kernel
			////////////////////////
			x = d_x + vn[0] * s;
			y = d_y + vn[1] * s;
			/////////////////////////////////////////////////////
			if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
				continue;
			x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
			y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
			//val = image[x1][y1];
			/////////////////////////////////////////////////////////
			if (c_sign) { // non edge region
				if (sign[x1][y1] == 1) {
					vec[0].push_back(cmap[x1][y1].r);
					vec[1].push_back(cmap[x1][y1].g);
					vec[2].push_back(cmap[x1][y1].b);
				}
			}
			else { // edge region
				if (sign[x1][y1] == 0) {
					vec[0].push_back(cmap[x1][y1].r);
					vec[1].push_back(cmap[x1][y1].g);
					vec[2].push_back(cmap[x1][y1].b);
				}
			}
		}
		/////////////////////////////////////////
		d_x += vt[0] * step_size1; // accurate new location x
		d_y += vt[1] * step_size1; // accurate new location y
		/////////////////////////////////////////
		i_x = round(d_x); // integer version of new location x
		i_y = round(d_y); // integer version of new location y
		//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
		/////////////////////////
	}
	////////////////////////////////////////////////
	// Other half
	d_x = (double)i; d_y = (double)j; 
	i_x = i; i_y = j;
	for (k = 0; k < half_l; k++) {
		vn[0] = gfield[i_x][i_y].gx;
		vn[1] = gfield[i_x][i_y].gy;
		if (vn[0] == 0.0 && vn[1] == 0.0) break;
		vn.make_unit();
		vt[0] = gfield[i_x][i_y].gy;
		vt[1] = -gfield[i_x][i_y].gx;
		vt.make_unit();
		////////////////////////////////////
		for (s = -half_w2; s <= half_w2; s++) { // width of Gaussian kernel
			////////////////////////
			x = d_x + vn[0] * s;
			y = d_y + vn[1] * s;
			/////////////////////////////////////////////////////
			if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
				continue;
			x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
			y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
			//val = image[x1][y1];
			/////////////////////////////////////////////////////////
			/////////////////////////////////////////////////////////
			if (c_sign) { // non edge region
				if (sign[x1][y1] == 1) {
					vec[0].push_back(cmap[x1][y1].r);
					vec[1].push_back(cmap[x1][y1].g);
					vec[2].push_back(cmap[x1][y1].b);
				}
			}
			else { // edge region
				if (sign[x1][y1] == 0) {
					vec[0].push_back(cmap[x1][y1].r);
					vec[1].push_back(cmap[x1][y1].g);
					vec[2].push_back(cmap[x1][y1].b);
				}
			}
		}
		/////////////////////////////////////////
		d_x += vt[0] * step_size1; // accurate new location x
		d_y += vt[1] * step_size1; // accurate new location y
		/////////////////////////////////////////
		i_x = round(d_x); // integer version of new location x
		i_y = round(d_y); // integer version of new location y
		//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
		/////////////////////////
	}
	//sum1 /= w_sum1; // normalize
	//sum2 /= w_sum2; // normalize
	sort(vec[0].begin(), vec[0].end()); 
	sort(vec[1].begin(), vec[1].end()); 
	sort(vec[2].begin(), vec[2].end()); 
	//flow_median = vec[vec.size()/2]; 
	//double z = 0.3;
	//if (vec[0].size() == 0 || vec[1].size() == 0 || vec[2].size() == 0) {
	//	shock_val.r = c_val_r;
	//	shock_val.g = c_val_g;
	//	shock_val.b = c_val_b;
	//	return shock_val; 
	//}
	if (c_sign) { // non edge region
		//tmp[i][j].r = vec[0][vec[0].size()-1]; 
		//tmp[i][j].g = vec[1][vec[1].size()-1]; 
		//tmp[i][j].b = vec[2][vec[2].size()-1]; 
		tmp[i][j].r = vec[0][vec[0].size()/2]; 
		tmp[i][j].g = vec[1][vec[1].size()/2]; 
		tmp[i][j].b = vec[2][vec[2].size()/2]; 
		//tmp[i][j].r = round( (1-z) * vec[0][vec[0].size()/2] + z * 255); 
		//tmp[i][j].g = round( (1-z) * vec[1][vec[1].size()/2] + z * 255); 
		//tmp[i][j].b = round( (1-z) * vec[2][vec[2].size()/2] + z * 255); 
		//image2[i][j] = round( (1-z) * vec[vec.size()-1] + z * 255 ); // brightest value
	}
	else {// edge region
		//image2[i][j] = vec[0]; 
		tmp[i][j].r = round( (1-z) * vec[0][0] + z * 0 ); // darkest value
		tmp[i][j].g = round( (1-z) * vec[1][0] + z * 0 ); // darkest value
		tmp[i][j].b = round( (1-z) * vec[2][0] + z * 0 ); // darkest value
	}
	////////////////////////////////////////////////////
	//return shock_val;
}

double GetPointFlowShock3(int i, int j, imatrix& image, Field& gfield, 
							vector& GAU1, vector& GAU2, vector& GAU3, imatrix& sign)
// following the flow, Gaussian sum the signed values
{
	vector vn(2), vt(2), vt_old(2);
	double x, y, d_x, d_y;
	double weight1, weight2, w_sum1, sum1, sum2, w_sum2;

	int s, i_x, i_y, k;
	int x1, y1;
	//int x2, y2;
	//double lb, lt, rb, rt;
	//double uu, vv, bb, tt;
	double val, c_val;
	int dd;

	int half_w1, half_w2, half_l;
	half_w1 = GAU1.getMax()-1;
	half_w2 = GAU2.getMax()-1;
	half_l = GAU3.getMax()-1;
	
	double shock_val = 0.0; // flow-based gradient magnitude

	///////////////////////////
	//deque<int> vec;
	//vec.clear();

	int c_sign;

	if (sign[i][j] == 1) c_sign = 1;
	else c_sign = 0;
		
	//double angle, angle_thres1, angle_thres2;
	//angle_thres1 = 90;
	//angle_thres2 = 180 - angle_thres1;

	double step_size, step_size1; 
	//double t;

	step_size = 1.0;
	//step_size = 2.0;
	step_size1 = step_size;
	/////////////////////////////////////////////////
	// INSIDE and OUTSIDE FLOW DOG
	////////////////////////////////////
	//count = 0; // number of pixels traversed
	sum1 = sum2 = 0.0;
	w_sum1 = w_sum2 = 0.0;
	weight1 = weight2 = 0.0;
	////////////////////////////////////////////////
	// One half
	d_x = (double)i; d_y = (double)j; 
	i_x = i; i_y = j;
	//////////////////////////
	c_val = image[i_x][i_y];
	weight1 = GAU1[0];
	weight1 *= GAU3[0];
	sum1 += c_val * weight1;
	w_sum1 += weight1;
	////////////////////////////
	for (k = 0; k < half_l; k++) {
		vn[0] = gfield[i_x][i_y].gx;
		vn[1] = gfield[i_x][i_y].gy;
		if (vn[0] == 0.0 && vn[1] == 0.0) break;
		vn.make_unit();
		vt[0] = -gfield[i_x][i_y].gy;
		vt[1] = gfield[i_x][i_y].gx;
		vt.make_unit();
		////////////////////////////////////////
		for (s = -half_w2; s <= half_w2; s++) { // width of Gaussian kernel
			////////////////////////
			x = d_x + vn[0] * s;
			y = d_y + vn[1] * s;
			/////////////////////////////////////////////////////
			if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
				continue;
			x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
			y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
			val = image[x1][y1];
			/////////////////////////////////////////////////////////
			dd = ABS(s);
			if (dd > half_w1) weight1 = 0.0;
			else if (c_sign) { // non edge region
                if (sign[x1][y1] == 1) weight1 = GAU1[dd];
				else weight1 = 0.0;
			}
			else { // edge region
				if (sign[x1][y1] == 0) weight1 = GAU1[dd];
				else weight1 = 0.0;
			}
			//////////////////////////////////
			// The following Gaussian smoothing along main axis is essential for good quality!
			weight1 *= GAU3[k]; 
			////////////////////
			sum1 += val * weight1;
			w_sum1 += weight1;
			//d3 = round( ABS(val - c_val) );
			/////////////////////////////////////////////////////
		}
		/////////////////////////////////////////
		d_x += vt[0] * step_size1; // accurate new location x
		d_y += vt[1] * step_size1; // accurate new location y
		/////////////////////////////////////////
		i_x = round(d_x); // integer version of new location x
		i_y = round(d_y); // integer version of new location y
		//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
		/////////////////////////
	}
	////////////////////////////////////////////////
	// Other half
	d_x = (double)i; d_y = (double)j; 
	i_x = i; i_y = j;
	for (k = 0; k < half_l; k++) {
		vn[0] = gfield[i_x][i_y].gx;
		vn[1] = gfield[i_x][i_y].gy;
		if (vn[0] == 0.0 && vn[1] == 0.0) break;
		vn.make_unit();
		vt[0] = gfield[i_x][i_y].gy;
		vt[1] = -gfield[i_x][i_y].gx;
		vt.make_unit();
		////////////////////////////////////
		for (s = -half_w2; s <= half_w2; s++) { // width of Gaussian kernel
			////////////////////////
			x = d_x + vn[0] * s;
			y = d_y + vn[1] * s;
			/////////////////////////////////////////////////////
			if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
				continue;
			x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
			y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
			val = image[x1][y1];
			/////////////////////////////////////////////////////////
			dd = ABS(s);
			if (dd > half_w1) weight1 = 0.0;
			else if (c_sign) { // non edge region
                if (sign[x1][y1] == 1) weight1 = GAU1[dd];
				else weight1 = 0.0;
			}
			else { // edge region
				if (sign[x1][y1] == 0) weight1 = GAU1[dd];
				else weight1 = 0.0;
			}
			//////////////////////////////////
			// The following Gaussian smoothing along main axis is essential for good quality!
			weight1 *= GAU3[k]; 
			////////////////////
			sum1 += val * weight1;
			w_sum1 += weight1;
			//d3 = round( ABS(val - c_val) );
			/////////////////////////////////////////////////////
		}
		/////////////////////////////////////////
		d_x += vt[0] * step_size1; // accurate new location x
		d_y += vt[1] * step_size1; // accurate new location y
		/////////////////////////////////////////
		i_x = round(d_x); // integer version of new location x
		i_y = round(d_y); // integer version of new location y
		//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
		/////////////////////////
	}
	sum1 /= w_sum1; // normalize
	//sum2 /= w_sum2; // normalize
	//sort(vec.begin(), vec.end()); 
	//flow_median = vec[vec.size()/2]; 
	double z = 0.3;
	if (c_sign) // non edge region
		//shock_val = vec[vec.size()-1]; 
		//shock_val = sum1;
		shock_val = sum1;
		//image2[i][j] = round( (1-z) * vec[vec.size()-1] + z * 255 ); // brightest value
	else // edge region
		//image2[i][j] = vec[0]; 
		shock_val = round( (1-z) * sum1 + z * 0 ); // darkest value
		//shock_val = sum1;
	////////////////////////////////////////////////////
	return shock_val;
}

void GetFlowShock(imatrix& image, Field& gfield, imatrix& image2, matrix& G_mag, 
			  double sigma, double sigma3, double tau, double z) 
// Flow DOG
{
	int	i, j;
	double MAX_DOG = -1.0;
	//int s, t;
	//int x, y;

    int image_x = image.getRow();
	int image_y = image.getCol();

	//int half1, half2; // small window and big window
	//int index1, index2; // index for Gaussian matrix
	//double sum1, sum2, w_sum1, w_sum2;

	//////////////////////////////////////////////
	//double factor = 2.0;
	//MakeGaussMatrix(factor, GAU); // factor controls the Gaussian window size for each index
	vector GAU1, GAU2, GAU3;
	MakeGaussVector(sigma, GAU1); // entire inner circle
	MakeGaussVector(sigma*1.6, GAU2); // entire outer circle

	int half_w1, half_w2, half_l;
	half_w1 = GAU1.getMax()-1;
	half_w2 = GAU2.getMax()-1;
	
	//double factor = 3.0;
	//MakeGaussVector(sigma*factor, GAU3); // flow length
	MakeGaussVector(sigma3, GAU3); // flow length
	half_l = GAU3.getMax()-1;
	
	//int half_l = round( half_w1 * factor );

	TRACE("half_w1 = %d\n", half_w1);
	TRACE("half_w2 = %d\n", half_w2);
	TRACE("half_l = %d\n", half_l);

	imatrix sign(image_x, image_y);
	matrix tmp(image_x, image_y);
	//tmp.zero();

	//StartTimer();
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//index = gray2[i][j];
			//tmp[i][j] = GetPointFlowDOG(i, j, image, gfield, GAU1, GAU2, tau);
			//tmp[i][j] = GetPointFlowDOG3(i, j, image, gfield, GAU1, GAU2, GAU3, tau);
			sign[i][j] = GetPointFlowShock(i, j, gray, gfield, GAU1, GAU2, GAU3, tau);
			tmp[i][j] = GetPointFlowShock2(i, j, image, gfield, GAU1, GAU2, GAU3, sign, z);
			//tmp[i][j] = GetPointFlowShock3(i, j, image, gfield, GAU1, GAU2, GAU3, sign);
		}
	}
	//TRACE("Elapsed Time = %f\n", ElapsedTime());
	////////////////////////////////////////////

	// Normalize DOG value (not necessary! - MAX_DOG is always 1)
	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			//TRACE("p[%d][%d].mag = %0.3f\n", i, j, p[i][j].mag);
			//tmp[i][j] = tmp[i][j] / MAX_DOG; // place it between [0, 1]
			//G_mag[i][j] = 1-tmp[i][j]; // used for nonmaxima suppression
			//TRACE("G_mag[%d][%d] = %.1f\n", i, j, G_mag[i][j]);
			//TRACE("tmp[%d][%d] = %0.3f\n", i, j, tmp[i][j]);
			//TRACE("G_mag[%d][%d] = %0.3f\n", i, j, G_mag[i][j]);
			if (tmp[i][j] < 0)
				TRACE("tmp[%d][%d] = %0.2f\n", i, j, tmp[i][j]);
			//image2[i][j] = round(tmp[i][j] * 255.);
			image2[i][j] = round(tmp[i][j]);
			//image2[i][j] = 255 - round(tmp[i][j] * 255.);
		}
	}
}

void GetFlowColShock(cimatrix& cmap, Field& gfield, imatrix& gray, 
			  double sigma, double sigma3, double tau, double z) 
// Flow DOG
{
	int	i, j;
	double MAX_DOG = -1.0;
	//int s, t;
	//int x, y;

    int image_x = gray.getRow();
	int image_y = gray.getCol();

	//int half1, half2; // small window and big window
	//int index1, index2; // index for Gaussian matrix
	//double sum1, sum2, w_sum1, w_sum2;

	//////////////////////////////////////////////
	//double factor = 2.0;
	//MakeGaussMatrix(factor, GAU); // factor controls the Gaussian window size for each index
	vector GAU1, GAU2, GAU3;
	MakeGaussVector(sigma, GAU1); // entire inner circle
	MakeGaussVector(sigma*1.6, GAU2); // entire outer circle

	int half_w1, half_w2, half_l;
	half_w1 = GAU1.getMax()-1;
	half_w2 = GAU2.getMax()-1;
	
	//double factor = 3.0;
	//MakeGaussVector(sigma*factor, GAU3); // flow length
	MakeGaussVector(sigma3, GAU3); // flow length
	half_l = GAU3.getMax()-1;
	
	//int half_l = round( half_w1 * factor );

	TRACE("half_w1 = %d\n", half_w1);
	TRACE("half_w2 = %d\n", half_w2);
	TRACE("half_l = %d\n", half_l);

	imatrix sign(image_x, image_y);
	cimatrix tmp(image_x, image_y);
	//tmp.zero();

	//StartTimer();
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//index = gray2[i][j];
			//tmp[i][j] = GetPointFlowDOG(i, j, image, gfield, GAU1, GAU2, tau);
			//tmp[i][j] = GetPointFlowDOG3(i, j, image, gfield, GAU1, GAU2, GAU3, tau);
			sign[i][j] = GetPointFlowShock(i, j, gray, gfield, GAU1, GAU2, GAU3, tau);
			//tmp[i][j] = GetPointFlowShock2(i, j, image, gfield, GAU1, GAU2, GAU3, sign, z);
			GetPointFlowColShock(i, j, cmap, gfield, tmp, GAU1, GAU2, GAU3, sign, z);
			//tmp[i][j] = GetPointFlowShock3(i, j, image, gfield, GAU1, GAU2, GAU3, sign);
		}
	}
	//TRACE("Elapsed Time = %f\n", ElapsedTime());
	////////////////////////////////////////////

	// Normalize DOG value (not necessary! - MAX_DOG is always 1)
	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			//if (tmp[i][j] < 0)
			//	TRACE("tmp[%d][%d] = %0.2f\n", i, j, tmp[i][j]);
			//image2[i][j] = round(tmp[i][j] * 255.);
			cmap[i][j].r = tmp[i][j].r;
			cmap[i][j].g = tmp[i][j].g;
			cmap[i][j].b = tmp[i][j].b;
			//image2[i][j] = 255 - round(tmp[i][j] * 255.);
		}
	}
}

void GetDOG4(imatrix& image, matrix& G_mag, imatrix& image2, double sigma, double tau, double phi) 
// Here we use one more parameter (phi), for controlling the sharpness of edge
// Find the two indexes from sigma!
// G_mag gets the actual real values in [0, 1]
// image2 gets the integer values in [0, 255]
{
	int	i, j, k;
	double MAX_DOG = -1.0;
	int s, t;
	int x, y;

	int image_x = image.getRow();
	int image_y = image.getCol();

	int half1, half2; // small window and big window
	//int index1, index2; // index for Gaussian matrix
	double sum1, sum2, w_sum1, w_sum2;

	//////////////////////////////////
	//Make2DGaussMask(sigma); // mask for unilateral filtering

	//N = gau_mask.getRow();
	//half = N / 2;

	//ClearMemDC(&dc); // clear the canvas white
	//////////////////////////////////////////////
	//double factor = 2.0;
	//MakeGaussMatrix(factor, GAU); // factor controls the Gaussian window size for each index
	vector GAU1, GAU2;
	MakeGaussVector(sigma, GAU1);
	MakeGaussVector(sigma*1.6, GAU2);
	half1 = GAU1.getMax()-1;
	half2 = GAU2.getMax()-1;

	////////////////////////////////////////////////////////
	matrix tmp(image_x, image_y);
	//tmp.zero();
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//index = gray2[i][j];
			sum1 = 0;
			w_sum1 = 0.0;
			//half1 = GAU_W[index1]-1;
			//half = 8;
			//TRACE("GAU_W_1[%d] = %d\n", index1, GAU_W[index1]);
			for (s = -half1; s <= half1; s++) {
				for (t = -half1; t <= half1; t++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					//k = round( dist2(x, y, i, j) );
					if ( k > half1 ) continue; 
					/////////////////////////////////////////////////////
					sum1 += image[x][y] * GAU1[k];
					w_sum1 += GAU1[k];
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			sum1 /= w_sum1; 
			//TRACE("w_sum = %.6f\n", w_sum);
			//////////////////////////////////////////////
			sum2 = 0;
			w_sum2 = 0.0;
			//half2 = GAU_W[index2]-1;
			//half2 = GAU1.getMax()-1; // Now this was a big mistake!!!
			//TRACE("GAU_W_2[%d] = %d\n", index2, GAU_W[index2]);
			for (s = -half2; s <= half2; s++) {
				for (t = -half2; t <= half2; t++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					//k = round( dist2(x, y, i, j) );
					//if ( k > half1 ) continue; 
					if ( k > half2 ) continue; 
					/////////////////////////////////////////////////////
					sum2 += image[x][y] * GAU2[k];
					w_sum2 += GAU2[k];
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			//TRACE("w_sum = %.6f\n", w_sum);
			sum2 /= w_sum2; 
			//////////////////////////////
			/*
			// to incorporate both sides of the edge!
			if (sum1 - sum2 > 0) // non edge
				tmp[i][j] = ( 1.0 - tanh(sum1 - sum2) ); // [0, 1]
			else
				tmp[i][j] = 1.0 + tanh(sum1 - sum2); // [ 0, 1 ]
			*/
			///* handle only one side of the edge!
			//TRACE("sum1 = %f\n", sum1);
			//TRACE("sum2 = %f\n", sum2);
			//TRACE("sum1 - tau * sum2 = %f\n", sum1 - tau * sum2);
			/////////////////////////////////////////
			// POSITIVE INNTER CIRCLE
			if (sum1 - tau * sum2 > 0) // non edge
				tmp[i][j] = 1.0;
			else
				//tmp[i][j] = 1.0 + tanh(sum1 - tau * sum2); // [ 0, 1 ]
				tmp[i][j] = 1.0 + tanh( phi * (sum1 - tau * sum2) ); // [ 0, 1 ]
				//tmp[i][j] = 1.0 + tanh( (sum1 - tau * sum2)/10 ); // make it darker!
			///////////////////////////////////////////
			// POSITIVE INNTER CIRCLE (opposite)
			/*
			if (sum1 - tau * sum2 < 0) // non edge
				tmp[i][j] = 1.0;
			else
				tmp[i][j] = -1.0 + tanh(sum1 - tau * sum2); // [ 0, 1 ]
				//tmp[i][j] = 1.0 + tanh( (sum1 - tau * sum2)/10 ); // make it darker!
			*/	
			////////////////////////////////////
			// NEGATIVE INNTER CIRCLE
			/*
			if (-sum1 + tau * sum2 > 0) // non edge
				tmp[i][j] = 1.0;
			else
				tmp[i][j] = 1.0 + tanh(-sum1 + tau * sum2); // [ 0, 1 ]
				//tmp[i][j] = 1.0 + tanh( (sum1 - tau * sum2)/10 ); // make it darker!
			*/
			//if (tmp[i][j] > MAX_DOG) MAX_DOG = tmp[i][j];
		}
	}
	////////////////////////////////////////////

	// Normalize DOG value (not necessary! - MAX_DOG is always 1)
	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			//TRACE("p[%d][%d].mag = %0.3f\n", i, j, p[i][j].mag);
			//tmp[i][j] = tmp[i][j] / MAX_DOG; // place it between [0, 1]
			//////////////////////////////////////////////////
			G_mag[i][j] = 1-tmp[i][j]; // [0, 1] used for nonmaxima suppression
			// the higher, the stronger the edgeness!
			///////////////////////////////////////////////////
			//TRACE("G_mag[%d][%d] = %.1f\n", i, j, G_mag[i][j]);
			//TRACE("tmp[%d][%d] = %0.3f\n", i, j, tmp[i][j]);
			//TRACE("G_mag[%d][%d] = %0.3f\n", i, j, G_mag[i][j]);
			if (tmp[i][j] < 0)
				TRACE("tmp[%d][%d] = %0.2f\n", i, j, tmp[i][j]);
			image2[i][j] = round(tmp[i][j] * 255.);
			//image2[i][j] = 255 - round(tmp[i][j] * 255.);
		}
	}
}

void GetDOG3(imatrix& image, matrix& G_mag, imatrix& image2, double sigma, double tau) 
// Difference of Gaussians, but valleys (instead of ridges) are extracted!
{
	int	i, j, k;
	double MAX_DOG = -1.0;
	int s, t;
	int x, y;

	int image_x = image.getRow();
	int image_y = image.getCol();

	int half1, half2; // small window and big window
	//int index1, index2; // index for Gaussian matrix
	double sum1, sum2, w_sum1, w_sum2;

	//////////////////////////////////
	//Make2DGaussMask(sigma); // mask for unilateral filtering

	//N = gau_mask.getRow();
	//half = N / 2;

	//ClearMemDC(&dc); // clear the canvas white
	//////////////////////////////////////////////
	//double factor = 2.0;
	//MakeGaussMatrix(factor, GAU); // factor controls the Gaussian window size for each index
	vector GAU1, GAU2;
	MakeGaussVector(sigma, GAU1);
	MakeGaussVector(sigma*1.6, GAU2);

	////////////////////////////////////////////////////////
	matrix tmp(image_x, image_y);
	//tmp.zero();

	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//index = gray2[i][j];
			sum1 = 0;
			w_sum1 = 0.0;
			//half1 = GAU_W[index1]-1;
			half1 = GAU1.getMax()-1;
			//half = 8;
			//TRACE("GAU_W_1[%d] = %d\n", index1, GAU_W[index1]);
			for (s = -half1; s <= half1; s++) {
				for (t = -half1; t <= half1; t++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					//k = round( dist2(x, y, i, j) );
					if ( k > half1 ) continue; 
					/////////////////////////////////////////////////////
					sum1 += image[x][y] * GAU1[k];
					w_sum1 += GAU1[k];
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			sum1 /= w_sum1; 
			//TRACE("w_sum = %.6f\n", w_sum);
			//////////////////////////////////////////////
			sum2 = 0;
			w_sum2 = 0.0;
			//half2 = GAU_W[index2]-1;
			//half2 = GAU1.getMax()-1; // Now this was a big mistake!!!
			half2 = GAU2.getMax()-1;
			//TRACE("GAU_W_2[%d] = %d\n", index2, GAU_W[index2]);
			for (s = -half2; s <= half2; s++) {
				for (t = -half2; t <= half2; t++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					//k = round( dist2(x, y, i, j) );
					//if ( k > half1 ) continue; 
					if ( k > half2 ) continue; 
					/////////////////////////////////////////////////////
					sum2 += image[x][y] * GAU2[k];
					w_sum2 += GAU2[k];
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			//TRACE("w_sum = %.6f\n", w_sum);
			sum2 /= w_sum2; 
			//////////////////////////////
			/*
			// to incorporate both sides of the edge!
			if (sum1 - sum2 > 0) // non edge
				tmp[i][j] = ( 1.0 - tanh(sum1 - sum2) ); // [0, 1]
			else
				tmp[i][j] = 1.0 + tanh(sum1 - sum2); // [ 0, 1 ]
			*/
			///* handle only one side of the edge!
			//TRACE("sum1 = %f\n", sum1);
			//TRACE("sum2 = %f\n", sum2);
			//TRACE("sum1 - tau * sum2 = %f\n", sum1 - tau * sum2);
			/////////////////////////////////////////
			// NEGATIVE INNTER CIRCLE BECOMES EDGES
			/*
			if (sum1 - tau * sum2 > 0) // non edge
				tmp[i][j] = 1.0;
			else
				tmp[i][j] = 1.0 + tanh(sum1 - tau * sum2); // [ 0, 1 ]
				//tmp[i][j] = 1.0 + tanh( (sum1 - tau * sum2)/10 ); // make it darker!
			*/
			///////////////////////////////////////////
			// POSITIVE INNTER CIRCLE (opposite) BECOMES EDGES
			///*
			if (tau * sum1 - sum2 < 0) // non edge
				tmp[i][j] = 1.0;
			else
				tmp[i][j] = 1.0 - tanh(tau * sum1 - sum2); // [ 0, 1 ]
			//*/	
			////////////////////////////////////
			// NEGATIVE INNTER CIRCLE
			/*
			if (-sum1 + tau * sum2 > 0) // non edge
				tmp[i][j] = 1.0;
			else
				tmp[i][j] = 1.0 + tanh(-sum1 + tau * sum2); // [ 0, 1 ]
				//tmp[i][j] = 1.0 + tanh( (sum1 - tau * sum2)/10 ); // make it darker!
			*/
		}
	}
	////////////////////////////////////////////

	// Normalize DOG value (not necessary! - MAX_DOG is always 1)
	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			//TRACE("p[%d][%d].mag = %0.3f\n", i, j, p[i][j].mag);
			//tmp[i][j] = tmp[i][j] / MAX_DOG; // place it between [0, 1]
			//////////////////////////////////////////////////
			G_mag[i][j] = 1-tmp[i][j]; // [0, 1] used for nonmaxima suppression
			// the higher, the stronger the edgeness!
			///////////////////////////////////////////////////
			//TRACE("G_mag[%d][%d] = %.1f\n", i, j, G_mag[i][j]);
			//TRACE("tmp[%d][%d] = %0.3f\n", i, j, tmp[i][j]);
			//TRACE("G_mag[%d][%d] = %0.3f\n", i, j, G_mag[i][j]);
			if (tmp[i][j] < 0)
				TRACE("tmp[%d][%d] = %0.2f\n", i, j, tmp[i][j]);
			image2[i][j] = round(tmp[i][j] * 255.);
			//image2[i][j] = 255 - round(tmp[i][j] * 255.);
		}
	}
}

void GetContrast(imatrix& image, matrix& G_mag, imatrix& image2, double sigma, double tao) 
// Using a dodge-and-burn in tone mapping paper
{
	int	i, j, k;
	double MAX_DOG = -1.0;
	int s, t;
	int x, y;

	int image_x = image.getRow();
	int image_y = image.getCol();

	int half1; // small window and big window
	//int index1, index2; // index for Gaussian matrix
	double sum1, w_sum1;
	double c_val;

	//////////////////////////////////
	//Make2DGaussMask(sigma); // mask for unilateral filtering

	//N = gau_mask.getRow();
	//half = N / 2;

	//ClearMemDC(&dc); // clear the canvas white
	//////////////////////////////////////////////
	//double factor = 2.0;
	//MakeGaussMatrix(factor, GAU); // factor controls the Gaussian window size for each index
	vector GAU1;
	MakeGaussVector(sigma, GAU1);
	//MakeGaussVector(sigma*1.6, GAU2);

	TRACE("half_w = %d\n", GAU1.getMax());

	////////////////////////////////////////////////////////
	matrix tmp(image_x, image_y);
	//tmp.zero();

	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//index = gray2[i][j];
			sum1 = 0;
			w_sum1 = 0.0;
			//half1 = GAU_W[index1]-1;
			half1 = GAU1.getMax()-1;
			//half = 8;
			//TRACE("GAU_W_1[%d] = %d\n", index1, GAU_W[index1]);
			c_val = (double)image[i][j] / 255.;
			for (s = -half1; s <= half1; s++) {
				for (t = -half1; t <= half1; t++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					//k = round( dist2(x, y, i, j) );
					if ( k > half1 ) continue; 
					/////////////////////////////////////////////////////
					sum1 += image[x][y] * GAU1[k];
					w_sum1 += GAU1[k];
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			sum1 /= w_sum1; 
			sum1 /= 255.; // now [0, 1]
			//TRACE("sum1 %.6f\n", sum1);
			//////////////////////////////
			
			/////////////////////////////////////////
			// POSITIVE INNTER CIRCLE
			//tmp[i][j] = c_val / (1 + pow(sum1, 30)); // dodge-and-burn, doesn't work!
			//c_val += 20.0 * (c_val - sum1); // works very well!!!
			//c_val += tanh( 5.0 * (c_val - sum1) ); // good!
			c_val += tanh( tao * (c_val - sum1) ); // good!
			//c_val += 0.001 / (c_val - sum1); // doesn't work
			//TRACE("c_val = %.6f\n", c_val);
			if (c_val > 1.0) c_val = 1.0;
			else if (c_val < 0.0) c_val = 0.0;
			tmp[i][j] = c_val;
		}
	}
	////////////////////////////////////////////

	// Normalize DOG value (not necessary! - MAX_DOG is always 1)
	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			//TRACE("p[%d][%d].mag = %0.3f\n", i, j, p[i][j].mag);
			//tmp[i][j] = tmp[i][j] / MAX_DOG; // place it between [0, 1]
			//////////////////////////////////////////////////
			G_mag[i][j] = 1-tmp[i][j]; // [0, 1] used for nonmaxima suppression
			// the higher, the stronger the edgeness!
			///////////////////////////////////////////////////
			//TRACE("G_mag[%d][%d] = %.1f\n", i, j, G_mag[i][j]);
			//TRACE("tmp[%d][%d] = %0.3f\n", i, j, tmp[i][j]);
			//TRACE("G_mag[%d][%d] = %0.3f\n", i, j, G_mag[i][j]);
			if (tmp[i][j] < 0)
				TRACE("tmp[%d][%d] = %0.2f\n", i, j, tmp[i][j]);
			image2[i][j] = round(tmp[i][j] * 255.);
			//image2[i][j] = round( tmp[i][j] );
			//image2[i][j] = 255 - round(tmp[i][j] * 255.);
		}
	}
}

void GetOrientedDOG(imatrix& image, Field& gfield, imatrix& image2, matrix& G_mag, 
			  double sigma, double tau) 
// Oriented DOG
// G_mag gets the actual real values in [0, 1]
// image2 gets the integer values in [0, 255]
{
	int	i, j;
	double MAX_DOG = -1.0;
	int s, t;
	int x, y;

	int image_x = image.getRow();
	int image_y = image.getCol();

	int half1, half2; // small window and big window
	//int index1, index2; // index for Gaussian matrix
	double sum1, sum2, w_sum1, w_sum2;

	//////////////////////////////////
	//Make2DGaussMask(sigma); // mask for unilateral filtering

	//N = gau_mask.getRow();
	//half = N / 2;

	//ClearMemDC(&dc); // clear the canvas white
	//////////////////////////////////////////////
	//double factor = 2.0;
	//MakeGaussMatrix(factor, GAU); // factor controls the Gaussian window size for each index
	vector GAU1, GAU2;
	MakeGaussVector(sigma, GAU1); // entire inner circle
	MakeGaussVector(sigma*1.6, GAU2); // entire outer circle

	////////////////////////////////////////////////////////
	// sensitivity of edge detector. between [0, 1] 
	// the smaller, less noise 
	//double tau = 0.99; 

	matrix tmp(image_x, image_y);
	//tmp.zero();

	/*
	for (i = 0; i < 256; i++) {
		for (j = 0; j < GAU.getCol(); j++) {
			TRACE("GAU[%d][%d] = %.3f ", i, j, GAU[i][j]);
		}
		TRACE("\n");
	}
	*/
	//gau_w = MakeGaussMask(4.0, gau); // window 20x20

	vector v(2), vt(2), w(2);
	double gx, gy, d1, d2, weight, v_norm;
		
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//index = gray2[i][j];
			sum1 = 0;
			w_sum1 = 0.0;
			//half1 = GAU_W[index1]-1;
			half1 = GAU1.getMax()-1;
			//half = 8;
			gx = gfield[i][j].gx;
			gy = gfield[i][j].gy;
			//TRACE("GAU_W_1[%d] = %d\n", index1, GAU_W[index1]);
			////////////////////////////////
			// vector components for the distance computation!
			v[0] = gx; // gradient vector
			v[1] = gy;
			//v[0] = 0.0;
			//v[1] = 1.0;
			v.make_unit();
			vt[0] = -gy; // tangent vector (main axis!)
			vt[1] = gx;
			//vt[0] = -1.0; // tangent vector
			//vt[1] = 0.0;
			vt.make_unit();
			v_norm = v.norm();
			for (t = -half1; t <= half1; t++) {
				for (s = -half1; s <= half1; s++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					/*
					k = (int)dist2(x, y, i, j);
					//k = round( dist2(x, y, i, j) );
					if ( k > half1 ) continue; 
					*/
					//////////////////////////////////
					w[0] = (double)x - i; // C - A
					w[1] = (double)y - j;
					//w.make_unit(); // you shouldn't make this unit!
					/////////////////////
					// distance to the (-gy, gx) MAIN AXIS!
					d1 = ABS(v * w) / v_norm; // should be positive!
					if ( d1 > half1 ) continue; 
					/////////////////////
					// distance to the (gx, gy) AXIS!
					d2 = ABS(vt * w) / v_norm; // should be positive!
					if ( d2 > half1 ) continue; 
					
					//TRACE("k = %d\n", k);
					//TRACE("d = %.1f\n", d);
					//rad = d * 1.5 * PI / (double)half1;
					//rad = d * 4.0 * PI / (double)half1;
					//rad = d * 10.0 * PI / (double)half1;
					//TRACE("rad = %.1f\n", rad);
					///////////////////////////////////////
					//weight = GAU[index1][k] * cos(rad);
					//weight = GAU[index1][k] * cos(rad);
					//weight = GAU[index1][round(d2)] * GAU[index1][round(d1)];
					weight = GAU1[round(d1)] * GAU1[round(d2)];
					//weight = GAU1[round(d1)]; // ONLY ORIENTATION IS CONSIDERED!
					//TRACE("weight = %f\n", weight);
					//if (weight < 0) TRACE("weight = %f\n", weight);
					//if (cos(rad) < 0) TRACE("cos(rad) = %f\n", cos(rad));
					/////////////////////////////////////////////////////
					sum1 += image[x][y] * weight;
					w_sum1 += weight;
					//sum1 += image[x][y] * GAU[index1][k];
					//w_sum1 += GAU[index1][k];
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			sum1 /= w_sum1; 
			//sum1 /= 100;
			//TRACE("sum1 = %.6f\n", sum1);
			//TRACE("w_sum = %.6f\n", w_sum);
			//////////////////////////////////////////////
			//////////////////////////////////////////////
			sum2 = 0;
			w_sum2 = 0.0;
			//half2 = GAU_W[index2]-1;
			half2 = GAU2.getMax()-1;
			//TRACE("GAU_W_2[%d] = %d\n", index2, GAU_W[index2]);
			for (s = -half2; s <= half2; s++) {
				for (t = -half2; t <= half2; t++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					/*
					k = (int)dist2(x, y, i, j);
					//k = round( dist2(x, y, i, j) );
					if ( k > half1 ) continue; 
					*/
					/////////////////////////////////////////////////////
					////////////////////////////////
					w[0] = (double)x - i; // C - A
					w[1] = (double)y - j;
					//w.make_unit(); // you shouldn't make this unit!
					/////////////////////
					// distance to the (-gy, gx) MAIN AXIS!
					d1 = ABS(v * w) / v_norm; // should be positive!
					if ( d1 > half2 ) continue; 
					/////////////////////
					// distance to the (gx, gy) AXIS!
					d2 = ABS(vt * w) / v_norm; // should be positive!
					if ( d2 > half2 ) continue; 
					//TRACE("k = %d\n", k);
					//TRACE("d = %.1f\n", d);
					//rad = d * 1.5 * PI / (double)half1;
					//rad = d * 4.0 * PI / (double)half1;
					//rad = d * 10.0 * PI / (double)half1;
					//TRACE("rad = %.1f\n", rad);
					///////////////////////////////////////
					//weight = GAU[index1][k] * cos(rad);
					//weight = GAU[index1][k] * cos(rad);
					//weight = GAU[index2][round(d2)] * GAU[index2][round(d1)];
					weight = GAU2[round(d1)] * GAU2[round(d2)];
					//weight = GAU2[round(d1)];
					//TRACE("weight = %f\n", weight);
					//if (weight < 0) TRACE("weight = %f\n", weight);
					//if (cos(rad) < 0) TRACE("cos(rad) = %f\n", cos(rad));
					/////////////////////////////////////////////////////
					sum2 += image[x][y] * weight;
					w_sum2 += weight;
					//sum1 += image[x][y] * GAU[index1][k];
					//w_sum1 += GAU[index1][k];
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
					//sum2 += image[x][y] * GAU[index2][k];
					//w_sum2 += GAU[index2][k];
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			//TRACE("w_sum = %.6f\n", w_sum);
			sum2 /= w_sum2; 
			//////////////////////////////
			//////////////////////////////////////
			if (sum1 - tau * sum2 > 0) // non edge
				tmp[i][j] = 1.0; 
			else // edge!
				tmp[i][j] = 1.0 + tanh(sum1 - tau * sum2);
		}
	}
	////////////////////////////////////////////

	// Normalize DOG value (not necessary! - MAX_DOG is always 1)
	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			//TRACE("p[%d][%d].mag = %0.3f\n", i, j, p[i][j].mag);
			//tmp[i][j] = tmp[i][j] / MAX_DOG; // place it between [0, 1]
			G_mag[i][j] = 1-tmp[i][j]; // used for nonmaxima suppression
			//TRACE("G_mag[%d][%d] = %.1f\n", i, j, G_mag[i][j]);
			//TRACE("tmp[%d][%d] = %0.3f\n", i, j, tmp[i][j]);
			//TRACE("G_mag[%d][%d] = %0.3f\n", i, j, G_mag[i][j]);
			if (tmp[i][j] < 0)
				TRACE("tmp[%d][%d] = %0.2f\n", i, j, tmp[i][j]);
			image2[i][j] = round(tmp[i][j] * 255.);
			//image2[i][j] = 255 - round(tmp[i][j] * 255.);
		}
	}
}

void GetOrientedDOG3(imatrix& image, Field& gfield, imatrix& image2, matrix& G_mag, 
			  double sigma, double tau) 
// Oriented DOG
// G_mag gets the actual real values in [0, 1]
// image2 gets the integer values in [0, 255]
// Here, we consider FULL ORIENTED DOG! WITHOUT TAPERING OFF WITH PERPENDICULAR GAUSSIAN!
{
	int	i, j;
	double MAX_DOG = -1.0;
	int s, t;
	int x, y;

	int image_x = image.getRow();
	int image_y = image.getCol();

	int half1, half2; // small window and big window
	//int index1, index2; // index for Gaussian matrix
	double sum1, sum2, w_sum1, w_sum2;

	//////////////////////////////////
	//Make2DGaussMask(sigma); // mask for unilateral filtering

	//N = gau_mask.getRow();
	//half = N / 2;

	//ClearMemDC(&dc); // clear the canvas white
	//////////////////////////////////////////////
	//double factor = 2.0;
	//MakeGaussMatrix(factor, GAU); // factor controls the Gaussian window size for each index
	vector GAU1, GAU2;
	MakeGaussVector(sigma, GAU1); // entire inner circle
	MakeGaussVector(sigma*1.6, GAU2); // entire outer circle

	////////////////////////////////////////////////////////
	// sensitivity of edge detector. between [0, 1] 
	// the smaller, less noise 
	//double tau = 0.99; 

	matrix tmp(image_x, image_y);
	//tmp.zero();

	/*
	for (i = 0; i < 256; i++) {
		for (j = 0; j < GAU.getCol(); j++) {
			TRACE("GAU[%d][%d] = %.3f ", i, j, GAU[i][j]);
		}
		TRACE("\n");
	}
	*/
	//gau_w = MakeGaussMask(4.0, gau); // window 20x20

	//int k;
	vector v(2), vt(2), w(2);
	double gx, gy, d1, weight, v_norm;
	double d2;

	int half_w1, half_w2; // BOUNDING BOX for our ROTATING SQUARE KERNEL
		
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//index = gray2[i][j];
			sum1 = 0;
			w_sum1 = 0.0;
			//half1 = GAU_W[index1]-1;
			half1 = GAU1.getMax()-1;
			//half = 8;
			gx = gfield[i][j].gx;
			gy = gfield[i][j].gy;
			//TRACE("GAU_W_1[%d] = %d\n", index1, GAU_W[index1]);
			////////////////////////////////
			// vector components for the distance computation!
			v[0] = gx; // gradient vector
			v[1] = gy;
			//v[0] = 0.0;
			//v[1] = 1.0;
			v.make_unit();
			vt[0] = -gy; // tangent vector (main axis!)
			vt[1] = gx;
			//vt[0] = -1.0; // tangent vector
			//vt[1] = 0.0;
			vt.make_unit();
			v_norm = v.norm();
			// we use ORIENTED SQUARE KERNEL!
			// Thus, the Minimum Bounding Box should have half_w1 = half1 * sqrt(2);
			half_w1 = round(half1 * 1.5); 
			for (t = -half_w1; t <= half_w1; t++) {
				for (s = -half_w1; s <= half_w1; s++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel (instead of square kernel)
					// even without it, it works almost the same
					// because near the square boundary, Gaussian is minimal!
					/*
					//k = (int)dist2(x, y, i, j);
					k = round( dist2(x, y, i, j) );
					if ( k > half1 ) continue; 
					*/
					//////////////////////////////////
					w[0] = (double)x - i; // C - A
					w[1] = (double)y - j;
					//w.make_unit(); // you shouldn't make this unit!
					/////////////////////
					// distance to the (-gy, gx) MAIN AXIS!
					d1 = ABS(v * w) / v_norm; // should be positive!
					if ( d1 > half1 ) continue; 
					/////////////////////
					// distance to the (gx, gy) AXIS!
					d2 = ABS(vt * w) / v_norm; // should be positive!
					if ( d2 > half1 ) continue; 
					
					//TRACE("k = %d\n", k);
					//TRACE("d = %.1f\n", d);
					//rad = d * 1.5 * PI / (double)half1;
					//rad = d * 4.0 * PI / (double)half1;
					//rad = d * 10.0 * PI / (double)half1;
					//TRACE("rad = %.1f\n", rad);
					///////////////////////////////////////
					//weight = GAU[index1][k] * cos(rad);
					//weight = GAU[index1][k] * cos(rad);
					//weight = GAU[index1][round(d2)] * GAU[index1][round(d1)];
					//weight = GAU1[round(d1)] * GAU1[round(d2)];
					weight = GAU1[round(d1)];
					//weight = GAU1[round(d1)]; // ONLY ORIENTATION IS CONSIDERED!
					//TRACE("weight = %f\n", weight);
					//if (weight < 0) TRACE("weight = %f\n", weight);
					//if (cos(rad) < 0) TRACE("cos(rad) = %f\n", cos(rad));
					/////////////////////////////////////////////////////
					sum1 += image[x][y] * weight;
					w_sum1 += weight;
					//sum1 += image[x][y] * GAU[index1][k];
					//w_sum1 += GAU[index1][k];
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			sum1 /= w_sum1; 
			//sum1 /= 100;
			//TRACE("sum1 = %.6f\n", sum1);
			//TRACE("w_sum = %.6f\n", w_sum);
			//////////////////////////////////////////////
			//////////////////////////////////////////////
			sum2 = 0;
			w_sum2 = 0.0;
			//half2 = GAU_W[index2]-1;
			//half2 = GAU1.getMax()-1; // this is a big mistake! did this creat all the noises?
			half2 = GAU2.getMax()-1;
			//TRACE("GAU_W_2[%d] = %d\n", index2, GAU_W[index2]);
			half_w2 = round(half2 * 1.5); 
			for (s = -half_w2; s <= half_w2; s++) {
				for (t = -half_w2; t <= half_w2; t++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					/*
					//k = (int)dist2(x, y, i, j);
					k = round( dist2(x, y, i, j) );
					if ( k > half2 ) continue; 
					*/
					/////////////////////////////////////////////////////
					////////////////////////////////
					w[0] = (double)x - i; // C - A
					w[1] = (double)y - j;
					//w.make_unit(); // you shouldn't make this unit!
					/////////////////////
					// distance to the (-gy, gx) MAIN AXIS!
					d1 = ABS(v * w) / v_norm; // should be positive!
					if ( d1 > half2 ) continue; 
					/////////////////////
					// distance to the (gx, gy) AXIS!
					d2 = ABS(vt * w) / v_norm; // should be positive!
					if ( d2 > half2 ) continue; 
					//TRACE("k = %d\n", k);
					//TRACE("d = %.1f\n", d);
					//rad = d * 1.5 * PI / (double)half1;
					//rad = d * 4.0 * PI / (double)half1;
					//rad = d * 10.0 * PI / (double)half1;
					//TRACE("rad = %.1f\n", rad);
					///////////////////////////////////////
					//weight = GAU[index1][k] * cos(rad);
					//weight = GAU[index1][k] * cos(rad);
					//weight = GAU[index2][round(d2)] * GAU[index2][round(d1)];
					//weight = GAU2[round(d1)] * GAU2[round(d2)];
					weight = GAU2[round(d1)];
					//TRACE("weight = %f\n", weight);
					//if (weight < 0) TRACE("weight = %f\n", weight);
					//if (cos(rad) < 0) TRACE("cos(rad) = %f\n", cos(rad));
					/////////////////////////////////////////////////////
					sum2 += image[x][y] * weight;
					w_sum2 += weight;
					//sum1 += image[x][y] * GAU[index1][k];
					//w_sum1 += GAU[index1][k];
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
					//sum2 += image[x][y] * GAU[index2][k];
					//w_sum2 += GAU[index2][k];
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			//TRACE("w_sum = %.6f\n", w_sum);
			sum2 /= w_sum2; 
			//////////////////////////////
			//////////////////////////////////////
			if (sum1 - tau * sum2 > 0) // non edge
				tmp[i][j] = 1.0; 
			else // edge!
				tmp[i][j] = 1.0 + tanh(sum1 - tau * sum2);
		}
	}
	////////////////////////////////////////////

	// Normalize DOG value (not necessary! - MAX_DOG is always 1)
	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			//TRACE("p[%d][%d].mag = %0.3f\n", i, j, p[i][j].mag);
			//tmp[i][j] = tmp[i][j] / MAX_DOG; // place it between [0, 1]
			G_mag[i][j] = 1-tmp[i][j]; // used for nonmaxima suppression
			//TRACE("G_mag[%d][%d] = %.1f\n", i, j, G_mag[i][j]);
			//TRACE("tmp[%d][%d] = %0.3f\n", i, j, tmp[i][j]);
			//TRACE("G_mag[%d][%d] = %0.3f\n", i, j, G_mag[i][j]);
			if (tmp[i][j] < 0)
				TRACE("tmp[%d][%d] = %0.2f\n", i, j, tmp[i][j]);
			image2[i][j] = round(tmp[i][j] * 255.);
			//image2[i][j] = 255 - round(tmp[i][j] * 255.);
		}
	}
}

void GetOrientedDOG4(imatrix& image, Field& gfield, imatrix& image2, matrix& G_mag, 
			  double sigma, double tau) 
// Oriented DOG with BILINEAR INTERPOLATION!
// G_mag gets the actual real values in [0, 1]
// image2 gets the integer values in [0, 255]
// Here, we consider FULL ORIENTED DOG! WITHOUT TAPERING OFF WITH PERPENDICULAR GAUSSIAN!
{
	int	i, j;
	double MAX_DOG = -1.0;
	int s, t;
	
	int image_x = image.getRow();
	int image_y = image.getCol();

	int half1, half2; // small window and big window
	//int index1, index2; // index for Gaussian matrix
	double sum1, sum2, w_sum1, w_sum2;

	//////////////////////////////////
	//Make2DGaussMask(sigma); // mask for unilateral filtering

	//N = gau_mask.getRow();
	//half = N / 2;

	//ClearMemDC(&dc); // clear the canvas white
	//////////////////////////////////////////////
	//double factor = 2.0;
	//MakeGaussMatrix(factor, GAU); // factor controls the Gaussian window size for each index
	vector GAU1, GAU2;
	MakeGaussVector(sigma, GAU1); // entire inner circle
	MakeGaussVector(sigma*1.6, GAU2); // entire outer circle

	////////////////////////////////////////////////////////
	// sensitivity of edge detector. between [0, 1] 
	// the smaller, less noise 
	//double tau = 0.99; 

	matrix tmp(image_x, image_y);
	//tmp.zero();

	/*
	for (i = 0; i < 256; i++) {
		for (j = 0; j < GAU.getCol(); j++) {
			TRACE("GAU[%d][%d] = %.3f ", i, j, GAU[i][j]);
		}
		TRACE("\n");
	}
	*/
	//gau_w = MakeGaussMask(4.0, gau); // window 20x20

	//int k;
	vector v(2), vt(2), w(2);
	double gx, gy, weight, v_norm;
	double x, y, c_x, c_y, d_x, d_y;

	int x1, y1, x2, y2;
	double lb, lt, rb, rt;
	double uu, vv, bb, tt, val;
	double step_size;
	int d1;
    
	//int half_w1, half_w2; // BOUNDING BOX for our ROTATING SQUARE KERNEL
		
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//index = gray2[i][j];
			sum1 = 0;
			w_sum1 = 0.0;
			//half1 = GAU_W[index1]-1;
			half1 = GAU1.getMax()-1;
			half2 = GAU2.getMax()-1;
			//half = 8;
			gx = gfield[i][j].gx;
			gy = gfield[i][j].gy;
			//TRACE("GAU_W_1[%d] = %d\n", index1, GAU_W[index1]);
			////////////////////////////////
			// vector components for the distance computation!
			v[0] = gx; // gradient vector
			v[1] = gy;
			//v[0] = 0.0;
			//v[1] = 1.0;
			v.make_unit();
			vt[0] = -gy; // tangent vector (main axis!)
			vt[1] = gx;
			//vt[0] = -1.0; // tangent vector
			//vt[1] = 0.0;
			vt.make_unit();
			v_norm = v.norm();
			// we use ORIENTED SQUARE KERNEL!
			// Thus, the Minimum Bounding Box should have half_w1 = half1 * sqrt(2);
			//half_w1 = round(half1 * 1.5); 
			c_x = (double)i;
			c_y = (double)j;
			/////////////////////////////
			step_size = 1.0; // (0.0, 1.0] depends on the angle (curvature) at the pixel!
			////////////////////////////
			for (t = -half1; t <= half1; t++) { // height of rectangle kernel
			//for (t = -half2; t <= half2; t++) { // height of rectangle kernel
				d_x = c_x + vt[0] * t * step_size; // how narrow the height of rectangle kernel
				d_y = c_y + vt[1] * t * step_size; // depends on step_size
				for (s = -half1; s <= half1; s++) { // width of Gaussian kernel
					////////////////////////
					x = d_x + v[0] * s;
					y = d_y + v[1] * s;
					/////////////////////////////////////////////////////
					if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
						continue;
					/////////////////////////////////////////////////
					// BILINEAR INTERPOLATION!
					x1 = (int)x;		if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
					x2 = (int)x+1;		if (x2 < 0) x2 = 0; if (x2 > IMAGE_X-1) x2 = IMAGE_X-1;
					y1 = (int)y;		if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
					y2 = (int)y+1;		if (y2 < 0) y2 = 0; if (y2 > IMAGE_Y-1) y2 = IMAGE_Y-1;
					lb = (double)image[x1][y1];
					rb = (double)image[x2][y1];
					lt = (double)image[x1][y2];
					rt = (double)image[x2][y2];
					uu = x - x1;
					vv = y - y1;
					bb = (1-uu) * lb + uu * rb;
					tt = (1-uu) * lt + uu * rt;
					val = (1-vv) * bb + vv * tt;
					/////////////////////////////////////////////////////////
					d1 = ABS(s);
					weight = GAU1[d1];
					/////////////////////////////////////////////////////
					//sum1 += image[xi][yi] * weight;
					sum1 += val * weight;
					w_sum1 += weight;
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			sum1 /= w_sum1; 
			//sum1 /= 100;
			//TRACE("sum1 = %.6f\n", sum1);
			//TRACE("w_sum = %.6f\n", w_sum);
			//////////////////////////////////////////////

			//////////////////////////////////////////////
			// OUTER GAUSSIAN
			sum2 = 0;
			w_sum2 = 0.0;
			//half2 = GAU_W[index2]-1;
			// half2 = GAU2.getMax()-1;
			//TRACE("GAU_W_2[%d] = %d\n", index2, GAU_W[index2]);
			//half_w2 = round(half2 * 1.5); 
			for (t = -half1; t <= half1; t++) { // height of rectangle kernel
			//for (t = -half2; t <= half2; t++) { // height of rectangle kernel
				d_x = c_x + vt[0] * t * step_size; // how narrow the height of rectangle kernel
				d_y = c_y + vt[1] * t * step_size; // depends on step_size
				///////////////////////////////////////////////////////
				// this has to be half2, but half1 also works! Why?
				//for (s = -half2; s <= half2; s++) { 
				for (s = -half1; s <= half1; s++) { // this one works and faster! 
					////////////////////////
					x = d_x + v[0] * s;
					y = d_y + v[1] * s;
					/////////////////////////////////////////////////////
					if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
						continue;
					/////////////////////////////////////////////////
					// BILINEAR INTERPOLATION!
					x1 = (int)x;		if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
					x2 = (int)x+1;	if (x2 < 0) x2 = 0; if (x2 > IMAGE_X-1) x2 = IMAGE_X-1;
					y1 = (int)y;		if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
					y2 = (int)y+1;	if (y2 < 0) y2 = 0; if (y2 > IMAGE_Y-1) y2 = IMAGE_Y-1;
					lb = (double)image[x1][y1];
					rb = (double)image[x2][y1];
					lt = (double)image[x1][y2];
					rt = (double)image[x2][y2];
					uu = x - x1;
					vv = y - y1;
					bb = (1-uu) * lb + uu * rb;
					tt = (1-uu) * lt + uu * rt;
					val = (1-vv) * bb + vv * tt;
					/////////////////////////////////////////////////////////
					d1 = ABS(s);
					weight = GAU2[d1];
					/////////////////////////////////////////////////////
					//sum1 += image[xi][yi] * weight;
					sum2 += val * weight;
					w_sum2 += weight;
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			//TRACE("w_sum = %.6f\n", w_sum);
			sum2 /= w_sum2; 
			//////////////////////////////
			//////////////////////////////////////
			if (sum1 - tau * sum2 > 0) // non edge
				tmp[i][j] = 1.0; 
			else // edge!
				tmp[i][j] = 1.0 + tanh(sum1 - tau * sum2);
		}
	}
	////////////////////////////////////////////

	// Normalize DOG value (not necessary! - MAX_DOG is always 1)
	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			//TRACE("p[%d][%d].mag = %0.3f\n", i, j, p[i][j].mag);
			//tmp[i][j] = tmp[i][j] / MAX_DOG; // place it between [0, 1]
			G_mag[i][j] = 1-tmp[i][j]; // used for nonmaxima suppression
			//TRACE("G_mag[%d][%d] = %.1f\n", i, j, G_mag[i][j]);
			//TRACE("tmp[%d][%d] = %0.3f\n", i, j, tmp[i][j]);
			//TRACE("G_mag[%d][%d] = %0.3f\n", i, j, G_mag[i][j]);
			if (tmp[i][j] < 0)
				TRACE("tmp[%d][%d] = %0.2f\n", i, j, tmp[i][j]);
			image2[i][j] = round(tmp[i][j] * 255.);
			//image2[i][j] = 255 - round(tmp[i][j] * 255.);
		}
	}
}

void GetOrientedDOG5(imatrix& image, Field& gfield, imatrix& image2, matrix& G_mag, 
			  double sigma, double tau) 
// Oriented DOG with BILINEAR INTERPOLATION!
// And ADAPTIVE KERNEL HEIGHT according to CURVATURE VALUE!
// G_mag gets the actual real values in [0, 1]
// image2 gets the integer values in [0, 255]
// Here, we consider FULL ORIENTED DOG! WITHOUT TAPERING OFF WITH PERPENDICULAR GAUSSIAN!
{
	int	i, j;
	double MAX_DOG = -1.0;
	int s, t;
	
	int image_x = image.getRow();
	int image_y = image.getCol();

	int half1, half2; // small window and big window
	//int index1, index2; // index for Gaussian matrix
	double sum1, sum2, w_sum1, w_sum2;

	//////////////////////////////////
	//Make2DGaussMask(sigma); // mask for unilateral filtering

	//N = gau_mask.getRow();
	//half = N / 2;

	//ClearMemDC(&dc); // clear the canvas white
	//////////////////////////////////////////////
	//double factor = 2.0;
	//MakeGaussMatrix(factor, GAU); // factor controls the Gaussian window size for each index
	vector GAU1, GAU2;
	MakeGaussVector(sigma, GAU1); // entire inner circle
	MakeGaussVector(sigma*1.6, GAU2); // entire outer circle

	////////////////////////////////////////////////////////
	// sensitivity of edge detector. between [0, 1] 
	// the smaller, less noise 
	//double tau = 0.99; 

	matrix tmp(image_x, image_y);
	//tmp.zero();

	/*
	for (i = 0; i < 256; i++) {
		for (j = 0; j < GAU.getCol(); j++) {
			TRACE("GAU[%d][%d] = %.3f ", i, j, GAU[i][j]);
		}
		TRACE("\n");
	}
	*/
	//gau_w = MakeGaussMask(4.0, gau); // window 20x20

	//int k;
	vector v(2), vt(2), w(2);
	double gx, gy, weight, v_norm;
	double x, y, c_x, c_y, d_x, d_y;

	int x1, y1, x2, y2;
	double lb, lt, rb, rt;
	double uu, vv, bb, tt, val;
	double step_size;
	int d1;

	vector v1(2);
	double angle, angle1, angle2;
    
	//int half_w1, half_w2; // BOUNDING BOX for our ROTATING SQUARE KERNEL
		
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//index = gray2[i][j];
			sum1 = 0;
			w_sum1 = 0.0;
			//half1 = GAU_W[index1]-1;
			half1 = GAU1.getMax()-1;
			//half = 8;
			gx = gfield[i][j].gx;
			gy = gfield[i][j].gy;
			//TRACE("GAU_W_1[%d] = %d\n", index1, GAU_W[index1]);
			////////////////////////////////
			// vector components for the distance computation!
			v[0] = gx; // gradient vector
			v[1] = gy;
			//v[0] = 0.0;
			//v[1] = 1.0;
			v.make_unit();
			vt[0] = -gy; // tangent vector (main axis!)
			vt[1] = gx;
			//vt[0] = -1.0; // tangent vector
			//vt[1] = 0.0;
			vt.make_unit();
			v_norm = v.norm();
			// we use ORIENTED SQUARE KERNEL!
			// Thus, the Minimum Bounding Box should have half_w1 = half1 * sqrt(2);
			//half_w1 = round(half1 * 1.5); 
			c_x = (double)i;
			c_y = (double)j;
			//////////////////////////////////////////////////////
			// compute angle! (curvature) and step_size!
			x1 = round(c_x + vt[0] * 1.5);
			y1 = round(c_y + vt[1] * 1.5);
			x2 = round(c_x - vt[0] * 1.5);
			y2 = round(c_y - vt[1] * 1.5);
			if (x1 > IMAGE_X-1 || x1 < 0 || y1 > IMAGE_Y-1 || y1 < 0 ||
				x2 > IMAGE_X-1 || x2 < 0 || y2 > IMAGE_Y-1 || y2 < 0) { // boundary point
				step_size = 1.0;
			}
			else {
				v1[0] = -gfield[x1][y1].gy;
				v1[1] = gfield[x1][y1].gx;
				v1.make_unit();
				angle1 = vt * v1; // [-1.0, 1.0]
				if (angle1 > 1.0) angle1 = 1.0;
				if (angle1 < -1.0) angle1 = -1.0;
				angle1 = ABS(angle1); // [0.0, 1.0] 0 and 180 are equally good!
				angle1 = 1.0 - angle1; // Now 0.0 is big angle1, 1.0 is small angle1!
				//angle1 = angle1 * angle1 * angle1; // Now big angle1 gets even smaller step size!

				v1[0] = -gfield[x2][y2].gy;
				v1[1] = gfield[x2][y2].gx;
				v1.make_unit();
				angle2 = vt * v1; // [-1.0, 1.0]
				if (angle2 > 1.0) angle2 = 1.0;
				if (angle2 < -1.0) angle2 = -1.0;
				angle2 = ABS(angle2); // [0.0, 1.0] 0 and 180 are equally good!
				angle2 = 1.0 - angle2; // Now 0.0 is big angle2, 1.0 is small angle2!

				angle = (angle1 + angle2) / 2.0; 
				
				step_size = 1.0 * angle + 0.000001; // (0.0, 1.0] depends on the angle (curvature) at the pixel!
			}
			////////////////////////////
			for (t = -half1; t <= half1; t++) { // height of rectangle kernel
				d_x = c_x + vt[0] * t * step_size; // how narrow the height of rectangle kernel
				d_y = c_y + vt[1] * t * step_size; // depends on step_size
				for (s = -half1; s <= half1; s++) { // width of Gaussian kernel
					////////////////////////
					x = d_x + v[0] * s;
					y = d_y + v[1] * s;
					/////////////////////////////////////////////////////
					if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
						continue;
					/////////////////////////////////////////////////
					// BILINEAR INTERPOLATION!
					x1 = (int)x;		if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
					x2 = (int)x+1;		if (x2 < 0) x2 = 0; if (x2 > IMAGE_X-1) x2 = IMAGE_X-1;
					y1 = (int)y;		if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
					y2 = (int)y+1;		if (y2 < 0) y2 = 0; if (y2 > IMAGE_Y-1) y2 = IMAGE_Y-1;
					lb = (double)image[x1][y1];
					rb = (double)image[x2][y1];
					lt = (double)image[x1][y2];
					rt = (double)image[x2][y2];
					uu = x - x1;
					vv = y - y1;
					bb = (1-uu) * lb + uu * rb;
					tt = (1-uu) * lt + uu * rt;
					val = (1-vv) * bb + vv * tt;
					/////////////////////////////////////////////////////////
					d1 = ABS(s);
					weight = GAU1[d1];
					/////////////////////////////////////////////////////
					//sum1 += image[xi][yi] * weight;
					sum1 += val * weight;
					w_sum1 += weight;
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			sum1 /= w_sum1; 
			//sum1 /= 100;
			//TRACE("sum1 = %.6f\n", sum1);
			//TRACE("w_sum = %.6f\n", w_sum);
			//////////////////////////////////////////////

			//////////////////////////////////////////////
			// OUTER GAUSSIAN
			sum2 = 0;
			w_sum2 = 0.0;
			//half2 = GAU_W[index2]-1;
			half2 = GAU2.getMax()-1;
			//TRACE("GAU_W_2[%d] = %d\n", index2, GAU_W[index2]);
			//half_w2 = round(half2 * 1.5); 
			for (t = -half1; t <= half1; t++) { // height of rectangle kernel
				d_x = c_x + vt[0] * t * step_size; // how narrow the height of rectangle kernel
				d_y = c_y + vt[1] * t * step_size; // depends on step_size
				///////////////////////////////////////////////////////
				// this has to be half2, but half1 also works! Why?
				//for (s = -half2; s <= half2; s++) { 
				for (s = -half1; s <= half1; s++) { // this one works and faster! 
					////////////////////////
					x = d_x + v[0] * s;
					y = d_y + v[1] * s;
					/////////////////////////////////////////////////////
					if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
						continue;
					/////////////////////////////////////////////////
					// BILINEAR INTERPOLATION!
					x1 = (int)x;		if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
					x2 = (int)x+1;	if (x2 < 0) x2 = 0; if (x2 > IMAGE_X-1) x2 = IMAGE_X-1;
					y1 = (int)y;		if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
					y2 = (int)y+1;	if (y2 < 0) y2 = 0; if (y2 > IMAGE_Y-1) y2 = IMAGE_Y-1;
					lb = (double)image[x1][y1];
					rb = (double)image[x2][y1];
					lt = (double)image[x1][y2];
					rt = (double)image[x2][y2];
					uu = x - x1;
					vv = y - y1;
					bb = (1-uu) * lb + uu * rb;
					tt = (1-uu) * lt + uu * rt;
					val = (1-vv) * bb + vv * tt;
					/////////////////////////////////////////////////////////
					d1 = ABS(s);
					weight = GAU2[d1];
					/////////////////////////////////////////////////////
					//sum1 += image[xi][yi] * weight;
					sum2 += val * weight;
					w_sum2 += weight;
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			//TRACE("w_sum = %.6f\n", w_sum);
			sum2 /= w_sum2; 
			//////////////////////////////
			//////////////////////////////////////
			if (sum1 - tau * sum2 > 0) // non edge
				tmp[i][j] = 1.0; 
			else // edge!
				tmp[i][j] = 1.0 + tanh(sum1 - tau * sum2);
		}
	}
	////////////////////////////////////////////

	// Normalize DOG value (not necessary! - MAX_DOG is always 1)
	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			//TRACE("p[%d][%d].mag = %0.3f\n", i, j, p[i][j].mag);
			//tmp[i][j] = tmp[i][j] / MAX_DOG; // place it between [0, 1]
			G_mag[i][j] = 1-tmp[i][j]; // used for nonmaxima suppression
			//TRACE("G_mag[%d][%d] = %.1f\n", i, j, G_mag[i][j]);
			//TRACE("tmp[%d][%d] = %0.3f\n", i, j, tmp[i][j]);
			//TRACE("G_mag[%d][%d] = %0.3f\n", i, j, G_mag[i][j]);
			if (tmp[i][j] < 0)
				TRACE("tmp[%d][%d] = %0.2f\n", i, j, tmp[i][j]);
			image2[i][j] = round(tmp[i][j] * 255.);
			//image2[i][j] = 255 - round(tmp[i][j] * 255.);
		}
	}
}

double GetPointFlowDOG(int x, int y, imatrix& image, Field& gfield, 
							vector& GAU1, vector& GAU2, double tau)
// following the flow, compute the gradient at (x, y)
// this one keeps the current pixel location as float coordinates
// and this one uses weight, giving higher smoothing weight to higher gradient magnitudes!!!
{
	double d_i, d_j;
	int k, int_i, int_j;
	//int half2;
	double l_i, l_j, r_i, r_j;
	int count;

	//int half_l = ker_l / 2 + 1; // half length of the curved kernel
	//double half_w = 1.414; // half width of the curved kernel
	//double half_w = 1.414; // half width of the curved kernel
	//double half_w = 1; // half width of the curved kernel
	//double half_w = ker_w / 2; // half width of the curved kernel
	int half1, half2;
	half1 = GAU1.getMax()-1;
	half2 = GAU2.getMax()-1;

	int half_l1, half_l2;
	half_l1 = half1;
	half_l2 = half2;

	double flow_DOG = 0.0; // flow-based gradient magnitude
	double weight, w_sum1, sum1, sum2, w_sum2;
	int index;

	vector v(2), w(2), z(2);
	double angle_thres1, angle_thres2;
	
	angle_thres1 = 20;
	angle_thres2 = 180 - angle_thres1;

	double step_size; 
	double step_size1, step_size2;
	int xx, yy;
	double t;
	int i;

	step_size = 1.0;
	step_size1 = step_size2 = step_size;
	/////////////////////////////////////////////////
	// INSIDE FLOW DOG
	////////////////////////////////////
	count = 0; // number of pixels traversed
	sum1 = 0.0;
	w_sum1 = 0.0;
	////////////////////////////////////////////////
	// One half
	d_i = (double)x; d_j = (double)y; 
	int_i = x;	int_j = y;
	v[0] = z[0] = -gfield[int_i][int_j].gy;
	v[1] = z[1] = gfield[int_i][int_j].gx;
	for (k = 0; k < half_l1; k++) {
		w[0] = -gfield[int_i][int_j].gy;
		w[1] = gfield[int_i][int_j].gx;
		if (w[0] == 0.0 && w[1] == 0.0) break;
		w.make_unit();
		////////////////////////////////
		//////////////////////////////////////////////////
		// Angle computation
		l_i = d_i + -w[1] * half1; // left perpendicular
		l_j = d_j + w[0] * half1; // left perpendicular
		r_i = d_i + w[1] * half1; // right perpendicular
		r_j = d_j + -w[0] * half1; // right perpendicular
		for (i = -half1; i <= half1; i++) {
			index = ABS(i);
			t = (half1 - index) / (double)half1; // [0, 1]
			if (i <= 0) {
				xx = round( (1-t) * l_i + t * d_i );
				yy = round( (1-t) * l_j + t * d_j );
			}
			else {
				xx = round( (1-t) * r_i + t * d_i );
				yy = round( (1-t) * r_j + t * d_j );
			}
			if (xx < 0) xx = 0;
			if (xx > IMAGE_X-1) xx = IMAGE_X-1;
			if (yy < 0) yy = 0;
			if (yy > IMAGE_Y-1) yy = IMAGE_Y-1;
			weight = GAU1[index];
			sum1 += image[xx][yy] * weight;
			w_sum1 += weight;
		}
		/////////////////////////////////////////
		count++;
		//////////////////////////////////
		//dc.SetPixelV(int_i, IMAGE_Y-1-int_j, RGB(r, g, b));
		//////////////////////////////
		d_i += w[0] * step_size1; // advance
		d_j += w[1] * step_size1; 
		//d_i += v[0] * step_size1; // advance
		//d_j += v[1] * step_size1; 
        ///////////////////////////
		/////////////////////////////////////////
		int_i = round(d_i); // integer version of new location x
		int_j = round(d_j); // integer version of new location y
		if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		///////////////////////////////////
		z[0] = w[0] * step_size1;
		z[1] = w[1] * step_size1;
	}
	/*
	///////////////////////////////////////
	// other half
	d_i = (double)x; d_j = (double)y; 
	int_i = x;	int_j = y;
	z[0] = gfield[int_i][int_j].gy; // opposite direction!
	z[1] = -gfield[int_i][int_j].gx;
	for (k = 0; k < half_l1; k++) {
		w[0] = gfield[int_i][int_j].gy;
		w[1] = -gfield[int_i][int_j].gx;
		if (w[0] == 0.0 && w[1] == 0.0) break;
		w.make_unit();
		////////////////////////////////
		angle = w * z; // compare with previous vector
		if (angle > 1.0) angle = 1.0;
		if (angle < -1.0) angle = -1.0;
		angle = acos(angle) / PI * 180; // angle in [0, 180]
		//TRACE("angle = %.3f\n", angle);
		if ( angle < angle_thres1  ) { // the angle between two vectors is between [0, 30]
			step_size2 = step_size; 
		}
		else if ( angle > angle_thres2  ) { // the angle between two vectors is between [150, 180]
			step_size2 = -step_size; // reverse the moving direction!
		}
		else break; // too much turn. Stop advancing!
		//////////////////////////////////////////////////
		// Angle computation
		l_i = d_i + -w[1] * half1; // left perpendicular
		l_j = d_j + w[0] * half1; // left perpendicular
		r_i = d_i + w[1] * half1; // right perpendicular
		r_j = d_j + -w[0] * half1; // right perpendicular
		for (i = -half1; i <= half1; i++) {
			index = ABS(i);
			t = (half1 - index) / (double)half1;
			if (i <= 0) {
				xx = round( (1-t) * l_i + t * d_i );
				yy = round( (1-t) * l_j + t * d_j );
			}
			else {
				xx = round( (1-t) * r_i + t * d_i );
				yy = round( (1-t) * r_j + t * d_j );
			}
			if (xx < 0) xx = 0;
			if (xx > IMAGE_X-1) xx = IMAGE_X-1;
			if (yy < 0) yy = 0;
			if (yy > IMAGE_Y-1) yy = IMAGE_Y-1;
			if (k != 0) { // SKIP THE START PIXEL (already computed above!)
				weight = GAU1[index];
				sum1 += image[xx][yy] * weight;
				w_sum1 += weight;
			}
		}
		/////////////////////////////////////////
		count++;
		//////////////////////////////////
		//dc.SetPixelV(int_i, IMAGE_Y-1-int_j, RGB(r, g, b));
		//////////////////////////////
		d_i += w[0] * step_size2; // advance
		d_j += w[1] * step_size2; 
        ///////////////////////////
		//if (round(d_i) == int_i && round(d_j) == int_j) // no change
		//	continue; // push some more
		/////////////////////////////////////////
		int_i = round(d_i); // integer version of new location x
		int_j = round(d_j); // integer version of new location y
		if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		///////////////////////////////////
		z[0] = w[0] * step_size2;
		z[1] = w[1] * step_size2;
	}
	*/
	sum1 /= w_sum1; // normalize
	////////////////////////////////////////////////////

	/////////////////////////////////////////////////
	// OUTSIDE FLOW DOG
	////////////////////////////////////
	count = 0; // number of pixels traversed
	sum2 = 0.0;
	w_sum2 = 0.0;
	////////////////////////////////////////////////
	// One half
	d_i = (double)x; d_j = (double)y; 
	int_i = x;	int_j = y;
	v[0] = z[0] = -gfield[int_i][int_j].gy;
	v[1] = z[1] = gfield[int_i][int_j].gx;
	for (k = 0; k < half_l2; k++) {
		w[0] = -gfield[int_i][int_j].gy;
		w[1] = gfield[int_i][int_j].gx;
		if (w[0] == 0.0 && w[1] == 0.0) break;
		w.make_unit();
		////////////////////////////////
		//////////////////////////////////////////////////
		// Angle computation
		l_i = d_i + -w[1] * half2; // left perpendicular
		l_j = d_j + w[0] * half2; // left perpendicular
		r_i = d_i + w[1] * half2; // right perpendicular
		r_j = d_j + -w[0] * half2; // right perpendicular
		for (i = -half2; i <= half2; i++) {
			index = ABS(i);
			t = (half2 - index) / (double)half2;
			if (i <= 0) {
				xx = round( (1-t) * l_i + t * d_i );
				yy = round( (1-t) * l_j + t * d_j );
			}
			else {
				xx = round( (1-t) * r_i + t * d_i );
				yy = round( (1-t) * r_j + t * d_j );
			}
			if (xx < 0) xx = 0;
			if (xx > IMAGE_X-1) xx = IMAGE_X-1;
			if (yy < 0) yy = 0;
			if (yy > IMAGE_Y-1) yy = IMAGE_Y-1;
			////////////////////////////
			weight = GAU2[index];
			sum2 += image[xx][yy] * weight;
			w_sum2 += weight;
		}
		/////////////////////////////////////////
		count++;
		//////////////////////////////////
		//dc.SetPixelV(int_i, IMAGE_Y-1-int_j, RGB(r, g, b));
		//////////////////////////////
		d_i += w[0] * step_size1; // advance
		d_j += w[1] * step_size1; 
		//d_i += v[0] * step_size1; // advance
		//d_j += v[1] * step_size1; 
        ///////////////////////////
		int_i = round(d_i); // integer version of new location x
		int_j = round(d_j); // integer version of new location y
		if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		///////////////////////////////////
		z[0] = w[0] * step_size1;
		z[1] = w[1] * step_size1;
	}
	/*
	///////////////////////////////////////
	// other half
	d_i = (double)x; d_j = (double)y; 
	int_i = x;	int_j = y;
	z[0] = gfield[int_i][int_j].gy; // opposite direction!
	z[1] = -gfield[int_i][int_j].gx;
	for (k = 0; k < half_l2; k++) {
		w[0] = gfield[int_i][int_j].gy;
		w[1] = -gfield[int_i][int_j].gx;
		if (w[0] == 0.0 && w[1] == 0.0) break;
		w.make_unit();
		////////////////////////////////
		angle = w * z; // compare with previous vector
		if (angle > 1.0) angle = 1.0;
		if (angle < -1.0) angle = -1.0;
		angle = acos(angle) / PI * 180; // angle in [0, 180]
		//TRACE("angle = %.3f\n", angle);
		if ( angle < angle_thres1  ) { // the angle between two vectors is between [0, 30]
			step_size2 = step_size; 
		}
		else if ( angle > angle_thres2  ) { // the angle between two vectors is between [150, 180]
			step_size2 = -step_size; // reverse the moving direction!
		}
		else break; // too much turn. Stop advancing!
		//////////////////////////////////////////////////
		// Angle computation
		l_i = d_i + -w[1] * half2; // left perpendicular
		l_j = d_j + w[0] * half2; // left perpendicular
		r_i = d_i + w[1] * half2; // right perpendicular
		r_j = d_j + -w[0] * half2; // right perpendicular
		for (i = -half2; i <= half2; i++) {
			index = ABS(i);
			t = (half2 - index) / (double)half2;
			if (i <= 0) {
				xx = round( (1-t) * l_i + t * d_i );
				yy = round( (1-t) * l_j + t * d_j );
			}
			else {
				xx = round( (1-t) * r_i + t * d_i );
				yy = round( (1-t) * r_j + t * d_j );
			}
			if (xx < 0) xx = 0;
			if (xx > IMAGE_X-1) xx = IMAGE_X-1;
			if (yy < 0) yy = 0;
			if (yy > IMAGE_Y-1) yy = IMAGE_Y-1;
			if (k != 0) { // SKIP THE START PIXEL (already computed above!)
				weight = GAU2[index];
				sum2 += image[xx][yy] * weight;
				w_sum2 += weight;
			}
		}
		/////////////////////////////////////////
		count++;
		//////////////////////////////////
		//dc.SetPixelV(int_i, IMAGE_Y-1-int_j, RGB(r, g, b));
		//////////////////////////////
		d_i += w[0] * step_size2; // advance
		d_j += w[1] * step_size2; 
        ///////////////////////////
		//if (round(d_i) == int_i && round(d_j) == int_j) // no change
		//	continue; // push some more
		/////////////////////////////////////////
		int_i = round(d_i); // integer version of new location x
		int_j = round(d_j); // integer version of new location y
		if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		///////////////////////////////////
		z[0] = w[0] * step_size2;
		z[1] = w[1] * step_size2;
	}
	*/
	sum2 /= w_sum2; // normalize
	////////////////////////////////////////////////////
	if (sum1 == 0.0 && sum2 == 0.0)
		sum1 = 1.0; // make it a non-edge
	//////////////////////////////////////
	if (sum1 - tau * sum2 > 0) // non edge
		flow_DOG = 1.0; 
	else // edge!
		flow_DOG = 1.0 + tanh(sum1 - tau * sum2);

	return flow_DOG;
	
}

double GetPointFlowDOG2(int x, int y, imatrix& image, Field& gfield, 
							vector& GAU1, vector& GAU2, double tau)
// following the flow, compute the gradient at (x, y)
// this one keeps the current pixel location as float coordinates
// and this one uses weight, giving higher smoothing weight to higher gradient magnitudes!!!
// Here we use a discrete advancing method!
{
	double d_i, d_j;
	int k, int_i, int_j;
	//int half2;
	double l_i, l_j, r_i, r_j;
	int count;

	//int half_l = ker_l / 2 + 1; // half length of the curved kernel
	//double half_w = 1.414; // half width of the curved kernel
	//double half_w = 1.414; // half width of the curved kernel
	//double half_w = 1; // half width of the curved kernel
	//double half_w = ker_w / 2; // half width of the curved kernel
	int half1, half2;
	half1 = GAU1.getMax()-1;
	half2 = GAU2.getMax()-1;

	int half_l1, half_l2;
	half_l1 = half1;
	half_l2 = half2;

	double flow_DOG = 0.0; // flow-based gradient magnitude
	double weight, w_sum1, sum1, sum2, w_sum2;
	int index;

	vector v(2), w(2), z(2);
	double angle_thres1, angle_thres2;
	
	angle_thres1 = 20;
	angle_thres2 = 180 - angle_thres1;

	double step_size; 
	double step_size1, step_size2;
	int xx, yy;
	double t;
	int i;

	step_size = 1.0;
	step_size1 = step_size2 = step_size;
	/////////////////////////////////////////////////
	// INSIDE FLOW DOG
	////////////////////////////////////
	count = 0; // number of pixels traversed
	sum1 = 0.0;
	w_sum1 = 0.0;
	////////////////////////////////////////////////
	// One half
	d_i = (double)x; d_j = (double)y; 
	int_i = x;	int_j = y;
	v[0] = z[0] = -gfield[int_i][int_j].gy;
	v[1] = z[1] = gfield[int_i][int_j].gx;
	for (k = 0; k < half_l1; k++) {
		w[0] = -gfield[int_i][int_j].gy;
		w[1] = gfield[int_i][int_j].gx;
		if (w[0] == 0.0 && w[1] == 0.0) break;
		w.make_unit();
		////////////////////////////////
		/*
		angle = w * z; // compare with previous vector
		if (angle > 1.0) angle = 1.0;
		if (angle < -1.0) angle = -1.0;
		angle = acos(angle) / PI * 180; // angle in [0, 180]
		//TRACE("angle = %.3f\n", angle);
		if ( angle < angle_thres1  ) { // the angle between two vectors is between [0, 30]
			step_size1 = step_size; 
		}
		else if ( angle > angle_thres2  ) { // the angle between two vectors is between [150, 180]
			step_size1 = -step_size; // reverse the moving direction!
		}
		else break; // too much turn. Stop advancing!
		*/
		//////////////////////////////////////////////////
		// Angle computation
		l_i = d_i + -w[1] * half1; // left perpendicular
		l_j = d_j + w[0] * half1; // left perpendicular
		r_i = d_i + w[1] * half1; // right perpendicular
		r_j = d_j + -w[0] * half1; // right perpendicular
		for (i = -half1; i <= half1; i++) {
			index = ABS(i);
			t = (half1 - index) / (double)half1; // [0, 1]
			if (i <= 0) {
				xx = round( (1-t) * l_i + t * d_i );
				yy = round( (1-t) * l_j + t * d_j );
			}
			else {
				xx = round( (1-t) * r_i + t * d_i );
				yy = round( (1-t) * r_j + t * d_j );
			}
			if (xx < 0) xx = 0;
			if (xx > IMAGE_X-1) xx = IMAGE_X-1;
			if (yy < 0) yy = 0;
			if (yy > IMAGE_Y-1) yy = IMAGE_Y-1;
			weight = GAU1[index];
			sum1 += image[xx][yy] * weight;
			w_sum1 += weight;
		}
		/////////////////////////////////////////
		count++;
		//////////////////////////////////
		//dc.SetPixelV(int_i, IMAGE_Y-1-int_j, RGB(r, g, b));
		//////////////////////////////
		d_i += w[0] * step_size1; // advance
		d_j += w[1] * step_size1; 
		//d_i += v[0] * step_size1; // advance
		//d_j += v[1] * step_size1; 
        ///////////////////////////
		/////////////////////////////////////////
		int_i = round(d_i); // integer version of new location x
		int_j = round(d_j); // integer version of new location y
		if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		///////////////////////////////////
		z[0] = w[0] * step_size1;
		z[1] = w[1] * step_size1;
	}
	/*
	///////////////////////////////////////
	// other half
	d_i = (double)x; d_j = (double)y; 
	int_i = x;	int_j = y;
	z[0] = gfield[int_i][int_j].gy; // opposite direction!
	z[1] = -gfield[int_i][int_j].gx;
	for (k = 0; k < half_l1; k++) {
		w[0] = gfield[int_i][int_j].gy;
		w[1] = -gfield[int_i][int_j].gx;
		if (w[0] == 0.0 && w[1] == 0.0) break;
		w.make_unit();
		////////////////////////////////
		angle = w * z; // compare with previous vector
		if (angle > 1.0) angle = 1.0;
		if (angle < -1.0) angle = -1.0;
		angle = acos(angle) / PI * 180; // angle in [0, 180]
		//TRACE("angle = %.3f\n", angle);
		if ( angle < angle_thres1  ) { // the angle between two vectors is between [0, 30]
			step_size2 = step_size; 
		}
		else if ( angle > angle_thres2  ) { // the angle between two vectors is between [150, 180]
			step_size2 = -step_size; // reverse the moving direction!
		}
		else break; // too much turn. Stop advancing!
		//////////////////////////////////////////////////
		// Angle computation
		l_i = d_i + -w[1] * half1; // left perpendicular
		l_j = d_j + w[0] * half1; // left perpendicular
		r_i = d_i + w[1] * half1; // right perpendicular
		r_j = d_j + -w[0] * half1; // right perpendicular
		for (i = -half1; i <= half1; i++) {
			index = ABS(i);
			t = (half1 - index) / (double)half1;
			if (i <= 0) {
				xx = round( (1-t) * l_i + t * d_i );
				yy = round( (1-t) * l_j + t * d_j );
			}
			else {
				xx = round( (1-t) * r_i + t * d_i );
				yy = round( (1-t) * r_j + t * d_j );
			}
			if (xx < 0) xx = 0;
			if (xx > IMAGE_X-1) xx = IMAGE_X-1;
			if (yy < 0) yy = 0;
			if (yy > IMAGE_Y-1) yy = IMAGE_Y-1;
			if (k != 0) { // SKIP THE START PIXEL (already computed above!)
				weight = GAU1[index];
				sum1 += image[xx][yy] * weight;
				w_sum1 += weight;
			}
		}
		/////////////////////////////////////////
		count++;
		//////////////////////////////////
		//dc.SetPixelV(int_i, IMAGE_Y-1-int_j, RGB(r, g, b));
		//////////////////////////////
		d_i += w[0] * step_size2; // advance
		d_j += w[1] * step_size2; 
        ///////////////////////////
		//if (round(d_i) == int_i && round(d_j) == int_j) // no change
		//	continue; // push some more
		/////////////////////////////////////////
		int_i = round(d_i); // integer version of new location x
		int_j = round(d_j); // integer version of new location y
		if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		///////////////////////////////////
		z[0] = w[0] * step_size2;
		z[1] = w[1] * step_size2;
	}
	*/
	sum1 /= w_sum1; // normalize
	////////////////////////////////////////////////////

	/////////////////////////////////////////////////
	// OUTSIDE FLOW DOG
	////////////////////////////////////
	count = 0; // number of pixels traversed
	sum2 = 0.0;
	w_sum2 = 0.0;
	////////////////////////////////////////////////
	// One half
	d_i = (double)x; d_j = (double)y; 
	int_i = x;	int_j = y;
	v[0] = z[0] = -gfield[int_i][int_j].gy;
	v[1] = z[1] = gfield[int_i][int_j].gx;
	for (k = 0; k < half_l2; k++) {
		w[0] = -gfield[int_i][int_j].gy;
		w[1] = gfield[int_i][int_j].gx;
		if (w[0] == 0.0 && w[1] == 0.0) break;
		w.make_unit();
		////////////////////////////////
		/*
		angle = w * z; // compare with previous vector
		if (angle > 1.0) angle = 1.0;
		if (angle < -1.0) angle = -1.0;
		angle = acos(angle) / PI * 180; // angle in [0, 180]
		//TRACE("angle = %.3f\n", angle);
		if ( angle < angle_thres1  ) { // the angle between two vectors is between [0, 30]
			step_size1 = step_size; 
		}
		else if ( angle > angle_thres2  ) { // the angle between two vectors is between [150, 180]
			step_size1 = -step_size; // reverse the moving direction!
		}
		else break; // too much turn. Stop advancing!
		*/
		//////////////////////////////////////////////////
		// Angle computation
		l_i = d_i + -w[1] * half2; // left perpendicular
		l_j = d_j + w[0] * half2; // left perpendicular
		r_i = d_i + w[1] * half2; // right perpendicular
		r_j = d_j + -w[0] * half2; // right perpendicular
		for (i = -half2; i <= half2; i++) {
			index = ABS(i);
			t = (half2 - index) / (double)half2;
			if (i <= 0) {
				xx = round( (1-t) * l_i + t * d_i );
				yy = round( (1-t) * l_j + t * d_j );
			}
			else {
				xx = round( (1-t) * r_i + t * d_i );
				yy = round( (1-t) * r_j + t * d_j );
			}
			if (xx < 0) xx = 0;
			if (xx > IMAGE_X-1) xx = IMAGE_X-1;
			if (yy < 0) yy = 0;
			if (yy > IMAGE_Y-1) yy = IMAGE_Y-1;
			////////////////////////////
			weight = GAU2[index];
			sum2 += image[xx][yy] * weight;
			w_sum2 += weight;
		}
		/////////////////////////////////////////
		count++;
		//////////////////////////////////
		//dc.SetPixelV(int_i, IMAGE_Y-1-int_j, RGB(r, g, b));
		//////////////////////////////
		d_i += w[0] * step_size1; // advance
		d_j += w[1] * step_size1; 
		//d_i += v[0] * step_size1; // advance
		//d_j += v[1] * step_size1; 
        ///////////////////////////
		int_i = round(d_i); // integer version of new location x
		int_j = round(d_j); // integer version of new location y
		if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		///////////////////////////////////
		z[0] = w[0] * step_size1;
		z[1] = w[1] * step_size1;
	}
	/*
	///////////////////////////////////////
	// other half
	d_i = (double)x; d_j = (double)y; 
	int_i = x;	int_j = y;
	z[0] = gfield[int_i][int_j].gy; // opposite direction!
	z[1] = -gfield[int_i][int_j].gx;
	for (k = 0; k < half_l2; k++) {
		w[0] = gfield[int_i][int_j].gy;
		w[1] = -gfield[int_i][int_j].gx;
		if (w[0] == 0.0 && w[1] == 0.0) break;
		w.make_unit();
		////////////////////////////////
		angle = w * z; // compare with previous vector
		if (angle > 1.0) angle = 1.0;
		if (angle < -1.0) angle = -1.0;
		angle = acos(angle) / PI * 180; // angle in [0, 180]
		//TRACE("angle = %.3f\n", angle);
		if ( angle < angle_thres1  ) { // the angle between two vectors is between [0, 30]
			step_size2 = step_size; 
		}
		else if ( angle > angle_thres2  ) { // the angle between two vectors is between [150, 180]
			step_size2 = -step_size; // reverse the moving direction!
		}
		else break; // too much turn. Stop advancing!
		//////////////////////////////////////////////////
		// Angle computation
		l_i = d_i + -w[1] * half2; // left perpendicular
		l_j = d_j + w[0] * half2; // left perpendicular
		r_i = d_i + w[1] * half2; // right perpendicular
		r_j = d_j + -w[0] * half2; // right perpendicular
		for (i = -half2; i <= half2; i++) {
			index = ABS(i);
			t = (half2 - index) / (double)half2;
			if (i <= 0) {
				xx = round( (1-t) * l_i + t * d_i );
				yy = round( (1-t) * l_j + t * d_j );
			}
			else {
				xx = round( (1-t) * r_i + t * d_i );
				yy = round( (1-t) * r_j + t * d_j );
			}
			if (xx < 0) xx = 0;
			if (xx > IMAGE_X-1) xx = IMAGE_X-1;
			if (yy < 0) yy = 0;
			if (yy > IMAGE_Y-1) yy = IMAGE_Y-1;
			if (k != 0) { // SKIP THE START PIXEL (already computed above!)
				weight = GAU2[index];
				sum2 += image[xx][yy] * weight;
				w_sum2 += weight;
			}
		}
		/////////////////////////////////////////
		count++;
		//////////////////////////////////
		//dc.SetPixelV(int_i, IMAGE_Y-1-int_j, RGB(r, g, b));
		//////////////////////////////
		d_i += w[0] * step_size2; // advance
		d_j += w[1] * step_size2; 
        ///////////////////////////
		//if (round(d_i) == int_i && round(d_j) == int_j) // no change
		//	continue; // push some more
		/////////////////////////////////////////
		int_i = round(d_i); // integer version of new location x
		int_j = round(d_j); // integer version of new location y
		if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		///////////////////////////////////
		z[0] = w[0] * step_size2;
		z[1] = w[1] * step_size2;
	}
	*/
	sum2 /= w_sum2; // normalize
	////////////////////////////////////////////////////
	if (sum1 == 0.0 && sum2 == 0.0)
		sum1 = 1.0; // make it a non-edge
	//////////////////////////////////////
	if (sum1 - tau * sum2 > 0) // non edge
		flow_DOG = 1.0; 
	else // edge!
		flow_DOG = 1.0 + tanh(sum1 - tau * sum2);

	return flow_DOG;
}

double GetPointFlowDOG3(int i, int j, imatrix& image, Field& gfield, 
							vector& GAU1, vector& GAU2, vector& GAU3, double tau)
// following the flow, compute the DOG
{
	vector vn(2), vt(2), vt_old(2);
	double x, y, d_x, d_y;
	double weight1, weight2, w_sum1, sum1, sum2, w_sum2;

	int s, i_x, i_y, k;
	int x1, y1, x2, y2;
	double lb, lt, rb, rt;
	double uu, vv, bb, tt, val;
	int dd;

	//int half_l = ker_l / 2 + 1; // half length of the curved kernel
	//double half_w = 1.414; // half width of the curved kernel
	//double half_w = 1.414; // half width of the curved kernel
	//double half_w = 1; // half width of the curved kernel
	//double half_w = ker_w / 2; // half width of the curved kernel
	int half_w1, half_w2, half_l;
	half_w1 = GAU1.getMax()-1;
	half_w2 = GAU2.getMax()-1;
	half_l = GAU3.getMax()-1;
	
	double flow_DOG = 0.0; // flow-based gradient magnitude
	
	double angle, angle_thres1, angle_thres2;
	angle_thres1 = 90;
	angle_thres2 = 180 - angle_thres1;
	//angle_thres2 = 150;

	double step_size, step_size1; 
	//double t;

	step_size = 1.0;
	step_size1 = step_size;
	/////////////////////////////////////////////////
	// INSIDE and OUTSIDE FLOW DOG
	////////////////////////////////////
	//count = 0; // number of pixels traversed
	sum1 = sum2 = 0.0;
	w_sum1 = w_sum2 = 0.0;
	weight1 = weight2 = 0.0;
	////////////////////////////////////////////////
	// One half
	d_x = (double)i; d_y = (double)j; 
	i_x = i; i_y = j;
	//v[0] = z[0] = -gfield[int_i][int_j].gy;
	//v[1] = z[1] = gfield[int_i][int_j].gx;
	vt_old[0] = -gfield[i_x][i_y].gy;
	vt_old[1] = gfield[i_x][i_y].gx;
	for (k = 0; k < half_l; k++) {
		vn[0] = gfield[i_x][i_y].gx;
		vn[1] = gfield[i_x][i_y].gy;
		if (vn[0] == 0.0 && vn[1] == 0.0) break;
		vn.make_unit();
		vt[0] = -gfield[i_x][i_y].gy;
		vt[1] = gfield[i_x][i_y].gx;
		vt.make_unit();
		//////////////////////////////////////////////////////
		angle = vt * vt_old;
		if (angle > 1.0) angle = 1.0;
		if (angle < -1.0) angle = -1.0;
		angle = acos(angle) / PI * 180; // angle in [0, 180]
		//TRACE("angle = %.3f\n", angle);
		if ( angle <= angle_thres1  ) { // the angle between two vectors is between [0, 90]
			step_size1 = step_size; 
		}
		else if ( angle > angle_thres2  ) { // the angle between two vectors is between (90, 180]
		//if ( angle > angle_thres2  ) { // the angle between two vectors is between (150, 180]
			step_size1 = -step_size; // reverse the moving direction!
		}
		////////////////////////////////////////
		for (s = -half_w2; s <= half_w2; s++) { // width of Gaussian kernel
			////////////////////////
			x = d_x + vn[0] * s;
			y = d_y + vn[1] * s;
			/////////////////////////////////////////////////////
			if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
				continue;
			/////////////////////////////////////////////////
			// BILINEAR INTERPOLATION!
			x1 = (int)x;	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
			x2 = (int)x+1;	if (x2 < 0) x2 = 0; if (x2 > IMAGE_X-1) x2 = IMAGE_X-1;
			y1 = (int)y;	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
			y2 = (int)y+1;	if (y2 < 0) y2 = 0; if (y2 > IMAGE_Y-1) y2 = IMAGE_Y-1;
			lb = (double)image[x1][y1];
			rb = (double)image[x2][y1];
			lt = (double)image[x1][y2];
			rt = (double)image[x2][y2];
			uu = x - x1;
			vv = y - y1;
			bb = (1-uu) * lb + uu * rb;
			tt = (1-uu) * lt + uu * rt;
			val = (1-vv) * bb + vv * tt;
			/////////////////////////////////////////////////////////
			dd = ABS(s);
			if (dd > half_w1) weight1 = 0.0;
			else weight1 = GAU1[dd];
			weight1 *= GAU3[k];
			sum1 += val * weight1;
			w_sum1 += weight1;
			//d3 = round( ABS(val - c_val) );
			//weight *= GAU3[d3];
			/////////////////////////////////////////////////////
			weight2 = GAU2[dd];
			weight2 *= GAU3[k];
			sum2 += val * weight2;
			w_sum2 += weight2;
		}
		/////////////////////////////////////////
		d_x += vt[0] * step_size1; // accurate new location x
		d_y += vt[1] * step_size1; // accurate new location y
		/////////////////////////////////////////
		i_x = round(d_x); // integer version of new location x
		i_y = round(d_y); // integer version of new location y
		//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
		/////////////////////////
		vt_old.copy(vt);
	}
	////////////////////////////////////////////////
	// Other half
	d_x = (double)i; d_y = (double)j; 
	i_x = i; i_y = j;
	vt_old[0] = gfield[i_x][i_y].gy;
	vt_old[1] = -gfield[i_x][i_y].gx;
	for (k = 0; k < half_l; k++) {
		vn[0] = gfield[i_x][i_y].gx;
		vn[1] = gfield[i_x][i_y].gy;
		if (vn[0] == 0.0 && vn[1] == 0.0) break;
		vn.make_unit();
		vt[0] = gfield[i_x][i_y].gy;
		vt[1] = -gfield[i_x][i_y].gx;
		vt.make_unit();
		//////////////////////////////////////////////////////
		angle = vt * vt_old;
		if (angle > 1.0) angle = 1.0;
		if (angle < -1.0) angle = -1.0;
		angle = acos(angle) / PI * 180; // angle in [0, 180]
		//TRACE("angle = %.3f\n", angle);
		if ( angle <= angle_thres1  ) { // the angle between two vectors is between [0, 90]
			step_size1 = step_size; 
		}
		else if ( angle > angle_thres2  ) { // the angle between two vectors is between (90, 180]
			step_size1 = -step_size; // reverse the moving direction!
		}
		//if ( angle > angle_thres2  ) { // the angle between two vectors is between (150, 180]
		//	step_size1 = -step_size; // reverse the moving direction!
		//}
		////////////////////////////////////
		for (s = -half_w2; s <= half_w2; s++) { // width of Gaussian kernel
			////////////////////////
			x = d_x + vn[0] * s;
			y = d_y + vn[1] * s;
			/////////////////////////////////////////////////////
			if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
				continue;
			/////////////////////////////////////////////////
			// BILINEAR INTERPOLATION!
			x1 = (int)x;	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
			x2 = (int)x+1;	if (x2 < 0) x2 = 0; if (x2 > IMAGE_X-1) x2 = IMAGE_X-1;
			y1 = (int)y;	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
			y2 = (int)y+1;	if (y2 < 0) y2 = 0; if (y2 > IMAGE_Y-1) y2 = IMAGE_Y-1;
			lb = (double)image[x1][y1];
			rb = (double)image[x2][y1];
			lt = (double)image[x1][y2];
			rt = (double)image[x2][y2];
			uu = x - x1;
			vv = y - y1;
			bb = (1-uu) * lb + uu * rb;
			tt = (1-uu) * lt + uu * rt;
			val = (1-vv) * bb + vv * tt;
			/////////////////////////////////////////////////////////
			dd = ABS(s);
			if (dd > half_w1) weight1 = 0.0;
			else weight1 = GAU1[dd];
			sum1 += val * weight1;
			w_sum1 += weight1;
			//d3 = round( ABS(val - c_val) );
			//weight *= GAU3[d3];
			/////////////////////////////////////////////////////
			weight2 = GAU2[dd];
			sum2 += val * weight2;
			w_sum2 += weight2;
		}
		/////////////////////////////////////////
		d_x += vt[0] * step_size1; // accurate new location x
		d_y += vt[1] * step_size1; // accurate new location y
		/////////////////////////////////////////
		i_x = round(d_x); // integer version of new location x
		i_y = round(d_y); // integer version of new location y
		//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
		/////////////////////////
		vt_old.copy(vt);
	}
	sum1 /= w_sum1; // normalize
	sum2 /= w_sum2; // normalize
	////////////////////////////////////////////////////
	if (sum1 == 0.0 && sum2 == 0.0)
		sum1 = 1.0; // make it a non-edge
	//////////////////////////////////////
	if (sum1 - tau * sum2 > 0) // non edge
		flow_DOG = 1.0; 
	else // edge!
		flow_DOG = 1.0 + tanh(sum1 - tau * sum2);

	return flow_DOG;
	
}

double GetPointFlowDOG4(int i, int j, imatrix& image, Field& gfield, 
							vector& GAU1, vector& GAU2, vector& GAU3, double tau)
// following the flow, compute the DOG
// but do not adjust GVF directions! Just follow it!
{
	vector vn(2), vt(2), vt_old(2);
	double x, y, d_x, d_y;
	double weight1, weight2, w_sum1, sum1, sum2, w_sum2;

	int s, i_x, i_y, k;
	int x1, y1;
	//int x2, y2;
	//double lb, lt, rb, rt;
	//double uu, vv, bb, tt;
	int dd;
	double val, c_val;

	int half_w1, half_w2, half_l;
	half_w1 = GAU1.getMax()-1;
	half_w2 = GAU2.getMax()-1;
	half_l = GAU3.getMax()-1;
	
	double flow_DOG = 0.0; // flow-based gradient magnitude
	
	//double angle, angle_thres1, angle_thres2;
	//angle_thres1 = 90;
	//angle_thres2 = 180 - angle_thres1;

	double step_size, step_size1; 
	//double t;

	step_size = 1.0;
	//step_size = 2.0;
	step_size1 = step_size;
	/////////////////////////////////////////////////
	// INSIDE and OUTSIDE FLOW DOG
	////////////////////////////////////
	//count = 0; // number of pixels traversed
	sum1 = sum2 = 0.0;
	w_sum1 = w_sum2 = 0.0;
	weight1 = weight2 = 0.0;
	////////////////////////////////////////////////
	// One half
	d_x = (double)i; d_y = (double)j; 
	i_x = i; i_y = j;
	//////////////////////////
	c_val = image[i_x][i_y];
	weight1 = GAU1[0];
	weight1 *= GAU3[0];
	sum1 += c_val * weight1;
	w_sum1 += weight1;
	weight2 = GAU2[0];
	weight2 *= GAU3[0];
	sum2 += c_val * weight2;
	w_sum2 += weight2;
	////////////////////////////
	for (k = 0; k < half_l; k++) {
		vn[0] = gfield[i_x][i_y].gx;
		vn[1] = gfield[i_x][i_y].gy;
		if (vn[0] == 0.0 && vn[1] == 0.0) break;
		vn.make_unit();
		vt[0] = -gfield[i_x][i_y].gy;
		vt[1] = gfield[i_x][i_y].gx;
		vt.make_unit();
		////////////////////////////////////////
		for (s = -half_w2; s <= half_w2; s++) { // width of Gaussian kernel
			////////////////////////
			x = d_x + vn[0] * s;
			y = d_y + vn[1] * s;
			/////////////////////////////////////////////////////
			if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
				continue;
			x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
			y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
			val = image[x1][y1];
			/////////////////////////////////////////////////////////
			dd = ABS(s);
			if (dd > half_w1) weight1 = 0.0;
			else weight1 = GAU1[dd];
			//////////////////////////////////
			// The following Gaussian smoothing along main axis is essential for good quality!
			weight1 *= GAU3[k]; 
			////////////////////
			sum1 += val * weight1;
			w_sum1 += weight1;
			//d3 = round( ABS(val - c_val) );
			/////////////////////////////////////////////////////
			weight2 = GAU2[dd];
			weight2 *= GAU3[k];
			sum2 += val * weight2;
			w_sum2 += weight2;
		}
		/////////////////////////////////////////
		d_x += vt[0] * step_size1; // accurate new location x
		d_y += vt[1] * step_size1; // accurate new location y
		/////////////////////////////////////////
		i_x = round(d_x); // integer version of new location x
		i_y = round(d_y); // integer version of new location y
		//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
		/////////////////////////
	}
	////////////////////////////////////////////////
	// Other half
	d_x = (double)i; d_y = (double)j; 
	i_x = i; i_y = j;
	for (k = 0; k < half_l; k++) {
		vn[0] = gfield[i_x][i_y].gx;
		vn[1] = gfield[i_x][i_y].gy;
		if (vn[0] == 0.0 && vn[1] == 0.0) break;
		vn.make_unit();
		vt[0] = gfield[i_x][i_y].gy;
		vt[1] = -gfield[i_x][i_y].gx;
		vt.make_unit();
		////////////////////////////////////
		for (s = -half_w2; s <= half_w2; s++) { // width of Gaussian kernel
			////////////////////////
			x = d_x + vn[0] * s;
			y = d_y + vn[1] * s;
			/////////////////////////////////////////////////////
			if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
				continue;
			x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
			y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
			val = image[x1][y1];
			/////////////////////////////////////////////////////////
			dd = ABS(s);
			if (dd > half_w1) weight1 = 0.0;
			else weight1 = GAU1[dd];
			weight1 *= GAU3[k];
			sum1 += val * weight1;
			w_sum1 += weight1;
			//d3 = round( ABS(val - c_val) );
			/////////////////////////////////////////////////////
			weight2 = GAU2[dd];
			weight2 *= GAU3[k];
			sum2 += val * weight2;
			w_sum2 += weight2;
		}
		/////////////////////////////////////////
		d_x += vt[0] * step_size1; // accurate new location x
		d_y += vt[1] * step_size1; // accurate new location y
		/////////////////////////////////////////
		i_x = round(d_x); // integer version of new location x
		i_y = round(d_y); // integer version of new location y
		//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
		/////////////////////////
	}
	sum1 /= w_sum1; // normalize
	sum2 /= w_sum2; // normalize
	////////////////////////////////////////////////////
	if (sum1 == 0.0 && sum2 == 0.0)
		sum1 = 1.0; // make it a non-edge
	//////////////////////////////////////
	if (sum1 - tau * sum2 > 0) // non edge
		flow_DOG = 1.0; 
	else // edge!
		flow_DOG = 1.0 + tanh(sum1 - tau * sum2);

	return flow_DOG;
	
}

inline void EndTimer(char *filename)
{
	ofstream outfile;

	outfile.open(filename, ios::app);
	outfile << fixed << setprecision(1);
	outfile << "Elapsed Time = " << ElapsedTime() << endl;
	outfile.close();
}

void GetFlowDOG4(imatrix& image, Field& gfield, imatrix& image2, matrix& G_mag, 
			  double sigma, double sigma3, double tau) 
// Separate version: FAST!
{
	int	i, j;
	double MAX_DOG = -1.0;
	//int s, t;
	//int x, y;

	vector vn(2), vt(2), vt_old(2);
	//double x, y, d_x, d_y;

	//int s, i_x, i_y, k;
	//int x1, y1;
	//int dd;
	//double val;

	double flow_DOG = 0.0; // flow-based gradient magnitude
	
	//double angle, angle_thres1, angle_thres2;
	//angle_thres1 = 90;
	//angle_thres2 = 180 - angle_thres1;

	double step_size, step_size1; 
	//double t;

	step_size = 1.0;
	//step_size = 2.0;
	step_size1 = step_size;

    int image_x = image.getRow();
	int image_y = image.getCol();

	//int half1, half2; // small window and big window
	//int index1, index2; // index for Gaussian matrix
	//double sum1, sum2, w_sum1, w_sum2;

	//////////////////////////////////////////////
	//double factor = 2.0;
	//MakeGaussMatrix(factor, GAU); // factor controls the Gaussian window size for each index
	vector GAU1, GAU2, GAU3;
	MakeGaussVector(sigma, GAU1); // entire inner circle
	MakeGaussVector(sigma*1.6, GAU2); // entire outer circle

	int half_w1, half_w2, half_l;
	half_w1 = GAU1.getMax()-1;
	half_w2 = GAU2.getMax()-1;
	
	//double factor = 3.0;
	//MakeGaussVector(sigma*factor, GAU3); // flow length
	MakeGaussVector(sigma3, GAU3); // flow length
	half_l = GAU3.getMax()-1;
	
	//int half_l = round( half_w1 * factor );

	TRACE("FDOG\n");
	TRACE("half_w1 = %d\n", half_w1);
	TRACE("half_w2 = %d\n", half_w2);
	TRACE("half_l = %d\n", half_l);

	matrix tmp(image_x, image_y);
	//tmp.zero();

	matrix dog(image_x, image_y);
	//tmp.zero();

	//StartTimer();
	//GetFlowShockDoG(gray, gfield, dog, GAU1, GAU2, tau);
	GetFlowShockDoG2(gray, gfield, dog, GAU1, GAU2, tau);
	//TRACE("DoG computation ended\n");
	//GetFlowDoGMainAxis(gfield, dog, tmp, GAU3);
	GetFlowDoGMainAxis2(gfield, dog, tmp, GAU3);
	//TRACE("Influence computation ended\n");
	//EndTimer("_Result_FDOG.txt");

	//TRACE("Elapsed Time = %f\n", ElapsedTime());
	////////////////////////////////////////////

	// Normalize DOG value (not necessary! - MAX_DOG is always 1)
	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			//TRACE("p[%d][%d].mag = %0.3f\n", i, j, p[i][j].mag);
			//tmp[i][j] = tmp[i][j] / MAX_DOG; // place it between [0, 1]
			G_mag[i][j] = 1-tmp[i][j]; // used for nonmaxima suppression
			//TRACE("G_mag[%d][%d] = %.1f\n", i, j, G_mag[i][j]);
			//TRACE("tmp[%d][%d] = %0.3f\n", i, j, tmp[i][j]);
			//TRACE("G_mag[%d][%d] = %0.3f\n", i, j, G_mag[i][j]);
			if (tmp[i][j] < 0)
				TRACE("tmp[%d][%d] = %0.2f\n", i, j, tmp[i][j]);
			image2[i][j] = round(tmp[i][j] * 255.);
			//image2[i][j] = 255 - round(tmp[i][j] * 255.);
		}
	}
}

void GetFlowDOG2(imatrix& image, Field& gfield, imatrix& image2, matrix& G_mag, 
			  double sigma, double sigma3, double tau) 
// Flow DOG
{
	int	i, j;
	double MAX_DOG = -1.0;
	//int s, t;
	//int x, y;

    int image_x = image.getRow();
	int image_y = image.getCol();

	//int half1, half2; // small window and big window
	//int index1, index2; // index for Gaussian matrix
	//double sum1, sum2, w_sum1, w_sum2;

	//////////////////////////////////////////////
	//double factor = 2.0;
	//MakeGaussMatrix(factor, GAU); // factor controls the Gaussian window size for each index
	vector GAU1, GAU2, GAU3;
	MakeGaussVector(sigma, GAU1); // entire inner circle
	MakeGaussVector(sigma*1.6, GAU2); // entire outer circle

	int half_w1, half_w2, half_l;
	half_w1 = GAU1.getMax()-1;
	half_w2 = GAU2.getMax()-1;
	
	//double factor = 3.0;
	//MakeGaussVector(sigma*factor, GAU3); // flow length
	MakeGaussVector(sigma3, GAU3); // flow length
	half_l = GAU3.getMax()-1;
	
	//int half_l = round( half_w1 * factor );

	TRACE("half_w1 = %d\n", half_w1);
	TRACE("half_w2 = %d\n", half_w2);
	TRACE("half_l = %d\n", half_l);

	matrix tmp(image_x, image_y);
	//tmp.zero();

	//StartTimer();
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//index = gray2[i][j];
			//tmp[i][j] = GetPointFlowDOG(i, j, image, gfield, GAU1, GAU2, tau);
			//tmp[i][j] = GetPointFlowDOG3(i, j, image, gfield, GAU1, GAU2, GAU3, tau);
			tmp[i][j] = GetPointFlowDOG4(i, j, image, gfield, GAU1, GAU2, GAU3, tau);
		}
	}
	//TRACE("Elapsed Time = %f\n", ElapsedTime());
	////////////////////////////////////////////

	// Normalize DOG value (not necessary! - MAX_DOG is always 1)
	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			//TRACE("p[%d][%d].mag = %0.3f\n", i, j, p[i][j].mag);
			//tmp[i][j] = tmp[i][j] / MAX_DOG; // place it between [0, 1]
			G_mag[i][j] = 1-tmp[i][j]; // used for nonmaxima suppression
			//TRACE("G_mag[%d][%d] = %.1f\n", i, j, G_mag[i][j]);
			//TRACE("tmp[%d][%d] = %0.3f\n", i, j, tmp[i][j]);
			//TRACE("G_mag[%d][%d] = %0.3f\n", i, j, G_mag[i][j]);
			if (tmp[i][j] < 0)
				TRACE("tmp[%d][%d] = %0.2f\n", i, j, tmp[i][j]);
			image2[i][j] = round(tmp[i][j] * 255.);
			//image2[i][j] = 255 - round(tmp[i][j] * 255.);
		}
	}
}

void GetFlowDOG2_speedcheck(imatrix& image, Field& gfield, imatrix& image2, matrix& G_mag, 
			  double sigma, double sigma3, double tau) 
// Flow DOG
{
	int	i, j;
	double MAX_DOG = -1.0;
	//int s, t;
	//int x, y;

    int image_x = image.getRow();
	int image_y = image.getCol();

	//int half1, half2; // small window and big window
	//int index1, index2; // index for Gaussian matrix
	//double sum1, sum2, w_sum1, w_sum2;

	//////////////////////////////////////////////
	//double factor = 2.0;
	//MakeGaussMatrix(factor, GAU); // factor controls the Gaussian window size for each index
	vector GAU1, GAU2, GAU3;
	MakeGaussVector(sigma, GAU1); // entire inner circle
	MakeGaussVector(sigma*1.6, GAU2); // entire outer circle

	int half_w1, half_w2, half_l;
	half_w1 = GAU1.getMax()-1;
	half_w2 = GAU2.getMax()-1;
	
	//double factor = 3.0;
	//MakeGaussVector(sigma*factor, GAU3); // flow length
	MakeGaussVector(sigma3, GAU3); // flow length
	half_l = GAU3.getMax()-1;
	
	//int half_l = round( half_w1 * factor );

	TRACE("half_w1 = %d\n", half_w1);
	TRACE("half_w2 = %d\n", half_w2);
	TRACE("half_l = %d\n", half_l);

	matrix tmp(image_x, image_y);
	//tmp.zero();

	StartTimer();
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//index = gray2[i][j];
			//tmp[i][j] = GetPointFlowDOG(i, j, image, gfield, GAU1, GAU2, tau);
			//tmp[i][j] = GetPointFlowDOG3(i, j, image, gfield, GAU1, GAU2, GAU3, tau);
			tmp[i][j] = GetPointFlowDOG4(i, j, image, gfield, GAU1, GAU2, GAU3, tau);
		}
	}
	ofstream outfile;
	outfile.open("Result_FDOG.txt", ios::app);
	outfile << fixed << setprecision(1);
	outfile << "Elapsed Time = " << ElapsedTime() << endl;
	outfile << "half_w1 = " << half_w1 << endl;
	outfile << "half_w2 = " << half_w2 << endl;
	outfile << "half_l = " << half_l << endl;
	outfile.close();
	exit(1);
	//TRACE("Elapsed Time = %f\n", ElapsedTime());
	////////////////////////////////////////////

	// Normalize DOG value (not necessary! - MAX_DOG is always 1)
	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			//TRACE("p[%d][%d].mag = %0.3f\n", i, j, p[i][j].mag);
			//tmp[i][j] = tmp[i][j] / MAX_DOG; // place it between [0, 1]
			G_mag[i][j] = 1-tmp[i][j]; // used for nonmaxima suppression
			//TRACE("G_mag[%d][%d] = %.1f\n", i, j, G_mag[i][j]);
			//TRACE("tmp[%d][%d] = %0.3f\n", i, j, tmp[i][j]);
			//TRACE("G_mag[%d][%d] = %0.3f\n", i, j, G_mag[i][j]);
			if (tmp[i][j] < 0)
				TRACE("tmp[%d][%d] = %0.2f\n", i, j, tmp[i][j]);
			image2[i][j] = round(tmp[i][j] * 255.);
			//image2[i][j] = 255 - round(tmp[i][j] * 255.);
		}
	}
}

void GetFlowDOG3(imatrix& image, Field& gfield, imatrix& image2, matrix& G_mag, 
			  double sigma, double sigma3, double tau) 
// Flow DOG, Adjust GVF direction!
{
	int	i, j;
	double MAX_DOG = -1.0;
	//int s, t;
	//int x, y;

    int image_x = image.getRow();
	int image_y = image.getCol();

	//int half1, half2; // small window and big window
	//int index1, index2; // index for Gaussian matrix
	//double sum1, sum2, w_sum1, w_sum2;

	//////////////////////////////////////////////
	//double factor = 2.0;
	//MakeGaussMatrix(factor, GAU); // factor controls the Gaussian window size for each index
	vector GAU1, GAU2, GAU3;
	MakeGaussVector(sigma, GAU1); // entire inner circle
	MakeGaussVector(sigma*1.6, GAU2); // entire outer circle

	int half_w1, half_w2, half_l;
	half_w1 = GAU1.getMax()-1;
	half_w2 = GAU2.getMax()-1;
	
	//double factor = 3.0;
	//MakeGaussVector(sigma*factor, GAU3); // flow length
	MakeGaussVector(sigma3, GAU3); // flow length
	half_l = GAU3.getMax()-1;
	
	//int half_l = round( half_w1 * factor );

	TRACE("half_w1 = %d\n", half_w1);
	TRACE("half_w2 = %d\n", half_w2);
	TRACE("half_l = %d\n", half_l);

	matrix tmp(image_x, image_y);
	//tmp.zero();

	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//index = gray2[i][j];
			//tmp[i][j] = GetPointFlowDOG(i, j, image, gfield, GAU1, GAU2, tau);
			tmp[i][j] = GetPointFlowDOG3(i, j, image, gfield, GAU1, GAU2, GAU3, tau);
		}
	}
	////////////////////////////////////////////

	// Normalize DOG value (not necessary! - MAX_DOG is always 1)
	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			//TRACE("p[%d][%d].mag = %0.3f\n", i, j, p[i][j].mag);
			//tmp[i][j] = tmp[i][j] / MAX_DOG; // place it between [0, 1]
			G_mag[i][j] = 1-tmp[i][j]; // used for nonmaxima suppression
			//TRACE("G_mag[%d][%d] = %.1f\n", i, j, G_mag[i][j]);
			//TRACE("tmp[%d][%d] = %0.3f\n", i, j, tmp[i][j]);
			//TRACE("G_mag[%d][%d] = %0.3f\n", i, j, G_mag[i][j]);
			if (tmp[i][j] < 0)
				TRACE("tmp[%d][%d] = %0.2f\n", i, j, tmp[i][j]);
			image2[i][j] = round(tmp[i][j] * 255.);
			//image2[i][j] = 255 - round(tmp[i][j] * 255.);
		}
	}
}

int GetPointFlowMedian2(int i, int j, imatrix& image, Field& gfield, int half_w, int half_l)
// following the flow, compute the DOG
// give weight to pixels (min max filter?)
{
	vector vn(2), vt(2), vt_old(2);
	double x, y, d_x, d_y;
	//double weight1, weight2, w_sum1, sum1, sum2, w_sum2;

	int s, i_x, i_y, k;
	
	//int x2, y2;
	//double lb, lt, rb, rt;
	//double uu, vv, bb, tt, val;
	//int dd;

	int x1, y1, c_val, val;

	deque<int> vec;
	
	int flow_median; // return value
	
	double angle, angle_thres1, angle_thres2;
	angle_thres1 = 90;
	angle_thres2 = 180 - angle_thres1;

	double step_size, step_size1; 
	//double t;

	step_size = 1.0;
	step_size1 = step_size;
	/////////////////////////////////////////////////
	// FLOW MEDIAN
	////////////////////////////////////
	c_val = image[i][j];
	////////////////////////////////////////////////
	// One half
	d_x = (double)i; d_y = (double)j; 
	i_x = i; i_y = j;
	vt_old[0] = -gfield[i_x][i_y].gy;
	vt_old[1] = gfield[i_x][i_y].gx;
	vt_old.make_unit();
	for (k = 0; k <= half_l; k++) {
		vn[0] = gfield[i_x][i_y].gx;
		vn[1] = gfield[i_x][i_y].gy;
		if (vn[0] == 0.0 && vn[1] == 0.0) break;
		vn.make_unit();
		vt[0] = -gfield[i_x][i_y].gy;
		vt[1] = gfield[i_x][i_y].gx;
		vt.make_unit();
		//////////////////////////////////////////////////////
		angle = vt * vt_old;
		if (angle > 1.0) angle = 1.0;
		if (angle < -1.0) angle = -1.0;
		angle = acos(angle) / PI * 180; // angle in [0, 180]
		//TRACE("angle = %.3f\n", angle);
		if ( angle <= angle_thres1  ) { // the angle between two vectors is between [0, 90]
			step_size1 = step_size; 
		}
		else if ( angle > angle_thres2  ) { // the angle between two vectors is between (90, 180]
			step_size1 = -step_size; // reverse the moving direction!
		}
		////////////////////////////////////////
		for (s = -half_w; s <= half_w; s++) { // width of Gaussian kernel
			////////////////////////
			x = d_x + vn[0] * s; // arm
			y = d_y + vn[1] * s;
			/////////////////////////////////////////////////////
			if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
				continue;
			/////////////////////////////////////////////////
			// BILINEAR INTERPOLATION!
			/*
			x1 = (int)x;	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
			x2 = (int)x+1;	if (x2 < 0) x2 = 0; if (x2 > IMAGE_X-1) x2 = IMAGE_X-1;
			y1 = (int)y;	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
			y2 = (int)y+1;	if (y2 < 0) y2 = 0; if (y2 > IMAGE_Y-1) y2 = IMAGE_Y-1;
			lb = (double)image[x1][y1];
			rb = (double)image[x2][y1];
			lt = (double)image[x1][y2];
			rt = (double)image[x2][y2];
			uu = x - x1;
			vv = y - y1;
			bb = (1-uu) * lb + uu * rb;
			tt = (1-uu) * lt + uu * rt;
			val = (1-vv) * bb + vv * tt;
			*/
			x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
			y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
			val = image[x1][y1];
			/////////////////////////////////////////////////////////
			vec.push_back(val);
			//if (val < c_val) {
			//	vec.push_back(val);
			//}
			/////////////////////////////////////////////////////
		}
		/////////////////////////////////////////
		d_x += vt[0] * step_size1; // accurate new location x
		d_y += vt[1] * step_size1; // accurate new location y
		/////////////////////////////////////////
		i_x = round(d_x); // integer version of new location x
		i_y = round(d_y); // integer version of new location y
		//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
		/////////////////////////
		vt_old.copy(vt);
	}
	////////////////////////////////////////////////
	// Other half
	d_x = (double)i; d_y = (double)j; 
	i_x = i; i_y = j;
	vt_old[0] = gfield[i_x][i_y].gy;
	vt_old[1] = -gfield[i_x][i_y].gx;
	vt_old.make_unit();
	for (k = 0; k <= half_l; k++) {
		vn[0] = gfield[i_x][i_y].gx;
		vn[1] = gfield[i_x][i_y].gy;
		if (vn[0] == 0.0 && vn[1] == 0.0) break;
		vn.make_unit();
		vt[0] = gfield[i_x][i_y].gy;
		vt[1] = -gfield[i_x][i_y].gx;
		vt.make_unit();
		//////////////////////////////////////////////////////
		angle = vt * vt_old;
		if (angle > 1.0) angle = 1.0;
		if (angle < -1.0) angle = -1.0;
		angle = acos(angle) / PI * 180; // angle in [0, 180]
		//TRACE("angle = %.3f\n", angle);
		if ( angle <= angle_thres1  ) { // the angle between two vectors is between [0, 90]
			step_size1 = step_size; 
		}
		else if ( angle > angle_thres2  ) { // the angle between two vectors is between (90, 180]
			step_size1 = -step_size; // reverse the moving direction!
		}
		////////////////////////////////////////
		for (s = -half_w; s <= half_w; s++) { // width of Gaussian kernel
			////////////////////////
			x = d_x + vn[0] * s; // arm
			y = d_y + vn[1] * s;
			/////////////////////////////////////////////////////
			if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
				continue;
			/////////////////////////////////////////////////
			// BILINEAR INTERPOLATION!
			/*
			x1 = (int)x;	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
			x2 = (int)x+1;	if (x2 < 0) x2 = 0; if (x2 > IMAGE_X-1) x2 = IMAGE_X-1;
			y1 = (int)y;	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
			y2 = (int)y+1;	if (y2 < 0) y2 = 0; if (y2 > IMAGE_Y-1) y2 = IMAGE_Y-1;
			lb = (double)image[x1][y1];
			rb = (double)image[x2][y1];
			lt = (double)image[x1][y2];
			rt = (double)image[x2][y2];
			uu = x - x1;
			vv = y - y1;
			bb = (1-uu) * lb + uu * rb;
			tt = (1-uu) * lt + uu * rt;
			val = (1-vv) * bb + vv * tt;
			*/
			x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
			y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
			val = image[x1][y1];
			/////////////////////////////////////////////////////////
			vec.push_back(val);
			
			/////////////////////////////////////////////////////
		}
		/////////////////////////////////////////
		d_x += vt[0] * step_size1; // accurate new location x
		d_y += vt[1] * step_size1; // accurate new location y
		/////////////////////////////////////////
		i_x = round(d_x); // integer version of new location x
		i_y = round(d_y); // integer version of new location y
		//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
		/////////////////////////
		vt_old.copy(vt);
	}
	////////////////////////////////////////////
	sort(vec.begin(), vec.end()); 
	//flow_median = vec[vec.size()/2]; 
	flow_median = vec[0]; 
	//for (k = count/2; k > 0; k--) {
	//	if (vec[k] != 255) break;
	//}
	//flow_median = vec[k]; 

	return flow_median;
}

int GetPointFlowMedian3(int i, int j, imatrix& image, Field& gfield, int half_w, int half_l)
// following the perpendicular flow
// give weight to pixels (min max filter?)
{
	vector vn(2), vt(2), vn_old(2);
	double x, y, d_x, d_y;
	//double weight1, weight2, w_sum1, sum1, sum2, w_sum2;

	int s, i_x, i_y, k;
	
	//int x2, y2;
	//double lb, lt, rb, rt;
	//double uu, vv, bb, tt, val;
	//int dd;

	int x1, y1, c_val, val;

	deque<int> vec;
	
	int flow_median; // return value
	
	double angle, angle_thres1, angle_thres2;
	angle_thres1 = 90;
	angle_thres2 = 180 - angle_thres1;

	double step_size, step_size1; 
	//double t;

	step_size = 1.0;
	step_size1 = step_size;
	/////////////////////////////////////////////////
	// FLOW MEDIAN
	////////////////////////////////////
	c_val = image[i][j];
	////////////////////////////////////////////////
	// One half
	d_x = (double)i; d_y = (double)j; 
	i_x = i; i_y = j;
	vn_old[0] = gfield[i_x][i_y].gx;
	vn_old[1] = gfield[i_x][i_y].gy;
	for (k = 0; k <= half_l; k++) {
		vn[0] = gfield[i_x][i_y].gx;
		vn[1] = gfield[i_x][i_y].gy;
		if (vn[0] == 0.0 && vn[1] == 0.0) break;
		vn.make_unit();
		//////////////////////////////////////////////////////
		angle = vn * vn_old;
		if (angle > 1.0) angle = 1.0;
		if (angle < -1.0) angle = -1.0;
		angle = acos(angle) / PI * 180; // angle in [0, 180]
		//TRACE("angle = %.3f\n", angle);
		if ( angle <= angle_thres1  ) { // the angle between two vectors is between [0, 90]
			step_size1 = step_size; 
		}
		else if ( angle > angle_thres2  ) { // the angle between two vectors is between (90, 180]
			step_size1 = -step_size; // reverse the moving direction!
		}
		////////////////////////////////////////
		for (s = -half_w; s <= half_w; s++) { // width of Gaussian kernel
			////////////////////////
			x = d_x + vt[0] * s; // arm
			y = d_y + vt[1] * s;
			/////////////////////////////////////////////////////
			if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
				continue;
			/////////////////////////////////////////////////
			// BILINEAR INTERPOLATION!
			/*
			x1 = (int)x;	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
			x2 = (int)x+1;	if (x2 < 0) x2 = 0; if (x2 > IMAGE_X-1) x2 = IMAGE_X-1;
			y1 = (int)y;	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
			y2 = (int)y+1;	if (y2 < 0) y2 = 0; if (y2 > IMAGE_Y-1) y2 = IMAGE_Y-1;
			lb = (double)image[x1][y1];
			rb = (double)image[x2][y1];
			lt = (double)image[x1][y2];
			rt = (double)image[x2][y2];
			uu = x - x1;
			vv = y - y1;
			bb = (1-uu) * lb + uu * rb;
			tt = (1-uu) * lt + uu * rt;
			val = (1-vv) * bb + vv * tt;
			*/
			x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
			y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
			val = image[x1][y1];
			/////////////////////////////////////////////////////////
			vec.push_back(val);
			//if (val < c_val) {
			//	vec.push_back(val);
			//}
			/////////////////////////////////////////////////////
		}
		/////////////////////////////////////////
		d_x += vn[0] * step_size1; // accurate new location x
		d_y += vn[1] * step_size1; // accurate new location y
		/////////////////////////////////////////
		i_x = round(d_x); // integer version of new location x
		i_y = round(d_y); // integer version of new location y
		//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
		/////////////////////////
		vn_old.copy(vn);
	}
	////////////////////////////////////////////////
	// Other half
	d_x = (double)i; d_y = (double)j; 
	i_x = i; i_y = j;
	vn_old[0] = gfield[i_x][i_y].gx;
	vn_old[1] = gfield[i_x][i_y].gy;
	for (k = 0; k <= half_l; k++) {
		vn[0] = gfield[i_x][i_y].gx;
		vn[1] = gfield[i_x][i_y].gy;
		if (vn[0] == 0.0 && vn[1] == 0.0) break;
		vn.make_unit();
		//////////////////////////////////////////////////////
		angle = vn * vn_old;
		if (angle > 1.0) angle = 1.0;
		if (angle < -1.0) angle = -1.0;
		angle = acos(angle) / PI * 180; // angle in [0, 180]
		//TRACE("angle = %.3f\n", angle);
		if ( angle <= angle_thres1  ) { // the angle between two vectors is between [0, 90]
			step_size1 = step_size; 
		}
		else if ( angle > angle_thres2  ) { // the angle between two vectors is between (90, 180]
			step_size1 = -step_size; // reverse the moving direction!
		}
		////////////////////////////////////////
		for (s = -half_w; s <= half_w; s++) { // width of Gaussian kernel
			////////////////////////
			x = d_x + vt[0] * s; // arm
			y = d_y + vt[1] * s;
			/////////////////////////////////////////////////////
			if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
				continue;
			/////////////////////////////////////////////////
			// BILINEAR INTERPOLATION!
			/*
			x1 = (int)x;	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
			x2 = (int)x+1;	if (x2 < 0) x2 = 0; if (x2 > IMAGE_X-1) x2 = IMAGE_X-1;
			y1 = (int)y;	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
			y2 = (int)y+1;	if (y2 < 0) y2 = 0; if (y2 > IMAGE_Y-1) y2 = IMAGE_Y-1;
			lb = (double)image[x1][y1];
			rb = (double)image[x2][y1];
			lt = (double)image[x1][y2];
			rt = (double)image[x2][y2];
			uu = x - x1;
			vv = y - y1;
			bb = (1-uu) * lb + uu * rb;
			tt = (1-uu) * lt + uu * rt;
			val = (1-vv) * bb + vv * tt;
			*/
			x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
			y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
			val = image[x1][y1];
			/////////////////////////////////////////////////////////
			vec.push_back(val);
			//if (val < c_val) {
			//	vec.push_back(val);
			//}
			/////////////////////////////////////////////////////
		}
		/////////////////////////////////////////
		d_x += vn[0] * step_size1; // accurate new location x
		d_y += vn[1] * step_size1; // accurate new location y
		/////////////////////////////////////////
		i_x = round(d_x); // integer version of new location x
		i_y = round(d_y); // integer version of new location y
		//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
		/////////////////////////
		vn_old.copy(vn);
	}
	////////////////////////////////////////////
	sort(vec.begin(), vec.end()); 
	//flow_median = vec[vec.size()/2]; 
	flow_median = vec[vec.size()-1]; 
	//for (k = count/2; k > 0; k--) {
	//	if (vec[k] != 255) break;
	//}
	//flow_median = vec[k]; 

	return flow_median;
}

int GetPointFlowMedian(int i, int j, imatrix& image, Field& gfield, int half_w, int half_l)
// following the flow, compute the DOG
// give weight to pixels
{
	vector vn(2), vt(2), vt_old(2);
	double x, y, d_x, d_y;
	//double weight1, weight2, w_sum1, sum1, sum2, w_sum2;

	int s, i_x, i_y, k;
	
	//int x2, y2;
	//double lb, lt, rb, rt;
	//double uu, vv, bb, tt, val;
	//int dd;

	int x1, y1, c_val, val;

	deque<int> vec;
	
	int flow_median; // return value
	
	//double angle, angle_thres1, angle_thres2;
	//angle_thres1 = 90;
	//angle_thres2 = 180 - angle_thres1;

	double step_size, step_size1; 
	//double t;

	step_size = 1.0;
	step_size1 = step_size;
	/////////////////////////////////////////////////
	// FLOW MEDIAN
	////////////////////////////////////
	c_val = image[i][j];
	////////////////////////////////////////////////
	// One half
	d_x = (double)i; d_y = (double)j; 
	i_x = i; i_y = j;
	vt_old[0] = -gfield[i_x][i_y].gy;
	vt_old[1] = gfield[i_x][i_y].gx;
	vt_old.make_unit();
	for (k = 0; k <= half_l; k++) {
		vn[0] = gfield[i_x][i_y].gx;
		vn[1] = gfield[i_x][i_y].gy;
		if (vn[0] == 0.0 && vn[1] == 0.0) break;
		vn.make_unit();
		vt[0] = -gfield[i_x][i_y].gy;
		vt[1] = gfield[i_x][i_y].gx;
		vt.make_unit();
		//////////////////////////////////////////////////////
		/*
		angle = vt * vt_old;
		if (angle > 1.0) angle = 1.0;
		if (angle < -1.0) angle = -1.0;
		angle = acos(angle) / PI * 180; // angle in [0, 180]
		//TRACE("angle = %.3f\n", angle);
		if ( angle <= angle_thres1  ) { // the angle between two vectors is between [0, 90]
			step_size1 = step_size; 
		}
		else if ( angle > angle_thres2  ) { // the angle between two vectors is between (90, 180]
			step_size1 = -step_size; // reverse the moving direction!
		}
		//else break;
		*/
		////////////////////////////////////////
		for (s = -half_w; s <= half_w; s++) { // width of Gaussian kernel
			////////////////////////
			x = d_x + vn[0] * s; // arm
			y = d_y + vn[1] * s;
			/////////////////////////////////////////////////////
			if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
				continue;
			x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
			y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
			val = image[x1][y1];
			/////////////////////////////////////////////////////////
			vec.push_back(val);
			/////////////////////////////////////////////////////
		}
		/////////////////////////////////////////
		d_x += vt[0] * step_size1; // accurate new location x
		d_y += vt[1] * step_size1; // accurate new location y
		/////////////////////////////////////////
		i_x = round(d_x); // integer version of new location x
		i_y = round(d_y); // integer version of new location y
		//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
		/////////////////////////
		vt_old.copy(vt);
	}
	////////////////////////////////////////////////
	// Other half
	d_x = (double)i; d_y = (double)j; 
	i_x = i; i_y = j;
	vt_old[0] = gfield[i_x][i_y].gy;
	vt_old[1] = -gfield[i_x][i_y].gx;
	vt_old.make_unit();
	for (k = 0; k <= half_l; k++) {
		vn[0] = gfield[i_x][i_y].gx;
		vn[1] = gfield[i_x][i_y].gy;
		if (vn[0] == 0.0 && vn[1] == 0.0) break;
		vn.make_unit();
		vt[0] = gfield[i_x][i_y].gy;
		vt[1] = -gfield[i_x][i_y].gx;
		vt.make_unit();
		//////////////////////////////////////////////////////
		/*
		angle = vt * vt_old;
		if (angle > 1.0) angle = 1.0;
		if (angle < -1.0) angle = -1.0;
		angle = acos(angle) / PI * 180; // angle in [0, 180]
		//TRACE("angle = %.3f\n", angle);
		if ( angle <= angle_thres1  ) { // the angle between two vectors is between [0, 90]
			step_size1 = step_size; 
		}
		else if ( angle > angle_thres2  ) { // the angle between two vectors is between (90, 180]
			step_size1 = -step_size; // reverse the moving direction!
		}
		//else break;
		*/
		////////////////////////////////////////
		for (s = -half_w; s <= half_w; s++) { // width of Gaussian kernel
			////////////////////////
			x = d_x + vn[0] * s; // arm
			y = d_y + vn[1] * s;
			/////////////////////////////////////////////////////
			if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
				continue;
			x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
			y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
			val = image[x1][y1];
			/////////////////////////////////////////////////////////
			vec.push_back(val);
			/////////////////////////////////////////////////////
		}
		/////////////////////////////////////////
		d_x += vt[0] * step_size1; // accurate new location x
		d_y += vt[1] * step_size1; // accurate new location y
		/////////////////////////////////////////
		i_x = round(d_x); // integer version of new location x
		i_y = round(d_y); // integer version of new location y
		//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
		/////////////////////////
		vt_old.copy(vt);
	}
	////////////////////////////////////////////
	sort(vec.begin(), vec.end()); 
	flow_median = vec[vec.size()/2]; 
	//for (k = count/2; k > 0; k--) {
	//	if (vec[k] != 255) break;
	//}
	//flow_median = vec[k]; 

	return flow_median;
}

void GetFlowMedian(imatrix& image, Field& gfield, imatrix& image2, matrix& G_mag, 
				   int width, int length, int max_itr)
// Flow Median filter!
{
	int	i, j, k;
	double MAX_DOG = -1.0;
	//int s, t;
	//int x, y;

    int image_x = image.getRow();
	int image_y = image.getCol();

	//////////////////////////////////////////////
	//double factor = 2.0;
	//MakeGaussMatrix(factor, GAU); // factor controls the Gaussian window size for each index

	int half_w, half_l;
	half_w = width / 2;
	
	//double factor = 3.0;
    //half_l = round(half_w * factor);
	half_l = length / 2;
	
	TRACE("half_w = %d\n", half_w);
	TRACE("half_l = %d\n", half_l);

	imatrix tmp(image_x, image_y);
	tmp.copy(image);
	
	imatrix tmp2(image_x, image_y);
	//tmp.zero();

	for (k = 0; k < max_itr; k++) {
		/////////////////////////////////////
		// flow-based erosion
		/*
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				////////////////////////////
				//tmp[i][j] = GetPointFlowMedian(i, j, image, gfield, half_w, half_l);
				tmp2[i][j] = GetPointFlowMedian3(i, j, tmp, gfield, 1, 1);
			}
		}
		tmp.copy(tmp2);
		*/
		/////////////////////////////////////
		// flow-based dilation
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				////////////////////////////
				tmp2[i][j] = GetPointFlowMedian(i, j, tmp, gfield, half_w, half_l);
				//tmp2[i][j] = GetPointFlowMedian2(i, j, tmp, gfield, half_w, half_l);
			}
		}
		tmp.copy(tmp2);
	}
	////////////////////////////////////////////

	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			G_mag[i][j] = (255-tmp[i][j]) / 255.; // used for nonmaxima suppression
			if (tmp[i][j] < 0)
				TRACE("tmp[%d][%d] = %0.2f\n", i, j, tmp[i][j]);
			image2[i][j] = tmp[i][j];
		}
	}
}

int GetPointFlowMedianDiffusion(imatrix& image, int i, int j, imatrix& tmp, Field& gfield)
// following the flow, compute median diffusion
// give weight to pixels (min max filter?)
// image: original image, tmp: current image
{
	vector vn(2), vt(2), vt_old(2);
	double x, y, d_x, d_y;
	//double weight1, weight2, w_sum1, sum1, sum2, w_sum2;

	int s, i_x, i_y;

	//int x2, y2;
	//double lb, lt, rb, rt;
	//double uu, vv, bb, tt;
	//int dd;

	double val;

	int x1, y1, c_val;

	deque<int> vec;
	
	int flow_median; // return value
	
	//double angle, angle_thres1, angle_thres2;
	//angle_thres1 = 90;
	//angle_thres2 = 180 - angle_thres1;

	//double step_size, step_size1; 
	//double t;

	//step_size = 1.0;
	//step_size1 = step_size;
	/////////////////////////////////////////////////
	// FLOW MEDIAN
	////////////////////////////////////
	c_val = tmp[i][j];
	vec.push_back(c_val);
	////////////////////////////////////////////////
	d_x = (double)i; d_y = (double)j; 
	i_x = i; i_y = j;
	///////////////////////////
	vn[0] = gfield[i_x][i_y].gx;
	vn[1] = gfield[i_x][i_y].gy;
	if (vn[0] == 0.0 && vn[1] == 0.0) return c_val;
	vn.make_unit();
	vt[0] = -gfield[i_x][i_y].gy;
	vt[1] = gfield[i_x][i_y].gx;
	vt.make_unit();
	////////////////////////////////////////
	for (s = -1; s <= 1; s+=2) { // width of Gaussian kernel
		////////////////////////
		x = d_x + vn[0] * s; // arm
		y = d_y + vn[1] * s;
		/////////////////////////////////////////////////////
		if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
			continue;
		/////////////////////////////////////////////////
		// BILINEAR INTERPOLATION!
		/*
		x1 = (int)x;	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
		x2 = (int)x+1;	if (x2 < 0) x2 = 0; if (x2 > IMAGE_X-1) x2 = IMAGE_X-1;
		y1 = (int)y;	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
		y2 = (int)y+1;	if (y2 < 0) y2 = 0; if (y2 > IMAGE_Y-1) y2 = IMAGE_Y-1;
		lb = (double)tmp[x1][y1];
		rb = (double)tmp[x2][y1];
		lt = (double)tmp[x1][y2];
		rt = (double)tmp[x2][y2];
		uu = x - x1;
		vv = y - y1;
		bb = (1-uu) * lb + uu * rb;
		tt = (1-uu) * lt + uu * rt;
		val = (1-vv) * bb + vv * tt;
		*/
		x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
		y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
		val = tmp[x1][y1];
		/////////////////////////////////////////////////////////
		//if (round(val) < c_val) { // darker than me in normal direction (I'm near edge!)
		if ( image[x1][y1] + image[i][j] == 255) { // one is black another is white
			//return c_val; // stop diffusion
			//continue;
			//vec.push_back(val);
		}
		//vec.push_back(round(val));
		/////////////////////////////////////////////////////
	}
	for (s = -1; s <= 1; s+=2) { // width of Gaussian kernel
		////////////////////////
		x = d_x + vt[0] * s; // arm
		y = d_y + vt[1] * s;
		/////////////////////////////////////////////////////
		if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
			continue;
		/////////////////////////////////////////////////
		// BILINEAR INTERPOLATION!
		/*
		x1 = (int)x;	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
		x2 = (int)x+1;	if (x2 < 0) x2 = 0; if (x2 > IMAGE_X-1) x2 = IMAGE_X-1;
		y1 = (int)y;	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
		y2 = (int)y+1;	if (y2 < 0) y2 = 0; if (y2 > IMAGE_Y-1) y2 = IMAGE_Y-1;
		lb = (double)tmp[x1][y1];
		rb = (double)tmp[x2][y1];
		lt = (double)tmp[x1][y2];
		rt = (double)tmp[x2][y2];
		uu = x - x1;
		vv = y - y1;
		bb = (1-uu) * lb + uu * rb;
		tt = (1-uu) * lt + uu * rt;
		val = (1-vv) * bb + vv * tt;
		*/
		x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
		y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
		val = tmp[x1][y1];
		/////////////////////////////////////////////////////////
		vec.push_back(round(val));
		/////////////////////////////////////////////////////
	}
	////////////////////////////////////////////
	sort(vec.begin(), vec.end()); 
	//flow_median = vec[vec.size()/2]; 
	flow_median = vec[0]; // darkest color
	//for (k = count/2; k > 0; k--) {
	//	if (vec[k] != 255) break;
	//}
	//flow_median = vec[k]; 

	return flow_median;
}

int GetPointFlowMedianDiffusion2(imatrix& image, int i, int j, imatrix& tmp, Field& gfield)
// following the flow, compute median diffusion
// use CURVE EVOLUTION! compute the NORMAL OF THE CURVE!
// image: original image, tmp: current image
{
	vector vn(2), vt(2), vt_old(2), g(2);
	double x, y, d_x, d_y;
	//double weight1, weight2, w_sum1, sum1, sum2, w_sum2;

	int s, i_x, i_y;
	
	//int x2, y2;
	//double lb, lt, rb, rt;
	//double uu, vv, bb, tt;
	//int dd;

	double val;
	int x1, y1, c_val;

	deque<int> vec;
	
	int flow_median; // return value
	double weight;
	
	double angle;
	//double angle_thres1, angle_thres2;
	//angle_thres1 = 90;
	//angle_thres2 = 180 - angle_thres1;

	//double step_size, step_size1; 
	//double t;

	//step_size = 1.0;
	//step_size1 = step_size;
	/////////////////////////////////////////////////
	// FLOW MEDIAN
	////////////////////////////////////
	c_val = tmp[i][j];
	vec.push_back(c_val);
	////////////////////////////////////////
	if (i == IMAGE_X-1 || i == 0 || j == IMAGE_Y-1 || j == 0) 
		return c_val;
	////////////////////////////////////////////////
	d_x = (double)i; d_y = (double)j; 
	i_x = i; i_y = j;
	vn[0] = gfield[i_x][i_y].gx;
	vn[1] = gfield[i_x][i_y].gy;
	if (vn[0] == 0.0 && vn[1] == 0.0) return c_val;
	vn.make_unit();
	vt[0] = -gfield[i_x][i_y].gy;
	vt[1] = gfield[i_x][i_y].gx;
	vt.make_unit();
	/////////////////////////////////////////////////
	g[0] = (double) (tmp[i+1][j-1] + 2*tmp[i+1][j] + tmp[i+1][j+1] 
			- tmp[i-1][j-1] - 2*tmp[i-1][j] - tmp[i-1][j+1]);
	g[1] = (double) (tmp[i-1][j+1] + 2*tmp[i][j+1] + tmp[i+1][j+1]	
			- tmp[i-1][j-1] - 2*tmp[i][j-1] - tmp[i+1][j-1]);
	g.make_unit();
	///////////////////////////////////////////
	angle = vt * g;
	if (angle > 1.0) angle = 1.0;
	if (angle < -1.0) angle = -1.0;
	weight = ABS(angle); 
	//angle = acos(angle) / PI * 180; // angle in [0, 180]
	//TRACE("angle = %f\n", angle);
	//TRACE("weight = %f\n", weight);
	////////////////////////////////////////
	for (s = -1; s <= 1; s+=2) { // width of Gaussian kernel
		////////////////////////
		x = d_x + vt[0] * s; // arm
		y = d_y + vt[1] * s;
		/////////////////////////////////////////////////////
		if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
			continue;
		/////////////////////////////////////////////////
		// BILINEAR INTERPOLATION!
		/*
		x1 = (int)x;	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
		x2 = (int)x+1;	if (x2 < 0) x2 = 0; if (x2 > IMAGE_X-1) x2 = IMAGE_X-1;
		y1 = (int)y;	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
		y2 = (int)y+1;	if (y2 < 0) y2 = 0; if (y2 > IMAGE_Y-1) y2 = IMAGE_Y-1;
		lb = (double)tmp[x1][y1];
		rb = (double)tmp[x2][y1];
		lt = (double)tmp[x1][y2];
		rt = (double)tmp[x2][y2];
		uu = x - x1;
		vv = y - y1;
		bb = (1-uu) * lb + uu * rb;
		tt = (1-uu) * lt + uu * rt;
		val = (1-vv) * bb + vv * tt;
		*/
		x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
		y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
		val = tmp[x1][y1];
		/////////////////////////////////////////////////////////
		vec.push_back(round(val));
		/////////////////////////////////////////////////////
	}
	////////////////////////////////////////////
	sort(vec.begin(), vec.end()); 
	//flow_median = vec[vec.size()/2]; 
	//flow_median = vec[0]; // darkest color
	flow_median = round( weight * vec[0] + (1-weight) * c_val );
	//for (k = count/2; k > 0; k--) {
	//	if (vec[k] != 255) break;
	//}
	//flow_median = vec[k]; 

	return flow_median;
}

void GetFlowMedianDiffusion(imatrix& image, Field& gfield, imatrix& image2, matrix& G_mag, int max_itr)
// Flow Median filter!
// But use anisotropic diffusion!
{
	int	i, j, k;
	double MAX_DOG = -1.0;
	//int s, t;
	//int x, y;

    int image_x = image.getRow();
	int image_y = image.getCol();

	//int half1, half2; // small window and big window
	//int index1, index2; // index for Gaussian matrix
	//double sum1, sum2, w_sum1, w_sum2;

	//////////////////////////////////////////////
	//double factor = 2.0;
	//MakeGaussMatrix(factor, GAU); // factor controls the Gaussian window size for each index

	//int half_w, half_l;
	//half_w = width / 2;
	
	//double factor = 3.0;
    //half_l = round(half_w * factor);
	//half_l = length / 2;
	//TRACE("half_w = %d\n", half_w);
	//TRACE("half_l = %d\n", half_l);

	imatrix tmp(image_x, image_y);
	tmp.copy(image);
	
	imatrix tmp2(image_x, image_y);
	//tmp.zero();

	for (k = 0; k < max_itr; k++) {
		/////////////////////////////////////
		// flow-based diffusion
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				////////////////////////////
				//tmp2[i][j] = GetPointFlowMedianDiffusion(image, i, j, tmp, gfield);
				tmp2[i][j] = GetPointFlowMedianDiffusion2(image, i, j, tmp, gfield);
			}
		}
		tmp.copy(tmp2);
	}
	////////////////////////////////////////////

	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			G_mag[i][j] = (255-tmp[i][j]) / 255.; // used for nonmaxima suppression
			if (tmp[i][j] < 0)
				TRACE("tmp[%d][%d] = %0.2f\n", i, j, tmp[i][j]);
			image2[i][j] = tmp[i][j];
		}
	}
}

void GetOrientedDOG2(imatrix& image, Field& gfield, imatrix& image2, matrix& G_mag, 
			  double sigma, double tau) 
// Oriented DOG (using ellipse)
// G_mag gets the actual real values in [0, 1]
// image2 gets the integer values in [0, 255]
{
	int	i, j;
	double MAX_DOG = -1.0;
	int s, t;
	int x, y;

	int image_x = image.getRow();
	int image_y = image.getCol();

	int half1, half2, half3; // small window and big window
	//int index1, index2; // index for Gaussian matrix
	double sum1, sum2, w_sum1, w_sum2;

	//////////////////////////////////
	//Make2DGaussMask(sigma); // mask for unilateral filtering

	//N = gau_mask.getRow();
	//half = N / 2;

	//ClearMemDC(&dc); // clear the canvas white
	//////////////////////////////////////////////
	//double factor = 2.0;
	//MakeGaussMatrix(factor, GAU); // factor controls the Gaussian window size for each index
	vector GAU1, GAU2, GAU3;
	MakeGaussVector(sigma, GAU1); // entire inner circle; ellipse in outer circle
	MakeGaussVector(sigma*1.6, GAU2); // entire outer circle
	MakeGaussVector(sigma/1.6, GAU3); // ellipse in inner circle

	////////////////////////////////////////////////////////
	// sensitivity of edge detector. between [0, 1] 
	// the smaller, less noise 
	//double tau = 0.99; 

	matrix tmp(image_x, image_y);
	//tmp.zero();

	/*
	for (i = 0; i < 256; i++) {
		for (j = 0; j < GAU.getCol(); j++) {
			TRACE("GAU[%d][%d] = %.3f ", i, j, GAU[i][j]);
		}
		TRACE("\n");
	}
	*/
	//gau_w = MakeGaussMask(4.0, gau); // window 20x20

	vector v(2), vt(2), w(2);
	double gx, gy, d1, d2, weight, v_norm;
		
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//index = gray2[i][j];
			sum1 = 0;
			w_sum1 = 0.0;
			//half1 = GAU_W[index1]-1;
			half1 = GAU1.getMax()-1;
			half3 = GAU3.getMax()-1;
			//half = 8;
			gx = gfield[i][j].gx;
			gy = gfield[i][j].gy;
			//TRACE("GAU_W_1[%d] = %d\n", index1, GAU_W[index1]);
			////////////////////////////////
			// vector components for the distance computation!
			v[0] = gx; // gradient vector
			v[1] = gy;
			//v[0] = 0.0;
			//v[1] = 1.0;
			v.make_unit();
			vt[0] = -gy; // tangent vector (main axis!)
			vt[1] = gx;
			//vt[0] = -1.0; // tangent vector
			//vt[1] = 0.0;
			vt.make_unit();
			v_norm = v.norm();
			for (t = -half1; t <= half1; t++) {
				for (s = -half1; s <= half1; s++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					/*
					k = (int)dist2(x, y, i, j);
					//k = round( dist2(x, y, i, j) );
					if ( k > half1 ) continue; 
					*/
					//////////////////////////////////
					w[0] = (double)x - i; // C - A
					w[1] = (double)y - j;
					//w.make_unit(); // you shouldn't make this unit!
					/////////////////////
					// distance to the (-gy, gx) AXIS! (important one)
					d1 = ABS(v * w) / v_norm; // should be positive!
					if ( d1 > half3 ) continue; 
					/////////////////////
					// distance to the (gx, gy) AXIS!
					d2 = ABS(vt * w) / v_norm; // should be positive!
					if ( d2 > half1 ) continue; 
					
					//TRACE("k = %d\n", k);
					//TRACE("d = %.1f\n", d);
					//rad = d * 1.5 * PI / (double)half1;
					//rad = d * 4.0 * PI / (double)half1;
					//rad = d * 10.0 * PI / (double)half1;
					//TRACE("rad = %.1f\n", rad);
					///////////////////////////////////////
					//weight = GAU[index1][k] * cos(rad);
					//weight = GAU[index1][k] * cos(rad);
					//weight = GAU[index1][round(d2)] * GAU[index1][round(d1)];
					weight = GAU3[round(d1)] * GAU1[round(d2)];
					//TRACE("weight = %f\n", weight);
					//if (weight < 0) TRACE("weight = %f\n", weight);
					//if (cos(rad) < 0) TRACE("cos(rad) = %f\n", cos(rad));
					/////////////////////////////////////////////////////
					sum1 += image[x][y] * weight;
					w_sum1 += weight;
					//sum1 += image[x][y] * GAU[index1][k];
					//w_sum1 += GAU[index1][k];
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			sum1 /= w_sum1; 
			//sum1 /= 100;
			//TRACE("sum1 = %.6f\n", sum1);
			//TRACE("w_sum = %.6f\n", w_sum);
			//////////////////////////////////////////////
			//////////////////////////////////////////////
			sum2 = 0;
			w_sum2 = 0.0;
			//half2 = GAU_W[index2]-1;
			half2 = GAU1.getMax()-1;
			//TRACE("GAU_W_2[%d] = %d\n", index2, GAU_W[index2]);
			for (s = -half2; s <= half2; s++) {
				for (t = -half2; t <= half2; t++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					/*
					k = (int)dist2(x, y, i, j);
					//k = round( dist2(x, y, i, j) );
					if ( k > half1 ) continue; 
					*/
					/////////////////////////////////////////////////////
					////////////////////////////////
					w[0] = (double)x - i; // C - A
					w[1] = (double)y - j;
					//w.make_unit(); // you shouldn't make this unit!
					/////////////////////
					// distance to the (-gy, gx) AXIS! (important one)
					d1 = ABS(v * w) / v_norm; // should be positive!
					if ( d1 > half1 ) continue; 
					/////////////////////
					// distance to the (gx, gy) AXIS!
					d2 = ABS(vt * w) / v_norm; // should be positive!
					if ( d2 > half2 ) continue; 
					
					//TRACE("k = %d\n", k);
					//TRACE("d = %.1f\n", d);
					//rad = d * 1.5 * PI / (double)half1;
					//rad = d * 4.0 * PI / (double)half1;
					//rad = d * 10.0 * PI / (double)half1;
					//TRACE("rad = %.1f\n", rad);
					///////////////////////////////////////
					//weight = GAU[index1][k] * cos(rad);
					//weight = GAU[index1][k] * cos(rad);
					//weight = GAU[index2][round(d2)] * GAU[index2][round(d1)];
					weight = GAU1[round(d1)] * GAU2[round(d2)];
					//TRACE("weight = %f\n", weight);
					//if (weight < 0) TRACE("weight = %f\n", weight);
					//if (cos(rad) < 0) TRACE("cos(rad) = %f\n", cos(rad));
					/////////////////////////////////////////////////////
					sum2 += image[x][y] * weight;
					w_sum2 += weight;
					//sum1 += image[x][y] * GAU[index1][k];
					//w_sum1 += GAU[index1][k];
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
					//sum2 += image[x][y] * GAU[index2][k];
					//w_sum2 += GAU[index2][k];
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			//TRACE("w_sum = %.6f\n", w_sum);
			sum2 /= w_sum2; 
			//////////////////////////////
			//////////////////////////////////////
			if (sum1 - tau * sum2 > 0) // non edge
				tmp[i][j] = 1.0; 
			else // edge!
				tmp[i][j] = 1.0 + tanh(sum1 - tau * sum2);
		}
	}
	////////////////////////////////////////////

	// Normalize DOG value (not necessary! - MAX_DOG is always 1)
	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			//TRACE("p[%d][%d].mag = %0.3f\n", i, j, p[i][j].mag);
			//tmp[i][j] = tmp[i][j] / MAX_DOG; // place it between [0, 1]
			G_mag[i][j] = 1-tmp[i][j]; // used for nonmaxima suppression
			//TRACE("G_mag[%d][%d] = %.1f\n", i, j, G_mag[i][j]);
			//TRACE("tmp[%d][%d] = %0.3f\n", i, j, tmp[i][j]);
			//TRACE("G_mag[%d][%d] = %0.3f\n", i, j, G_mag[i][j]);
			if (tmp[i][j] < 0)
				TRACE("tmp[%d][%d] = %0.2f\n", i, j, tmp[i][j]);
			image2[i][j] = round(tmp[i][j] * 255.);
			//image2[i][j] = 255 - round(tmp[i][j] * 255.);
		}
	}
}

void GetGabor(imatrix& image, Field& gfield, imatrix& image2, matrix& G_mag, 
			  int index1, int index2, double tau) 
// Gabor filter
// G_mag gets the actual real values in [0, 1]
// image2 gets the integer values in [0, 255]
{
	int	i, j, k;
	double MAX_DOG = -1.0;
	int s, t;
	int x, y;

	int image_x = image.getRow();
	int image_y = image.getCol();

	int half1; // small window and big window
	//int index1, index2; // index for Gaussian matrix
	double sum1, w_sum1;

	//////////////////////////////////
	//Make2DGaussMask(sigma); // mask for unilateral filtering

	//N = gau_mask.getRow();
	//half = N / 2;

	//ClearMemDC(&dc); // clear the canvas white
	//////////////////////////////////////////////
	double factor = 2.0;
	MakeGaussMatrix(factor, GAU); // factor controls the Gaussian window size for each index

	//index1 = 30;
	TRACE("GAU_W_1[%d] = %d\n", index1, GAU_W[index1]);
	//index2 = 100;
	TRACE("GAU_W_2[%d] = %d\n", index2, GAU_W[index2]);

	////////////////////////////////////////////////////////
	// sensitivity of edge detector. between [0, 1] 
	// the smaller, less noise
	//double tau = 0.99; 

	matrix tmp(image_x, image_y);
	//tmp.zero();

	/*
	for (i = 0; i < 256; i++) {
		for (j = 0; j < GAU.getCol(); j++) {
			TRACE("GAU[%d][%d] = %.3f ", i, j, GAU[i][j]);
		}
		TRACE("\n");
	}
	*/
	//gau_w = MakeGaussMask(4.0, gau); // window 20x20

	vector v(2), vt(2), w(2);
	double gx, gy, d, rad, weight;
		
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			////////////////////////////
			//index = gray2[i][j];
			sum1 = 0;
			w_sum1 = 0.0;
			half1 = GAU_W[index1]-1;
			//half = 8;
			gx = gfield[i][j].gx;
			gy = gfield[i][j].gy;
			//TRACE("GAU_W_1[%d] = %d\n", index1, GAU_W[index1]);
			for (t = -half1; t <= half1; t++) {
				for (s = -half1; s <= half1; s++) {
					////////////////////////
					x = i+s; y = j+t;
					/////////////////////////////////////////////////////
					if (x > IMAGE_X-1 || x < 0 || y > IMAGE_Y-1 || y < 0) 
						continue;
					/////////////////////////////////////////////////////////
					// circular kernel
					k = (int)dist2(x, y, i, j);
					//k = round( dist2(x, y, i, j) );
					if ( k > half1 ) continue; 
					////////////////////////////////
					// distance to the gradient line!
					//v[0] = gx;
					//v[1] = gy;
					v[0] = 0.0;
					v[1] = 1.0;
					v.make_unit();
					w[0] = (double)x - i; // C - A
					w[1] = (double)y - j;
					//w.make_unit(); // you shouldn't make this unit!
					//vt[0] = -gy; // tangent vector
					//vt[1] = gx;
					vt[0] = -1.0; // tangent vector
					vt[1] = 0.0;
					vt.make_unit();
					d = ABS(vt * w) / v.norm(); // should be positive!
					TRACE("k = %d\n", k);
					TRACE("d = %.1f\n", d);
					//rad = d * 1.5 * PI / (double)half1;
					rad = d * 4.0 * PI / (double)half1;
					//rad = d * 10.0 * PI / (double)half1;
					//TRACE("rad = %.1f\n", rad);
					///////////////////////////////////////
					//weight = GAU[index1][k] * cos(rad);
					weight = GAU[index1][k] * cos(rad);
					TRACE("weight = %f\n", weight);
					//if (weight < 0) TRACE("weight = %f\n", weight);
					//if (cos(rad) < 0) TRACE("cos(rad) = %f\n", cos(rad));
					/////////////////////////////////////////////////////
					sum1 += image[x][y] * weight;
					w_sum1 += weight;
					//sum1 += image[x][y] * GAU[index1][k];
					//w_sum1 += GAU[index1][k];
					//TRACE("GAU[%d][%d] = %f\n", index, k, GAU[index][k]);
					//TRACE("k = %d\n", k);
				}
			}
			////////////////////////////////////
			// Normalization
			//if (w_sum == 0.0) TRACE("w_sum = 0.0\n");
			sum1 /= w_sum1; 
			//sum1 /= 100;
			//TRACE("sum1 = %.6f\n", sum1);
			//TRACE("w_sum = %.6f\n", w_sum);
			//////////////////////////////////////////////
			//////////////////////////////////////
			if (sum1 > 0) tmp[i][j] = 1.0; 
			else // edge!
				tmp[i][j] = 1.0 + tanh(sum1);
			//if (sum1 - tau * sum2 > 0) // non edge
			//	tmp[i][j] = 1.0; 
			//else // edge!
			//	tmp[i][j] = 1.0 + tanh(sum1 - tau * sum2);
			//if (tmp[i][j] > MAX_DOG) MAX_DOG = tmp[i][j];
		}
	}
	////////////////////////////////////////////

	// Normalize DOG value (not necessary! - MAX_DOG is always 1)
	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			//TRACE("p[%d][%d].mag = %0.3f\n", i, j, p[i][j].mag);
			//tmp[i][j] = tmp[i][j] / MAX_DOG; // place it between [0, 1]
			G_mag[i][j] = 1-tmp[i][j]; // used for nonmaxima suppression
			//TRACE("G_mag[%d][%d] = %.1f\n", i, j, G_mag[i][j]);
			//TRACE("tmp[%d][%d] = %0.3f\n", i, j, tmp[i][j]);
			//TRACE("G_mag[%d][%d] = %0.3f\n", i, j, G_mag[i][j]);
			if (tmp[i][j] < 0)
				TRACE("tmp[%d][%d] = %0.2f\n", i, j, tmp[i][j]);
			image2[i][j] = round(tmp[i][j] * 255.);
			//image2[i][j] = 255 - round(tmp[i][j] * 255.);
		}
	}
}

void Thresholding(int image_x, int image_y, imatrix& image, double thres) 
{
	int	i, j;
	double val;

	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			val = image[i][j] / 255.0; // [0, 1]
			if (val < thres)
				image[i][j] = 0; // black
			else image[i][j] = 255; // white
		}
	}
}

int CountBlackPixels(imatrix& image) 
{
	int	i, j;

	int image_x = image.getRow();
	int image_y = image.getCol();

	int count = 0;

	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			if (image[i][j] == 0)
				count++;
		}
	}

	return count;
}

void EdgeThinning(CDC& dc, imatrix& image) 
// Perform Morphological Edge Thinning!
{
	int	i, j, k;
	int s, t;
	int x, y;
	int image_x, image_y;

	image_x = image.getRow();
	image_y = image.getCol();

	//imatrix tmp(image_x, image_y);
	//tmp.copy(image);

	imatrix p[8];
	for (k = 0; k < 8; k++) { p[k].init(3, 3); }
	/*
	///////////////////////////////////////////
	// weaker constraint for diagonal edges (remove less)
	p[0][0][0] = 1;	p[0][0][1] = 1;	p[0][0][2] = 2; 
	p[0][1][0] = 1;	p[0][1][1] = 2;	p[0][1][2] = 0; 
	p[0][2][0] = 2;	p[0][2][1] = 0;	p[0][2][2] = 0; 

	p[1][0][0] = 2;	p[1][0][1] = 0;	p[1][0][2] = 0; 
	p[1][1][0] = 1;	p[1][1][1] = 2;	p[1][1][2] = 0; 
	p[1][2][0] = 1;	p[1][2][1] = 1;	p[1][2][2] = 2; 
	
	p[2][0][0] = 0;	p[2][0][1] = 0;	p[2][0][2] = 2; 
	p[2][1][0] = 0;	p[2][1][1] = 2;	p[2][1][2] = 1; 
	p[2][2][0] = 2;	p[2][2][1] = 1;	p[2][2][2] = 1;

	p[3][0][0] = 2;	p[3][0][1] = 1;	p[3][0][2] = 1; 
	p[3][1][0] = 0;	p[3][1][1] = 2;	p[3][1][2] = 1; 
	p[3][2][0] = 0;	p[3][2][1] = 0;	p[3][2][2] = 2; 
	*/
	////////////////////////////////////////////
	// stronger constraint for diagonal edges (remove more)
	p[0][0][0] = 2;	p[0][0][1] = 1;	p[0][0][2] = 2; 
	p[0][1][0] = 1;	p[0][1][1] = 2;	p[0][1][2] = 0; 
	p[0][2][0] = 2;	p[0][2][1] = 0;	p[0][2][2] = 0; 

	p[1][0][0] = 2;	p[1][0][1] = 0;	p[1][0][2] = 0; 
	p[1][1][0] = 1;	p[1][1][1] = 2;	p[1][1][2] = 0; 
	p[1][2][0] = 2;	p[1][2][1] = 1;	p[1][2][2] = 2; 
	
	p[2][0][0] = 0;	p[2][0][1] = 0;	p[2][0][2] = 2; 
	p[2][1][0] = 0;	p[2][1][1] = 2;	p[2][1][2] = 1; 
	p[2][2][0] = 2;	p[2][2][1] = 1;	p[2][2][2] = 2;

	p[3][0][0] = 2;	p[3][0][1] = 1;	p[3][0][2] = 2; 
	p[3][1][0] = 0;	p[3][1][1] = 2;	p[3][1][2] = 1; 
	p[3][2][0] = 0;	p[3][2][1] = 0;	p[3][2][2] = 2; 

	p[4][0][0] = 1;	p[4][0][1] = 2;	p[4][0][2] = 0; 
	p[4][1][0] = 1;	p[4][1][1] = 2;	p[4][1][2] = 0; 
	p[4][2][0] = 1;	p[4][2][1] = 2;	p[4][2][2] = 0; 

	p[5][0][0] = 0;	p[5][0][1] = 0;	p[5][0][2] = 0; 
	p[5][1][0] = 2;	p[5][1][1] = 2;	p[5][1][2] = 2; 
	p[5][2][0] = 1;	p[5][2][1] = 1;	p[5][2][2] = 1; 

	p[6][0][0] = 0;	p[6][0][1] = 2;	p[6][0][2] = 1; 
	p[6][1][0] = 0;	p[6][1][1] = 2;	p[6][1][2] = 1; 
	p[6][2][0] = 0;	p[6][2][1] = 2;	p[6][2][2] = 1; 

	p[7][0][0] = 1;	p[7][0][1] = 1;	p[7][0][2] = 1; 
	p[7][1][0] = 2;	p[7][1][1] = 2;	p[7][1][2] = 2; 
	p[7][2][0] = 0;	p[7][2][1] = 0;	p[7][2][2] = 0; 

	bool removable =false;
	bool match_fail = false;
	bool remain = true;
	int round = 1;
	
	while (remain) { // there's still a possibility of remaining removable pixels
		remain = false; // assume that there's no more removable pixels
		for (j = 1; j < image_y-1; j++) {
			for (i = 1; i < image_x-1; i++) {
				//TRACE("image[%d][%d] == %d\n", i, j, image[i][j]);
				if (image[i][j] == 255) continue; // already white pixel
				////////////////////////////
				if (image[i][j] == 0) { // black pixel. let's check if it's removable
					removable = false; // assume this pixel is unremovable
					for (k = 0; k < 8; k++) {
						match_fail = false; // assume this pattern matches
						for (s = 0; s <= 2; s++) {
							for (t = 0; t <= 2; t++) {
								x = i+s-1; y = j+t-1;
								if (p[k][s][t] == 1) { // edge pixel
									if (image[x][y] == 0) continue; // match
									else match_fail = true; // match failed
								}
								else if (p[k][s][t] == 0) { // non-edge pixel
									if (image[x][y] == 255) continue; // match
									else match_fail = true; // match failed
								}
								if (match_fail) break; // get out of for t
							}
							if (match_fail) break; // get out of for s
						}
						if (match_fail == false) { // match success! let's get out!
							removable = true;
							break; // get out of (for k)
						}
					} // for k 
					if (removable) {
						//tmp[i][j] = 255; // incorrect: the connectivity is not preserved!
						// You have to change it and then evaluate the next pixel right away!
						image[i][j] = 255; // make it white 
						//TRACE("Round %d: [%d][%d] removable!\n", round, x, y);
						remain = true; // we have to run at least one more round!
					}
				} // if (tmp[i][j] == 0)
			} // for i
		} // for j
		//tmp.copy(image); // update tmp
		round++;
		//if (round > 100) break;
		//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, image);
		//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	} // while (remain)
	////////////////////////////////////////////
}

double GetPointFlowDOG(int x, int y, matrix& G_mag, Field& gfield, 
							int ker_l, double step_size)
// following the flow, compute the average DOG at (x, y) over the flow
// Here we simply add the DOG[i][j] cumulatively (for repetitive application!)
{
	double d_i, d_j, tx, ty, nx, ny;
	int k, int_i, int_j;
	//int half2;
	//double t;
	int count;

	int half_l = ker_l / 2 + 1; // half length of the curved kernel

	//double half_w = 1.414; // half width of the curved kernel
	//double half_w = 1.414; // half width of the curved kernel
	//double half_w = 1; // half width of the curved kernel
	//double half_w = ker_w / 2; // half width of the curved kernel

	double flow_dog = 0.0; // flow-based gradient magnitude

	////////////////////////////////////
	//t = 1.0;
	//t = 1.414; // step_size
	//t = 0.5; // step_size
	count = 0; // number of pixels traversed
	////////////////////////////////////////////////
	// One half
	d_i = (double)x; d_j = (double)y; 
	tx = -gfield[x][y].gy;
	ty = gfield[x][y].gx;
	int_i = x;	int_j = y;
	for (k = 0; k < half_l; k++) {
		if (tx == 0.0 && ty == 0.0) break;
		///////////////////////////////////////
		nx = tx / sqrt(tx*tx+ty*ty);  // x component of the unit direction vector 
		ny = ty / sqrt(tx*tx+ty*ty);  // y component of the unit direction vector
		////////////////////////////////
		/////////////////////////////////////////
		//flow_mag += ABS( image[right_i][right_j] - image[left_i][left_j] );
		//flow_mag += gfield[int_i][int_j].mag;
		flow_dog += G_mag[int_i][int_j];
		//TRACE("G_mag[%d][%d] = %.1f\n", int_i, int_j, G_mag[int_i][int_j]);
		count++;
		//////////////////////////////////
		//dc.SetPixelV(int_i, IMAGE_Y-1-int_j, RGB(r, g, b));
		//////////////////////////////
		d_i += nx * step_size; // accurate new location x
		d_j += ny * step_size; // accurate new location y
        ///////////////////////////
		//if (round(d_i) == int_i && round(d_j) == int_j) // no change
		//	continue; // push some more
		/////////////////////////////////////////
		int_i = round(d_i); // integer version of new location x
		int_j = round(d_j); // integer version of new location y
		if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		
		///////////////////////////////////
		//d_i = (double)int_i;
		//d_j = (double)int_j;
		//////////////////////////////////
		tx = -gfield[int_i][int_j].gy;
		ty = gfield[int_i][int_j].gx;
	}
	///////////////////////////////////////
	// other half
	// Note that center pixel gradient magnitude is computed twice (consistent with Sobel grad)
	///*
	d_i = (double)x; d_j = (double)y; 
	int_i = x;	int_j = y;
	tx = -gfield[x][y].gy;
	ty = gfield[x][y].gx;
	/////////////////////////////////////
	for (k = 0; k < half_l; k++) {
		if (tx == 0.0 && ty == 0.0) break;
		///////////////////////////////////////
		nx = tx / sqrt(tx*tx+ty*ty);  // x component of the unit direction vector 
		ny = ty / sqrt(tx*tx+ty*ty);  // y component of the unit direction vector
		////////////////////////////////
		/////////////////////////////////////////
		//flow_mag += gfield[int_i][int_j].mag;
		flow_dog += G_mag[int_i][int_j];
		count++;
		//////////////////////////////////
		//dc.SetPixelV(int_i, IMAGE_Y-1-int_j, RGB(r, g, b));
		//////////////////////////////
		d_i -= nx * step_size; // accurate new location x
		d_j -= ny * step_size; // accurate new location y
        ///////////////////////////
		//if (round(d_i) == int_i && round(d_j) == int_j) // no change
		//	continue; // push some more
		/////////////////////////////////////////
		int_i = round(d_i); // integer version of new location x
		int_j = round(d_j); // integer version of new location y
		if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		
		//////////////////////////////////
		tx = -gfield[int_i][int_j].gy;
		ty = gfield[int_i][int_j].gx;
	}
	//*/

	if (count > 0)
		flow_dog /= (double)count;

	return flow_dog;
	
}

void GetFlowDOG(int image_x, int image_y, matrix& G_mag, imatrix& dog, Field& gfield, 
				int ker_l, double step_size) 
// Flow DOG: simply get the average DOG value over the flow
{
	int i, j;
	double MAX_CUM_DOG = -1.;
	//double MAX_VAL = 1020.; // 255 + 2 * 255 + 255 (Maximum possible Sobel value)

	matrix tmp(image_x, image_y);

	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			//tmp[i][j].mag = GetPointFlowGradient(dc, i, j, image, gfield, ker_l, ker_w, step_size);
			//TRACE("G_mag[%d][%d] = %.1f\n", i, j, G_mag[i][j]);
			tmp[i][j] = GetPointFlowDOG(i, j, G_mag, gfield, ker_l, step_size);
			if (tmp[i][j] > MAX_CUM_DOG) MAX_CUM_DOG = tmp[i][j];
			//if (tmp[i][j] > MAX_DOG) {
			//	MAX_GRADIENT = tmp[i][j].mag;
			//}
		}
	}
	
	TRACE("MAX_CUM_DOG = %0.1f\n", MAX_CUM_DOG);

	// Normalize DOG
	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			//TRACE("p[%d][%d].mag = %0.3f\n", i, j, p[i][j].mag);
			tmp[i][j] = tmp[i][j] / MAX_CUM_DOG; // place it between [0, 1]
			//G_mag[i][j] = tmp[i][j]; // used for nonmaxima suppresion
			if (tmp[i][j] < 0)
				TRACE("tmp[%d][%d] = %0.2f\n", i, j, tmp[i][j]);

			dog[i][j] = 255 - round(tmp[i][j] * 255.);
			G_mag[i][j] = tmp[i][j];
		}
	}

}

double GetPointFlowGradient2(CDC& dc, int x, int y, imatrix& image, Field& gfield, 
							int ker_l, double step_size)
// following the flow, compute the gradient at (x, y)
// Here we simply add the gfield[i][j].mag cumulatively (for repetitive application!)
{
	double d_i, d_j, tx, ty, nx, ny;
	int k, int_i, int_j;
	//int half2;
	int count;

	int half_l = ker_l / 2 + 1; // half length of the curved kernel

	//double half_w = 1.414; // half width of the curved kernel
	//double half_w = 1.414; // half width of the curved kernel
	double half_w = 1; // half width of the curved kernel

	double flow_mag = 0.0; // flow-based gradient magnitude

	////////////////////////////////////
	//t = 1.0;
	//t = 1.414; // step_size
	//t = 0.5; // step_size
	count = 0; // number of pixels traversed
	////////////////////////////////////////////////
	// One half
	d_i = (double)x; d_j = (double)y; 
	tx = -gfield[x][y].gy;
	ty = gfield[x][y].gx;
	int_i = x;	int_j = y;
	for (k = 0; k < half_l; k++) {
		if (tx == 0.0 && ty == 0.0) break;
		///////////////////////////////////////
		nx = tx / sqrt(tx*tx+ty*ty);  // x component of the unit direction vector 
		ny = ty / sqrt(tx*tx+ty*ty);  // y component of the unit direction vector
		////////////////////////////////
		/////////////////////////////////////////
		//flow_mag += ABS( image[right_i][right_j] - image[left_i][left_j] );
		flow_mag += gfield[int_i][int_j].mag;
		count++;
		//////////////////////////////////
		//dc.SetPixelV(int_i, IMAGE_Y-1-int_j, RGB(r, g, b));
		//////////////////////////////
		d_i += nx * step_size; // accurate new location x
		d_j += ny * step_size; // accurate new location y
        ///////////////////////////
		//if (round(d_i) == int_i && round(d_j) == int_j) // no change
		//	continue; // push some more
		/////////////////////////////////////////
		int_i = round(d_i); // integer version of new location x
		int_j = round(d_j); // integer version of new location y
		if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		
		///////////////////////////////////
		//d_i = (double)int_i;
		//d_j = (double)int_j;
		//////////////////////////////////
		tx = -gfield[int_i][int_j].gy;
		ty = gfield[int_i][int_j].gx;
	}
	///////////////////////////////////////
	// other half
	// Note that center pixel gradient magnitude is computed twice (consistent with Sobel grad)
	///*
	d_i = (double)x; d_j = (double)y; 
	int_i = x;	int_j = y;
	tx = -gfield[x][y].gy;
	ty = gfield[x][y].gx;
	/////////////////////////////////////
	for (k = 0; k < half_l; k++) {
		if (tx == 0.0 && ty == 0.0) break;
		///////////////////////////////////////
		nx = tx / sqrt(tx*tx+ty*ty);  // x component of the unit direction vector 
		ny = ty / sqrt(tx*tx+ty*ty);  // y component of the unit direction vector
		////////////////////////////////
		/////////////////////////////////////////
		//flow_mag += ABS( image[right_i][right_j] - image[left_i][left_j] );
		flow_mag += gfield[int_i][int_j].mag;
		count++;
		//////////////////////////////////
		//dc.SetPixelV(int_i, IMAGE_Y-1-int_j, RGB(r, g, b));
		//////////////////////////////
		d_i -= nx * step_size; // accurate new location x
		d_j -= ny * step_size; // accurate new location y
        ///////////////////////////
		//if (round(d_i) == int_i && round(d_j) == int_j) // no change
		//	continue; // push some more
		/////////////////////////////////////////
		int_i = round(d_i); // integer version of new location x
		int_j = round(d_j); // integer version of new location y
		if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		
		//////////////////////////////////
		tx = -gfield[int_i][int_j].gy;
		ty = gfield[int_i][int_j].gx;
	}
	//*/

	if (count > 0)
		flow_mag /= (double)count;

	return flow_mag;
	
}

double GetPointFlowGradient(CDC& dc, int x, int y, imatrix& image, Field& gfield, 
							int ker_l, double ker_w, double step_size)
// This function is the key of my flow-based image processing algorithm!
// following the flow, compute the gradient at (x, y)
// this one keeps the current pixel location as float coordinates, so works correctly!
{
	double d_i, d_j, tx, ty, nx, ny;
	int k, int_i, int_j;
	//int half2;
	int left_i, left_j, right_i, right_j;
	int count;

	int half_l = ker_l / 2 + 1; // half length of the curved kernel

	//double half_w = 1.414; // half width of the curved kernel
	//double half_w = 1.414; // half width of the curved kernel
	//double half_w = 1; // half width of the curved kernel
	double half_w = ker_w / 2; // half width of the curved kernel

	double flow_mag = 0.0; // flow-based gradient magnitude

	/*
	r = Dbuffer[(y * IMAGE_X + x) * 3 + 0];
	g = Dbuffer[(y * IMAGE_X + x) * 3 + 1];
	b = Dbuffer[(y * IMAGE_X + x) * 3 + 2];
	PerturbRGB(r, g, b, 70);
	*/

	////////////////////////////////////
	//t = 1.0;
	//t = 1.414; // step_size
	//t = 0.5; // step_size
	count = 0; // number of pixels traversed
	////////////////////////////////////////////////
	// One half
	d_i = (double)x; d_j = (double)y; 
	tx = -gfield[x][y].gy;
	ty = gfield[x][y].gx;
	int_i = x;	int_j = y;
	for (k = 0; k < half_l; k++) {
		if (tx == 0.0 && ty == 0.0) break;
		///////////////////////////////////////
		nx = tx / sqrt(tx*tx+ty*ty);  // x component of the unit direction vector 
		ny = ty / sqrt(tx*tx+ty*ty);  // y component of the unit direction vector
		////////////////////////////////
		//////////////////////////////////////////////////
		// Angle computation
		left_i = round(d_i + -ny * half_w); // left perpendicular
		left_j = round(d_j + nx * half_w); // left perpendicular
		if (left_i < 0) left_i = 0;
		if (left_i > IMAGE_X-1) left_i = IMAGE_X-1;
		if (left_j < 0) left_j = 0;
		if (left_j > IMAGE_Y-1) left_j = IMAGE_Y-1;
		right_i = round(d_i + ny * half_w); // right perpendicular
		right_j = round(d_j + -nx * half_w); // right perpendicular
		if (right_i < 0) right_i = 0;
		if (right_i > IMAGE_X-1) right_i = IMAGE_X-1;
		if (right_j < 0) right_j = 0;
		if (right_j > IMAGE_Y-1) right_j = IMAGE_Y-1;
		/////////////////////////////////////////
		flow_mag += ABS( image[right_i][right_j] - image[left_i][left_j] );
		count++;
		//////////////////////////////////
		//dc.SetPixelV(int_i, IMAGE_Y-1-int_j, RGB(r, g, b));
		//////////////////////////////
		d_i += nx * step_size; // accurate new location x
		d_j += ny * step_size; // accurate new location y
        ///////////////////////////
		//if (round(d_i) == int_i && round(d_j) == int_j) // no change
		//	continue; // push some more
		/////////////////////////////////////////
		int_i = round(d_i); // integer version of new location x
		int_j = round(d_j); // integer version of new location y
		if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		
		///////////////////////////////////
		//d_i = (double)int_i;
		//d_j = (double)int_j;
		//////////////////////////////////
		tx = -gfield[int_i][int_j].gy;
		ty = gfield[int_i][int_j].gx;
	}
	///////////////////////////////////////
	// other half
	// Note that center pixel gradient magnitude is computed twice (consistent with Sobel grad)
	///*
	d_i = (double)x; d_j = (double)y; 
	int_i = x;	int_j = y;
	tx = -gfield[x][y].gy;
	ty = gfield[x][y].gx;
	/////////////////////////////////////
	for (k = 0; k < half_l; k++) {
		if (tx == 0.0 && ty == 0.0) break;
		///////////////////////////////////////
		nx = tx / sqrt(tx*tx+ty*ty);  // x component of the unit direction vector 
		ny = ty / sqrt(tx*tx+ty*ty);  // y component of the unit direction vector
		////////////////////////////////
		//////////////////////////////////////////////////
		// Angle computation
		left_i = round(d_i + -ny * half_w); // left perpendicular
		left_j = round(d_j + nx * half_w); // left perpendicular
		if (left_i < 0) left_i = 0;
		if (left_i > IMAGE_X-1) left_i = IMAGE_X-1;
		if (left_j < 0) left_j = 0;
		if (left_j > IMAGE_Y-1) left_j = IMAGE_Y-1;
		right_i = round(d_i + ny * half_w); // right perpendicular
		right_j = round(d_j + -nx * half_w); // right perpendicular
		if (right_i < 0) right_i = 0;
		if (right_i > IMAGE_X-1) right_i = IMAGE_X-1;
		if (right_j < 0) right_j = 0;
		if (right_j > IMAGE_Y-1) right_j = IMAGE_Y-1;
		/////////////////////////////////////////
		flow_mag += ABS( image[right_i][right_j] - image[left_i][left_j] );
		count++;
		//////////////////////////////////
		//dc.SetPixelV(int_i, IMAGE_Y-1-int_j, RGB(r, g, b));
		//////////////////////////////
		d_i -= nx * step_size; // accurate new location x
		d_j -= ny * step_size; // accurate new location y
        ///////////////////////////
		//if (round(d_i) == int_i && round(d_j) == int_j) // no change
		//	continue; // push some more
		/////////////////////////////////////////
		int_i = round(d_i); // integer version of new location x
		int_j = round(d_j); // integer version of new location y
		if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		
		///////////////////////////////////
		//d_i = (double)int_i;
		//d_j = (double)int_j;
		//////////////////////////////////
		tx = -gfield[int_i][int_j].gy;
		ty = gfield[int_i][int_j].gx;
	}
	//*/

	if (count > 0)
		flow_mag /= (double)count;

	return flow_mag;
}

double GetPointFlowGradient3(CDC& dc, int x, int y, imatrix& image, Field& gfield, 
							int ker_l, double ker_w, double step_size)
// following the flow, compute the gradient at (x, y)
// this one keeps the current pixel location as float coordinates
// and this one uses weight, giving higher smoothing weight to higher gradient magnitudes!!!
{
	double d_i, d_j, tx, ty, nx, ny;
	int k, int_i, int_j;
	//int half2;
	int left_i, left_j, right_i, right_j;
	int count;

	int half_l = ker_l / 2 + 1; // half length of the curved kernel

	//double half_w = 1.414; // half width of the curved kernel
	//double half_w = 1.414; // half width of the curved kernel
	//double half_w = 1; // half width of the curved kernel
	double half_w = ker_w / 2; // half width of the curved kernel

	double flow_mag = 0.0; // flow-based gradient magnitude
	double weight, total_weight = 0.0;

	/*
	r = Dbuffer[(y * IMAGE_X + x) * 3 + 0];
	g = Dbuffer[(y * IMAGE_X + x) * 3 + 1];
	b = Dbuffer[(y * IMAGE_X + x) * 3 + 2];
	PerturbRGB(r, g, b, 70);
	*/

	////////////////////////////////////
	//t = 1.0;
	//t = 1.414; // step_size
	//t = 0.5; // step_size
	count = 0; // number of pixels traversed
	////////////////////////////////////////////////
	// One half
	d_i = (double)x; d_j = (double)y; 
	tx = -gfield[x][y].gy;
	ty = gfield[x][y].gx;
	int_i = x;	int_j = y;
	for (k = 0; k < half_l; k++) {
		if (tx == 0.0 && ty == 0.0) break;
		///////////////////////////////////////
		nx = tx / sqrt(tx*tx+ty*ty);  // x component of the unit direction vector 
		ny = ty / sqrt(tx*tx+ty*ty);  // y component of the unit direction vector
		////////////////////////////////
		//////////////////////////////////////////////////
		// Angle computation
		left_i = round(d_i + -ny * half_w); // left perpendicular
		left_j = round(d_j + nx * half_w); // left perpendicular
		if (left_i < 0) left_i = 0;
		if (left_i > IMAGE_X-1) left_i = IMAGE_X-1;
		if (left_j < 0) left_j = 0;
		if (left_j > IMAGE_Y-1) left_j = IMAGE_Y-1;
		right_i = round(d_i + ny * half_w); // right perpendicular
		right_j = round(d_j + -nx * half_w); // right perpendicular
		if (right_i < 0) right_i = 0;
		if (right_i > IMAGE_X-1) right_i = IMAGE_X-1;
		if (right_j < 0) right_j = 0;
		if (right_j > IMAGE_Y-1) right_j = IMAGE_Y-1;
		/////////////////////////////////////////
		weight = ABS( image[right_i][right_j] - image[left_i][left_j] );
		total_weight += weight;
		flow_mag += weight * ABS( image[right_i][right_j] - image[left_i][left_j] );
		count++;
		//////////////////////////////////
		//dc.SetPixelV(int_i, IMAGE_Y-1-int_j, RGB(r, g, b));
		//////////////////////////////
		d_i += nx * step_size; // accurate new location x
		d_j += ny * step_size; // accurate new location y
        ///////////////////////////
		//if (round(d_i) == int_i && round(d_j) == int_j) // no change
		//	continue; // push some more
		/////////////////////////////////////////
		int_i = round(d_i); // integer version of new location x
		int_j = round(d_j); // integer version of new location y
		if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		
		///////////////////////////////////
		//d_i = (double)int_i;
		//d_j = (double)int_j;
		//////////////////////////////////
		tx = -gfield[int_i][int_j].gy;
		ty = gfield[int_i][int_j].gx;
	}
	///////////////////////////////////////
	// other half
	// Note that center pixel gradient magnitude is computed twice (consistent with Sobel grad)
	///*
	d_i = (double)x; d_j = (double)y; 
	int_i = x;	int_j = y;
	tx = -gfield[x][y].gy;
	ty = gfield[x][y].gx;
	/////////////////////////////////////
	for (k = 0; k < half_l; k++) {
		if (tx == 0.0 && ty == 0.0) break;
		///////////////////////////////////////
		nx = tx / sqrt(tx*tx+ty*ty);  // x component of the unit direction vector 
		ny = ty / sqrt(tx*tx+ty*ty);  // y component of the unit direction vector
		////////////////////////////////
		//////////////////////////////////////////////////
		// Angle computation
		left_i = round(d_i + -ny * half_w); // left perpendicular
		left_j = round(d_j + nx * half_w); // left perpendicular
		if (left_i < 0) left_i = 0;
		if (left_i > IMAGE_X-1) left_i = IMAGE_X-1;
		if (left_j < 0) left_j = 0;
		if (left_j > IMAGE_Y-1) left_j = IMAGE_Y-1;
		right_i = round(d_i + ny * half_w); // right perpendicular
		right_j = round(d_j + -nx * half_w); // right perpendicular
		if (right_i < 0) right_i = 0;
		if (right_i > IMAGE_X-1) right_i = IMAGE_X-1;
		if (right_j < 0) right_j = 0;
		if (right_j > IMAGE_Y-1) right_j = IMAGE_Y-1;
		/////////////////////////////////////////
		weight = ABS( image[right_i][right_j] - image[left_i][left_j] );
		total_weight += weight;
		flow_mag += weight * ABS( image[right_i][right_j] - image[left_i][left_j] );
		count++;
		//////////////////////////////////
		//dc.SetPixelV(int_i, IMAGE_Y-1-int_j, RGB(r, g, b));
		//////////////////////////////
		d_i -= nx * step_size; // accurate new location x
		d_j -= ny * step_size; // accurate new location y
        ///////////////////////////
		//if (round(d_i) == int_i && round(d_j) == int_j) // no change
		//	continue; // push some more
		/////////////////////////////////////////
		int_i = round(d_i); // integer version of new location x
		int_j = round(d_j); // integer version of new location y
		if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
		
		///////////////////////////////////
		//d_i = (double)int_i;
		//d_j = (double)int_j;
		//////////////////////////////////
		tx = -gfield[int_i][int_j].gy;
		ty = gfield[int_i][int_j].gx;
	}
	//*/

	if (count > 0) {
		//flow_mag /= (double)count;
		flow_mag /= total_weight;
	}

	return flow_mag;
	
}

void GetFlowGradient(CDC& dc, int image_x, int image_y, imatrix& image, Field& gfield, imatrix& image2, 
					 int ker_l, double ker_w, double step_size) 
// Flow gradient version
{
	int i, j;
	double MAX_GRADIENT = -1.;
	//double MAX_VAL = -1.;
	//double MAX_VAL = 255.;
	double MAX_VAL = 1020.; // 255 + 2 * 255 + 255 (Maximum possible Sobel value)

	Field tmp;

	tmp.init(image_x, image_y);

	/*
	for (i = 0; i < Nr; i++) { 
		for (j = 0; j < Nc; j++) {
			if (image[i][j] > MAX_VAL) MAX_VAL = (double)image[i][j];
		}
	}
	TRACE("MAX_VAL = %f\n", MAX_VAL);
	*/
	
	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			////////////////////////////////////////////////////////////////
			// Important!: the value of image intensity should be normalized to [0,1]
			//tmp[i][j].gx = (image[i+1][j-1] + 2*(double)image[i+1][j] + image[i+1][j+1] 
			//	- image[i-1][j-1] - 2*(double)image[i-1][j] - image[i-1][j+1]) / MAX_VAL;
			//tmp[i][j].gy = (image[i-1][j+1] + 2*(double)image[i][j+1] + image[i+1][j+1]
			//	- image[i-1][j-1] - 2*(double)image[i][j-1] - image[i+1][j-1]) / MAX_VAL;
			/////////////////////////////////////////////
			// Amplify!!!
			//p[i][j].gx = pow(p[i][j].gx, 2); 
			//p[i][j].gy = pow(p[i][j].gy, 2); 
			//p[i][j].gx = pow(p[i][j].gx, 2); 
			//TRACE("p[i][j].gx = %.1f\n", p[i][j].gx);
			//TRACE("p[i][j].gy = %.1f\n", p[i][j].gy);
			//tmp[i][j].mag = sqrt(tmp[i][j].gx * tmp[i][j].gx + tmp[i][j].gy * tmp[i][j].gy);
			tmp[i][j].mag = GetPointFlowGradient(dc, i, j, image, gfield, ker_l, ker_w, step_size);
			//tmp[i][j].mag = GetPointFlowGradient3(dc, i, j, image, gfield, ker_l, ker_w, step_size);
			//tmp[i][j].mag = GetPointFlowGradient2(dc, i, j, image, gfield, ker_l, step_size);

			if (tmp[i][j].mag > MAX_GRADIENT) {
				MAX_GRADIENT = tmp[i][j].mag;
				//TRACE("p[i][j].gx = %01.f\n", p[i][j].gx);
				//TRACE("p[i][j].gy = %01.f\n", p[i][j].gy);
				//TRACE("MAX_GRADIENT = %0.1f\n", MAX_GRADIENT);
			}
		}
	}
	
	TRACE("MAX_GRADIENT = %0.1f\n", MAX_GRADIENT);

	max_grad = round(MAX_GRADIENT);

	// Normalize gradient magnitude
	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			//TRACE("p[%d][%d].mag = %0.3f\n", i, j, p[i][j].mag);
			tmp[i][j].mag = tmp[i][j].mag / (double)MAX_GRADIENT; // place it between [0, 1]
			G_mag[i][j] = tmp[i][j].mag; // used for nonmaxima suppresion
			if (tmp[i][j].mag < 0)
				TRACE("tmp[%d][%d].mag = %0.2f\n", i, j, tmp[i][j].mag);

			image2[i][j] = 255 - round(tmp[i][j].mag * 255.);
			////////////////////////////////////////
			// update gfield.mag for repetitive application!
			//gfield[i][j].mag = tmp[i][j].mag; 
			////////////////////////////////////
		}
	}

	//////////////////////////////////////////////////////////////
	/// Amplify the gradients (strong grad -> stronger, weak grad -> weaker)
	/*
	for (i = 0; i < Nr; i++) { 
		for (j = 0; j < Nc; j++) {
			p[i][j].mag = pow(2.0, p[i][j].mag);
		}
	}
	*/
}


void NonmaximaSuppression(int image_x, int image_y, Field& gfield, matrix& G_mag, 
						  imatrix& image, double hi_thres)
{
	double	gx, gy;
	double	g, g1, g2, g3, g4;
	double	t; // interpolation parameter
	int i, j;

	///////////////////////////////////////
	for (j = 0; j < image_y; j++)
		for (i = 0; i < image_x; i++)
			image[i][j] = 255;
	//////////////////////////////////////////
	// Nonmaxima suppression
	for (j = 1; j < image_y-1; j++) {
		for (i = 1; i < image_x-1; i++) {
			gx = gfield[i][j].gx;
			gy = gfield[i][j].gy;
			g = G_mag[i][j];
			//TRACE("gx = %f, gy = %f, g = %f\n", gx, gy, g);
			//if (gx < 0.01 && gy < 0.01) continue; // not an edge
			if (fabs(gx) >= fabs(gy)) { // close to horizontal (note: gy can be 0)
				t = fabs(gy) / fabs(gx); 
				//TRACE("t = %f\n", t);
				g1 = G_mag[i+1][j]; // right
				g2 = G_mag[i-1][j]; // left
				//TRACE("g1 = %f, g2 = %f\n", g1, g2);
				if (gx*gy >= 0.0) { // 1 or 3 quadrant
					g3 = G_mag[i+1][j+1]; // right up
					g4 = G_mag[i-1][j-1]; // left down
				}
				else { // 2 or 4 quadrant
					g3 = G_mag[i+1][j-1]; // right down
					g4 = G_mag[i-1][j+1]; // left up
				}
			}
			else { // close to vertical (note: gx can be 0)
				t = fabs(gx) / fabs(gy);
				g1 = G_mag[i][j+1]; // up
				g2 = G_mag[i][j-1]; // down
				if (gx*gy >= 0.0) { // 1 or 3 quadrant
					g3 = G_mag[i+1][j+1]; // up right
					g4 = G_mag[i-1][j-1]; // down left
				}
				else { // 2 or 4 quadrant
					g3 = G_mag[i-1][j+1]; // up left
					g4 = G_mag[i+1][j-1]; // down right
				}
			}
			if ( g > ((1-t)*g1 + t*g3) && g > ((1-t)*g2 + t*g4) ) {
				////////////////////////////////////////
				//thin_edge[i][j] = 1; // it's a thin edge
				//image[i][j] = 0; // thin edge (maximum pixel)
				//////////////////////////////////////
				if (g > hi_thres) 
					image[i][j] = 0; // thin edge (maximum pixel)
				else 
					image[i][j] = 255; // thin edge below hi_thres
			}
			else { // non-maximum
				image[i][j] = 255;
			}
			
		}
	}
}

void NonmaximaSuppressionETF(matrix& gmag, ETF& e, imatrix& image, double thres)
// using ETF
{
	double	gx, gy;
	double	g, g1, g2, g3, g4;
	double	t; // interpolation parameter
	int i, j;

	int image_x = e.getRow();
	int image_y = e.getCol();

	///////////////////////////////////////
	for (j = 0; j < image_y; j++)
		for (i = 0; i < image_x; i++)
			image[i][j] = 255;
	//////////////////////////////////////////
	// Nonmaxima suppression
	for (j = 1; j < image_y-1; j++) {
		for (i = 1; i < image_x-1; i++) {
			//////////////////////////////////
			gx = -e[i][j].ty;
			gy = e[i][j].tx;
			g = gmag[i][j];
			//TRACE("gx = %f, gy = %f, g = %f\n", gx, gy, g);
			//if (gx < 0.01 && gy < 0.01) continue; 
			if (gx == 0.0 && gy == 0.0) { image[i][j] = 255; continue; } // not an edge 
			//////////////////////////////////////////////////////
			if (fabs(gx) >= fabs(gy)) { // close to horizontal (note: gy can be 0)
				t = fabs(gy) / fabs(gx); 
				//TRACE("t = %f\n", t);
				g1 = gmag[i+1][j]; // right
				g2 = gmag[i-1][j]; // left
				//TRACE("g1 = %f, g2 = %f\n", g1, g2);
				if (gx*gy >= 0.0) { // 1 or 3 quadrant
					g3 = gmag[i+1][j+1]; // right up
					g4 = gmag[i-1][j-1]; // left down
				}
				else { // 2 or 4 quadrant
					g3 = gmag[i+1][j-1]; // right down
					g4 = gmag[i-1][j+1]; // left up
				}
			}
			else { // close to vertical (note: gx can be 0)
				t = fabs(gx) / fabs(gy);
				g1 = gmag[i][j+1]; // up
				g2 = gmag[i][j-1]; // down
				if (gx*gy >= 0.0) { // 1 or 3 quadrant
					g3 = gmag[i+1][j+1]; // up right
					g4 = gmag[i-1][j-1]; // down left
				}
				else { // 2 or 4 quadrant
					g3 = gmag[i-1][j+1]; // up left
					g4 = gmag[i+1][j-1]; // down right
				}
			}
			if ( g < ((1-t)*g1 + t*g3) && g < ((1-t)*g2 + t*g4) ) {
				////////////////////////////////////////
				//thin_edge[i][j] = 1; // it's a thin edge
				//image[i][j] = 0; // thin edge (maximum pixel)
				//////////////////////////////////////
				if (g < thres) 
					image[i][j] = 0; // thin edge (maximum pixel)
				else 
					image[i][j] = 255; // thin edge below hi_thres
			}
			else { // non-maximum
				image[i][j] = 255;
			}
			
		}
	}
}

void ReplaceStrokeTexture(matrix& fdog, ETF& e, imatrix& image, double thres)
// using ETF
{
	double	gx, gy;
	double	g, g1, g2, g_old;
	//double	t; // interpolation parameter
	int i, j, x, y;
	int right, left, top, bottom;
	double x0, y0, x1, y1, x2, y2;
	double dist, s_min, s_right, s_left, s_top, s_bottom;
	int sign;

	int image_x = e.getRow();
	int image_y = e.getCol();

	imatrix tmp(image_x, image_y);
	tmp.copy(image);

	///////////////////////////////////////
	for (j = 0; j < image_y; j++)
		for (i = 0; i < image_x; i++)
			image[i][j] = 255;
	///////////////////////////////////////////////////////
	// vector field following to find dist, maximum g
	for (j = 1; j < image_y-1; j++) {
		for (i = 1; i < image_x-1; i++) {
			//////////////////////////////////
			dist = 0.0;
			gx = -e[i][j].ty;
			gy = e[i][j].tx;
			if (fdog[i][j] == 1.0) continue;  // not an edge 
			if (gx == 0.0 && gy == 0.0) continue; // not an edge 
			g = fdog[i][j];
			/////////////////////////////////////////////////////////
			//if (g > thres) { continue; } // not an edge
			//if (tmp[i][j] > 250) { continue; } // not an edge
			///////////////////////////////////////////////////////
			x0 = (double)i; y0 = (double)j;
			//////////////////////////////////////////////////////
			right = (int)(x0 + 1.0);
			left = (x0 > (double)((int)x0)) ? (int)x0 : (int)(x0-1);
			top = (int)(y0 + 1.0);
			bottom = (y0 > (double)((int)y0)) ? (int)y0 : (int)(y0-1);
			s_min = 100.0;
			s_right = (gx == 0.0) ? 1000 : (right - x0) / gx;
			if (s_right > 0.0 && s_right < s_min) s_min = s_right;
			s_left = (gx == 0.0) ? 1000 : (left - x0) / gx;
			if (s_left > 0.0 && s_left < s_min) s_min = s_left;
			s_top = (gy == 0.0) ? 1000 : (top - y0) / gy;
			if (s_top > 0.0 && s_top < s_min) s_min = s_top;
			s_bottom = (gy == 0.0) ? 1000 : (bottom - y0) / gy;
			if (s_bottom > 0.0 && s_bottom < s_min) s_min = s_bottom;

			x1 = x0 + gx * s_min;
			y1 = y0 + gy * s_min;
			g1 = fdog[(int)x1][(int)y1];
			x2 = x0 + gx * -s_min;
			y2 = y0 + gy * -s_min;
			g2 = fdog[(int)x2][(int)y2];
			////////////////////////////////
			if ( (g < g1) && (g < g2) ) { // maxima pixel
				image[i][j] = round(g * 255.0);
				continue;
			}
			if ( (g1 - g) <= (g2 - g) ) { // move towards g1
				sign = 1; 
				g_old = g; g = g1; 
				x0 = x1; y0 = y1;
			} 
			else { // move towards g2 
				//sign = -1; 
				sign = 1; 
				g_old = g; g = g2; 
				x0 = x2; y0 = y2;
			} 
			dist += s_min;
			//////////////////////////////////////////////////////
			while (1) {
				x = (int)x0; y = (int)y0;
				if ( x >= image_x-1 || x <= 0 || y >= image_y-1 || y <= 0 ) break;
				gx = -e[x][y].ty * sign;
				gy = e[x][y].tx * sign;
				if ( fdog[x][y] == 1.0 ) break;
				if (gx == 0.0 && gy == 0.0) break;
				//if ( g > thres ) { TRACE("g = %f\n", g); break; }
				//////////////////////////////////////////////////////
				right = (int)(x0 + 1.0);
				left = (x0 > ((int)x0)) ? (int)x0 : (int)(x0-1);
				top = (int)(y0 + 1.0);
				bottom = (y0 > ((int)y0)) ? (int)y0 : (int)(y0-1);
				s_min = 100.0;
				s_right = (gx == 0.0) ? 1000 : (right - x0) / gx;
				if (s_right > 0.0 && s_right < s_min) s_min = s_right;
				s_left = (gx == 0.0) ? 1000 : (left - x0) / gx;
				if (s_left > 0.0 && s_left < s_min) s_min = s_left;
				s_top = (gy == 0.0) ? 1000 : (top - y0) / gy;
				if (s_top > 0.0 && s_top < s_min) s_min = s_top;
				s_bottom = (gy == 0.0) ? 1000 : (bottom - y0) / gy;
				if (s_bottom > 0.0 && s_bottom < s_min) s_min = s_bottom;

				x1 = x0 + gx * s_min;
				y1 = y0 + gy * s_min;
				g1 = fdog[(int)x1][(int)y1];

				if ( (g < g1) && (g < g_old) ) break;

				//////////////////////////////////////////////
				// update dist, (x0, y0) and g_old, g
				g_old = g; g = g1; 
				x0 = x1; y0 = y1;
				dist += s_min;
			} // end while
			////////////////////////////////////////
			//image[i][j] = map(g, dist); 
			//image[i][j] = round(g * 255.0);
			image[(int)x0][(int)y0] = round(g * 255.0);
			//if (image[(int)x0][(int)y0] == 255) image[(int)x0][(int)y0] = round(g * 255.0);
			/////////////////////////////////////////////////////
		}
	}
}

void ReplaceStrokeTexture2(matrix& fdog, ETF& e, imatrix& image, double thres)
// Follow a straight line (instead of actual vector flow)
{
	double	gx, gy;
	double	g, g1, g2, g_old;
	//double	t; // interpolation parameter
	int i, j, x, y;
	int right, left, top, bottom;
	double x0, y0, x1, y1, x2, y2;
	double dist, s_min, s_right, s_left, s_top, s_bottom;
	int sign;

	int image_x = e.getRow();
	int image_y = e.getCol();

	imatrix tmp(image_x, image_y);
	tmp.copy(image);

	///////////////////////////////////////
	for (j = 0; j < image_y; j++)
		for (i = 0; i < image_x; i++)
			image[i][j] = 255;
	///////////////////////////////////////////////////////
	// vector field following to find dist, maximum g
	for (j = 1; j < image_y-1; j++) {
		for (i = 1; i < image_x-1; i++) {
			//////////////////////////////////
			dist = 0.0;
			gx = -e[i][j].ty;
			gy = e[i][j].tx;
			if (fdog[i][j] == 1.0) continue;  // not an edge 
			if (gx == 0.0 && gy == 0.0) continue; // not an edge 
			g = fdog[i][j];
			/////////////////////////////////////////////////////////
			if (g > thres) { continue; } // not an edge
			//if (tmp[i][j] > 250) { continue; } // not an edge
			///////////////////////////////////////////////////////
			x0 = (double)i; y0 = (double)j;
			//////////////////////////////////////////////////////
			right = (int)(x0 + 1.0);
			left = (x0 > (double)((int)x0)) ? (int)x0 : (int)(x0-1);
			top = (int)(y0 + 1.0);
			bottom = (y0 > (double)((int)y0)) ? (int)y0 : (int)(y0-1);
			s_min = 100.0;
			s_right = (gx == 0.0) ? 1000 : (right - x0) / gx;
			if (s_right > 0.0 && s_right < s_min) s_min = s_right;
			s_left = (gx == 0.0) ? 1000 : (left - x0) / gx;
			if (s_left > 0.0 && s_left < s_min) s_min = s_left;
			s_top = (gy == 0.0) ? 1000 : (top - y0) / gy;
			if (s_top > 0.0 && s_top < s_min) s_min = s_top;
			s_bottom = (gy == 0.0) ? 1000 : (bottom - y0) / gy;
			if (s_bottom > 0.0 && s_bottom < s_min) s_min = s_bottom;

			x1 = x0 + gx * s_min;
			y1 = y0 + gy * s_min;
			g1 = fdog[(int)x1][(int)y1];
			x2 = x0 + gx * -s_min;
			y2 = y0 + gy * -s_min;
			g2 = fdog[(int)x2][(int)y2];
			////////////////////////////////
			if ( (g < g1) && (g < g2) ) { // maxima pixel
				image[i][j] = round(g * 255.0);
				continue;
			}
			if ( (g1 - g) <= (g2 - g) ) { // move towards g1
				sign = 1; g_old = g; g = g1; 
				x0 = x1; y0 = y1;
			} 
			else { // move towards g2 
				sign = -1; g_old = g; g = g2; 
				x0 = x2; y0 = y2;
			} 
			dist += s_min;
			//////////////////////////////////////////////////////
			while (1) {
				x = (int)x0; y = (int)y0;
				if ( x >= image_x-1 || x <= 0 || y >= image_y-1 || y <= 0 ) break;
				gx = -e[i][j].ty * sign;
				gy = e[i][j].tx * sign;
				if ( fdog[x][y] == 1.0 ) break;
				if (gx == 0.0 && gy == 0.0) break;
				//if ( g > thres ) { TRACE("g = %f\n", g); break; }
				//////////////////////////////////////////////////////
				right = (int)(x0 + 1.0);
				left = (x0 > ((int)x0)) ? (int)x0 : (int)(x0-1);
				top = (int)(y0 + 1.0);
				bottom = (y0 > ((int)y0)) ? (int)y0 : (int)(y0-1);
				s_min = 100.0;
				s_right = (gx == 0.0) ? 1000 : (right - x0) / gx;
				if (s_right > 0.0 && s_right < s_min) s_min = s_right;
				s_left = (gx == 0.0) ? 1000 : (left - x0) / gx;
				if (s_left > 0.0 && s_left < s_min) s_min = s_left;
				s_top = (gy == 0.0) ? 1000 : (top - y0) / gy;
				if (s_top > 0.0 && s_top < s_min) s_min = s_top;
				s_bottom = (gy == 0.0) ? 1000 : (bottom - y0) / gy;
				if (s_bottom > 0.0 && s_bottom < s_min) s_min = s_bottom;

				x1 = x0 + gx * s_min;
				y1 = y0 + gy * s_min;
				g1 = fdog[(int)x1][(int)y1];

				if ( (g < g1) && (g < g_old) ) break;
				
				//////////////////////////////////////////////
				// update dist, (x0, y0) and g_old, g
				g_old = g; g = g1; 
				x0 = x1; y0 = y1;
				dist += s_min;
			} // end while
			////////////////////////////////////////
			//image[i][j] = map(g, dist); 
			image[i][j] = round(g * 255.0);
			//image[(int)x0][(int)y0] = round(g * 255.0);
			//if (image[(int)x0][(int)y0] == 255) image[(int)x0][(int)y0] = round(g * 255.0);
			/////////////////////////////////////////////////////
		}
	}
}

void ReplaceStrokeTexture3(matrix& fdog, ETF& e, imatrix& image)
// naively follow ETF direction (without changing the direction)
{
	double	gx, gy;
	double	g, g1, g2, g_old;
	//double	t; // interpolation parameter
	int i, j, x, y;
	int right, left, top, bottom;
	double x0, y0, x1, y1, x2, y2;
	double dist, s_min, s_right, s_left, s_top, s_bottom;
	//int sign;

	int image_x = e.getRow();
	int image_y = e.getCol();

	imatrix tmp(image_x, image_y);
	tmp.copy(image);

	///////////////////////////////////////
	for (j = 0; j < image_y; j++)
		for (i = 0; i < image_x; i++)
			image[i][j] = 255;
	///////////////////////////////////////////////////////
	// vector field following to find dist, maximum g
	for (j = 1; j < image_y-1; j++) {
		for (i = 1; i < image_x-1; i++) {
			//////////////////////////////////
			dist = 0.0;
			gx = -e[i][j].ty;
			gy = e[i][j].tx;
			if (fdog[i][j] == 1.0) continue;  // not an edge 
			if (gx == 0.0 && gy == 0.0) continue; // not an edge 
			g = fdog[i][j];
			/////////////////////////////////////////////////////////
			if (g > 0.99) { continue; } // not an edge
			//if (tmp[i][j] > 250) { continue; } // not an edge
			///////////////////////////////////////////////////////
			x0 = (double)i; y0 = (double)j;
			//////////////////////////////////////////////////////
			right = (int)(x0 + 1.0);
			left = (x0 > (double)((int)x0)) ? (int)x0 : (int)(x0-1);
			top = (int)(y0 + 1.0);
			bottom = (y0 > (double)((int)y0)) ? (int)y0 : (int)(y0-1);
			s_min = 100.0;
			s_right = (gx == 0.0) ? 1000 : (right - x0) / gx;
			if (s_right > 0.0 && s_right < s_min) s_min = s_right;
			s_left = (gx == 0.0) ? 1000 : (left - x0) / gx;
			if (s_left > 0.0 && s_left < s_min) s_min = s_left;
			s_top = (gy == 0.0) ? 1000 : (top - y0) / gy;
			if (s_top > 0.0 && s_top < s_min) s_min = s_top;
			s_bottom = (gy == 0.0) ? 1000 : (bottom - y0) / gy;
			if (s_bottom > 0.0 && s_bottom < s_min) s_min = s_bottom;

			x1 = x0 + gx * s_min;
			y1 = y0 + gy * s_min;
			g1 = fdog[(int)x1][(int)y1];
			x2 = x0 + gx * -s_min;
			y2 = y0 + gy * -s_min;
			g2 = fdog[(int)x2][(int)y2];
			////////////////////////////////
			if ( (g < g1) && (g < g2) ) { // maxima pixel
				image[i][j] = round(g * 255.0);
				continue;
			}
			//sign = 1; 
			g_old = g; g = g1; 
			x0 = x1; y0 = y1;
			dist += s_min;
			//////////////////////////////////////////////////////
			while (1) {
				x = (int)x0; y = (int)y0;
				if ( x >= image_x-1 || x <= 0 || y >= image_y-1 || y <= 0 ) break;
				gx = -e[x][y].ty;
				gy = e[x][y].tx;
				if ( fdog[x][y] == 1.0 ) break;
				if (gx == 0.0 && gy == 0.0) break;
				//if ( g > thres ) { TRACE("g = %f\n", g); break; }
				//////////////////////////////////////////////////////
				right = (int)(x0 + 1.0);
				left = (x0 > ((int)x0)) ? (int)x0 : (int)(x0-1);
				top = (int)(y0 + 1.0);
				bottom = (y0 > ((int)y0)) ? (int)y0 : (int)(y0-1);
				s_min = 100.0;
				s_right = (gx == 0.0) ? 1000 : (right - x0) / gx;
				if (s_right > 0.0 && s_right < s_min) s_min = s_right;
				s_left = (gx == 0.0) ? 1000 : (left - x0) / gx;
				if (s_left > 0.0 && s_left < s_min) s_min = s_left;
				s_top = (gy == 0.0) ? 1000 : (top - y0) / gy;
				if (s_top > 0.0 && s_top < s_min) s_min = s_top;
				s_bottom = (gy == 0.0) ? 1000 : (bottom - y0) / gy;
				if (s_bottom > 0.0 && s_bottom < s_min) s_min = s_bottom;

				x1 = x0 + gx * s_min;
				y1 = y0 + gy * s_min;
				g1 = fdog[(int)x1][(int)y1];

				if ( (g <= g1) && (g <= g_old) ) break;
				
				//////////////////////////////////////////////
				// update dist, (x0, y0) and g_old, g
				g_old = g; g = g1; 
				x0 = x1; y0 = y1;
				dist += s_min;
			} // end while
			////////////////////////////////////////
			//image[i][j] = map(g, dist); 
			//image[i][j] = round(g * 255.0);
			image[(int)x0][(int)y0] = round(g * 255.0);
			//if (image[(int)x0][(int)y0] == 255) image[(int)x0][(int)y0] = round(g * 255.0);
			/////////////////////////////////////////////////////
		}
	}
}

void ReplaceStrokeTexture4(matrix& fdog, ETF& e, imatrix& image, imatrix& tex)
// naively follow ETF direction (without changing the direction)
// replace the pixel with texture pixel!
{
	double	gx, gy;
	double	g, g1, g2, g_old;
	//double	t; // interpolation parameter
	int i, j, x, y;
	int right, left, top, bottom;
	double x0, y0, x1, y1, x2, y2;
	double dist, s_min, s_right, s_left, s_top, s_bottom;
	//int sign;

	int image_x = e.getRow();
	int image_y = e.getCol();

	imatrix tmp(image_x, image_y);
	tmp.copy(image);

	int tex_x = tex.getRow();
	int tex_y = tex.getCol();

	TRACE("tex_x = %d, tex_y = %d\n", tex_x, tex_y);
	
	double max_dist;
	int perturb;
	int t_x, t_y;
	//double piv_x, piv_y;
	//double slope;
	//max_dist = 50.0; // pencil
	max_dist = 30.0; // 
	perturb = 0; // 
	//perturb = 10; // pencil 

	//piv_x = 0.9; piv_y = 0.1; // piv_x in (0.0, 1.0)

	///////////////////////////////////////
	for (j = 0; j < image_y; j++)
		for (i = 0; i < image_x; i++)
			image[i][j] = 255;
	///////////////////////////////////////////////////////
	// vector field following to find dist, maximum g
	for (j = 1; j < image_y-1; j++) {
		for (i = 1; i < image_x-1; i++) {
			//////////////////////////////////
			dist = 0.0;
			gx = -e[i][j].ty;
			gy = e[i][j].tx;
			//if (fdog[i][j] == 1.0) continue;  // not an edge 
			if (gx == 0.0 && gy == 0.0) continue; // not an edge 
			g = fdog[i][j];
			/////////////////////////////////////////////////////////
			//if (g > 0.99) { continue; } // not an edge
			//if (tmp[i][j] > 250) { continue; } // not an edge
			///////////////////////////////////////////////////////
			x0 = (double)i; y0 = (double)j;
			//////////////////////////////////////////////////////
			right = (int)(x0 + 1.0);
			left = (x0 > (double)((int)x0)) ? (int)x0 : (int)(x0-1);
			top = (int)(y0 + 1.0);
			bottom = (y0 > (double)((int)y0)) ? (int)y0 : (int)(y0-1);
			s_min = 100.0;
			s_right = (gx == 0.0) ? 1000 : (right - x0) / gx;
			if (s_right > 0.0 && s_right < s_min) s_min = s_right;
			s_left = (gx == 0.0) ? 1000 : (left - x0) / gx;
			if (s_left > 0.0 && s_left < s_min) s_min = s_left;
			s_top = (gy == 0.0) ? 1000 : (top - y0) / gy;
			if (s_top > 0.0 && s_top < s_min) s_min = s_top;
			s_bottom = (gy == 0.0) ? 1000 : (bottom - y0) / gy;
			if (s_bottom > 0.0 && s_bottom < s_min) s_min = s_bottom;

			x1 = x0 + gx * s_min;
			y1 = y0 + gy * s_min;
			g1 = fdog[(int)x1][(int)y1];
			x2 = x0 + gx * -s_min;
			y2 = y0 + gy * -s_min;
			g2 = fdog[(int)x2][(int)y2];
			////////////////////////////////
			if ( (g < g1) && (g < g2) ) { // maxima pixel
				//image[i][j] = round(g * 255.0);
				t_x = round( (dist / max_dist) * (double)(tex_x-1) ); 
				t_y = round( (1.0-g) * (double)(tex_y-1) );
				/*
				g = 1-g;
				if (g >= piv_x) { 
					slope = (1.0 - piv_y) / (1.0 - piv_x);
					g = slope * (g - piv_x) + piv_y; 
					t_y = round( g * (double)(tex_y-1) );
				}
				else { 
					slope = piv_y / piv_x;
					g = slope * g; 
					t_y = round( g * (double)(tex_y-1) );
				}
				*/
				t_y = intrand(t_y - perturb, t_y + perturb);
				//t_y = intrand(0, t_y-1);
				if (t_y > tex_y-1) t_y = tex_y-1;
				if (t_y < 0) t_y = 0;
				//TRACE("t_x = %d, t_y = %d\n", t_x, t_y);
				image[i][j] = tex[t_x][t_y];
				continue;
			}
			//sign = 1; 
			g_old = g; g = g1; 
			x0 = x1; y0 = y1;
			dist += s_min;
			//////////////////////////////////////////////////////
			while (1) {
				x = (int)x0; y = (int)y0;
				if ( x >= image_x-1 || x <= 0 || y >= image_y-1 || y <= 0 ) { 
					dist = max_dist; g = 1.0;
					break;
				}
				gx = -e[x][y].ty;
				gy = e[x][y].tx;
				if ( fdog[x][y] == 1.0 ) break;
				if (gx == 0.0 && gy == 0.0) break;
				//if ( g > thres ) { TRACE("g = %f\n", g); break; }
				//////////////////////////////////////////////////////
				right = (int)(x0 + 1.0);
				left = (x0 > ((int)x0)) ? (int)x0 : (int)(x0-1);
				top = (int)(y0 + 1.0);
				bottom = (y0 > ((int)y0)) ? (int)y0 : (int)(y0-1);
				s_min = 100.0;
				s_right = (gx == 0.0) ? 1000 : (right - x0) / gx;
				if (s_right > 0.0 && s_right < s_min) s_min = s_right;
				s_left = (gx == 0.0) ? 1000 : (left - x0) / gx;
				if (s_left > 0.0 && s_left < s_min) s_min = s_left;
				s_top = (gy == 0.0) ? 1000 : (top - y0) / gy;
				if (s_top > 0.0 && s_top < s_min) s_min = s_top;
				s_bottom = (gy == 0.0) ? 1000 : (bottom - y0) / gy;
				if (s_bottom > 0.0 && s_bottom < s_min) s_min = s_bottom;

				x1 = x0 + gx * s_min;
				y1 = y0 + gy * s_min;
				g1 = fdog[(int)x1][(int)y1];

				if ( (g <= g1) && (g <= g_old) ) break;
				
				//////////////////////////////////////////////
				// update dist, (x0, y0) and g_old, g
				g_old = g; g = g1; 
				x0 = x1; y0 = y1;
				dist += s_min;

				//if (dist > max_dist) { dist = max_dist; break; }
			} // end while
			////////////////////////////////////////
			//image[i][j] = map(g, dist); 
			//image[i][j] = round(g * 255.0);
			//image[(int)x0][(int)y0] = round(g * 255.0);
			if (dist > max_dist) dist = max_dist;
			t_x = round( (dist / max_dist) * (double)(tex_x-1) ); 
			t_y = round( (1.0-g) * (double)(tex_y-1) );
			/*
			g = 1-g;
			if (g >= piv_x) { 
				slope = (1.0 - piv_y) / (1.0 - piv_x);
				g = slope * (g - piv_x) + piv_y; 
				t_y = round( g * (double)(tex_y-1) );
			}
			else { 
				slope = piv_y / piv_x;
				g = slope * g; 
				t_y = round( g * (double)(tex_y-1) );
			}
			//t_y = intrand(0, tex_y-1);
			*/
			t_y = intrand(t_y - perturb, t_y + perturb);
			if (t_y > tex_y-1) t_y = tex_y-1;
			if (t_y < 0) t_y = 0;
			//TRACE("t_x = %d, t_y = %d\n", t_x, t_y);
			image[i][j] = tex[t_x][t_y];
			//if (image[(int)x0][(int)y0] == 255) image[(int)x0][(int)y0] = round(g * 255.0);
			/////////////////////////////////////////////////////
		}
	}
}

void ReplaceStrokeTexture5(matrix& fdog, ETF& e, imatrix& image, imatrix& tex)
// naively follow ETF direction (without changing the direction)
// replace the pixel with texture pixel!
// Use something other than the fdog value to determine ty! (some smoothly varying value!)
{
	double	gx, gy;
	double	g, g1, g2, g_old;
	//double	t; // interpolation parameter
	int i, j, x, y;
	int right, left, top, bottom;
	double x0, y0, x1, y1, x2, y2;
	double dist, s_min, s_right, s_left, s_top, s_bottom;
	//int sign;

	int image_x = e.getRow();
	int image_y = e.getCol();

	imatrix tmp(image_x, image_y);
	tmp.copy(image);

	int tex_x = tex.getRow();
	int tex_y = tex.getCol();

	TRACE("tex_x = %d, tex_y = %d\n", tex_x, tex_y);
	
	double max_dist;
	double h;
	//int perturb;
	int t_x, t_y;
	//double piv_x, piv_y;
	//double slope;
	max_dist = 10.0; 
    //max_dist = 3.0; // pencil
	//perturb = 0; // 
	//perturb = 10; // pencil 

	//piv_x = 0.9; piv_y = 0.1; // piv_x in (0.0, 1.0)

	///////////////////////////////////////
	for (j = 0; j < image_y; j++)
		for (i = 0; i < image_x; i++)
			image[i][j] = 255;
	///////////////////////////////////////////////////////
	// vector field following to find dist, maximum g
	for (j = 1; j < image_y-1; j++) {
		for (i = 1; i < image_x-1; i++) {
			//////////////////////////////////
			dist = 0.0;
			gx = -e[i][j].ty;
			gy = e[i][j].tx;
			//if (fdog[i][j] == 1.0) continue;  // not an edge 
			if (gx == 0.0 && gy == 0.0) continue; // not an edge 
			g = fdog[i][j];
			/////////////////////////////////////////////////////////
			//if (g > 0.99) { continue; } // not an edge
			///////////////////////////////////////////////////////
			x0 = (double)i; y0 = (double)j;
			//////////////////////////////////////////////////////
			right = (int)(x0 + 1.0);
			left = (x0 > (double)((int)x0)) ? (int)x0 : (int)(x0-1);
			top = (int)(y0 + 1.0);
			bottom = (y0 > (double)((int)y0)) ? (int)y0 : (int)(y0-1);
			s_min = 100.0;
			s_right = (gx == 0.0) ? 1000 : (right - x0) / gx;
			if (s_right > 0.0 && s_right < s_min) s_min = s_right;
			s_left = (gx == 0.0) ? 1000 : (left - x0) / gx;
			if (s_left > 0.0 && s_left < s_min) s_min = s_left;
			s_top = (gy == 0.0) ? 1000 : (top - y0) / gy;
			if (s_top > 0.0 && s_top < s_min) s_min = s_top;
			s_bottom = (gy == 0.0) ? 1000 : (bottom - y0) / gy;
			if (s_bottom > 0.0 && s_bottom < s_min) s_min = s_bottom;

			x1 = x0 + gx * s_min;
			y1 = y0 + gy * s_min;
			g1 = fdog[(int)x1][(int)y1];
			x2 = x0 + gx * -s_min;
			y2 = y0 + gy * -s_min;
			g2 = fdog[(int)x2][(int)y2];
			////////////////////////////////
			if ( (g < g1) && (g < g2) ) { // maxima pixel
				//image[i][j] = round(g * 255.0);
				//t_x = round( (dist / max_dist) * (double)(tex_x-1) ); 
				//t_x = (int)dist % tex_x; 
				t_x = 0;
				//////////////////////////////////////////
				h = atan(gy/gx); // [-PI/2, PI/2]
				h += PI/2.0; // [0, PI]
				h = h / PI * 180; // [0, 180]
				if (h > 180) h = 180; if (h < 0) h = 0;
				t_y = (int)h % tex_y;
				//t_y = round( (1.0-g) * (double)(tex_y-1) );
				//t_y = intrand(t_y - perturb, t_y + perturb);
				//t_y = intrand(0, t_y-1);
				//if (t_y > tex_y-1) t_y = tex_y-1;
				//if (t_y < 0) t_y = 0;
				//TRACE("t_x = %d, t_y = %d\n", t_x, t_y);
				image[i][j] = tex[t_x][t_y];
				continue;
			}
			//sign = 1; 
			g_old = g; g = g1; 
			x0 = x1; y0 = y1;
			dist += s_min;
			//////////////////////////////////////////////////////
			while (1) {
				x = (int)x0; y = (int)y0;
				if ( x >= image_x-1 || x <= 0 || y >= image_y-1 || y <= 0 ) { 
					dist = max_dist; g = 1.0;
					break;
				}
				gx = -e[x][y].ty;
				gy = e[x][y].tx;
				if ( fdog[x][y] == 1.0 ) break;
				if (gx == 0.0 && gy == 0.0) break;
				//if ( g > thres ) { TRACE("g = %f\n", g); break; }
				//////////////////////////////////////////////////////
				right = (int)(x0 + 1.0);
				left = (x0 > ((int)x0)) ? (int)x0 : (int)(x0-1);
				top = (int)(y0 + 1.0);
				bottom = (y0 > ((int)y0)) ? (int)y0 : (int)(y0-1);
				s_min = 100.0;
				s_right = (gx == 0.0) ? 1000 : (right - x0) / gx;
				if (s_right > 0.0 && s_right < s_min) s_min = s_right;
				s_left = (gx == 0.0) ? 1000 : (left - x0) / gx;
				if (s_left > 0.0 && s_left < s_min) s_min = s_left;
				s_top = (gy == 0.0) ? 1000 : (top - y0) / gy;
				if (s_top > 0.0 && s_top < s_min) s_min = s_top;
				s_bottom = (gy == 0.0) ? 1000 : (bottom - y0) / gy;
				if (s_bottom > 0.0 && s_bottom < s_min) s_min = s_bottom;

				x1 = x0 + gx * s_min;
				y1 = y0 + gy * s_min;
				g1 = fdog[(int)x1][(int)y1];

				if ( (g <= g1) && (g <= g_old) ) break;
				
				//////////////////////////////////////////////
				// update dist, (x0, y0) and g_old, g
				g_old = g; g = g1; 
				x0 = x1; y0 = y1;
				dist += s_min;

				//if (dist > max_dist) { dist = max_dist; break; }
				if (dist > max_dist) break;
			} // end while
			////////////////////////////////////////
			//image[i][j] = map(g, dist); 
			//image[i][j] = round(g * 255.0);
			//image[(int)x0][(int)y0] = round(g * 255.0);
			if (dist > max_dist) continue;
			//if (dist > max_dist) dist = max_dist;
			t_x = round( (dist / max_dist) * (double)(tex_x-1) );
			//dist *= 100; 
			//t_x = (int)dist % tex_x; 
			//////////////////////////////////////////
			h = atan(gy/gx); // [-PI/2, PI/2]
			h += PI/2.0; // [0, PI]
			h = h / PI * 180; // [0, 180]
			if (h > 180) h = 180; if (h < 0) h = 0;
			t_y = (int)h % tex_y;
			//t_y = round( (1.0-g) * (double)(tex_y-1) );
			//t_y = intrand(t_y - perturb, t_y + perturb);
			//if (t_y > tex_y-1) t_y = tex_y-1;
			//if (t_y < 0) t_y = 0;
			//TRACE("t_x = %d, t_y = %d\n", t_x, t_y);
			image[i][j] = tex[t_x][t_y];
			//if (image[(int)x0][(int)y0] == 255) image[(int)x0][(int)y0] = round(g * 255.0);
			/////////////////////////////////////////////////////
		}
	}
}

void ReplaceStrokeTexture6(matrix& fdog, ETF& e, imatrix& image, imatrix& tex)
// naively follow ETF direction (without changing the direction)
// replace the pixel with texture pixel!
// Use something other than the fdog value to determine ty! (some smoothly varying value!)
// here we use (x + y)
{
	double	gx, gy;
	double	g, g1, g2, g_old;
	//double	t; // interpolation parameter
	int i, j, x, y;
	int right, left, top, bottom;
	double x0, y0, x1, y1, x2, y2;
	double dist, s_min, s_right, s_left, s_top, s_bottom;
	//int sign;

	int image_x = e.getRow();
	int image_y = e.getCol();

	imatrix tmp(image_x, image_y);
	tmp.copy(image);

	int tex_x = tex.getRow();
	int tex_y = tex.getCol();

	TRACE("tex_x = %d, tex_y = %d\n", tex_x, tex_y);
	
	double max_dist;
	//double h;
	//int perturb;
	int t_x, t_y;
	//double piv_x, piv_y;
	//double slope;
	max_dist = 10.0; 
    //max_dist = 1.5; // pencil
	//perturb = 0; // 
	//perturb = 10; // pencil 
	double factor = 1.0;
	//double freq = 5.0;
	//double freq = 10.0; // good!
	//double freq = 7.0; // good!
	//double freq = 20.0; // good!
	double freq_x = 20.0; // good!
	double freq_y = 10.0; // good!

	//piv_x = 0.9; piv_y = 0.1; // piv_x in (0.0, 1.0)

	///////////////////////////////////////
	for (j = 0; j < image_y; j++)
		for (i = 0; i < image_x; i++)
			image[i][j] = 255;
	///////////////////////////////////////////////////////
	// vector field following to find dist, maximum g
	for (j = 1; j < image_y-1; j++) {
		for (i = 1; i < image_x-1; i++) {
			//////////////////////////////////
			dist = 0.0;
			gx = -e[i][j].ty;
			gy = e[i][j].tx;
			//if (fdog[i][j] == 1.0) continue;  // not an edge 
			if (gx == 0.0 && gy == 0.0) continue; // not an edge 
			g = fdog[i][j];
			/////////////////////////////////////////////////////////
			//if (g > 0.99) { continue; } // not an edge
			///////////////////////////////////////////////////////
			x0 = (double)i; y0 = (double)j;
			//////////////////////////////////////////////////////
			right = (int)(x0 + 1.0);
			left = (x0 > (double)((int)x0)) ? (int)x0 : (int)(x0-1);
			top = (int)(y0 + 1.0);
			bottom = (y0 > (double)((int)y0)) ? (int)y0 : (int)(y0-1);
			s_min = 100.0;
			s_right = (gx == 0.0) ? 1000 : (right - x0) / gx;
			if (s_right > 0.0 && s_right < s_min) s_min = s_right;
			s_left = (gx == 0.0) ? 1000 : (left - x0) / gx;
			if (s_left > 0.0 && s_left < s_min) s_min = s_left;
			s_top = (gy == 0.0) ? 1000 : (top - y0) / gy;
			if (s_top > 0.0 && s_top < s_min) s_min = s_top;
			s_bottom = (gy == 0.0) ? 1000 : (bottom - y0) / gy;
			if (s_bottom > 0.0 && s_bottom < s_min) s_min = s_bottom;

			x1 = x0 + gx * s_min;
			y1 = y0 + gy * s_min;
			g1 = fdog[(int)x1][(int)y1];
			x2 = x0 + gx * -s_min;
			y2 = y0 + gy * -s_min;
			g2 = fdog[(int)x2][(int)y2];
			////////////////////////////////
			if ( (g < g1) && (g < g2) ) { // maxima pixel
				//image[i][j] = round(g * 255.0);
				//t_x = round( (dist / max_dist) * (double)(tex_x-1) ); 
				//t_x = (int)dist % tex_x; 
				t_x = 0;
				//////////////////////////////////////////
				//g = 1.0 - g;
				//g = factor * ( sin(freq * x0/180.*PI) * cos(freq * y0/180.*PI) ); // g in [-0.2, 1.2]
				g = freq_y * (x0 + y0);
				t_y = (int)g % tex_y;
				//g += factor; // g in [0.0, 1.4]
				//g /= (2.0 * factor);
				//if (g > 1.0) g = 1.0; if (g < 0.0) g = 0.0;
				//t_y = round( g * (double)(tex_y-1) );
				//t_y = intrand(t_y - perturb, t_y + perturb);
				//t_y = intrand(0, t_y-1);
				//if (t_y > tex_y-1) t_y = tex_y-1;
				//if (t_y < 0) t_y = 0;
				//TRACE("t_x = %d, t_y = %d\n", t_x, t_y);
				image[i][j] = tex[t_x][t_y];
				//g = fdog[i][j];
				//image[i][j] = round(tex[t_x][t_y] * g);
				continue;
			}
			//sign = 1; 
			g_old = g; g = g1; 
			x0 = x1; y0 = y1;
			dist += s_min;
			//////////////////////////////////////////////////////
			while (1) {
				x = (int)x0; y = (int)y0;
				if ( x >= image_x-1 || x <= 0 || y >= image_y-1 || y <= 0 ) { 
					dist = max_dist+1; g = 1.0;
					break;
				}
				gx = -e[x][y].ty;
				gy = e[x][y].tx;
				if ( fdog[x][y] == 1.0 ) break;
				if (gx == 0.0 && gy == 0.0) break;
				//if ( g > thres ) { TRACE("g = %f\n", g); break; }
				//////////////////////////////////////////////////////
				right = (int)(x0 + 1.0);
				left = (x0 > ((int)x0)) ? (int)x0 : (int)(x0-1);
				top = (int)(y0 + 1.0);
				bottom = (y0 > ((int)y0)) ? (int)y0 : (int)(y0-1);
				s_min = 100.0;
				s_right = (gx == 0.0) ? 1000 : (right - x0) / gx;
				if (s_right > 0.0 && s_right < s_min) s_min = s_right;
				s_left = (gx == 0.0) ? 1000 : (left - x0) / gx;
				if (s_left > 0.0 && s_left < s_min) s_min = s_left;
				s_top = (gy == 0.0) ? 1000 : (top - y0) / gy;
				if (s_top > 0.0 && s_top < s_min) s_min = s_top;
				s_bottom = (gy == 0.0) ? 1000 : (bottom - y0) / gy;
				if (s_bottom > 0.0 && s_bottom < s_min) s_min = s_bottom;

				x1 = x0 + gx * s_min;
				y1 = y0 + gy * s_min;
				g1 = fdog[(int)x1][(int)y1];

				if ( (g <= g1) && (g <= g_old) ) break;
				
				//////////////////////////////////////////////
				// update dist, (x0, y0) and g_old, g
				g_old = g; g = g1; 
				x0 = x1; y0 = y1;
				dist += s_min;

				//if (dist > max_dist) { dist = max_dist; break; }
				if (dist > max_dist) break;
			} // end while
			////////////////////////////////////////
			//image[i][j] = map(g, dist); 
			//image[i][j] = round(g * 255.0);
			//image[(int)x0][(int)y0] = round(g * 255.0);
			if (dist > max_dist) continue;
			//if (dist > max_dist) dist = max_dist;
			g = freq_x * dist;
			t_x = (int)g % tex_x;
			//t_x = round( (dist / max_dist) * (double)(tex_x-1) );
			//dist *= 100; 
			//t_x = (int)dist % tex_x; 
			//////////////////////////////////////////
			//g = 1.0 - g;
			//g = factor * ( sin(freq * x0/180.*PI) * cos(freq * y0/180.*PI) ); // g in [-0.2, 12]
			//g = freq * dist;
			g = freq_y * (x0 + y0);
			t_y = (int)g % tex_y;
			//g += factor; // g in [0, 14]
			//g /= (2.0 * factor);
			//if (g > 1.0) g = 1.0; if (g < 0.0) g = 0.0;
			//t_y = round( g * (double)(tex_y-1) );
			//t_y = round( (1.0-g) * (double)(tex_y-1) );
			//t_y = intrand(t_y - perturb, t_y + perturb);
			//if (t_y > tex_y-1) t_y = tex_y-1;
			//if (t_y < 0) t_y = 0;
			//TRACE("t_x = %d, t_y = %d\n", t_x, t_y);
			image[i][j] = tex[t_x][t_y];
			//g = fdog[i][j];
			//image[i][j] = round(tex[t_x][t_y] * g);
			//if (image[(int)x0][(int)y0] == 255) image[(int)x0][(int)y0] = round(g * 255.0);
			/////////////////////////////////////////////////////
		}
	}
}

void ReplaceStrokeTexture8(matrix& fdog, ETF& e, imatrix& image, imatrix& thin, imatrix& tex, bool sumie)
// replace the pixel with texture pixel!
// Use something other than the fdog value to determine ty! (some smoothly varying value!)
// here we use min(x, y) or max(x, y)
{
	double	gx, gy, tx, ty, gx_old, gy_old;
	double	g, g1, g2, g_old;
	//double	t; // interpolation parameter
	int i, j, x, y;
	int right, left, top, bottom;
	double x0, y0, x1, y1, x2, y2;
	double dist, s_min, s_right, s_left, s_top, s_bottom;
	//int sign;

	int image_x = e.getRow();
	int image_y = e.getCol();

	imatrix tmp(image_x, image_y);
	tmp.copy(image);

	int tex_x = tex.getRow();
	int tex_y = tex.getCol();

	TRACE("tex_x = %d, tex_y = %d\n", tex_x, tex_y);
	
	//double max_dist;
	//double h;
	//int perturb;
	int t_x, t_y;
	//double angle;
	//double freq = 5.0;
	double freq_x = 30; // pencil
	double freq_y = 10; // pencil

	bool abnormal;
	bool enter_r, enter_l, enter_t, enter_b;

	///////////////////////////////////////
	image.white();
	///////////////////////////////////////////////////////
	// vector field following to find dist, maximum g
	for (j = 1; j < image_y-1; j++) {
		for (i = 1; i < image_x-1; i++) {
			//////////////////////////////////
			abnormal = false;
			dist = 0.0;
			gx = -e[i][j].ty;
			gy = e[i][j].tx;
			//if (fdog[i][j] == 1.0) continue;  // not an edge 
			if (gx == 0.0 && gy == 0.0) continue; // not an edge 
			g = fdog[i][j];
			/////////////////////////////////////////////////////////
			//if (g > 0.7) { continue; } // not an edge
			//if (g > 0.8) { continue; } // not an edge
			//if (g > 0.9) { continue; } // not an edge
			//if (g > 0.99) { continue; } // not an edge
			///////////////////////////////////////////////////////
			x0 = (double)i; y0 = (double)j;
			//x0 = (double)i + 0.5; y0 = (double)j + 0.5;
			//////////////////////////////////////////////////////
			right = (int)(x0 + 1.0);
			//left = (int)x0;
			left = (int)(x0 - 1.0);
			top = (int)(y0 + 1.0);
			bottom = (int)(y0 - 1.0);
			//bottom = (int)y0;
			//TRACE("[%d,%d] right = %d, left = %d, top = %d, bottom = %d\n", i, j, right, left, top, bottom);
			//////////////////////////
			s_min = 100.0;
			enter_r = enter_l = enter_b = enter_t = false;
			s_right = (gx == 0.0) ? -1 : (right - x0) / gx;
			if (s_right > 0.0 && s_right < s_min) {
				enter_r = true; enter_l = enter_t = enter_b = false;
				s_min = s_right;
			}
			s_left = (gx == 0.0) ? -1 : (left - x0) / gx;
			if (s_left > 0.0 && s_left < s_min) {
				enter_l = true; enter_r = enter_t = enter_b = false;
				s_min = s_left;
			}
			s_top = (gy == 0.0) ? -1 : (top - y0) / gy;
			if (s_top > 0.0 && s_top < s_min) {
				enter_t = true; enter_b = enter_r = enter_l = false;
				s_min = s_top;
			}
			s_bottom = (gy == 0.0) ? -1 : (bottom - y0) / gy;
			if (s_bottom > 0.0 && s_bottom < s_min) {
				enter_b = true; enter_t = enter_r = enter_l = false;
				s_min = s_bottom;
			}

			x1 = x0 + gx * s_min; if (enter_r || enter_l) x1 = (double)round(x1);
			y1 = y0 + gy * s_min; if (enter_t || enter_b) y1 = (double)round(y1);
			g1 = fdog[(int)x1][(int)y1];
			x2 = x0 + gx * -s_min; if (enter_r || enter_l) x1 = (double)round(x1);
			y2 = y0 + gy * -s_min; if (enter_t || enter_b) y1 = (double)round(y1);
			g2 = fdog[(int)x2][(int)y2];
			////////////////////////////////
			//if ( (g < g1) && (g < g2) ) { // maxima pixel
			if (thin[i][j] == 0) {
				//image[i][j] = round(g * 255.0);
				//t_x = round( (dist / max_dist) * (double)(tex_x-1) ); 
				//t_x = (int)dist % tex_x; 
				t_x = 0;
				//////////////////////////////////////////
				if (fabs(e[i][j].tx) >= fabs(e[i][j].ty)) g = x0;
				else g = y0;
				g = freq_y * g;
				t_y = (int)g % tex_y;
				image[i][j] = tex[t_x][t_y];
				if (sumie) {
					g = fdog[i][j]; 
					image[i][j] = round(g * 255.);
				}
				//g = fdog[i][j];
				//image[i][j] = round(tex[t_x][t_y] * g);
				continue;
			}
			//sign = 1; 
			g_old = g; g = g1; 
			x2 = x0; y2 = y0;
			x0 = x1; y0 = y1;
			gx_old = gx; gy_old = gy;
			dist += s_min;
			//////////////////////////////////////////////////////
			while (1) {
				x = (int)x0; y = (int)y0;
				if ( thin[x][y] == 0 ) break;
				///////////////////////////////////
				if ( x >= image_x-1 || x <= 0 || y >= image_y-1 || y <= 0 ) { 
					//dist = max_dist+1; g = 1.0;
					abnormal = true;
					break;
				}
				gx = -e[x][y].ty;
				gy = e[x][y].tx;
				//if ( fdog[x][y] == 1.0 ) break;
				if (gx == 0.0 && gy == 0.0) { 
					abnormal = true;
					break;
				}
				///////////////////////////////////////
				if (gx * gx_old + gy * gy_old < 0.0) break;
				//if ( g > thres ) { TRACE("g = %f\n", g); break; }
				//////////////////////////////////////////////////////
				right = (int)(x0 + 1.0);
				left = (x0 > (double)((int)x0)) ? (int)x0 : (int)(x0-1);
				top = (int)(y0 + 1.0);
				bottom = (y0 > ((int)y0)) ? (int)y0 : (int)(y0-1);
				///////////////////////////////////////////////////
				s_min = 100.0;
				enter_r = enter_l = enter_t = enter_b = false;
				s_right = (gx == 0.0) ? 1000 : (right - x0) / gx;
				if (s_right > 0.0 && s_right < s_min) {
					enter_r = true; enter_l = enter_t = enter_b = false; 
					s_min = s_right;
				}
				s_left = (gx == 0.0) ? 1000 : (left - x0) / gx;
				if (s_left > 0.0 && s_left < s_min) {
					enter_l = true; enter_r = enter_t = enter_b = false;
					s_min = s_left;
				}
				s_top = (gy == 0.0) ? 1000 : (top - y0) / gy;
				if (s_top > 0.0 && s_top < s_min) {
					enter_t = true; enter_b = enter_r = enter_l = false;
					s_min = s_top;
				}
				s_bottom = (gy == 0.0) ? 1000 : (bottom - y0) / gy;
				if (s_bottom > 0.0 && s_bottom < s_min) {
					enter_b = true; enter_t = enter_r = enter_l = false;
					s_min = s_bottom;
				}

				x1 = x0 + gx * s_min; if (enter_r || enter_l) x1 = (double)round(x1);
				y1 = y0 + gy * s_min; if (enter_t || enter_b) y1 = (double)round(y1);
				g1 = fdog[(int)x1][(int)y1];

				/*
				if ( (int)x0 == (int)x1 )
					if ( (int)y0 == (int)y1 ) 
						break;
				*/

				//if ( (g <= g1) && (g <= g_old) ) break;
				
				//////////////////////////////////////////////
				// update dist, (x0, y0) and g_old, g
				g_old = g; g = g1; 
				x2 = x0; y2 = y0;
				x0 = x1; y0 = y1;
				gx_old = gx; gy_old = gy;
				dist += s_min;

				//if (dist > max_dist) break;
			} // end while
			////////////////////////////////////////
			//if (dist > max_dist) continue;
			if (abnormal) continue;
			////////////////////////
			g = freq_x * dist;
			t_x = (int)g % tex_x;
			//t_x = round( (dist / max_dist) * (double)(tex_x-1) );
			//if (t_x > 60)	TRACE("t_x = %d\n", t_x);
			//t_x = round( (dist / max_dist) * (double)(tex_x-1) );
			//dist *= 100; 
			//t_x = (int)dist % tex_x; 
			//////////////////////////////////////////
			//g = 1.0 - g;
			//g = factor * ( sin(freq * x0/180.*PI) * cos(freq * y0/180.*PI) ); // g in [-0.2, 12]
			//g = freq * dist;
			//g = freq_y * (x0 + y0);
			tx = e[(int)x0][(int)y0].tx;
			ty = e[(int)x0][(int)y0].ty;
			//angle = atan2(gy, gx); // [-PI, PI] 
			//angle = ABS(angle); // [0, PI]
			//if (angle < 0.25 * PI || angle > 0.75 * PI) g = x0;
			//else g = y0;
			////////////////////////////
			if (fabs(tx) >= fabs(ty)) g = x0;
			else g = y0;
			////////////////////////
			g = freq_y * g;
			t_y = (int)g % tex_y;
			image[i][j] = tex[t_x][t_y];
			///////////////////////////
			if (sumie) {
				g = fdog[(int)x0][(int)y0]; 
                image[i][j] = round(g * 255.);
			}
			//g = fdog[i][j];
			//image[i][j] = round(tex[t_x][t_y] * g);
			//if (image[(int)x0][(int)y0] == 255) image[(int)x0][(int)y0] = round(g * 255.0);
			/////////////////////////////////////////////////////
		}
	}
}

void ReplaceStrokeTexture13(matrix& fdog, ETF& e, imatrix& image, imatrix& thin, imatrix& tex, bool sumie)
// simply follow the flow like FDOG (don't use LIC)
// replace the pixel with texture pixel!
// Use something other than the fdog value to determine ty! (some smoothly varying value!)
{
	double	gx, gy, tx, ty, gx_old, gy_old;
	double	g, g1, g_old;
	//double	t; // interpolation parameter
	int i, j, x, y;
	double x0, y0, x1, y1, x2, y2;
	double dist;
	//int sign;

	int image_x = e.getRow();
	int image_y = e.getCol();

	imatrix tmp(image_x, image_y);
	tmp.copy(image);

	int tex_x = tex.getRow();
	int tex_y = tex.getCol();

	TRACE("tex_x = %d, tex_y = %d\n", tex_x, tex_y);
	
	//double max_dist;
	//double h;
	//int perturb;
	int t_x, t_y;
	//double angle;
	//double freq = 5.0;
	double freq_x = 30; // pencil
	double freq_y = 5; // pencil

	bool abnormal;
	double step_size = 1.0;

	///////////////////////////////////////
	image.white();
	///////////////////////////////////////////////////////
	// vector field following to find dist, maximum g
	for (j = 1; j < image_y-1; j++) {
		for (i = 1; i < image_x-1; i++) {
			//////////////////////////////////
			abnormal = false;
			dist = 0.0;
			gx = -e[i][j].ty;
			gy = e[i][j].tx;
			//if (fdog[i][j] == 1.0) continue;  // not an edge 
			if (gx == 0.0 && gy == 0.0) continue; // not an edge 
			g = fdog[i][j];
			/////////////////////////////////////////////////////////
			//if (g > 0.7) { continue; } // not an edge
			//if (g > 0.8) { continue; } // not an edge
			//if (g > 0.9) { continue; } // not an edge
			//if (g > 0.99) { continue; } // not an edge
			///////////////////////////////////////////////////////
			//x0 = (double)i; y0 = (double)j;
			x0 = (double)i; y0 = (double)j;
			//////////////////////////////////////////////////////
			x1 = x0 + gx * step_size;
			y1 = y0 + gy * step_size;
			g1 = fdog[round(x1)][round(y1)];
			////////////////////////////////
			if (thin[i][j] == 0) { // maxima pixel
				t_x = 0;
				//////////////////////////////////////////
				if (fabs(e[i][j].tx) >= fabs(e[i][j].ty)) g = x0;
				else g = y0;
				g = freq_y * g;
				t_y = (int)g % tex_y;
				image[i][j] = tex[t_x][t_y];
				if (sumie) {
					g = fdog[i][j]; 
					image[i][j] = round(g * 255.);
				}
				continue;
			}
			g_old = g; g = g1; 
			x2 = x0; y2 = y0;
			x0 = x1; y0 = y1;
			gx_old = gx; gy_old = gy;
			dist += step_size;
			//////////////////////////////////////////////////////
			while (1) {
				x = round(x0); y = round(y0);
				if ( thin[x][y] == 0 ) break; // maxima pixel
				///////////////////////////////////
				if ( x >= image_x-1 || x <= 0 || y >= image_y-1 || y <= 0 ) { 
					abnormal = true;
					break;
				}
				gx = -e[x][y].ty;
				gy = e[x][y].tx;
				if (gx == 0.0 && gy == 0.0) { 
					abnormal = true;
					break;
				}
				///////////////////////////////////////
				if (gx * gx_old + gy * gy_old < 0.0) break;
				//////////////////////////////////////////////////////
				
				x1 = x0 + gx * step_size; 
				y1 = y0 + gy * step_size; 
				g1 = fdog[round(x1)][round(y1)];

				//////////////////////////////////////////////
				g_old = g; g = g1; 
				x2 = x0; y2 = y0;
				x0 = x1; y0 = y1;
				gx_old = gx; gy_old = gy;
				dist += step_size;

			} // end while
			////////////////////////////////////////
			if (abnormal) continue;
			////////////////////////
			g = freq_x * dist;
			t_x = (int)g % tex_x;
			//////////////////////////////////////////
			tx = e[round(x0)][round(y0)].tx;
			ty = e[round(x0)][round(y0)].ty;
			////////////////////////////
			if (fabs(tx) >= fabs(ty)) g = x0;
			else g = y0;
			////////////////////////
			g = freq_y * g;
			t_y = (int)g % tex_y;
			image[i][j] = tex[t_x][t_y];
			///////////////////////////
			if (sumie) {
				g = fdog[round(x0)][round(y0)]; 
                image[i][j] = round(g * 255.);
			}
			/////////////////////////////////////////////////////
		}
	}
}


void ReplaceStrokeTexture9(matrix& fdog, ETF& e, imatrix& image, imatrix& tex, bool sumie)
// non-symmetric texture (horizontally)
// start from the center of the pixel (not the corner)
// replace the pixel with texture pixel!
// Use something other than the fdog value to determine ty! (some smoothly varying value!)
// here we use min(x, y) or max(x, y)
{
	double	gx, gy, tx, ty;
	double	g, g1, g2, g_old;
	//double	t; // interpolation parameter
	int i, j, x, y;
	int right, left, top, bottom;
	double x0, y0, x1, y1, x2, y2;
	double dist, s_min, s_right, s_left, s_top, s_bottom;
	//int sign;

	int image_x = e.getRow();
	int image_y = e.getCol();

	imatrix tmp(image_x, image_y);
	tmp.copy(image);

	int tex_x = tex.getRow();
	int tex_y = tex.getCol();

	TRACE("tex_x = %d, tex_y = %d\n", tex_x, tex_y);
	
	//double max_dist;
	//double h;
	//int perturb;
	int t_x, t_y;
	//double piv_x, piv_y;
	//double slope;
	//double max_dist = 10.0; 
	//max_dist = 5.0; 
	//max_dist = 3.0; 
    //max_dist = 5; // pencil
	//perturb = 0; // 
	//perturb = 10; // pencil 
	//double factor = 1.0;
	//double angle;
	//double freq = 5.0;
	//double freq_x = 10; // pencil
	double freq_x = 150; // crayon
	double freq_y = 10; // pencil

	//piv_x = 0.9; piv_y = 0.1; // piv_x in (0.0, 1.0)
	//bool sumie = false;
	//bool sumie = true;
	//double t;

	///////////////////////////////////////
	for (j = 0; j < image_y; j++)
		for (i = 0; i < image_x; i++)
			image[i][j] = 255;
	///////////////////////////////////////////////////////
	// vector field following to find dist, maximum g
	for (j = 1; j < image_y-1; j++) {
		for (i = 1; i < image_x-1; i++) {
			//////////////////////////////////
			dist = 0.0;
			gx = -e[i][j].ty;
			gy = e[i][j].tx;
			//if (fdog[i][j] == 1.0) continue;  // not an edge 
			if (gx == 0.0 && gy == 0.0) continue; // not an edge 
			g = fdog[i][j];
			/////////////////////////////////////////////////////////
			//if (g > 0.7) { continue; } // not an edge
			//if (g > 0.8) { continue; } // not an edge
			//if (g > 0.9) { continue; } // not an edge
			if (g > 0.99) { continue; } // not an edge
			///////////////////////////////////////////////////////
			//x0 = (double)i + 0.5; y0 = (double)j + 0.5;
			x0 = (double)i; y0 = (double)j;
			//////////////////////////////////////////////////////
			right = (int)(x0 + 1.0);
			//left = (int)x0;
			left = (x0 > (double)((int)x0)) ? (int)x0 : (int)(x0-1);
			top = (int)(y0 + 1.0);
			//bottom = (int)y0;
			bottom = (y0 > (double)((int)y0)) ? (int)y0 : (int)(y0-1);
			////////////////////////////////////////
			s_min = 100.0;
			s_right = (gx == 0.0) ? 1000 : (right - x0) / gx;
			if (s_right > 0.0 && s_right < s_min) s_min = s_right;
			s_left = (gx == 0.0) ? 1000 : (left - x0) / gx;
			if (s_left > 0.0 && s_left < s_min) s_min = s_left;
			s_top = (gy == 0.0) ? 1000 : (top - y0) / gy;
			if (s_top > 0.0 && s_top < s_min) s_min = s_top;
			s_bottom = (gy == 0.0) ? 1000 : (bottom - y0) / gy;
			if (s_bottom > 0.0 && s_bottom < s_min) s_min = s_bottom;

			x1 = x0 + gx * s_min;
			y1 = y0 + gy * s_min;
			g1 = fdog[(int)x1][(int)y1];
			x2 = x0 + gx * -s_min;
			y2 = y0 + gy * -s_min;
			g2 = fdog[(int)x2][(int)y2];
			////////////////////////////////
			if ( (g < g1) && (g < g2) ) { // maxima pixel
				//image[i][j] = round(g * 255.0);
				//t_x = round( (dist / max_dist) * (double)(tex_x-1) ); 
				//t_x = (int)dist % tex_x; 
				//t_x = 0;
				t_x = tex_x / 2;
				//////////////////////////////////////////
				//g = 1.0 - g;
				//g = factor * ( sin(freq * x0/180.*PI) * cos(freq * y0/180.*PI) ); // g in [-0.2, 1.2]
				//g = freq_y * (x0 + y0);
				tx = e[i][j].tx;
				ty = e[i][j].ty;
				//angle = atan2(gy, gx); // [-PI, PI] 
				//angle = ABS(angle); // [0, PI]
				//if (angle < 0.25 * PI || angle > 0.75 * PI) g = x0;
				//else g = y0;
				//if (fabs(tx) >= fabs(ty)) g = x0 - 0.5;
				//else g = y0 - 0.5;
				if (fabs(tx) >= fabs(ty)) g = x0;
				else g = y0;
				/////////////////////////
				g = freq_y * g;
				t_y = (int)g % tex_y;
				//g += factor; // g in [0.0, 1.4]
				//g /= (2.0 * factor);
				//if (g > 1.0) g = 1.0; if (g < 0.0) g = 0.0;
				//t_y = round( g * (double)(tex_y-1) );
				//t_y = intrand(t_y - perturb, t_y + perturb);
				//t_y = intrand(0, t_y-1);
				//if (t_y > tex_y-1) t_y = tex_y-1;
				//if (t_y < 0) t_y = 0;
				//TRACE("t_x = %d, t_y = %d\n", t_x, t_y);
				image[i][j] = tex[t_x][t_y];
				if (sumie) {
					//g = fdog[i][j]; 
					g = (255. - tex[t_x][t_y]) / 255.; // [0, 1] use this as an alpha map
					g *= fdog[i][j]; 
					image[i][j] = round(g * 255.);
				}
				//g = fdog[i][j];
				//image[i][j] = round(tex[t_x][t_y] * g);
				continue;
			}
			//sign = 1; 
			g_old = g; g = g1; 
			//x2 = x0; y2 = y0;
			x0 = x1; y0 = y1;
			dist += s_min;
			//////////////////////////////////////////////////////
			while (1) {
				x = (int)x0; y = (int)y0;
				if ( x >= image_x-1 || x <= 0 || y >= image_y-1 || y <= 0 ) { 
					//dist = max_dist+1; g = 1.0;
					break;
				}
				gx = -e[x][y].ty;
				gy = e[x][y].tx;
				if ( fdog[x][y] == 1.0 ) break;
				if (gx == 0.0 && gy == 0.0) break;
				//if ( g > thres ) { TRACE("g = %f\n", g); break; }
				//////////////////////////////////////////////////////
				right = (int)(x0 + 1.0);
				left = (x0 > ((int)x0)) ? (int)x0 : (int)(x0-1);
				top = (int)(y0 + 1.0);
				bottom = (y0 > ((int)y0)) ? (int)y0 : (int)(y0-1);
				s_min = 100.0;
				s_right = (gx == 0.0) ? 1000 : (right - x0) / gx;
				if (s_right > 0.0 && s_right < s_min) s_min = s_right;
				s_left = (gx == 0.0) ? 1000 : (left - x0) / gx;
				if (s_left > 0.0 && s_left < s_min) s_min = s_left;
				s_top = (gy == 0.0) ? 1000 : (top - y0) / gy;
				if (s_top > 0.0 && s_top < s_min) s_min = s_top;
				s_bottom = (gy == 0.0) ? 1000 : (bottom - y0) / gy;
				if (s_bottom > 0.0 && s_bottom < s_min) s_min = s_bottom;

				x1 = x0 + gx * s_min;
				y1 = y0 + gy * s_min;
				g1 = fdog[(int)x1][(int)y1];

				if ( (g <= g1) && (g <= g_old) ) break;
				//if ( (g < g1) && (g <= g_old) ) break;
				//if ( (g <= g1) && (g < g_old) ) break;
				
				//////////////////////////////////////////////
				// update dist, (x0, y0) and g_old, g
				g_old = g; g = g1; 
				//x2 = x0; y2 = y0;
				x0 = x1; y0 = y1;
				dist += s_min;

				//if (dist > max_dist) break;
			} // end while
			////////////////////////////////////////
			//image[i][j] = map(g, dist); 
			//image[i][j] = round(g * 255.0);
			//image[(int)x0][(int)y0] = round(g * 255.0);
			//if (dist > max_dist) continue;
			//if (dist > max_dist) dist = max_dist;
			//g = freq_x * dist;
			//if ((int)g > tex_x-1) continue;
			//t_x = (int)g % tex_x;
			//t_x = tex_x / 2;
			//t_x = round( (dist / max_dist) * (double)(tex_x-1) );
			//if (t_x > 60)	TRACE("t_x = %d\n", t_x);
			//t_x = round( (dist / max_dist) * (double)(tex_x-1) );
			//dist *= 100; 
			//t_x = (int)dist % tex_x; 
			//////////////////////////////////////////
			//g = 1.0 - g;
			//g = factor * ( sin(freq * x0/180.*PI) * cos(freq * y0/180.*PI) ); // g in [-0.2, 12]
			//g = freq * dist;
			//g = freq_y * (x0 + y0);
			tx = e[(int)x0][(int)y0].tx;
			ty = e[(int)x0][(int)y0].ty;
			gx = -ty; gy = tx;
			//angle = atan2(gy, gx); // [-PI, PI] 
			//angle = ABS(angle); // [0, PI]
			////////////////////////////////////
			dist *= freq_x;
			////////////////////////
			if (fabs(tx) >= fabs(ty)) { // moving horizontally; judge with sign of gy
				if (gy >= 0.0) { // right half of the texture
					//t_x = round( tex_x/2 + (dist / max_dist) * (double)(tex_x/2 - 1) );
					t_x = tex_x/2 + (int)dist % tex_x/2;
				}
				else { // left half of the texture
					//t_x = round( tex_x/2 - (dist / max_dist) * (double)(tex_x/2) );
					t_x = tex_x/2 - (int)dist % tex_x/2 - 1;
				}
			}
			else { // moving vertically; judge with sign of gx
				if (gx >= 0.0) { // right half of the texture
					//t_x = round( tex_x/2 + (dist / max_dist) * (double)(tex_x/2 - 1) );
					t_x = tex_x/2 + (int)dist % tex_x/2;
				}
				else { // left half of the texture
					//t_x = round( tex_x/2 - (dist / max_dist) * (double)(tex_x/2) );
					t_x = tex_x/2 - (int)dist % tex_x/2 - 1;
				}
			}
			//////////////////////////////////////
			///////////////////////////////////////
			//if (angle < 0.25 * PI || angle > 0.75 * PI) g = x0;
			//else g = y0;
			////////////////////////////////
			if (fabs(tx) >= fabs(ty)) g = x0;
			else g = y0;
			///////////////////////////
			g = freq_y * g;
			t_y = (int)g % tex_y;
			//g += factor; // g in [0, 14]
			//g /= (2.0 * factor);
			//if (g > 1.0) g = 1.0; if (g < 0.0) g = 0.0;
			//t_y = round( g * (double)(tex_y-1) );
			//t_y = round( (1.0-g) * (double)(tex_y-1) );
			//t_y = intrand(t_y - perturb, t_y + perturb);
			//if (t_y > tex_y-1) t_y = tex_y-1;
			//if (t_y < 0) t_y = 0;
			//TRACE("t_x = %d, t_y = %d\n", t_x, t_y);
			image[i][j] = tex[t_x][t_y];
			if (sumie) {
				//g = fdog[(int)x0][(int)y0]; 
				g = (255. - tex[t_x][t_y]) / 255.; // [0, 1] use this as an alpha map
				g *= fdog[(int)x0][(int)y0]; 
                image[i][j] = round(g * 255.);
			}
			//g = fdog[i][j];
			//image[i][j] = round(tex[t_x][t_y] * g);
			//if (image[(int)x0][(int)y0] == 255) image[(int)x0][(int)y0] = round(g * 255.0);
			/////////////////////////////////////////////////////
		}
	}
}

void ReplaceStrokeTexture10(matrix& fdog, ETF& e, imatrix& image, imatrix& tex, bool sumie)
// non-symmetric texture (horizontally)
// start from the center of the pixel (not the corner)
// replace the pixel with texture pixel!
// Use something other than the fdog value to determine ty! (some smoothly varying value!)
// here we use min(x, y) or max(x, y)
{
	double	gx, gy, tx, ty;
	double	g, g1, g2, g_old;
	//double	t; // interpolation parameter
	int i, j, x, y;
	int right, left, top, bottom;
	double x0, y0, x1, y1, x2, y2;
	double dist, s_min, s_right, s_left, s_top, s_bottom;
	//int sign;

	int image_x = e.getRow();
	int image_y = e.getCol();

	imatrix tmp(image_x, image_y);
	tmp.copy(image);

	int tex_x = tex.getRow();
	int tex_y = tex.getCol();

	TRACE("tex_x = %d, tex_y = %d\n", tex_x, tex_y);
	
	//double max_dist;
	//double h;
	//int perturb;
	int t_y, t_xi;
	double t_x, t, l, r;
	int t_l, t_r;
	//double piv_x, piv_y;
	//double slope;
	double max_dist = 10.0; 
	//double max_dist = 5.0; 
	//double max_dist = 3.0; 
	//perturb = 0; // 
	//perturb = 10; // pencil 
	//double factor = 1.0;
	//double angle;
	//double freq = 5.0;
	double freq_x = 15; // pencil
	//double freq_x = 150; // crayon
	double freq_y = 10; // pencil

	//piv_x = 0.9; piv_y = 0.1; // piv_x in (0.0, 1.0)
	//bool sumie = false;
	//bool sumie = true;
	//double t;

	///////////////////////////////////////
	for (j = 0; j < image_y; j++)
		for (i = 0; i < image_x; i++)
			image[i][j] = 255;
	///////////////////////////////////////////////////////
	// vector field following to find dist, maximum g
	for (j = 1; j < image_y-1; j++) {
		for (i = 1; i < image_x-1; i++) {
			//////////////////////////////////
			dist = 0.0;
			gx = -e[i][j].ty; // this is how to get back to gx, gy
			gy = e[i][j].tx;
			//if (fdog[i][j] == 1.0) continue;  // not an edge 
			if (gx == 0.0 && gy == 0.0) continue; // not an edge 
			g = fdog[i][j];
			/////////////////////////////////////////////////////////
			//if (g > 0.7) { continue; } // not an edge
			//if (g > 0.8) { continue; } // not an edge
			//if (g > 0.9) { continue; } // not an edge
			//if (g > 0.99) { continue; } // not an edge
			///////////////////////////////////////////////////////
			//x0 = (double)i + 0.5; y0 = (double)j + 0.5;
			x0 = (double)i; y0 = (double)j;
			//////////////////////////////////////////////////////
			right = (int)(x0 + 1.0);
			//left = (int)x0;
			left = (x0 > (double)((int)x0)) ? (int)x0 : (int)(x0-1);
			top = (int)(y0 + 1.0);
			//bottom = (int)y0;
			bottom = (y0 > (double)((int)y0)) ? (int)y0 : (int)(y0-1);
			////////////////////////////////////////
			s_min = 100.0;
			s_right = (gx == 0.0) ? 1000 : (right - x0) / gx;
			if (s_right > 0.0 && s_right < s_min) s_min = s_right;
			s_left = (gx == 0.0) ? 1000 : (left - x0) / gx;
			if (s_left > 0.0 && s_left < s_min) s_min = s_left;
			s_top = (gy == 0.0) ? 1000 : (top - y0) / gy;
			if (s_top > 0.0 && s_top < s_min) s_min = s_top;
			s_bottom = (gy == 0.0) ? 1000 : (bottom - y0) / gy;
			if (s_bottom > 0.0 && s_bottom < s_min) s_min = s_bottom;

			x1 = x0 + gx * s_min;
			y1 = y0 + gy * s_min;
			g1 = fdog[(int)x1][(int)y1];
			x2 = x0 + gx * -s_min;
			y2 = y0 + gy * -s_min;
			g2 = fdog[(int)x2][(int)y2];
			////////////////////////////////
			if ( (g < g1) && (g < g2) ) { // maxima pixel
				//image[i][j] = round(g * 255.0);
				//t_x = round( (dist / max_dist) * (double)(tex_x-1) ); 
				//t_x = (int)dist % tex_x; 
				//t_x = 0;
				t_xi = tex_x / 2;
				//////////////////////////////////////////
				//g = 1.0 - g;
				//g = factor * ( sin(freq * x0/180.*PI) * cos(freq * y0/180.*PI) ); // g in [-0.2, 1.2]
				//g = freq_y * (x0 + y0);
				tx = e[i][j].tx;
				ty = e[i][j].ty;
				//angle = atan2(gy, gx); // [-PI, PI] 
				//angle = ABS(angle); // [0, PI]
				//if (angle < 0.25 * PI || angle > 0.75 * PI) g = x0;
				//else g = y0;
				//if (fabs(tx) >= fabs(ty)) g = x0 - 0.5;
				//else g = y0 - 0.5;
				if (fabs(tx) >= fabs(ty)) g = x0;
				else g = y0;
				/////////////////////////
				g = freq_y * g;
				t_y = (int)g % tex_y;
				//g += factor; // g in [0.0, 1.4]
				//g /= (2.0 * factor);
				//if (g > 1.0) g = 1.0; if (g < 0.0) g = 0.0;
				//t_y = round( g * (double)(tex_y-1) );
				//t_y = intrand(t_y - perturb, t_y + perturb);
				//t_y = intrand(0, t_y-1);
				//if (t_y > tex_y-1) t_y = tex_y-1;
				//if (t_y < 0) t_y = 0;
				//TRACE("t_x = %d, t_y = %d\n", t_x, t_y);
				image[i][j] = tex[t_xi][t_y];
				if (sumie) {
					//g = fdog[i][j]; 
					g = (255. - tex[t_xi][t_y]) / 255.; // [0, 1] use this as an alpha map
					g *= fdog[i][j]; 
					image[i][j] = round(g * 255.);
				}
				//g = fdog[i][j];
				//image[i][j] = round(tex[t_x][t_y] * g);
				continue;
			}
			//sign = 1; 
			g_old = g; g = g1; 
			//x2 = x0; y2 = y0;
			x0 = x1; y0 = y1;
			dist += s_min;
			//////////////////////////////////////////////////////
			while (1) {
				x = (int)x0; y = (int)y0;
				if ( x >= image_x-1 || x <= 0 || y >= image_y-1 || y <= 0 ) { 
					//dist = max_dist+1; g = 1.0;
					break;
				}
				gx = -e[x][y].ty; // this is how to get back to gx, gy
				gy = e[x][y].tx;
				if ( fdog[x][y] == 1.0 ) break;
				if (gx == 0.0 && gy == 0.0) break;
				//if ( g > thres ) { TRACE("g = %f\n", g); break; }
				//////////////////////////////////////////////////////
				right = (int)(x0 + 1.0);
				left = (x0 > ((int)x0)) ? (int)x0 : (int)(x0-1);
				top = (int)(y0 + 1.0);
				bottom = (y0 > ((int)y0)) ? (int)y0 : (int)(y0-1);
				s_min = 100.0;
				s_right = (gx == 0.0) ? 1000 : (right - x0) / gx;
				if (s_right > 0.0 && s_right < s_min) s_min = s_right;
				s_left = (gx == 0.0) ? 1000 : (left - x0) / gx;
				if (s_left > 0.0 && s_left < s_min) s_min = s_left;
				s_top = (gy == 0.0) ? 1000 : (top - y0) / gy;
				if (s_top > 0.0 && s_top < s_min) s_min = s_top;
				s_bottom = (gy == 0.0) ? 1000 : (bottom - y0) / gy;
				if (s_bottom > 0.0 && s_bottom < s_min) s_min = s_bottom;

				x1 = x0 + gx * s_min;
				y1 = y0 + gy * s_min;
				g1 = fdog[(int)x1][(int)y1];

				if ( (g <= g1) && (g <= g_old) ) break;
				//if ( g < g1 ) break;
				//if ( (g < g1) && (g <= g_old) ) break;
				//if ( (g <= g1) && (g < g_old) ) break;
				
				//////////////////////////////////////////////
				// update dist, (x0, y0) and g_old, g
				g_old = g; g = g1; 
				//x2 = x0; y2 = y0;
				x0 = x1; y0 = y1;
				dist += s_min;

				//if (dist > max_dist) break;
			} // end while
			////////////////////////////////////////
			//image[i][j] = map(g, dist); 
			//image[i][j] = round(g * 255.0);
			//image[(int)x0][(int)y0] = round(g * 255.0);
			//if (dist > max_dist) continue;
			//TRACE("dist = %f, max_dist = %f\n", dist, max_dist);
			//if (dist > max_dist) dist = max_dist;
			//g = freq_x * dist;
			//if ((int)g > tex_x-1) continue;
			//t_x = (int)g % tex_x;
			//t_x = tex_x / 2;
			//t_x = round( (dist / max_dist) * (double)(tex_x-1) );
			//if (t_x > 60)	TRACE("t_x = %d\n", t_x);
			//t_x = round( (dist / max_dist) * (double)(tex_x-1) );
			//dist *= 100; 
			//t_x = (int)dist % tex_x; 
			//////////////////////////////////////////
			//g = 1.0 - g;
			//g = factor * ( sin(freq * x0/180.*PI) * cos(freq * y0/180.*PI) ); // g in [-0.2, 12]
			//g = freq * dist;
			//g = freq_y * (x0 + y0);
			tx = e[(int)x0][(int)y0].tx;
			ty = e[(int)x0][(int)y0].ty;
			gx = -e[i][j].ty;
			gy = e[i][j].tx;
			//angle = atan2(gy, gx); // [-PI, PI] 
			//angle = ABS(angle); // [0, PI]
			////////////////////////////////////
			dist *= freq_x;
			////////////////////////
			if (fabs(tx) >= fabs(ty)) { // moving horizontally; judge with sign of gy
				if (gy >= 0.0) { // right half of the texture
					//t_x = (double)(tex_x/2) + (dist / max_dist) * (double)(tex_x/2 - 1);
					//t_x = round( tex_x/2 + (dist / max_dist) * (double)(tex_x/2 - 1) );
					t_x = tex_x/2 + (int)dist % tex_x/2;
				}
				else { // left half of the texture
					//t_x = (double)(tex_x/2) - (dist / max_dist) * (double)(tex_x/2);
					//t_x = round( tex_x/2 - (dist / max_dist) * (double)(tex_x/2) );
					t_x = tex_x/2 - (int)dist % tex_x/2 - 1;
				}//
			}
			else { // moving vertically; judge with sign of gx
				if (gx <= 0.0) { // right half of the texture
					//t_x = (double)(tex_x/2) + (dist / max_dist) * (double)(tex_x/2 - 1);
					//t_x = round( tex_x/2 + (dist / max_dist) * (double)(tex_x/2 - 1) );
					t_x = tex_x/2 + (int)dist % tex_x/2;
				}
				else { // left half of the texture
					//t_x = (double)(tex_x/2) - (dist / max_dist) * (double)(tex_x/2);
					//t_x = round( tex_x/2 - (dist / max_dist) * (double)(tex_x/2) );
					t_x = tex_x/2 - (int)dist % tex_x/2 - 1;
				}
			}
			//////////////////////////////////////
			///////////////////////////////////////
			//if (angle < 0.25 * PI || angle > 0.75 * PI) g = x0;
			//else g = y0;
			////////////////////////////////
			if (fabs(tx) >= fabs(ty)) g = x0;
			else g = y0;
			///////////////////////////
			g = freq_y * g;
			t_y = (int)g % tex_y;
			//g += factor; // g in [0, 14]
			//g /= (2.0 * factor);
			//if (g > 1.0) g = 1.0; if (g < 0.0) g = 0.0;
			//t_y = round( g * (double)(tex_y-1) );
			//t_y = round( (1.0-g) * (double)(tex_y-1) );
			//t_y = intrand(t_y - perturb, t_y + perturb);
			//if (t_y > tex_y-1) t_y = tex_y-1;
			//if (t_y < 0) t_y = 0;
			//TRACE("t_x = %d, t_y = %d\n", t_x, t_y);
			//TRACE("i, j = %d, %d\n", i, j);
			//TRACE("t_x = %f\n", t_x);
			t_l = (int)t_x; t_r = t_l + 1; if (t_r > tex_x-1) t_r = tex_x-1;
			t = t_x - (double)t_l;
			l = (double)tex[t_l][t_y];
			r = (double)tex[t_r][t_y];
			g = (1-t) * l + t * r;
			//image[i][j] = tex[t_x][t_y];
			image[i][j] = round(g);
			if (sumie) {
				//g = fdog[(int)x0][(int)y0]; 
				//g = (255. - tex[t_x][t_y]) / 255.; // [0, 1] use this as an alpha map
				g = (255. - g) / 255.; // [0, 1] use this as an alpha map
				g *= fdog[(int)x0][(int)y0]; 
                image[i][j] = round(g * 255.);
			}
			//g = fdog[i][j];
			//image[i][j] = round(tex[t_x][t_y] * g);
			//if (image[(int)x0][(int)y0] == 255) image[(int)x0][(int)y0] = round(g * 255.0);
			/////////////////////////////////////////////////////
		}
	}
}

void ReplaceStrokeTexture11(matrix& fdog, ETF& e, imatrix& image, imatrix& thin, imatrix& tex, bool sumie)
// use gray image as maxima pixel
// non-symmetric texture (horizontally)
// start from the center of the pixel (not the corner)
// replace the pixel with texture pixel!
// Use something other than the fdog value to determine ty! (some smoothly varying value!)
// here we use min(x, y) or max(x, y)
{
	double	gx, gy, tx, ty;
	double	g;
	//double	t; // interpolation parameter
	int i, j, x, y;
	int right, left, top, bottom;
	double x0, y0, x1, y1;
	double dist, s_min, s_right, s_left, s_top, s_bottom;
	//int sign;

	int image_x = e.getRow();
	int image_y = e.getCol();

	int tex_x = tex.getRow();
	int tex_y = tex.getCol();

	TRACE("tex_x = %d, tex_y = %d\n", tex_x, tex_y);
	
	//double max_dist;
	//double h;
	//int perturb;
	int t_y, t_x;
	//double t, l, r;
	bool enter_r, enter_l, enter_t, enter_b;
	//int t_l, t_r;
	//double piv_x, piv_y;
	//double slope;
	bool abnormal;
	//double max_dist = 5.0; 
	//double max_dist = 5.0; 
	//double max_dist = 3.0; 
	//perturb = 0; // 
	//perturb = 10; // pencil 
	//double factor = 1.0;
	//double angle;
	//double freq = 5.0;
	double freq_x = 8; // pencil
	//double freq_x = 150; // crayon
	double freq_y = 5; // pencil



	//piv_x = 0.9; piv_y = 0.1; // piv_x in (0.0, 1.0)
	//bool sumie = false;
	//bool sumie = true;
	//double t;

	///////////////////////////////////////
	for (j = 0; j < image_y; j++)
		for (i = 0; i < image_x; i++)
			image[i][j] = 255;
	///////////////////////////////////////////////////////
	// vector field following to find dist, maximum g
	for (j = 1; j < image_y-1; j++) {
		for (i = 1; i < image_x-1; i++) {
			//////////////////////////////////
			dist = 0.0;
			gx = -e[i][j].ty; // this is how to get back to gx, gy
			gy = e[i][j].tx;
			//if (fdog[i][j] == 1.0) continue;  // not an edge 
			if (gx == 0.0 && gy == 0.0) continue; // not an edge 
			g = fdog[i][j];
			//TRACE("g = %f\n", g);
			abnormal = false;
			/////////////////////////////////////////////////////////
			//if (g > 0.7) { continue; } // not an edge
			//if (g > 0.8) { continue; } // not an edge
			//if (g > 0.9) { continue; } // not an edge
			//if (g > 0.99) { continue; } // not an edge
			if (g == 1.0) { continue; } // not an edge
			///////////////////////////////////////////////////////
			if (thin[i][j] == 0) {
				t_x = tex_x / 2;
				tx = e[i][j].tx;
				ty = e[i][j].ty;
				if (fabs(tx) >= fabs(ty)) g = x0;
				else g = y0;
				/////////////////////////
				g = freq_y * g;
				t_y = (int)g % tex_y;
				image[i][j] = tex[t_x][t_y];
				continue; // maxima pixel!
			}
			////////////////////////////////////
			x0 = (double)i + 0.5; y0 = (double)j + 0.5;
			//x0 = (double)i; y0 = (double)j;
			/////////////////////////////////////////////
			gx = -e[i][j].ty; // this is how to get back to gx, gy
			gy = e[i][j].tx;
			g = fdog[i][j];
			//if ( fdog[x][y] == 1.0 ) break;
			if (gx == 0.0 && gy == 0.0) break;
			//if ( g > thres ) { TRACE("g = %f\n", g); break; }
			//////////////////////////////////////////////////////
			right = (int)(x0 + 1.0);
			left = (int)x0;
			top = (int)(y0 + 1.0);
			bottom = (int)y0;
			/////////////////////////////
			enter_r = enter_l = enter_t = enter_b = false;
			//////////////////////
			s_min = 100.0;
			s_right = (gx == 0.0) ? -1 : (right - x0) / gx;
			if (s_right > 0.0 && s_right < s_min) {
				s_min = s_right;
				enter_r = true; enter_l = false;
			}
			s_left = (gx == 0.0) ? -1 : (left - x0) / gx;
			if (s_left > 0.0 && s_left < s_min) {
				s_min = s_left;
				enter_l = true; enter_r = false;
			}
			s_top = (gy == 0.0) ? -1 : (top - y0) / gy;
			if (s_top > 0.0 && s_top < s_min) {
				s_min = s_top;
				enter_t = true; enter_b = false;
			}	
			s_bottom = (gy == 0.0) ? -1 : (bottom - y0) / gy;
			if (s_bottom > 0.0 && s_bottom < s_min) {
				s_min = s_bottom;
				enter_b = true; enter_t = false;
			}

			x1 = x0 + gx * s_min;
			y1 = y0 + gy * s_min;

			x0 = x1; y0 = y1;
			//////////////////////////////////////////////////////
			while (1) {
                //x = (int)x0; y = (int)y0;
				x = (int)x0;
                if (enter_l) x = (int)(x0-1); 
				y = (int)y0;
                if (enter_b) x = (int)(y0-1); 
				if ( x >= image_x-1 || x <= 0 || y >= image_y-1 || y <= 0 ) { 
					//dist = max_dist+1; g = 1.0;
					abnormal = true;
					break;
				}
				///////////////////////////////////////////
				if (thin[x][y] == 0) break; // maxima pixel!
				/////////////////////////////////////////////
				gx = -e[x][y].ty; // this is how to get back to gx, gy
				gy = e[x][y].tx;
				g = fdog[x][y];
				if ( fdog[x][y] == 1.0 ) {
					abnormal = true;
					break;
				}
				if (gx == 0.0 && gy == 0.0) {
					abnormal = true;
					break;
				}
				//if ( g > thres ) { TRACE("g = %f\n", g); break; }
				//////////////////////////////////////////////////////
				right = (int)(x0 + 1);
				if (enter_l) right = (int)x0;
				left = (int)x0;
				if (enter_r) left = (int)(x0-1);
				top = (int)(y0 + 1.0);
				if (enter_b) top = (int)y0;
				bottom = (int)y0; 
				if (enter_t) bottom = (int)(y0-1);
				/////////////////////////////////
				enter_r = enter_l = enter_t = enter_b = false;
				s_min = 100.0;
				s_right = (gx == 0.0) ? 100 : (right - x0) / gx;
				if (s_right > 0.0 && s_right < s_min) {
					s_min = s_right;
					enter_r = true; enter_l = false;
				}
				s_left = (gx == 0.0) ? 100 : (left - x0) / gx;
				if (s_left > 0.0 && s_left < s_min) {
					s_min = s_left;
					enter_l = true; enter_r = false;
				}
				s_top = (gy == 0.0) ? 100 : (top - y0) / gy;
				if (s_top > 0.0 && s_top < s_min) {
					s_min = s_top;
					enter_t = true; enter_b = false;
				}
				s_bottom = (gy == 0.0) ? 100 : (bottom - y0) / gy;
				if (s_bottom > 0.0 && s_bottom < s_min) {
					s_min = s_bottom;
					enter_b = true; enter_t = false;
				}
				/////////////////////////////
				if (s_min == 100.0) break;
				///////////////////////////////

				x1 = x0 + gx * s_min;
				y1 = y0 + gy * s_min;

				//g1 = fdog[(int)x1][(int)y1];
				//if (g1 >= g) break;
				//if (s_min == 0.0) {
				/*
					TRACE("x0 = %f, y0 = %f\n", x0, y0);
					TRACE("x1 = %f, y1 = %f\n", x1, y1);
					TRACE("right = %d, left = %d, top = %d, botoom = %d\n", right, left, top, bottom);
					TRACE("dist = %f\n", dist);
					TRACE("gx = %f, gy = %f, s_min = %.10f\n\n", gx, gy, s_min);
				*/
				//}
				
				x0 = x1; y0 = y1;
				dist += s_min;
				
				//if (dist > max_dist) break;
				
			} // end while
			////////////////////////////////////////
			//image[i][j] = map(g, dist); 
			//image[i][j] = round(g * 255.0);
			//image[(int)x0][(int)y0] = round(g * 255.0);
			//if (dist > max_dist) continue;
			if (abnormal) continue;
			//TRACE("dist = %f, max_dist = %f\n", dist, max_dist);
			//if (dist > max_dist) dist = max_dist;
			//g = freq_x * dist;
			//if ((int)g > tex_x-1) continue;
			//t_x = (int)g % tex_x;
			//t_x = tex_x / 2;
			//t_x = round( (dist / max_dist) * (double)(tex_x-1) );
			//if (t_x > 60)	TRACE("t_x = %d\n", t_x);
			//t_x = round( (dist / max_dist) * (double)(tex_x-1) );
			//dist *= 100; 
			//t_x = (int)dist % tex_x; 
			//////////////////////////////////////////
			//g = 1.0 - g;
			//g = factor * ( sin(freq * x0/180.*PI) * cos(freq * y0/180.*PI) ); // g in [-0.2, 12]
			//g = freq * dist;
			//g = freq_y * (x0 + y0);
			tx = e[(int)x0][(int)y0].tx;
			ty = e[(int)x0][(int)y0].ty;
			gx = -e[i][j].ty;
			gy = e[i][j].tx;
			//angle = atan2(gy, gx); // [-PI, PI] 
			//angle = ABS(angle); // [0, PI]
			////////////////////////////////////
			dist *= freq_x;
			////////////////////////
			if (fabs(tx) >= fabs(ty)) { // moving horizontally; judge with sign of gy
				if (gy >= 0.0) { // right half of the texture
					//t_x = (double)(tex_x/2) + (dist / max_dist) * (double)(tex_x/2 - 1);
					//t_x = round( tex_x/2 + (dist / max_dist) * (double)(tex_x/2 - 1) );
					t_x = tex_x/2 + (int)dist % tex_x/2;
				}
				else { // left half of the texture
					//t_x = (double)(tex_x/2) - (dist / max_dist) * (double)(tex_x/2);
					//t_x = round( tex_x/2 - (dist / max_dist) * (double)(tex_x/2) );
					t_x = tex_x/2 - (int)dist % tex_x/2 - 1;
				}//
			}
			else { // moving vertically; judge with sign of gx
				if (gx <= 0.0) { // right half of the texture
					//t_x = (double)(tex_x/2) + (dist / max_dist) * (double)(tex_x/2 - 1);
					//t_x = round( tex_x/2 + (dist / max_dist) * (double)(tex_x/2 - 1) );
					t_x = tex_x/2 + (int)dist % tex_x/2;
				}
				else { // left half of the texture
					//t_x = (double)(tex_x/2) - (dist / max_dist) * (double)(tex_x/2);
					//t_x = round( tex_x/2 - (dist / max_dist) * (double)(tex_x/2) );
					t_x = tex_x/2 - (int)dist % tex_x/2 - 1;
				}
			}
			//////////////////////////////////////
			///////////////////////////////////////
			//if (angle < 0.25 * PI || angle > 0.75 * PI) g = x0;
			//else g = y0;
			////////////////////////////////
			if (fabs(tx) >= fabs(ty)) g = x0;
			else g = y0;
			///////////////////////////
			g = freq_y * g;
			t_y = (int)g % tex_y;
			//g += factor; // g in [0, 14]
			//g /= (2.0 * factor);
			//if (g > 1.0) g = 1.0; if (g < 0.0) g = 0.0;
			//t_y = round( g * (double)(tex_y-1) );
			//t_y = round( (1.0-g) * (double)(tex_y-1) );
			//t_y = intrand(t_y - perturb, t_y + perturb);
			//if (t_y > tex_y-1) t_y = tex_y-1;
			//if (t_y < 0) t_y = 0;
			//TRACE("t_x = %d, t_y = %d\n", t_x, t_y);
			//TRACE("i, j = %d, %d\n", i, j);
			//TRACE("t_x = %f\n", t_x);
			//t_l = (int)t_x; t_r = t_l + 1; if (t_r > tex_x-1) t_r = tex_x-1;
			//t = t_x - (double)t_l;
			//l = (double)tex[t_l][t_y];
			//r = (double)tex[t_r][t_y];
			//g = (1-t) * l + t * r;
			image[i][j] = tex[t_x][t_y];
			//image[i][j] = round(g);
			if (sumie) {
				//g = fdog[(int)x0][(int)y0]; 
				//g = (255. - tex[t_x][t_y]) / 255.; // [0, 1] use this as an alpha map
				g = (255. - g) / 255.; // [0, 1] use this as an alpha map
				g *= fdog[(int)x0][(int)y0]; 
                image[i][j] = round(g * 255.);
			}
			//g = fdog[i][j];
			//image[i][j] = round(tex[t_x][t_y] * g);
			//if (image[(int)x0][(int)y0] == 255) image[(int)x0][(int)y0] = round(g * 255.0);
			/////////////////////////////////////////////////////
		}
	}
}

void ReplaceStrokeTexture12(matrix& fdog, ETF& e, imatrix& image, imatrix& thin, imatrix& tex, bool sumie)
// use gray image as maxima pixel
// non-symmetric texture (horizontally)
// start from the center of the pixel (not the corner)
// replace the pixel with texture pixel!
// Use something other than the fdog value to determine ty! (some smoothly varying value!)
// here we use min(x, y) or max(x, y)
{
	double	gx, gy, tx, ty;
	double	g, g_old;
	//double	t; // interpolation parameter
	int i, j, x, y;
	//int right, left, top, bottom;
	double x0, y0, x1, y1;
	double dist;
	//int sign;

	int image_x = e.getRow();
	int image_y = e.getCol();

	int tex_x = tex.getRow();
	int tex_y = tex.getCol();

	TRACE("tex_x = %d, tex_y = %d\n", tex_x, tex_y);
	
	//double max_dist;
	//double h;
	//int perturb;
	int t_y, t_x;
	//double t, l, r;
	//bool enter_r, enter_l, enter_t, enter_b;
	//int t_l, t_r;
	//double piv_x, piv_y;
	//double slope;
	bool abnormal;
	//double max_dist = 5.0; 
	//double max_dist = 5.0; 
	//double max_dist = 3.0; 
	//perturb = 0; // 
	//perturb = 10; // pencil 
	//double factor = 1.0;
	double step_size = 1.0;
	//double angle;
	//double freq = 5.0;
	double freq_x = 8; // pencil
	//double freq_x = 150; // crayon
	double freq_y = 5; // pencil

	///////////////////////////////////////
	for (j = 0; j < image_y; j++)
		for (i = 0; i < image_x; i++)
			image[i][j] = 255;
	///////////////////////////////////////////////////////
	// vector field following to find dist, maximum g
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			//////////////////////////////////
			dist = 0.0;
			gx = -e[i][j].ty; // this is how to get back to gx, gy
			gy = e[i][j].tx;
			//if (fdog[i][j] == 1.0) continue;  // not an edge 
			if (gx == 0.0 && gy == 0.0) continue; // not an edge 
			g = fdog[i][j];
			//TRACE("g = %f\n", g);
			abnormal = false;
			/////////////////////////////////////////////////////////
			//if (g > 0.7) { continue; } // not an edge
			//if (g > 0.8) { continue; } // not an edge
			//if (g > 0.9) { continue; } // not an edge
			//if (g > 0.99) { continue; } // not an edge
			if (g == 1.0) { continue; } // not an edge
			///////////////////////////////////////////////////////
			if (thin[i][j] == 0) { // maxima pixel
				t_x = tex_x / 2;
				tx = e[i][j].tx;
				ty = e[i][j].ty;
				if (fabs(tx) >= fabs(ty)) g = x0;
				else g = y0;
				/////////////////////////
				g = freq_y * g;
				t_y = (int)g % tex_y;
				image[i][j] = tex[t_x][t_y];
				continue; // maxima pixel!
			}
			////////////////////////////////////
			x0 = (double)i + 0.5; y0 = (double)j + 0.5;
			//x0 = (double)i; y0 = (double)j;
			//////////////////////////////////////////////////////
			x1 = x0 + gx * step_size;
			y1 = y0 + gy * step_size;

			x0 = x1; y0 = y1;
			g_old = g;
			//////////////////////////////////////////////////////
			while (1) {
                //x = (int)x0; y = (int)y0;
				x = round(x0);
				y = round(y0);
				if ( x >= image_x-1 || x <= 0 || y >= image_y-1 || y <= 0 ) { 
					abnormal = true;
					break;
				}
				///////////////////////////////////////////
				if (thin[x][y] == 0) break; // maxima pixel!
				/////////////////////////////////////////////
				gx = -e[x][y].ty; // this is how to get back to gx, gy
				gy = e[x][y].tx;
				g = fdog[x][y];
				if ( g == 1.0 ) {
					abnormal = true;
					break;
				}
				if (gx == 0.0 && gy == 0.0) {
					abnormal = true;
					break;
				}
				if (g >= g_old) break;
				//if ( g > thres ) { TRACE("g = %f\n", g); break; }
				//////////////////////////////////////////////////////
				x1 = x0 + gx * step_size;
				y1 = y0 + gy * step_size;
				
				x0 = x1; y0 = y1;

				dist += step_size;
				g_old = g;
			} // end while
			////////////////////////////////////////
			//image[i][j] = map(g, dist); 
			//image[i][j] = round(g * 255.0);
			//image[(int)x0][(int)y0] = round(g * 255.0);
			//if (dist > max_dist) continue;
			if (abnormal) continue;
			//////////////////////////////////////////
			//g = 1.0 - g;
			//g = factor * ( sin(freq * x0/180.*PI) * cos(freq * y0/180.*PI) ); // g in [-0.2, 12]
			//g = freq * dist;
			//g = freq_y * (x0 + y0);
			tx = e[x][y].tx;
			ty = e[x][y].ty;
			gx = -e[x][y].ty;
			gy = e[x][y].tx;
			//angle = atan2(gy, gx); // [-PI, PI] 
			//angle = ABS(angle); // [0, PI]
			////////////////////////////////////
			dist *= freq_x;
			////////////////////////
			if (fabs(tx) >= fabs(ty)) { // moving horizontally; judge with sign of gy
				if (gy >= 0.0) { // right half of the texture
					//t_x = (double)(tex_x/2) + (dist / max_dist) * (double)(tex_x/2 - 1);
					//t_x = round( tex_x/2 + (dist / max_dist) * (double)(tex_x/2 - 1) );
					t_x = tex_x/2 + (int)dist % tex_x/2;
				}
				else { // left half of the texture
					//t_x = (double)(tex_x/2) - (dist / max_dist) * (double)(tex_x/2);
					//t_x = round( tex_x/2 - (dist / max_dist) * (double)(tex_x/2) );
					t_x = tex_x/2 - (int)dist % tex_x/2 - 1;
				}//
			}
			else { // moving vertically; judge with sign of gx
				if (gx <= 0.0) { // right half of the texture
					//t_x = (double)(tex_x/2) + (dist / max_dist) * (double)(tex_x/2 - 1);
					//t_x = round( tex_x/2 + (dist / max_dist) * (double)(tex_x/2 - 1) );
					t_x = tex_x/2 + (int)dist % tex_x/2;
				}
				else { // left half of the texture
					//t_x = (double)(tex_x/2) - (dist / max_dist) * (double)(tex_x/2);
					//t_x = round( tex_x/2 - (dist / max_dist) * (double)(tex_x/2) );
					t_x = tex_x/2 - (int)dist % tex_x/2 - 1;
				}
			}
			//////////////////////////////////////
			///////////////////////////////////////
			//if (angle < 0.25 * PI || angle > 0.75 * PI) g = x0;
			//else g = y0;
			////////////////////////////////
			if (fabs(tx) >= fabs(ty)) t_y = x;
			else t_y = y;
			///////////////////////////
			t_y = round(freq_y * t_y);
			t_y = t_y % tex_y;
			//g += factor; // g in [0, 14]
			//g /= (2.0 * factor);
			//if (g > 1.0) g = 1.0; if (g < 0.0) g = 0.0;
			//t_y = round( g * (double)(tex_y-1) );
			//t_y = round( (1.0-g) * (double)(tex_y-1) );
			//t_y = intrand(t_y - perturb, t_y + perturb);
			//if (t_y > tex_y-1) t_y = tex_y-1;
			//if (t_y < 0) t_y = 0;
			//TRACE("t_x = %d, t_y = %d\n", t_x, t_y);
			//TRACE("i, j = %d, %d\n", i, j);
			//TRACE("t_x = %f\n", t_x);
			//t_l = (int)t_x; t_r = t_l + 1; if (t_r > tex_x-1) t_r = tex_x-1;
			//t = t_x - (double)t_l;
			//l = (double)tex[t_l][t_y];
			//r = (double)tex[t_r][t_y];
			//g = (1-t) * l + t * r;
			image[i][j] = tex[t_x][t_y];
			//image[i][j] = round(g);
			if (sumie) {
				//g = fdog[(int)x0][(int)y0]; 
				//g = (255. - tex[t_x][t_y]) / 255.; // [0, 1] use this as an alpha map
				g = (255. - g) / 255.; // [0, 1] use this as an alpha map
				g *= fdog[x][y]; 
                image[i][j] = round(g * 255.);
			}
			//g = fdog[i][j];
			//image[i][j] = round(tex[t_x][t_y] * g);
			//if (image[(int)x0][(int)y0] == 255) image[(int)x0][(int)y0] = round(g * 255.0);
			/////////////////////////////////////////////////////
		}
	}
}

void ReplaceStrokeTexture7(matrix& fdog, ETF& e, imatrix& image, imatrix& tex)
// test it on a white image
{
	//double	t; // interpolation parameter
	int i, j;

	int image_x = e.getRow();
	int image_y = e.getCol();

	imatrix tmp(image_x, image_y);
	tmp.copy(image);

	int tex_x = tex.getRow();
	int tex_y = tex.getCol();

	TRACE("tex_x = %d, tex_y = %d\n", tex_x, tex_y);
	
	double max_dist;
	double g;
	//double h;
	//int perturb;
	int t_x, t_y;
	double x0, y0;
	//double piv_x, piv_y;
	//double slope;
	//max_dist = 10.0; 
    max_dist = 4.0; // pencil
	//perturb = 0; // 
	//perturb = 10; // pencil 
	double factor = 1.0;
	double freq = 5.0;

	//piv_x = 0.9; piv_y = 0.1; // piv_x in (0.0, 1.0)

	///////////////////////////////////////
	for (j = 0; j < image_y; j++)
		for (i = 0; i < image_x; i++)
			image[i][j] = 255;
	///////////////////////////////////////////////////////
	// vector field following to find dist, maximum g
	for (j = 1; j < image_y-1; j++) {
		for (i = 1; i < image_x-1; i++) {
			//t_x = round( (dist / max_dist) * (double)(tex_x-1) );
			//dist *= 100; 
			//t_x = (int)dist % tex_x;
			x0 = (double)i;
			y0 = (double)j;
			//g = factor * ( cos(freq * x0/180.*PI) * sin(freq * y0/180.*PI) ); // g in [-20, 20]
			//g = fabs( sin(freq * x0/180.*PI) ); // g in [0, 1]
			g = freq * x0;
			t_x = (int)g % tex_x;
			//g += factor; // g in [0.0, 2]
			//t_y = (int)g % tex_y;
			//g /= (2.0 * factor);
			//if (g > 1.0) TRACE("g = %f\n", g);
			//t_x = round( g * (double)(tex_x-1) );
			//////////////////////////////////////////
			//g = fabs( tex_y * cos(freq * y0/180.*PI) * sin(freq * y0/180.*PI) ); // g in [-1, 1]
			g = freq * (x0 + y0);
			//g = freq * y0; 
			//g += factor; // g in [0.0, 2]
			//g = freq * y0;
			t_y = (int)g % tex_y;
			//g /= (2.0 * factor);
			//if (g > 1.0) TRACE("g = %f\n", g);
			//t_y = round( g * (double)(tex_y-1) );
			
			image[i][j] = tex[t_x][t_y];
			//if (image[(int)x0][(int)y0] == 255) image[(int)x0][(int)y0] = round(g * 255.0);
			/////////////////////////////////////////////////////
		}
	}
}

void Sobel(int image_x, int image_y, matrix& tmp_x, matrix& tmp_y, Image& gradient)
{
	double MAX_GRADIENT = -1.0;

	/*
	for (j = 1; j < image_y - 1; j++) {
		for (i = 1; i < image_x - 1; i++) {
			G_x[i][j] = (tmp_x[i+1][j-1] + 2*tmp_x[i+1][j] + tmp_x[i+1][j+1] 
				- tmp_x[i-1][j-1] - 2*tmp_x[i-1][j] - tmp_x[i-1][j+1]);
			G_y[i][j] = (tmp_y[i-1][j+1] + 2*tmp_y[i][j+1] + tmp_y[i+1][j+1]
				- tmp_y[i-1][j-1] - 2*tmp_y[i][j-1] - tmp_y[i+1][j-1]);
			G_mag[i][j] = sqrt(G_x[i][j] * G_x[i][j] + G_y[i][j] * g_y[i][j]);

			if (G_mag[i][j] > MAX_GRADIENT) {
				MAX_GRADIENT = G_mag[i][j];
				//TRACE("p[i][j].gx = %01.f\n", p[i][j].gx);
				//TRACE("p[i][j].gy = %01.f\n", p[i][j].gy);
				//TRACE("MAX_GRADIENT = %0.1f\n", MAX_GRADIENT);
			}
		}
	}
	*/
}

void InvertImage(int image_x, int image_y, imatrix& image) 
{
	int x, y;

	//for (y = IMAGE_Y - 1; y >= 0; y--) {
	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			//COLORREF rgbcol = memDC.GetPixel(x, (IMAGE_Y-1)-y);
			image[x][y] = 255 - image[x][y];
		}
	}
}


void DrawImage(CDC& dc, int image_x, int image_y, Image& image) 
{
	int x, y;
	GLubyte r;

	//for (y = IMAGE_Y - 1; y >= 0; y--) {
	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			//COLORREF rgbcol = memDC.GetPixel(x, (IMAGE_Y-1)-y);
			r = (GLubyte)image[x][y];
			/// Set Pixel in MemDC
			memDC2.SetPixelV(x, (IMAGE_Y-1)-y, RGB(r, r, r));
		}
	}
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC2, 0, 0, SRCCOPY);
}

void DrawGrayImage(CDC& dc, int image_x, int image_y, imatrix& image) 
{
	int x, y;
	GLubyte r;

	//for (y = IMAGE_Y - 1; y >= 0; y--) {
	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			//COLORREF rgbcol = memDC.GetPixel(x, (IMAGE_Y-1)-y);
			r = (GLubyte)image[x][y];
			dc.SetPixelV(x, (image_y-1)-y, RGB(r, r, r));
			//////////////////////////////////////////////////////////
			// 11/18/2007: Test for woodcut print
			//if (r > 0 && r < 255) dc.SetPixelV(x, (IMAGE_Y-1)-y, RGB(255, 0, 0));
			/////////////////////////////////////////////////////////////
		}
	}
}

void CreateRedZone(imatrix& redzone, double sigma) 
// Find the boundary between white and black
{
	int x, y;
	GLubyte r;

	GaussSmoothSep(redzone, sigma); 

	int image_x = redzone.getRow();
	int image_y = redzone.getCol();

	//for (y = IMAGE_Y - 1; y >= 0; y--) {
	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			////////////////////////
			r = (GLubyte)redzone[x][y];
			if (r > 0 && r < 255) redzone[x][y] = 255;
			else redzone[x][y] = 0;
			/////////////////////////////////////////////////////////////
		}
	}
}


void DrawCondInverseGrayImage(CDC& dc, imatrix& image, imatrix& bw) 
// Conditionally inverse the image
{
	int x, y;
	GLubyte r;

	int image_x = image.getRow();
	int image_y = image.getCol();

	//for (y = IMAGE_Y - 1; y >= 0; y--) {
	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			r = (GLubyte)image[x][y];
			if (bw[x][y] == 0) r = 255 - r;
			/// Set Pixel in MemDC
			dc.SetPixelV(x, (image_y-1)-y, RGB(r, r, r));
		}
	}
}

void DrawCondInverseGrayImageRedZone(CDC& dc, imatrix& image, imatrix& bw, imatrix& redzone) 
// Conditionally inverse the image
// If Redzone, do not inverse it!
{
	int x, y;
	GLubyte r;

	int image_x = image.getRow();
	int image_y = image.getCol();

	//for (y = IMAGE_Y - 1; y >= 0; y--) {
	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			r = (GLubyte)image[x][y];
			/////////////////////////////////////////////
			//if (redzone[x][y]) r = bw[x][y]; // redzone: keep original bw colors there!
			if (redzone[x][y] && bw[x][y] == 0) r = bw[x][y]; // redzone: only leave black area!
			//if (redzone[x][y]) r = 0; 
			// black area and no redzone, then inverse!
			else if (bw[x][y] == 0) r = 255 - r;
			///////////////////////////////////////////
			/// Set Pixel in MemDC
			dc.SetPixelV(x, (image_y-1)-y, RGB(r, r, r));
		}
	}
}

void DrawInverseGrayImage(CDC& dc, int image_x, int image_y, imatrix& image) 
{
	int x, y;
	GLubyte r;

	//for (y = IMAGE_Y - 1; y >= 0; y--) {
	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			//COLORREF rgbcol = memDC.GetPixel(x, (IMAGE_Y-1)-y);
			r = 255-(GLubyte)image[x][y];
			/// Set Pixel in MemDC
			dc.SetPixelV(x, (IMAGE_Y-1)-y, RGB(r, r, r));
		}
	}
}


void DrawColorImage(CDC& dc, int image_x, int image_y, cimatrix& image) 
{
	int x, y;
	GLubyte r, g, b;

	//for (y = IMAGE_Y - 1; y >= 0; y--) {
	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			//COLORREF rgbcol = memDC.GetPixel(x, (IMAGE_Y-1)-y);
			r = (GLubyte)image[x][y].r;
			g = (GLubyte)image[x][y].g;
			b = (GLubyte)image[x][y].b;
			/// Set Pixel in MemDC
			dc.SetPixelV(x, (image_y-1)-y, RGB(r, g, b));
		}
	}
}

void ColorQuantization(cimatrix& cmap, int level) 
// HSV color model
// Based on Gooch's method
{
	int x, y;
	GLubyte r1, g1, b1;
	double r, g, b;
	double h, s, v;
	double t;

	int image_x = cmap.getRow();
	int image_y = cmap.getCol();

	//imatrix tmp(image_x, image_y);

	//CopyCol2GrayImage(image_x, image_y, cmap, tmp);

	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			r = (double)cmap[x][y].r;
			g = (double)cmap[x][y].g;
			b = (double)cmap[x][y].b;
			r /= 255.;
			g /= 255.;
			b /= 255.;
			//TRACE("r = %f\n", r);
			//TRACE("g = %f\n", g);
			//TRACE("b = %f\n", b);
			RGB2HSV(r, g, b, h, s, v);
			///////////////////////////
			v = ( (int)(v * level) ) / (double)level + 1.0/(double)level/2.0;
			///////////////////////////////
			////////////////////////////////
			// extrapolate! s and v
			t = 1.1;
			s = (1-t)*0.0 + t*s;
			v = (1-t)*0.0 + t*v;
			if (s > 1.0) s = 1.0;
			if (v > 1.0) v = 1.0;
			///////////////////////////////
			HSV2RGB(h, s, v, r, g, b);
			r1 = (GLubyte)(r*255);
			g1 = (GLubyte)(g*255);
			b1 = (GLubyte)(b*255);
			cmap[x][y].r = r1;
			cmap[x][y].g = g1;
			cmap[x][y].b = b1;
		}
	}
}

void ColorQuantization2(cimatrix& cmap, int level) 
// HSV color model
// We quantize not just V but also H
{
	int x, y;
	GLubyte r1, g1, b1;
	double r, g, b;
	double h, s, v;
	//double t;

	int level1 = 10;
	//int level2 = 20; // bannana
	int level2 = 20; // eagle
	int level3 = 10;

	int image_x = cmap.getRow();
	int image_y = cmap.getCol();

	//imatrix tmp(image_x, image_y);

	//CopyCol2GrayImage(image_x, image_y, cmap, tmp);

	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			r = (double)cmap[x][y].r;
			g = (double)cmap[x][y].g;
			b = (double)cmap[x][y].b;
			r /= 255.;
			g /= 255.;
			b /= 255.;
			//TRACE("r = %f\n", r);
			//TRACE("g = %f\n", g);
			//TRACE("b = %f\n", b);
			RGB2HSV(r, g, b, h, s, v);
			///////////////////////////
			if (v == 0.0) v = 0.0;
			else if (v == 1.0) v = 1.0;
			v = ( (int)(v * level1) ) / (double)level1 + 1.0/(double)level1/2.0;
			h /= 360.0; // [0, 1]
			if (h == 0.0) h = 0.0;
			else if (h == 1.0) h = 1.0;
			else h = ( (int)(h * level2) ) / (double)level2 + 1.0/(double)level2/2.0;
			if (s == 0.0) s = 0.0;
			else if (s == 1.0) s = 1.0;
			else s = ( (int)(s * level3) ) / (double)level3 + 1.0/(double)level3/2.0;
			///////////////////////////////
			if (h > 1.0) h = 1.0;
			if (h < 0.0) h = 0.0;
			h *= 360.0; // [0, 360]
			////////////////////////////////
			// extrapolate! s and v
			double t = 1.1;
			//if (h > 360.0) h = 360.0;
			s = (1-t)*0.0 + t*s;
			if (s > 1.0) s = 1.0;
			if (s < 0.0) s = 0.0;
			//s = 1.0; // saturation always maximum!
			v = (1-t)*0.0 + t*v;
			if (v > 1.0) v = 1.0;
			if (v < 0.0) v = 0.0;
			///////////////////////////////
			HSV2RGB(h, s, v, r, g, b);
			r1 = (GLubyte)(r*255);
			g1 = (GLubyte)(g*255);
			b1 = (GLubyte)(b*255);
			cmap[x][y].r = r1;
			cmap[x][y].g = g1;
			cmap[x][y].b = b1;
		}
	}
}

void ColorQuantizationRGB(cimatrix& cmap, int level) 
// RGB color model
{
	int x, y;
	GLubyte r1, g1, b1;
	double r, g, b;
	//double t;

	int level1 = level;
	int level2 = level; // eagle
	int level3 = level;

	int image_x = cmap.getRow();
	int image_y = cmap.getCol();

	//imatrix tmp(image_x, image_y);

	//CopyCol2GrayImage(image_x, image_y, cmap, tmp);

	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			r = (double)cmap[x][y].r;
			g = (double)cmap[x][y].g;
			b = (double)cmap[x][y].b;
			r /= 255.;
			g /= 255.;
			b /= 255.;
			//TRACE("r = %f\n", r);
			//TRACE("g = %f\n", g);
			//TRACE("b = %f\n", b);
			//RGB2HSV(r, g, b, h, s, v);
			///////////////////////////
			if (r == 0.0) r = 0.0;
			else if (r == 1.0) r = 1.0;
			r = ( (int)(r * level1) ) / (double)level1 + 1.0/(double)level1/2.0;
			if (g == 0.0) g = 0.0;
			else if (g == 1.0) g = 1.0;
			else g = ( (int)(g * level2) ) / (double)level2 + 1.0/(double)level2/2.0;
			if (b == 0.0) b = 0.0;
			else if (b == 1.0) b = 1.0;
			else b = ( (int)(b * level3) ) / (double)level3 + 1.0/(double)level3/2.0;
			///////////////////////////////
			//if (h > 1.0) h = 1.0;
			//if (h < 0.0) h = 0.0;
			//h *= 360.0; // [0, 360]
			////////////////////////////////
			// extrapolate! s and v
			//double t = 1.1;
			//if (h > 360.0) h = 360.0;
			//s = (1-t)*0.0 + t*s;
			//if (s > 1.0) s = 1.0;
			//if (s < 0.0) s = 0.0;
			//s = 1.0; // saturation always maximum!
			//v = (1-t)*0.0 + t*v;
			//if (v > 1.0) v = 1.0;
			//if (v < 0.0) v = 0.0;
			///////////////////////////////
			r1 = (GLubyte)(r*255);
			g1 = (GLubyte)(g*255);
			b1 = (GLubyte)(b*255);
			cmap[x][y].r = r1;
			cmap[x][y].g = g1;
			cmap[x][y].b = b1;
		}
	}
}

void GrayQuantization(imatrix& image, int level) 
// Based on Gooch's method
{
	int x, y;
	double v;
	double t;

	int image_x = image.getRow();
	int image_y = image.getCol();

	//imatrix tmp(image_x, image_y);

	//CopyCol2GrayImage(image_x, image_y, cmap, tmp);

	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			v = (double)image[x][y];
			v /= 255.;
			///////////////////////////
			v = ( (int)(v * level) ) / (double)level + 1.0/(double)level/2.0;
			///////////////////////////////
			// extrapolate! s and v
			t = 1.1;
			//s = (1-t)*0.0 + t*s;
			v = (1-t)*0.0 + t*v;
			//if (s > 1.0) s = 1.0;
			if (v > 1.0) v = 1.0;
			///////////////////////////////
			image[x][y] = round(v * 255.);
		}
	}
}

void LevelSet(imatrix& image, int max_level) 
// propagate a level set front
{
	int i, j, k, index, val, max_pixel_no;
	double v, t;

	int image_x = image.getRow();
	int image_y = image.getCol();

	int gray_val[20] = {0}; // cannot have more than 20 levels
	int level_pixels[20] = {0}; // cannot have more than 20 levels
	
	if (max_level > 20) {
		TRACE("max_level cannot exceed 20\n");
		exit(1);
	}

	for (k = 0; k < max_level; k++) {
		v = k * 1.0 / (double)max_level; // [0, 1]
		v += 1.0/(double)max_level/2.0;
		t = 1.1;
		v = (1-t)*0.0 + t*v;
		if (v > 1.0) v = 1.0;
		gray_val[k] = round(v * 255.);
	}

	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			v = image[i][j] / 255.; // [0, 1]
			k = (int) (v * max_level);
			level_pixels[k]++;
		}
	}

	index = -1;
	max_pixel_no = 0;
	for (k = 0; k < max_level; k++) {
		if (k == 0 || k == max_level-1) continue; // exclude black and white pixels!
		if (level_pixels[k] > max_pixel_no) {
			index = k;
			max_pixel_no = level_pixels[k]; 
		}
	}

	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			val = image[i][j];
			//TRACE("val = %d\n", val);
			//TRACE("index = %d\n", index);
			//TRACE("gray_val[index] = %d\n", gray_val[index]);
			//TRACE("max_pixel_no = %d\n", max_pixel_no);
			if (val == gray_val[index]) {
				//TRACE("val = %d\n", val);
				//TRACE("gray_val[index] = %d\n", gray_val[index]);
				image[i][j] = 255;
			}
		}
	}
}

typedef struct node_item {
	int val;
	int count;
	struct node_item *next;
} node;

void LevelSet2(imatrix& image) 
// propagate a level set front
{
	int i, j, val;

	int image_x = image.getRow();
	int image_y = image.getCol();

	node *list, *p;
	bool found;

	list = NULL;
	
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			found = false;
			for (p = list; p; p=p->next) {
				if (p->val == image[i][j]) {
					found = true; break;
				}
			}
			if (found) p->count++;
			else {
				p = (node *)malloc(sizeof(node));
				p->count = 0;
				p->val = image[i][j];
				p->next = list; // add to the list (at the head)
				list = p;
			}
		}
	}

	int max_count = 0;
	node *max_p = NULL;
	for (p = list; p; p=p->next) {
		if (p->val > 240 || p->val < 30) continue;
		if (p->count > max_count) {
			max_count = p->count; 
			max_p = p;
		}
	}

	matrix Ix, Iy;
	Ix.init(image_x, image_y);
	Iy.init(image_x, image_y);

	double c, r, l, t, b, gx, gy, norm;
	int x, y, itr, m;

	itr = 30;

	for (m = 0; m < itr; m++) {
		//////////////////////////////
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				//////////////////////
				c = (double)image[i][j];
				
				if (i < image_x-1)	r = (double)image[i+1][j]; else r = c;
				if (i > 0)			l = (double)image[i-1][j]; else l = c;
				
				Ix[i][j] = (r - l) / 2.0; 

				if (j < image_y-1)	t = (double)image[i][j+1]; else t = c;
				if (j > 0)			b = (double)image[i][j-1]; else b = c;
				
				Iy[i][j] = (t - b) / 2.0;
			}
		}
		
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				///////////////////////////////////
				if (Ix[i][j] == 0.0 && Iy[i][j] == 0.0) continue;
				val = image[i][j];
				//TRACE("val = %d\n", val);
				if (val != max_p->val) {
					gx = Ix[i][j]; gy = Iy[i][j];
					norm = sqrt(gx*gx + gy*gy);
					gx /= norm; gy /= norm;
					x = round(i + gx); y = round(j + gy);
					if (x > image_x-1) x = image_x-1; if (x < 0) x = 0;
					if (y > image_y-1) y = image_y-1; if (y < 0) y = 0;
					if (image[x][y] == max_p->val) {
						image[i][j] = max_p->val;
						continue;
					}
					x = round(i - gx); y = round(j - gy);
					if (x > image_x-1) x = image_x-1; if (x < 0) x = 0;
					if (y > image_y-1) y = image_y-1; if (y < 0) y = 0;
					if (image[x][y] == max_p->val) {
						image[i][j] = max_p->val;
						continue;
					}
				}
			}
		}
	}
}

void LevelSet3(imatrix& image, int itr) 
// propagate a level set front
// check neighboring pixels
{
	int i, j, val;

	int image_x = image.getRow();
	int image_y = image.getCol();

	node *list, *p;
	bool found;

	list = NULL;
	
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			found = false;
			for (p = list; p; p=p->next) {
				if (p->val == image[i][j]) {
					found = true; break;
				}
			}
			if (found) p->count++;
			else {
				p = (node *)malloc(sizeof(node));
				p->count = 0;
				p->val = image[i][j];
				p->next = list; // add to the list (at the head)
				list = p;
			}
		}
	}

	int max_count = 0;
	node *max_p = NULL;
	for (p = list; p; p=p->next) {
		if (p->val > 240 || p->val < 30) continue;
		if (p->count > max_count) {
			max_count = p->count; 
			max_p = p;
		}
	}

	//matrix Ix, Iy;
	//Ix.init(image_x, image_y);
	//Iy.init(image_x, image_y);

	imatrix tmp(image_x, image_y);
	tmp.copy(image);

	int x, y, m;

	int thres = 100;

	for (m = 0; m < itr; m++) {
		//////////////////////////////
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				///////////////////////////////////
				//if (Ix[i][j] == 0.0 && Iy[i][j] == 0.0) continue;
				val = tmp[i][j];
				if (val <= 30) continue; // stop at lines
				if ( ABS(val - max_p->val) > thres ) continue; // too different colors
				//TRACE("val = %d\n", val);
				if (val != max_p->val) {
					if (i < image_x-1) {
						x = i+1; y = j;
						if (tmp[x][y] == max_p->val) {
							image[i][j] = max_p->val;
							continue;
						}
					}
					if (i < image_x-1 && j < image_y-1 ) {
						x = i+1; y = j+1;
						if (tmp[x][y] == max_p->val) {
							image[i][j] = max_p->val;
							continue;
						}
					}
					if (i < image_x-1 && j > 0 ) {
						x = i+1; y = j-1;
						if (tmp[x][y] == max_p->val) {
							image[i][j] = max_p->val;
							continue;
						}
					}
					if (i > 0) {
						x = i-1; y = j;
						if (tmp[x][y] == max_p->val) {
							image[i][j] = max_p->val;
							continue;
						}
					}
					if (i > 0 && j < image_y-1 ) {
						x = i-1; y = j+1;
						if (tmp[x][y] == max_p->val) {
							image[i][j] = max_p->val;
							continue;
						}
					}
					if (i > 0 && j > 0 ) {
						x = i-1; y = j-1;
						if (tmp[x][y] == max_p->val) {
							image[i][j] = max_p->val;
							continue;
						}
					}
					if (j < image_y-1) {
						x = i; y = j+1;
						if (tmp[x][y] == max_p->val) {
							image[i][j] = max_p->val;
							continue;
						}
					}
					if (j > 0) {
						x = i; y = j-1;
						if (tmp[x][y] == max_p->val) {
							image[i][j] = max_p->val;
							continue;
						}
					}
				}
			} // for i
		} // for j
		tmp.copy(image);
	} // for m
}

void Dilation(imatrix& image, int itr) 
// check neighboring pixels
{
	int i, j, val;

	int image_x = image.getRow();
	int image_y = image.getCol();

	node *list, *p;
	bool found;

	list = NULL;
	
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			found = false;
			for (p = list; p; p=p->next) {
				if (p->val == image[i][j]) {
					found = true; break;
				}
			}
			if (found) p->count++;
			else {
				p = (node *)malloc(sizeof(node));
				p->count = 0;
				p->val = image[i][j];
				p->next = list; // add to the list (at the head)
				list = p;
			}
		}
	}

	int max_count = 0;
	node *max_p = NULL;
	for (p = list; p; p=p->next) {
		if (p->val > 240 || p->val < 30) continue;
		if (p->count > max_count) {
			max_count = p->count; 
			max_p = p;
		}
	}

	//matrix Ix, Iy;
	//Ix.init(image_x, image_y);
	//Iy.init(image_x, image_y);

	imatrix tmp(image_x, image_y);
	tmp.copy(image);

	int x, y, m;

	int thres = 100, s, t;
	bool processed;

	for (m = 0; m < itr; m++) {
		//////////////////////////////
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				///////////////////////////////////
				//if (Ix[i][j] == 0.0 && Iy[i][j] == 0.0) continue;
				val = tmp[i][j];
				if (val <= 30) continue; // stop at lines
				if ( ABS(val - max_p->val) > thres ) continue; // too different colors
				//TRACE("val = %d\n", val);
				if (val != max_p->val) {
					processed = false;
					for (t = -1; t <= 1; t++) {
						for (s = -1; s <= 1; s++) {
							x = i + s; y = j + t;
							if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) continue;
							if (tmp[x][y] == max_p->val) {
								image[i][j] = max_p->val;
								processed = true;
							}
							if (processed) break;
						}
						if (processed) break;
					}
				}
			} // for i
		} // for j
		tmp.copy(image);
	} // for m

}

typedef struct nodeRGB_item {
	iRGB col;
	int count;
	struct nodeRGB_item *next;
} nodeRGB;

void DilationColor(CDC& dc, cimatrix& cmap) 
// check neighboring pixels
{
	int i, j;

	int image_x = cmap.getRow();
	int image_y = cmap.getCol();

	nodeRGB *list, *p, *q;
	iRGB col;

	bool found;

	list = NULL;
	
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			found = false;
			for (p = list; p; p=p->next) { // already in the list
				if (p->col.r == cmap[i][j].r && 
					p->col.g == cmap[i][j].g && 
					p->col.b == cmap[i][j].b) {
					found = true; break;
				}
			}
			if (found) p->count++;
			else { // newly insert
				p = (nodeRGB *)malloc(sizeof(nodeRGB));
				p->count = 0;
				p->col = cmap[i][j];
				p->next = list; // add to the list (at the head)
				list = p;
			}
		}
	}

	

	//TRACE("max_p->col = [%d, %d, %d]\n", max_p->col.r, max_p->col.g, max_p->col.b);
	//TRACE("max_p->count = %d\n", max_p->count);

	cimatrix tmp(image_x, image_y);
	tmp.copy(cmap);

	int x, y;

	int s, t;
	bool processed, remain;
	double dist;
	double thres = 100;

	int max_count;
	nodeRGB *max_p;

	//for (m = 0; m < itr; m++) {
	while (1) {
		/////////////////////////////////////
		// find max node
		max_count = 0;
		max_p = NULL;
		for (p = list; p; p=p->next) {
			//if (p->val > 240 || p->val < 30) continue;
			if (p->col.r < 10 && p->col.g < 10 && p->col.b < 10) continue; // line
			if (p->count > max_count) {
				max_count = p->count; 
				max_p = p;
			}
		}
		if (max_p == NULL) break; // exhausted
		/////////////////////////////
		thres *= 0.9;
		//////////////////////////////
		// Dilation!
		while (1) {
			remain = false;
			for (j = 0; j < image_y; j++) {
				for (i = 0; i < image_x; i++) {
					///////////////////////////////////
					//if (Ix[i][j] == 0.0 && Iy[i][j] == 0.0) continue;
					col = tmp[i][j];
					if (col.r < 10 && col.g < 10 && col.b < 10) continue; // stop at lines
					dist = dist3(col.r-max_p->col.r, col.g-max_p->col.g, col.b-max_p->col.b);
					if ( dist > thres ) continue; // colors are too different; stop
					//TRACE("val = %d\n", val);
					if (col.r != max_p->col.r || col.g != max_p->col.g || col.b != max_p->col.b) {
						processed = false;
						for (t = -1; t <= 1; t++) {
							for (s = -1; s <= 1; s++) {
								x = i + s; y = j + t;
								if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) continue;
								if (tmp[x][y].r == max_p->col.r && 
									tmp[x][y].g == max_p->col.g && 
									tmp[x][y].b == max_p->col.b) {
										////////////////////////////
										cmap[i][j] = max_p->col;
										processed = true;
										remain = true;
								}
								if (processed) break;
							}
							if (processed) break;
						}
					}
				} // for i
			} // for j
			if (!remain) break;
			tmp.copy(cmap);
			//////////////////////////////
			DrawColorImage(memDC, image_x, image_y, cmap);
			dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
		}
		/////////////////////////////////////
		// delete max node
		for (p=list, q=NULL; p; q=p, p=p->next) {
			//if (p->val > 240 || p->val < 30) continue;
			if (p == max_p) {
				if (q == NULL) { // max_p is the first node
					list = p->next; break;
				}
				q->next = p->next;
				break;
			}
		}
		//////////////////////////////////
		free(max_p);
		////////////////////////////////////////
	} // for m

}

void DilationColor2(CDC& dc, cimatrix& cmap, imatrix& line, double thres, double factor) 
// use line maps as stopping criteria
{
	int i, j;

	int image_x = cmap.getRow();
	int image_y = cmap.getCol();

	nodeRGB *list, *p, *q;
	iRGB col;

	bool found;

    list = NULL;
	//list2 = NULL;
	
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			found = false;
			for (p = list; p; p=p->next) { // already in the list
				if (p->col.r == cmap[i][j].r && 
					p->col.g == cmap[i][j].g && 
					p->col.b == cmap[i][j].b) {
					found = true; break;
				}
			}
			if (found) p->count++;
			else { // newly insert
				p = (nodeRGB *)malloc(sizeof(nodeRGB));
				p->count = 0;
				p->col = cmap[i][j];
				p->next = list; // add to the list (at the head)
				list = p;
			}
		}
	}

	//TRACE("max_p->col = [%d, %d, %d]\n", max_p->col.r, max_p->col.g, max_p->col.b);
	//TRACE("max_p->count = %d\n", max_p->count);

	cimatrix tmp(image_x, image_y);
	tmp.copy(cmap);

	imatrix done(image_x, image_y);
	done.zero();

	int x, y;

	int s, t;
	bool processed, remain;
	double dist;
	//double thres = 100;

	int max_count;
	nodeRGB *max_p;

	//for (m = 0; m < itr; m++) {
	while (1) {
		/////////////////////////////////////
		// find max node
		max_count = 0;
		max_p = NULL;
		for (p = list; p; p=p->next) {
			//if (p->val > 240 || p->val < 30) continue;
			//if (p->col.r < 10 && p->col.g < 10 && p->col.b < 10) continue; // line
			if (p->count > max_count) {
				max_count = p->count; 
				max_p = p;
			}
		}
		if (max_p == NULL) break; // exhausted
		/////////////////////////////
		thres *= factor;
		//////////////////////////////
		// Dilation!
		while (1) {
			remain = false;
			for (j = 0; j < image_y; j++) {
				for (i = 0; i < image_x; i++) {
					///////////////////////////////////
					//if (Ix[i][j] == 0.0 && Iy[i][j] == 0.0) continue;
					if (done[i][j]) continue;
					col = tmp[i][j];
					if (col.r == max_p->col.r && col.g == max_p->col.g && col.b == max_p->col.b) {
						done[i][j] = 1; continue;
					}
					//if (col.r < 10 && col.g < 10 && col.b < 10) continue; // stop at lines
					if (line[i][j] == 0) continue; // stop at lines
					//////////////////////////////////////////////
					dist = dist3(col.r-max_p->col.r, col.g-max_p->col.g, col.b-max_p->col.b);
					if ( dist > thres ) continue; // colors are too different; stop
					//TRACE("val = %d\n", val);
					if (col.r != max_p->col.r || col.g != max_p->col.g || col.b != max_p->col.b) {
						processed = false;
						for (t = -1; t <= 1; t++) {
							for (s = -1; s <= 1; s++) {
								x = i + s; y = j + t;
								if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) continue;
								if (tmp[x][y].r == max_p->col.r && 
									tmp[x][y].g == max_p->col.g && 
									tmp[x][y].b == max_p->col.b) {
										////////////////////////////
										cmap[i][j] = max_p->col;
										done[i][j] = 1;
										processed = true;
										remain = true;
								}
								if (processed) break;
							}
							if (processed) break;
						}
					}
				} // for i
			} // for j
			if (!remain) break;
			tmp.copy(cmap);
			//////////////////////////////
			DrawColorImage(memDC, image_x, image_y, cmap);
			dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
		}
		/////////////////////////////////////
		// delete max node
		for (p=list, q=NULL; p; q=p, p=p->next) {
			//if (p->val > 240 || p->val < 30) continue;
			if (p == max_p) {
				if (q == NULL) { // max_p is the first node
					list = p->next; break;
				}
				q->next = p->next;
				break;
			}
		}
		//free(max_p);
		// move to list2
		//if (list2 == NULL) max_p->next = NULL;
		//else max_p->next = list2;
		///////////////////////////////////////////////////
	} // for m

	/*
	for (p=list2; p; p=q) {
		q = p->next;
		free(p);
	}
	*/
}

void GetFlowDilation(imatrix& line, ETF& e, int half_l, int max_itr)
// flow-based Morphological dilation
// extend the black line along flow direction
{
	int k, m;
	int i, j, i_x, i_y;

	vector vt(2);
	double x, y, d_x, d_y;
	int x1, y1;

	int image_x = line.getRow();
	int image_y = line.getCol();

	imatrix tmp;
	tmp.copy(line);

	double step_size;
	bool found;
	int val;

	step_size = 1.0;

	for (m = 0; m < max_itr; m++) {
		/////////////////////////////////////////
		// FBL along main axis!
		//StartTimer();
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				/////////////////////////////
				if (line[i][j] == 0) continue; // already black
				////////////////////////////////
				found = false;
				////////////////////////////////////////////////
				// One half
				d_x = (double)i; d_y = (double)j; 
				i_x = i;	i_y = j;
				////////////////////////////////////////////////
				for (k = 0; k < half_l; k++) {
					vt[0] = e[i_x][i_y].tx;
					vt[1] = e[i_x][i_y].ty;
					if (vt[0] == 0.0 && vt[1] == 0.0) break;
					//vt.make_unit();
					////////////////////////////////////////////////
					x = d_x;
					y = d_y;
					/////////////////////////////////////////////////////
					if (x > (double)image_x-1 || x < 0.0 || y > (double)image_y-1 || y < 0.0) 
						continue;
					/////////////////////////////////////////////////
					x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > image_x-1) x1 = image_x-1;
					y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > image_y-1) y1 = image_y-1;
					//////////////////////////////
					val = tmp[x1][y1];
					if (val == 0) { found = true; break; }
					/////////////////////////////////////////////////////////
					d_x += vt[0] * step_size; // accurate new location x
					d_y += vt[1] * step_size; // accurate new location y
					/////////////////////////////////////////
					i_x = round(d_x); // integer version of new location x
					i_y = round(d_y); // integer version of new location y
					//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
					if (d_x < 0 || d_x > image_x-1 || d_y < 0 || d_y > image_y-1) break;
				}
				/////////////////////////////
				if (found) line[i][j] = 0;
				////////////////////////////////////////////////
				// Other half
				d_x = (double)i; d_y = (double)j; 
				i_x = i;	i_y = j;
				//////////////////////////////////////
				for (k = 0; k < half_l; k++) {
					vt[0] = -e[i_x][i_y].tx;
					vt[1] = -e[i_x][i_y].ty;
					if (vt[0] == 0.0 && vt[1] == 0.0) break;
					//vt.make_unit();
					///////////////////////////////
					x = d_x;
					y = d_y;
					/////////////////////////////////////////////////////
					if (x > (double)image_x-1 || x < 0.0 || y > (double)image_y-1 || y < 0.0) 
						continue;
					/////////////////////////////////////////////////
					x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > image_x-1) x1 = image_x-1;
					y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > image_y-1) y1 = image_y-1;
					val = tmp[x1][y1];
					if (val == 0) { found = true; break; }
					/////////////////////////////////////////
					d_x += vt[0] * step_size; // accurate new location x
					d_y += vt[1] * step_size; // accurate new location y
					/////////////////////////////////////////
					i_x = round(d_x); // integer version of new location x
					i_y = round(d_y); // integer version of new location y
					//if (int_i < 0 || int_i > IMAGE_X-1 || int_j < 0 || int_j > IMAGE_Y-1) break;
					if (d_x < 0 || d_x > image_x-1 || d_y < 0 || d_y > image_y-1) break;
				}
				//////////////////////////////////
				if (found) line[i][j] = 0;
			}
		}
		tmp.copy(line); // update tmp
	}
}

iRGB *CreatePaletteFromImage(cimatrix& cmap, int& N) 
{
	int i, j;

	int image_x = cmap.getRow();
	int image_y = cmap.getCol();

	nodeRGB *list, *p, *q;
    
	bool found;

    list = NULL;
	
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			found = false;
			for (p = list; p; p=p->next) { // already in the list
				if (p->col.r == cmap[i][j].r && 
					p->col.g == cmap[i][j].g && 
					p->col.b == cmap[i][j].b) {
					found = true; break;
				}
			}
			if (found) p->count++;
			else { // newly insert
				p = (nodeRGB *)malloc(sizeof(nodeRGB));
				p->count = 0;
				p->col = cmap[i][j];
				p->next = list; // add to the list (at the head)
				list = p;
			}
		}
	}

	N = 0;
	for (p = list; p; p=p->next) N++;

	TRACE("N = %d\n", N);

	iRGB *pal;
	pal = new iRGB[N];

	for (p=list, i=0; p; p=p->next, i++) {
		pal[i].r = p->col.r;
		pal[i].g = p->col.g;
		pal[i].b = p->col.b;
		//TRACE("pal[%d] = [%d, %d, %d]\n", p->col.r, p->col.g, p->col.b);
		//TRACE("pal[%d] = [%d, %d, %d]\n", i, pal[i].r, pal[i].g, pal[i].b);
	}

	for (p=list; p; p=q) {
		q = p->next;
		free(p);
	}

	return pal;
}

void ColorQuantizationUsingPalette(cimatrix& cmap, iRGB* pal, int N) 
// use only the colors in the palette
{
	int i, j, k;

	int image_x = cmap.getRow();
	int image_y = cmap.getCol();

	iRGB col, p_col, min_col;
	double dist, min_dist;

	cimatrix tmp(image_x, image_y);
	tmp.copy(cmap);

	TRACE("N = %d\n", N);

	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			col = tmp[i][j];
			min_dist = 1000000000;
			for (k = 0; k < N; k++) {
				p_col = pal[k];
				//TRACE("pal[%d] = [%d, %d, %d]\n", k, pal[i].r, pal[i].g, pal[i].b);
				dist = dist3(col.r-p_col.r, col.g-p_col.g, col.b-p_col.b);
				if (dist < min_dist) {
					min_dist = dist;
					min_col = p_col;
				}
			}
			cmap[i][j] = min_col;
		}
	}

}

void ClosingColor(CDC& dc, cimatrix& cmap, imatrix& line, int itr) 
// use line maps as stopping criteria
{
	int i, j;

	int image_x = cmap.getRow();
	int image_y = cmap.getCol();

	nodeRGB *list, *p, *q;
	iRGB col;

	bool found;

    list = NULL;
	//list2 = NULL;
	
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			found = false;
			for (p = list; p; p=p->next) { // already in the list
				if (p->col.r == cmap[i][j].r && 
					p->col.g == cmap[i][j].g && 
					p->col.b == cmap[i][j].b) {
					found = true; break;
				}
			}
			if (found) p->count++;
			else { // newly insert
				p = (nodeRGB *)malloc(sizeof(nodeRGB));
				p->count = 0;
				p->col = cmap[i][j];
				p->next = list; // add to the list (at the head)
				list = p;
			}
		}
	}

	//TRACE("max_p->col = [%d, %d, %d]\n", max_p->col.r, max_p->col.g, max_p->col.b);
	//TRACE("max_p->count = %d\n", max_p->count);

	cimatrix tmp(image_x, image_y);
	tmp.copy(cmap);

	imatrix done(image_x, image_y);
	done.zero();

	int x, y;

	int s, t, m;
	bool processed;
	//bool remain;
	//double dist;
	//double thres = 100;

	int max_count;
	nodeRGB *max_p;

	//for (m = 0; m < itr; m++) {
	while (1) {
		/////////////////////////////////////
		// find max node
		max_count = 0;
		max_p = NULL;
		for (p = list; p; p=p->next) {
			//if (p->val > 240 || p->val < 30) continue;
			//if (p->col.r < 10 && p->col.g < 10 && p->col.b < 10) continue; // line
			if (p->count > max_count) {
				max_count = p->count; 
				max_p = p;
			}
		}
		if (max_p == NULL) break; // exhausted
		/////////////////////////////
		//thres *= factor;
		//////////////////////////////
		// Dilation!
		//while (1) {
		for (m = 0; m < itr; m++) {
			//remain = false;
			for (j = 0; j < image_y; j++) {
				for (i = 0; i < image_x; i++) {
					///////////////////////////////////
					//if (Ix[i][j] == 0.0 && Iy[i][j] == 0.0) continue;
					//if (done[i][j]) continue;
					if (line[i][j] == 0) continue; // stop at lines
					col = tmp[i][j];
					if (col.r == max_p->col.r && col.g == max_p->col.g && col.b == max_p->col.b) {
						//done[i][j] = 1; 
						continue;
					}
					//////////////////////////////////////////////
					//dist = dist3(col.r-max_p->col.r, col.g-max_p->col.g, col.b-max_p->col.b);
					//if ( dist > thres ) continue; // colors are too different; stop
					processed = false;
					for (t = -1; t <= 1; t++) {
						for (s = -1; s <= 1; s++) {
							x = i + s; y = j + t;
							if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) continue;
							if (tmp[x][y].r == max_p->col.r && 
								tmp[x][y].g == max_p->col.g && 
								tmp[x][y].b == max_p->col.b) {
									////////////////////////////
									cmap[i][j] = max_p->col;
									processed = true;
									//remain = true;
							}
							if (processed) break;
						}
						if (processed) break;
					}
				} // for i
			} // for j
			//if (!remain) break;
			tmp.copy(cmap);
			//////////////////////////////////////////////
			// Erosion!
			for (j = 0; j < image_y; j++) {
				for (i = 0; i < image_x; i++) {
					///////////////////////////////////
					if (line[i][j] == 0) continue; // stop at lines
					col = tmp[i][j];
					if (col.r != max_p->col.r || col.g != max_p->col.g || col.b != max_p->col.b) {
						//done[i][j] = 1; 
						continue;
					}
					//////////////////////////////////////////////
					//dist = dist3(col.r-max_p->col.r, col.g-max_p->col.g, col.b-max_p->col.b);
					//if ( dist > thres ) continue; // colors are too different; stop
					processed = false;
					for (t = -1; t <= 1; t++) {
						for (s = -1; s <= 1; s++) {
							x = i + s; y = j + t;
							if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) continue;
							if (tmp[x][y].r != max_p->col.r || 
								tmp[x][y].g != max_p->col.g || 
								tmp[x][y].b != max_p->col.b) {
									////////////////////////////
									cmap[i][j] = tmp[x][y];
									processed = true;
									//remain = true;
							}
							if (processed) break;
						}
						if (processed) break;
					}
				} // for i
			} // for j
			//if (!remain) break;
			tmp.copy(cmap);
			//////////////////////////////
			DrawColorImage(memDC, image_x, image_y, cmap);
			dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
			TRACE("opening closing iteration %d\n", m);
		} // for m
		/////////////////////////////////////
		// delete max node
		for (p=list, q=NULL; p; q=p, p=p->next) {
			//if (p->val > 240 || p->val < 30) continue;
			if (p == max_p) {
				if (q == NULL) { // max_p is the first node
					list = p->next; break;
				}
				q->next = p->next;
				break;
			}
		}
		//free(max_p);
		// move to list2
		//if (list2 == NULL) max_p->next = NULL;
		//else max_p->next = list2;
		///////////////////////////////////////////////////
	} // for m

	/*
	for (p=list2; p; p=q) {
		q = p->next;
		free(p);
	}
	*/
}

void ErosionGray(CDC& dc, imatrix& gray, int itr) 
{
	int i, j;

	int image_x = gray.getRow();
	int image_y = gray.getCol();

	imatrix tmp(image_x, image_y);
	tmp.copy(gray);

	int x, y;

	int s, t, m;
	bool processed;

	for (m = 0; m < itr; m++) {
		//remain = false;
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				///////////////////////////////////
				if (tmp[i][j] != 0) continue;
				processed = false;
				for (t = -1; t <= 1; t++) {
					for (s = -1; s <= 1; s++) {
						x = i + s; y = j + t;
						if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) continue;
						if (tmp[x][y] == 255) {
							////////////////////////////
							gray[i][j] = 255;
							processed = true;
							//TRACE("processed!\n");
						}
						if (processed) break;
					}
					if (processed) break;
				}
			} // for i
		} // for j
		tmp.copy(gray);
		//////////////////////////////
		//DrawGrayImage(memDC, image_x, image_y, gray);
		//dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
		//TRACE("Erosion iteration %d\n", m);
	} // for m
}

void ErosionGrayCircle(CDC& dc, imatrix& gray, int itr) 
// use circle structuring element
{
	int i, j;

	int image_x = gray.getRow();
	int image_y = gray.getCol();

	imatrix tmp(image_x, image_y);
	tmp.copy(gray);

	int x, y;

	int s, t, m;
	bool processed;

	int size = 2;

	int mask[5][5] = { 
		{0, 1, 1, 1, 0},
		{1, 1, 1, 1, 1},
		{1, 1, 1, 1, 1},
		{1, 1, 1, 1, 1},
		{0, 1, 1, 1, 0}
	};

	/*
	int mask[3][3] = { 
		{0, 1, 0},
		{1, 1, 1},
		{0, 1, 0}
	};
	*/

	for (m = 0; m < itr; m++) {
		//remain = false;
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				///////////////////////////////////
				if (tmp[i][j] != 0) continue;
				processed = false;
				for (t = -size; t <= size; t++) {
					for (s = -size; s <= size; s++) {
						x = i + s; y = j + t;
						if (!mask[s+size][t+size]) continue;
						if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) continue;
						if (tmp[x][y] == 255) {
							////////////////////////////
							gray[i][j] = 255;
							processed = true;
							//TRACE("processed!\n");
						}
						if (processed) break;
					}
					if (processed) break;
				}
			} // for i
		} // for j
		tmp.copy(gray);
		//////////////////////////////
		//DrawGrayImage(memDC, image_x, image_y, gray);
		//dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
		//TRACE("Erosion iteration %d\n", m);
	} // for m
}


void RemoveIsolatedRegions(CDC& dc, imatrix& gray, int size_max) 
// using morphology, remove isolated regions
// start with the smalled possible isolated region, then test for bigger regions
{
	int i, j;

	int image_x = gray.getRow();
	int image_y = gray.getCol();

	imatrix tmp(image_x, image_y);
	tmp.copy(gray);

	int x, y;
	//int size = 1;

	int s, t;
	bool isolated;

	int size = 0;

	while (1) {
		//remain = false;
		size++;
		if (size > size_max) break;
		/////////////////////////////////
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				///////////////////////////////////
				if (tmp[i][j] != 0) continue; // ignore white pixels
				isolated = true;
				for (t = -size; t <= size; t++) { // left border
					x = i - size; y = j + t;
					if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) continue;
					if (tmp[x][y] == 0) { // we found neighboring black pixel
						isolated = false;
					}
					if (!isolated) break;
				}
				if (!isolated) continue;
				/////////////////////////////////
				for (t = -size; t <= size; t++) { // right border
					x = i + size; y = j + t;
					if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) continue;
					if (tmp[x][y] == 0) { // we found neighboring black pixel
						isolated = false;
					}
					if (!isolated) break;
				}
				if (!isolated) continue;
				for (s = -size; s <= size; s++) { // left border
					x = i + s; y = j - size;
					if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) continue;
					if (tmp[x][y] == 0) { // we found neighboring black pixel
						isolated = false;
					}
					if (!isolated) break;
				}
				if (!isolated) continue;
				/////////////////////////////////
				for (s = -size; s <= size; s++) { // right border
					x = i + s; y = j + size;
					if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) continue;
					if (tmp[x][y] == 0) { // we found neighboring black pixel
						isolated = false;
					}
					if (!isolated) break;
				}
				if (!isolated) continue;
				/////////////////////////////
				// isolated, confirmed
				gray[i][j] = 255;
			} // for i
		} // for j
		tmp.copy(gray);
		//////////////////////////////
		//DrawGrayImage(memDC, image_x, image_y, gray);
		//dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
		//TRACE("Erosion iteration %d\n", m);
	} // for m
}

void DilationGray(CDC& dc, imatrix& gray, int itr) 
{
	int i, j;

	int image_x = gray.getRow();
	int image_y = gray.getCol();

	imatrix tmp(image_x, image_y);
	tmp.copy(gray);

	int x, y;

	int s, t, m;
	bool processed;

	for (m = 0; m < itr; m++) {
		//remain = false;
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				///////////////////////////////////
				if (tmp[i][j] == 0) continue;
				processed = false;
				for (t = -1; t <= 1; t++) {
					for (s = -1; s <= 1; s++) {
						x = i + s; y = j + t;
						if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) continue;
						if (tmp[x][y] == 0) {
							////////////////////////////
							gray[i][j] = 0;
							processed = true;
							//TRACE("processed!\n");
						}
						if (processed) break;
					}
					if (processed) break;
				}
			} // for i
		} // for j
		tmp.copy(gray);
		//////////////////////////////
		//DrawGrayImage(memDC, image_x, image_y, gray);
		//dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
		//TRACE("Erosion iteration %d\n", m);
	} // for m
}

void GetOffsetLines(CDC& dc, imatrix& gray) 
{
	int i, j, k;

	int image_x = gray.getRow();
	int image_y = gray.getCol();

	imatrix tmp(image_x, image_y);
	tmp.copy(gray);

	deque<PixeL> pnts;
	pnts.clear();

	PixeL p;

	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			if (tmp[i][j] == 0) {
				p.x = i; p.y = j;
				pnts.push_back(p);
			}
		}
	}

	TRACE("pnts.size() = %d\n", pnts.size());

	double max_dist = dist2(0, 0, image_x-1, image_y-1);
	double min_dist, dist;

	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			min_dist = 1000000;
			if (tmp[i][j] != 0) {
				for (k = 0; k < (signed)pnts.size(); k++) {
					dist = dist2(i, j, pnts[k].x, pnts[k].y);
					if (dist < min_dist) min_dist = dist;
				}
				gray[i][j] = round( (min_dist / max_dist) * 255.0 );
			}
			DrawGrayImage(memDC, image_x, image_y, gray);
			dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
		}
	}
	
}

void DilationGraySep(CDC& dc, imatrix& gray, int itr) 
// separable version
{
	int i, j;

	int image_x = gray.getRow();
	int image_y = gray.getCol();

	imatrix tmp(image_x, image_y);
	tmp.copy(gray);

	int x, y;

	int s, t, m;
	bool processed;

	for (m = 0; m < itr; m++) {
		//remain = false;
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				///////////////////////////////////
				if (tmp[i][j] == 0) continue;
				processed = false;
				for (s = -1; s <= 1; s++) {
					x = i + s; y = j;
					if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) continue;
					if (tmp[x][y] == 0) {
						////////////////////////////
						gray[i][j] = 0;
						processed = true;
						//TRACE("processed!\n");
					}
					if (processed) break;
				}
			} // for i
		} // for j
		tmp.copy(gray);

		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				///////////////////////////////////
				if (tmp[i][j] == 0) continue;
				processed = false;
				for (t = -1; t <= 1; t++) {
					x = i; y = j + t;
					if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) continue;
					if (tmp[x][y] == 0) {
						////////////////////////////
						gray[i][j] = 0;
						processed = true;
						//TRACE("processed!\n");
					}
					if (processed) break;
				}
			} // for i
		} // for j
		tmp.copy(gray);
		//////////////////////////////
		//DrawGrayImage(memDC, image_x, image_y, gray);
		//dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
		//TRACE("Erosion iteration %d\n", m);
	} // for m
}


void ReplaceTextureWithDilation(CDC& dc, imatrix& gray, ETF& e, imatrix& tex, int itr) 
{
	int i, j;

	int image_x = gray.getRow();
	int image_y = gray.getCol();

	imatrix tmp(image_x, image_y);
	tmp.copy(gray);

	imatrix tmp2(image_x, image_y);
	tmp2.copy(gray);

	imatrix t_y_loc(image_x, image_y);

	t_y_loc.zero();
	gray.white();

	int x, y;

	int s, t, m;
	bool processed;

	double tx, ty, gx, gy;
	int t_x, t_y, x1, y1;

	int tex_x = tex.getRow();
	int tex_y = tex.getCol();

	int freq_x = 20;
	int freq_y = 10;

	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			if (tmp[i][j] == 0) { // thin line
				////////////////////////////
				t_x = 0;
				t_x = t_x % tex_x;
				tx = e[i][j].tx;
				ty = e[i][j].ty;
				if ( fabs(tx) >= fabs(ty) ) t_y = i;
				else t_y = j;
				t_y = t_y * freq_y;
				t_y = t_y % tex_y;
				t_y_loc[i][j] = t_y;
				gray[i][j] = tex[t_x][t_y];
				processed = true;
				//TRACE("processed!\n");
			}
		}
	}
    
	for (m = 0; m < itr; m++) {
		//remain = false;
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				///////////////////////////////////
				if (tmp[i][j] == 0) continue;
				processed = false;
				for (t = -1; t <= 1; t++) {
					for (s = -1; s <= 1; s++) {
						x = i + s; y = j + t;
						if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) continue;
						if (tmp[x][y] == 0) {
							////////////////////////////
							tmp2[i][j] = 0;
							t_x = m * freq_x;
							t_x = t_x % tex_x;
							gx = -e[x][y].ty;
							gy = e[x][y].tx;
							x1 = round(x + gx);
							y1 = round(y + gy);
							t_y = t_y_loc[x1][y1];
							gray[i][j] = tex[t_x][t_y];
							processed = true;
							//TRACE("processed!\n");
						}
						if (processed) break;
					}
					if (processed) break;
				}
			} // for i
		} // for j
		tmp.copy(tmp2);
		//////////////////////////////
		//DrawGrayImage(memDC, image_x, image_y, gray);
		//dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
		//TRACE("Erosion iteration %d\n", m);
	} // for m
}

void OpeningClosingColor(CDC& dc, cimatrix& cmap, imatrix& line, int itr) 
// this corresponds to mean curvature flow
// use line maps as stopping criteria
{
	int i, j;

	int image_x = cmap.getRow();
	int image_y = cmap.getCol();

	nodeRGB *list, *p, *q;
	iRGB col;

	bool found;

    list = NULL;
	//list2 = NULL;

	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			found = false;
			for (p = list; p; p=p->next) { // already in the list
				if (p->col.r == cmap[i][j].r && 
					p->col.g == cmap[i][j].g && 
					p->col.b == cmap[i][j].b) {
					found = true; break;
				}
			}
			if (found) p->count++;
			else { // newly insert
				p = (nodeRGB *)malloc(sizeof(nodeRGB));
				p->count = 0;
				p->col = cmap[i][j];
				p->next = list; // add to the list (at the head)
				list = p;
			}
		}
	}

	//TRACE("max_p->col = [%d, %d, %d]\n", max_p->col.r, max_p->col.g, max_p->col.b);
	//TRACE("max_p->count = %d\n", max_p->count);

	cimatrix tmp(image_x, image_y);
	tmp.copy(cmap);

	imatrix done(image_x, image_y);
	done.zero();

	int x, y;

	int s, t, m;
	bool processed;
	//bool remain;
	//double dist;
	//double thres = 100;

	int size = 2; // size of the structuring element

	int mask[5][5] = { 
		{0, 1, 1, 1, 0},
		{1, 1, 1, 1, 1},
		{1, 1, 1, 1, 1},
		{1, 1, 1, 1, 1},
		{0, 1, 1, 1, 0}
	};

	int max_count;
	nodeRGB *max_p;

	//for (m = 0; m < itr; m++) {
	while (1) {
		/////////////////////////////////////
		// find max node
		max_count = 0;
		max_p = NULL;
		for (p = list; p; p=p->next) {
			//if (p->val > 240 || p->val < 30) continue;
			//if (p->col.r < 10 && p->col.g < 10 && p->col.b < 10) continue; // line
			if (p->count > max_count) {
				max_count = p->count; 
				max_p = p;
			}
		}
		if (max_p == NULL) break; // exhausted
		/////////////////////////////
		//thres *= factor;
		//while (1) {
		for (m = 0; m < itr; m++) {
			//////////////////////////////
			// Opening = Erosion + Dilation	
			//////////////////////////////////////////////
			// Erosion!
			for (j = 0; j < image_y; j++) {
				for (i = 0; i < image_x; i++) {
					///////////////////////////////////
					if (line[i][j] == 0) continue; // stop at lines
					col = tmp[i][j];
					if (col.r != max_p->col.r || col.g != max_p->col.g || col.b != max_p->col.b) {
						//done[i][j] = 1; 
						continue;
					}
					//////////////////////////////////////////////
					//dist = dist3(col.r-max_p->col.r, col.g-max_p->col.g, col.b-max_p->col.b);
					//if ( dist > thres ) continue; // colors are too different; stop
					processed = false;
					for (t = -size; t <= size; t++) {
						for (s = -size; s <= size; s++) {
							if (mask[s+size][t+size] == 0) continue;
							x = i + s; y = j + t;
							if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) continue;
							if (tmp[x][y].r != max_p->col.r || 
								tmp[x][y].g != max_p->col.g || 
								tmp[x][y].b != max_p->col.b) {
									////////////////////////////
									cmap[i][j] = tmp[x][y];
									processed = true;
									//remain = true;
							}
							if (processed) break;
						}
						if (processed) break;
					}
				} // for i
			} // for j
			//if (!remain) break;
			tmp.copy(cmap);
			/////////////////////////////////////
			// Dilation!	
			//remain = false;
			for (j = 0; j < image_y; j++) {
				for (i = 0; i < image_x; i++) {
					///////////////////////////////////
					//if (Ix[i][j] == 0.0 && Iy[i][j] == 0.0) continue;
					//if (done[i][j]) continue;
					if (line[i][j] == 0) continue; // stop at lines
					col = tmp[i][j];
					if (col.r == max_p->col.r && col.g == max_p->col.g && col.b == max_p->col.b) {
						//done[i][j] = 1; 
						continue;
					}
					//////////////////////////////////////////////
					//dist = dist3(col.r-max_p->col.r, col.g-max_p->col.g, col.b-max_p->col.b);
					//if ( dist > thres ) continue; // colors are too different; stop
					processed = false;
					for (t = -size; t <= size; t++) {
						for (s = -size; s <= size; s++) {
							if (mask[s+size][t+size] == 0) continue;
							x = i + s; y = j + t;
							if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) continue;
							if (tmp[x][y].r == max_p->col.r && 
								tmp[x][y].g == max_p->col.g && 
								tmp[x][y].b == max_p->col.b) {
									////////////////////////////
									cmap[i][j] = max_p->col;
									processed = true;
									//remain = true;
							}
							if (processed) break;
						}
						if (processed) break;
					}
				} // for i
			} // for j
			//if (!remain) break;
			tmp.copy(cmap);
			

			///////////////////////////////////
			// Closing = Dilation + Erosion	
			//////////////////////////////
			// Dilation!	
			//remain = false;
			for (j = 0; j < image_y; j++) {
				for (i = 0; i < image_x; i++) {
					///////////////////////////////////
					//if (Ix[i][j] == 0.0 && Iy[i][j] == 0.0) continue;
					//if (done[i][j]) continue;
					if (line[i][j] == 0) continue; // stop at lines
					col = tmp[i][j];
					if (col.r == max_p->col.r && col.g == max_p->col.g && col.b == max_p->col.b) {
						//done[i][j] = 1; 
						continue;
					}
					//////////////////////////////////////////////
					//dist = dist3(col.r-max_p->col.r, col.g-max_p->col.g, col.b-max_p->col.b);
					//if ( dist > thres ) continue; // colors are too different; stop
					processed = false;
					for (t = -size; t <= size; t++) {
						for (s = -size; s <= size; s++) {
							if (mask[s+size][t+size] == 0) continue;
							x = i + s; y = j + t;
							if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) continue;
							if (tmp[x][y].r == max_p->col.r && 
								tmp[x][y].g == max_p->col.g && 
								tmp[x][y].b == max_p->col.b) {
									////////////////////////////
									cmap[i][j] = max_p->col;
									processed = true;
									//remain = true;
							}
							if (processed) break;
						}
						if (processed) break;
					}
				} // for i
			} // for j
			//if (!remain) break;
			tmp.copy(cmap);
			//////////////////////////////////////////////
			// Erosion!
			for (j = 0; j < image_y; j++) {
				for (i = 0; i < image_x; i++) {
					///////////////////////////////////
					if (line[i][j] == 0) continue; // stop at lines
					col = tmp[i][j];
					if (col.r != max_p->col.r || col.g != max_p->col.g || col.b != max_p->col.b) {
						//done[i][j] = 1; 
						continue;
					}
					//////////////////////////////////////////////
					//dist = dist3(col.r-max_p->col.r, col.g-max_p->col.g, col.b-max_p->col.b);
					//if ( dist > thres ) continue; // colors are too different; stop
					processed = false;
					for (t = -size; t <= size; t++) {
						for (s = -size; s <= size; s++) {
							if (mask[s+size][t+size] == 0) continue;
							x = i + s; y = j + t;
							if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) continue;
							if (tmp[x][y].r != max_p->col.r || 
								tmp[x][y].g != max_p->col.g || 
								tmp[x][y].b != max_p->col.b) {
									////////////////////////////
									cmap[i][j] = tmp[x][y];
									processed = true;
									//remain = true;
							}
							if (processed) break;
						}
						if (processed) break;
					}
				} // for i
			} // for j
			//if (!remain) break;
			tmp.copy(cmap);
			//////////////////////////////
			DrawColorImage(memDC, image_x, image_y, cmap);
			dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
		} // for m
		/////////////////////////////////////
		// delete max node
		for (p=list, q=NULL; p; q=p, p=p->next) {
			//if (p->val > 240 || p->val < 30) continue;
			if (p == max_p) {
				if (q == NULL) { // max_p is the first node
					list = p->next; break;
				}
				q->next = p->next;
				break;
			}
		}
		//free(max_p);
		// move to list2
		//if (list2 == NULL) max_p->next = NULL;
		//else max_p->next = list2;
		///////////////////////////////////////////////////
	} // for m

	/*
	for (p=list2; p; p=q) {
		q = p->next;
		free(p);
	}
	*/
}

void OpeningClosingBlack(CDC& dc, imatrix& gray, int itr) 
// this corresponds to mean curvature flow
{
	int i, j;

	int image_x = gray.getRow();
	int image_y = gray.getCol();

	int val;

	imatrix tmp(image_x, image_y);
	tmp.copy(gray);

	int x, y;

	int s, t, m;
	bool processed;
	//bool remain;
	//double dist;
	//double thres = 100;

	int size = 3; // size of the structuring element

	int mask[7][7] = { 
		{0, 0, 1, 1, 1, 0, 0},
		{0, 1, 1, 1, 1, 1, 0},
		{1, 1, 1, 1, 1, 1, 1},
		{1, 1, 1, 1, 1, 1, 1},
		{1, 1, 1, 1, 1, 1, 1},
		{0, 1, 1, 1, 1, 1, 0},
		{0, 0, 1, 1, 1, 0, 0}
	};

	for (m = 0; m < itr; m++) {
		//////////////////////////////
		// Opening = Erosion + Dilation	
		//////////////////////////////////////////////
		// Erosion!
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				///////////////////////////////////
				val = tmp[i][j];
				if (val != 0) {
					continue;
				}
				processed = false;
				for (t = -size; t <= size; t++) {
					for (s = -size; s <= size; s++) {
						if (mask[s+size][t+size] == 0) continue;
						x = i + s; y = j + t;
						if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) continue;
						if (tmp[x][y] != 0) {
							////////////////////////////
							gray[i][j] = tmp[x][y];
							processed = true;
							//remain = true;
						}
						if (processed) break;
					}
					if (processed) break;
				}
			} // for i
		} // for j
		//if (!remain) break;
		tmp.copy(gray);
		/////////////////////////////////////
		// Dilation!	
		//remain = false;
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				val = tmp[i][j];
				if (val == 0) {
					continue;
				}
				//////////////////////////////////////////////
				//dist = dist3(col.r-max_p->col.r, col.g-max_p->col.g, col.b-max_p->col.b);
				//if ( dist > thres ) continue; // colors are too different; stop
				processed = false;
				for (t = -size; t <= size; t++) {
					for (s = -size; s <= size; s++) {
						if (mask[s+size][t+size] == 0) continue;
						x = i + s; y = j + t;
						if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) continue;
						if (tmp[x][y] == 0) {
							////////////////////////////
							gray[i][j] = 0;
							processed = true;
							//remain = true;
						}
						if (processed) break;
					}
					if (processed) break;
				}
			} // for i
		} // for j
		//if (!remain) break;
		tmp.copy(gray);
		

		///////////////////////////////////
		// Closing = Dilation + Erosion	
		//////////////////////////////
		// Dilation!	
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				val = tmp[i][j];
				if (val == 0) {
					continue;
				}
				//////////////////////////////////////////////
				processed = false;
				for (t = -size; t <= size; t++) {
					for (s = -size; s <= size; s++) {
						if (mask[s+size][t+size] == 0) continue;
						x = i + s; y = j + t;
						if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) continue;
						if (tmp[x][y] == 0) {
								////////////////////////////
								gray[i][j] = 0;
								processed = true;
								//remain = true;
						}
						if (processed) break;
					}
					if (processed) break;
				}
			} // for i
		} // for j
		//if (!remain) break;
		tmp.copy(gray);
		//////////////////////////////////////////////
		// Erosion!
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				///////////////////////////////////
				val = tmp[i][j];
				if (val != 0) {
					continue;
				}
				//////////////////////////////////////////////
				processed = false;
				for (t = -size; t <= size; t++) {
					for (s = -size; s <= size; s++) {
						if (mask[s+size][t+size] == 0) continue;
						x = i + s; y = j + t;
						if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) continue;
						if (tmp[x][y] != 0) {
								////////////////////////////
								gray[i][j] = tmp[x][y];
								processed = true;
								//remain = true;
						}
						if (processed) break;
					}
					if (processed) break;
				}
			} // for i
		} // for j
		//if (!remain) break;
		tmp.copy(gray);
		//////////////////////////////
		DrawGrayImage(memDC, image_x, image_y, gray);
		dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
		TRACE("OpeningClosing %d\n", m);
		///////////////////////////////////////////////////////////
	} // for m
}

void Closing(imatrix& image, int size, int itr) 
// check neighboring pixels
{
	int i, j, val;

	int image_x = image.getRow();
	int image_y = image.getCol();

	node *list, *p;
	bool found;

	list = NULL;
	
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			found = false;
			for (p = list; p; p=p->next) {
				if (p->val == image[i][j]) {
					found = true; break;
				}
			}
			if (found) p->count++;
			else {
				p = (node *)malloc(sizeof(node));
				p->count = 0;
				p->val = image[i][j];
				p->next = list; // add to the list (at the head)
				list = p;
			}
		}
	}

	int max_count = 0;
	node *max_p = NULL;
	for (p = list; p; p=p->next) {
		if (p->val > 240 || p->val < 30) continue;
		if (p->count > max_count) {
			max_count = p->count; 
			max_p = p;
		}
	}

	//matrix Ix, Iy;
	//Ix.init(image_x, image_y);
	//Iy.init(image_x, image_y);

	imatrix tmp(image_x, image_y);
	tmp.copy(image);

	int x, y, m;

	int thres = 100, s, t;
	bool processed;

	for (m = 0; m < itr; m++) {
		////////////////////////////
		// Dilation
		//////////////////////////////
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				///////////////////////////////////
				//if (Ix[i][j] == 0.0 && Iy[i][j] == 0.0) continue;
				val = tmp[i][j];
				if (val <= 30) continue; // stop at lines
				if ( ABS(val - max_p->val) > thres ) continue; // too different colors
				//TRACE("val = %d\n", val);
				if (val != max_p->val) {
					processed = false;
					for (t = -size; t <= size; t++) {
						for (s = -size; s <= size; s++) { // size: size of the structuring element
							x = i + s; y = j + t;
							if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) continue;
							if (tmp[x][y] == max_p->val) {
								image[i][j] = max_p->val;
								processed = true;
							}
							if (processed) break;
						}
						if (processed) break;
					}
				}
			} // for i
		} // for j
		tmp.copy(image);
		/////////////////////////////
		// Erosion
		//////////////////////////////
		///*
		for (j = 0; j < image_y; j++) {
			for (i = 0; i < image_x; i++) {
				///////////////////////////////////
				//if (Ix[i][j] == 0.0 && Iy[i][j] == 0.0) continue;
				val = tmp[i][j];
				if (val <= 30) continue; // stop at lines
				if ( ABS(val - max_p->val) > thres ) continue; // too different colors
				//TRACE("val = %d\n", val);
				if (val == max_p->val) {
					processed = false;
					for (t = -1; t <= 1; t++) {
						for (s = -1; s <= 1; s++) {
							x = i + s; y = j + t;
							if (x > image_x-1 || x < 0 || y > image_y-1 || y < 0) continue;
							if (tmp[x][y] != max_p->val) {
								image[i][j] = tmp[x][y];
								processed = true;
							}
							if (processed) break;
						}
						if (processed) break;
					}
				}
			} // for i
		} // for j
		tmp.copy(image);
		//*/
	} // for m

}

void RemoveSmallRegions(CDC& dc, imatrix& line, int size)
{
	int i, j;

	int image_x = line.getRow();
	int image_y = line.getCol();

	imatrix processed(image_x, image_y);
	processed.zero();

	deque<PixeL> pnts;
	deque<PixeL> pnts2;

	PixeL p, r, l, t, b;
	int count, k;

	DrawGrayImage(memDC, image_x, image_y, line);
	dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
	
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			if (line[i][j] == 255) continue;
			if (processed[i][j]) continue;
			pnts.clear();
			pnts2.clear();
			count = 0;
			p.x = i; p.y = j;
			pnts.push_back(p);
			pnts2.push_back(p);
			processed[p.x][p.y] = 255;
			while (1) {
				if ((signed)pnts.size() == 0) break;
				p = pnts[0];
				//TRACE("[before] pnts.size() = %d\n", (signed)pnts.size());
				//TRACE("p.x = %d, p.y = %d\n", p.x, p.y);
				//TRACE("processed[%d][%d] = %d\n", p.x, p.y, processed[p.x][p.y]);
				pnts.pop_front();
				count++;
				//if (count > size) break;
				//TRACE("[after] pnts.size() = %d\n", (signed)pnts.size());
				////////////////////////////////
				r.x = p.x+1; r.y = p.y; 
				if (r.x <= image_x-1)
					if (line[r.x][r.y] == 0 && processed[r.x][r.y] == 0) {
						pnts.push_back(r);
						pnts2.push_back(r);
						processed[r.x][r.y] = 255;
					}
				l.x = p.x-1; l.y = p.y; 
				if (l.x >= 0)
					if (line[l.x][l.y] == 0 && processed[l.x][l.y] == 0) {
						pnts.push_back(l);
						pnts2.push_back(l);
						processed[l.x][l.y] = 255;
					}
				t.x = p.x;   t.y = p.y+1; 
				if (t.y <= image_y-1)
					if (line[t.x][t.y] == 0 && processed[t.x][t.y] == 0) {
						pnts.push_back(t);
						pnts2.push_back(t);
						processed[t.x][t.y] = 255;
					}
				b.x = p.x;   b.y = p.y-1; 
				if (b.y >= 0)
					if (line[b.x][b.y] == 0 && processed[b.x][b.y] == 0) {
						pnts.push_back(b);
						pnts2.push_back(b);
						processed[b.x][b.y] = 255;
					}
			}
			if (count <= size) { // remove this black region
				for (k = 0; k < (signed)pnts2.size(); k++) {
					p = pnts2[k];
					//TRACE("k = %d, p.x = %d, p.y = %d\n", k, p.x, p.y);
					line[p.x][p.y] = 255;
				}
			}
			DrawGrayImage(memDC, image_x, image_y, line);
			dc.BitBlt(0, 0, image_x, image_y, &memDC, 0, 0, SRCCOPY);
		}
	}
}


void ColorQuantizationLAB(cimatrix& cmap, int level) 
// LAB color model
// Based on Gooch's method
{
	int x, y;
	GLubyte r1, g1, b1;
	double r, g, b;
	double L, A, B;
	//double t;

	int image_x = cmap.getRow();
	int image_y = cmap.getCol();

	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			r = (double)cmap[x][y].r;
			g = (double)cmap[x][y].g;
			b = (double)cmap[x][y].b;
			//r /= 255.;
			//g /= 255.;
			//b /= 255.;
			//TRACE("r = %f\n", r);
			//TRACE("g = %f\n", g);
			//TRACE("b = %f\n", b);
			//RGB2HSV(r, g, b, h, s, v);
			RGB2LAB(r, g, b, L, A, B);
			///////////////////////////
			L /= 100.; // [0, 1]
			L = ( (int)(L * level) ) / (double)level + 1.0/(double)level/2.0;
			L *= 100.;
			if (L > 100.) L = 100.;
			///////////////////////////////
			////////////////////////////////
			// extrapolate! s and v
			/*
			t = 1.1;
			s = (1-t)*0.0 + t*s;
			v = (1-t)*0.0 + t*v;
			if (s > 1.0) s = 1.0;
			if (v > 1.0) v = 1.0;
			*/
			///////////////////////////////
			LAB2RGB(L, A, B, r, g, b);
			//HSV2RGB(h, s, v, r, g, b);
			r1 = (GLubyte)r;
			g1 = (GLubyte)g;
			b1 = (GLubyte)b;
			cmap[x][y].r = r1;
			cmap[x][y].g = g1;
			cmap[x][y].b = b1;
		}
	}
}

void ColorQuantizationLAB2(cimatrix& cmap, int level1, int level2, int level3) 
// LAB color model
// L: [0, 100], a: [-86.184636, 98.254219], b: [-107.863681, 94.482485] 
{
	int x, y;
	GLubyte r1, g1, b1;
	double r, g, b;
	double L, A, B;
	//double t;

	//int level1 = 5;
	//int level2 = 10;
	//int level3 = 10;

	double A_min = -86.184636;
	double A_max = 98.254219;
	double B_min = -107.863681;
	double B_max = 94.482485;

	int image_x = cmap.getRow();
	int image_y = cmap.getCol();

	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			r = (double)cmap[x][y].r;
			g = (double)cmap[x][y].g;
			b = (double)cmap[x][y].b;
			//r /= 255.;
			//g /= 255.;
			//b /= 255.;
			//TRACE("r = %f\n", r);
			//TRACE("g = %f\n", g);
			//TRACE("b = %f\n", b);
			//RGB2HSV(r, g, b, h, s, v);
			RGB2LAB(r, g, b, L, A, B);
			///////////////////////////
			L /= 100.; // [0, 1]
			if (L > 0.99) L = 1.0;
			else if (L < 0.01) L = 0.0;
			else L = ( (int)(L * level1) ) / (double)level1 + 1.0/(double)level1/2.0;
			//t = 1.1;
			//L = (1-t)*0.0 + t*L;
			if (L > 1.0) L = 1.0;
			if (L < 0.0) L = 0.0;
			L *= 100.;

			///////////////////////////////
			A += fabs(A_min); // make it positive
			A /= (A_max - A_min); // [0, 1]
			if (A == 1.0) A = 1.0;
			else if (A == 0.0) A = 0.0;
			else A = ( (int)(A * level2) ) / (double)level2 + 1.0/(double)level2/2.0;
			if (A > 1.0) A = 1.0;
			if (A < 0.0) A = 0.0;
			A *= (A_max - A_min);
			A -= fabs(A_min);
			////////////////////////////////
			B += fabs(B_min); // make it positive
			B /= (B_max - B_min); // [0, 1]
			if (B == 1.0) B = 1.0;
			else if (B == 0.0) B = 0.0;
			else B = ( (int)(B * level3) ) / (double)level3 + 1.0/(double)level3/2.0;
			if (B > 1.0) B = 1.0;
			if (B < 0.0) B = 0.0;
			B *= (B_max - B_min);
			B -= fabs(B_min);
			////////////////////////////////
			// extrapolate! s and v
			/*
			t = 1.1;
			s = (1-t)*0.0 + t*s;
			v = (1-t)*0.0 + t*v;
			if (s > 1.0) s = 1.0;
			if (v > 1.0) v = 1.0;
			*/
			///////////////////////////////
			LAB2RGB(L, A, B, r, g, b);
			//HSV2RGB(h, s, v, r, g, b);
			r1 = (GLubyte)r;
			g1 = (GLubyte)g;
			b1 = (GLubyte)b;
			cmap[x][y].r = r1;
			cmap[x][y].g = g1;
			cmap[x][y].b = b1;
		}
	}
}


void DrawCartoonImage(CDC& dc, int image_x, int image_y, cimatrix& image, imatrix& gray) 
// Merge color background and black outlines
{
	int x, y;
	GLubyte r, g, b;

	//for (y = IMAGE_Y - 1; y >= 0; y--) {
	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			//COLORREF rgbcol = memDC.GetPixel(x, (IMAGE_Y-1)-y);
			if (gray[x][y] == 0) {
				r = g = b = 0;
			}
			else {
				r = (GLubyte)image[x][y].r;
				g = (GLubyte)image[x][y].g;
				b = (GLubyte)image[x][y].b;
			}
			/// Set Pixel in MemDC
			dc.SetPixelV(x, (IMAGE_Y-1)-y, RGB(r, g, b));
		}
	}
}

void ConstructCartoonImage(cimatrix& image, imatrix& gray, cimatrix& merged) 
// Merge color background and black outlines
{
	int x, y;

	int image_x = image.getRow();
	int image_y = image.getCol();

	//for (y = IMAGE_Y - 1; y >= 0; y--) {
	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			//COLORREF rgbcol = memDC.GetPixel(x, (IMAGE_Y-1)-y);
			if (gray[x][y] == 0) {
				merged[x][y].r = 0;
				merged[x][y].g = 0;
				merged[x][y].b = 0;
			}
			else {
				merged[x][y].r = image[x][y].r;
				merged[x][y].g = image[x][y].g;
				merged[x][y].b = image[x][y].b;
			}
		}
	}
}

void ConstructCartoonImage2(cimatrix& image, imatrix& gray, cimatrix& merged, double threshold) 
// Merge color background and black outlines
/// with threshold [0, 1]
{
	int x, y;

	int image_x = image.getRow();
	int image_y = image.getCol();

	//for (y = IMAGE_Y - 1; y >= 0; y--) {
	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			//COLORREF rgbcol = memDC.GetPixel(x, (IMAGE_Y-1)-y);
			if (gray[x][y] < threshold * 255) {
				merged[x][y].r = (GLubyte)gray[x][y];
				merged[x][y].g = (GLubyte)gray[x][y];
				merged[x][y].b = (GLubyte)gray[x][y];
			}
			else {
				merged[x][y].r = image[x][y].r;
				merged[x][y].g = image[x][y].g;
				merged[x][y].b = image[x][y].b;
			}
		}
	}
}

void ConstructCartoonImage3(cimatrix& image, imatrix& gray, cimatrix& merged) 
// Merge color background and black outlines
// with smooth blending!
{
	int x, y;
	double t;

	int image_x = image.getRow();
	int image_y = image.getCol();

	//for (y = IMAGE_Y - 1; y >= 0; y--) {
	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			//COLORREF rgbcol = memDC.GetPixel(x, (IMAGE_Y-1)-y);
			t = gray[x][y] / 255.0;
			merged[x][y].r = (GLubyte)( (1-t) * gray[x][y] + t * image[x][y].r );
			merged[x][y].g = (GLubyte)( (1-t) * gray[x][y] + t * image[x][y].g );
			merged[x][y].b = (GLubyte)( (1-t) * gray[x][y] + t * image[x][y].b );
		}
	}
}

void DrawGrayImageMask(CDC& dc, int image_x, int image_y, int size, PixeL seed, imatrix& image) 
{
	GLubyte r2;
	int	s, r, half;
	int	i, j;

	half = size/2;

	for (s = 0; s < size; s++) {
		for (r = 0; r < size; r++) {
			/////////////////////////////////////////////////////////
			// circular kernel
			if ( dist2(s, r, half, half) > half-1 ) continue; 
			//////////////////////////////////////////////////
			i = seed.x-half+s;
			j = seed.y-half+r;
			if (i <= 0 || i >= image_x-1 || j <= 0 || j >= image_y-1)
				continue;
			r2 = (GLubyte)image[i][j];
			/// Set Pixel in MemDC
            dc.SetPixelV(i, (IMAGE_Y-1)-j, RGB(r2, r2, r2));
			/////////////////////////////////
			// for paper writing (4/7/2006)
			/*
			if (r2 == 0)
				dc.SetPixelV(i, (IMAGE_Y-1)-j, RGB(r2, r2, r2));
			else
				dc.SetPixelV(i, (IMAGE_Y-1)-j, RGB(255, 200, 100));
			*/
		}
	}
}

void DrawEdgeStrokes(CDC& dc, int image_x, int image_y, imatrix& image, int width) 
{
	int x, y;
	double d_i, d_j, tx, ty, nx, ny;
	int	st_x, st_y, end_x, end_y;
	int int_i, int_j;
	double t;
	CPen pen, *pOldPen;
	imatrix visit;
	
	visit.init(image_x, image_y);
	visit.zero();
	ClearMemDC(&dc); // clear the canvas white

	//gx = G_x[i][j];
	//gy = G_y[i][j];
	//g = G_mag[i][j];
	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			//COLORREF rgbcol = memDC.GetPixel(x, (IMAGE_Y-1)-y);
			if (image[x][y] == 0 && visit[x][y] == 0) {
				visit[x][y] = 1;
				//////////////////////////////////////////////////////////////
				// draw strokes
				////////////////////////////////////////////////
				// One half
				pen.CreatePen(PS_SOLID, width, RGB(0, 0, 0));
				pOldPen = (CPen *)dc.SelectObject(&pen);
				d_i = (double)x; d_j = (double)y; 
				tx = -G_y[x][y];
				ty = G_x[x][y];
				st_x = x;
				st_y = y;
				while(1) {
					if (tx == 0.0 && ty == 0.0) break;
					nx = tx / sqrt(tx*tx+ty*ty);
					ny = ty / sqrt(tx*tx+ty*ty);
					if (ABS(nx) > ABS(ny)) t = 1/ABS(nx);
					else t = 1/ABS(ny);
					d_i += nx*t;
					d_j += ny*t;
					//(-ny, nx)
					if (d_i < 0 || d_i > IMAGE_X-1 || d_j < 0 || d_j > IMAGE_Y-1) break;
					int_i = round(d_i);
					int_j = round(d_j);
					////////////////////////////////////
					visit[int_i][int_j] = 1;
					if (image[int_i][int_j] != 0) break;
					///////////////////////////////////
					//TRACE("i = %.1f, j = %.1f\n", i, j);
					end_x = int_i; end_y = int_j;
					dc.MoveTo(st_x, IMAGE_Y-1-st_y);
					dc.LineTo(end_x, IMAGE_Y-1-end_y);
					st_x = end_x; st_y = end_y;
					////////////////////////////
					//sum += (int)RGB_GETRED(double_buffer.GetPixel(int_i, IMAGE_Y-1-int_j));
					//TRACE("sum = %d\n", sum);
					//count++;
					tx = -G_y[x][y];
					ty = G_x[x][y];
				}
				dc.SelectObject(pOldPen);
				pen.DeleteObject(); 
				////////////////////////////////////////
				// Other half
				pen.CreatePen(PS_SOLID, width, RGB(0, 0, 0));
				pOldPen = (CPen *)dc.SelectObject(&pen);
				d_i = (double)x; d_j = (double)y; 
				tx = -G_y[x][y];
				ty = G_x[x][y];
				st_x = x;
				st_y = y;
				while(1) {
					if (tx == 0.0 && ty == 0.0) break;
					nx = tx / sqrt(tx*tx+ty*ty);
					ny = ty / sqrt(tx*tx+ty*ty);
					if (ABS(nx) > ABS(ny)) t = 1/ABS(nx);
					else t = 1/ABS(ny);
					d_i -= nx*t;
					d_j -= ny*t;
					//(-ny, nx)
					if (d_i < 0 || d_i > IMAGE_X-1 || d_j < 0 || d_j > IMAGE_Y-1) break;
					int_i = round(d_i);
					int_j = round(d_j);
					////////////////////////////////////
					visit[int_i][int_j] = 1;
					if (image[int_i][int_j] != 0) break;
					///////////////////////////////////
					//TRACE("i = %.1f, j = %.1f\n", i, j);
					end_x = int_i; end_y = int_j;
					dc.MoveTo(st_x, IMAGE_Y-1-st_y);
					dc.LineTo(end_x, IMAGE_Y-1-end_y);
					st_x = end_x; st_y = end_y;
					////////////////////////////
					//sum += (int)RGB_GETRED(double_buffer.GetPixel(int_i, IMAGE_Y-1-int_j));
					//TRACE("sum = %d\n", sum);
					//count++;
					tx = -G_y[x][y];
					ty = G_x[x][y];
				}
				dc.SelectObject(pOldPen);
				pen.DeleteObject(); 
			}
			/// Set Pixel in MemDC
			//dc.SetPixelV(x, (IMAGE_Y-1)-y, RGB(r, r, r));
		}
	}
}

void DrawEdgeStrokes2(CDC& dc, int image_x, int image_y, imatrix& image, int width) 
// try to maximize the connectivity
{
	int x, y;
	//double d_i, d_j, tx, ty, nx, ny;
	//int	st_x, st_y, end_x, end_y;
	int int_i, int_j;
	CPen pen, *pOldPen;
	imatrix visit;
	int i, j, xx, yy, found;
	
	visit.init(image_x, image_y); // is this pixel already visited?
	visit.zero(); // initially no pixel is visited
	ClearMemDC(&dc); // clear the canvas white

	//gx = G_x[i][j];
	//gy = G_y[i][j];
	//g = G_mag[i][j];
	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			//COLORREF rgbcol = memDC.GetPixel(x, (IMAGE_Y-1)-y);
			if (image[x][y] == 0 && visit[x][y] == 0) {
				visit[x][y] = 1;
				//////////////////////////////////////////////////////////////
				// draw strokes
				////////////////////////////////////////////////
				// One half
				pen.CreatePen(PS_SOLID, width, RGB(0, 0, 0));
				pOldPen = (CPen *)dc.SelectObject(&pen);
				int_i = x;
				int_j = y;
				dc.MoveTo(int_i, IMAGE_Y-1-int_j);
				while(1) {
					found = 0;
					/////////////////////////////////
					// search the 8-neighbor to find the connecting edge pixel
					for (i = -1; i <= 1; i++) {
						for (j = -1; j <= 1; j++) {
							xx = int_i + i;
							yy = int_j + j;
							if (xx < 0 || xx > IMAGE_X-1 || yy < 0 || yy > IMAGE_Y-1) continue;
							if (image[xx][yy] == 0 && visit[xx][yy] == 0) {
								found = 1;
								break; // found
							}
						}
						if (found) break;
					}
					if (!found) break; // dead end; no need to search any more
					///////////////////////////////
					int_i = xx;
					int_j = yy;
					visit[int_i][int_j] = 1;
					///////////////////////////////////
					dc.LineTo(int_i, IMAGE_Y-1-int_j);
					////////////////////////////
				}
				dc.SelectObject(pOldPen);
				pen.DeleteObject(); 
				////////////////////////////////////////
				// Other half
				pen.CreatePen(PS_SOLID, width, RGB(0, 0, 0));
				pOldPen = (CPen *)dc.SelectObject(&pen);
				int_i = x;
				int_j = y;
				dc.MoveTo(int_i, IMAGE_Y-1-int_j);
				while(1) {
					found = 0;
					for (i = -1; i <= 1; i++) {
						for (j = -1; j <= 1; j++) {
							xx = int_i + i;
							yy = int_j + j;
							if (xx < 0 || xx > IMAGE_X-1 || yy < 0 || yy > IMAGE_Y-1) continue;
							if (image[xx][yy] == 0 && visit[xx][yy] == 0) {
								found = 1;
								break; // found
							}
						}
						if (found) break;
					}
					if (!found) break; // dead end
					///////////////////////////////
					int_i = xx;
					int_j = yy;
					visit[int_i][int_j] = 1;
					///////////////////////////////////
					dc.LineTo(int_i, IMAGE_Y-1-int_j);
					////////////////////////////
				}
				dc.SelectObject(pOldPen);
				pen.DeleteObject(); 
				
			}
			/// Set Pixel in MemDC
			//dc.SetPixelV(x, (IMAGE_Y-1)-y, RGB(r, r, r));
		}
	}
}

//deque<PntsDeque> pnt_array;
/*
struct double2D {
	double x, y;
};
*/

//typedef deque<double2D> PntsDeque;
//deque<PntsDeque*> big_array;
deque<deque<double2D>*> big_array; // a one-dimensional array of strokes (each stroke as point set)
//deque<double2D> *pnts_array;

void StoreEdgeStrokes(int image_x, int image_y, imatrix& image) 
{
	int x, y;
	double d_i, d_j, tx, ty, nx, ny;
	int	st_x, st_y, end_x, end_y;
	int int_i, int_j;
	double t;
	imatrix visit;
	double2D p;
	//PntsDeque* dq;
	deque<double2D>* dq;
	
	visit.init(image_x, image_y);
	visit.zero();
	//ClearMemDC(&dc); // clear the canvas white

	//gx = G_x[i][j];
	//gy = G_y[i][j];
	//g = G_mag[i][j];
	//deque<PntsDeque>::iterator it;
	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			//TRACE("i'm here!\n");
			//COLORREF rgbcol = memDC.GetPixel(x, (IMAGE_Y-1)-y);
			if (image[x][y] == 0 && visit[x][y] == 0) {
				//dq = new PntsDeque;
				dq = new deque<double2D>;
				big_array.insert(big_array.end(), dq);
				//TRACE("big_array.size() = %d\n", big_array.size());
				visit[x][y] = 1;
				///////////////////////////////////
				p.x = (double)x; 
				p.y = (double)y; 
				//pnt_array.insert(pnt_array.end(), p);
				//it = pnts_array.end();
				//it->insert(it->end(), p);
				dq->insert(dq->end(), p);
				//////////////////////////////////////////////////////////////
				// draw strokes
				////////////////////////////////////////////////
				// One half
				d_i = (double)x; d_j = (double)y; 
				tx = -G_y[x][y];
				ty = G_x[x][y];
				st_x = x;
				st_y = y;
				while(1) {
					if (tx == 0.0 && ty == 0.0) break;
					nx = tx / sqrt(tx*tx+ty*ty);
					ny = ty / sqrt(tx*tx+ty*ty);
					if (ABS(nx) > ABS(ny)) t = 1/ABS(nx);
					else t = 1/ABS(ny);
					d_i += nx*t;
					d_j += ny*t;
					//(-ny, nx)
					if (d_i < 0 || d_i > IMAGE_X-1 || d_j < 0 || d_j > IMAGE_Y-1) break;
					int_i = round(d_i);
					int_j = round(d_j);
					////////////////////////////////////
					visit[int_i][int_j] = 1;
					if (image[int_i][int_j] != 0) break;
					///////////////////////////////////
					//TRACE("i = %.1f, j = %.1f\n", i, j);
					end_x = int_i; end_y = int_j;
					st_x = end_x; st_y = end_y;
					///////////////////////////////////
					p.x = (double)int_i; 
					p.y = (double)int_j; 
					//pnt_array.insert(pnt_array.end(), p);
					//it = pnts_array.end();
					//it->insert(it->end(), p);
					dq->insert(dq->end(), p);
					////////////////////////////
					//sum += (int)RGB_GETRED(double_buffer.GetPixel(int_i, IMAGE_Y-1-int_j));
					//TRACE("sum = %d\n", sum);
					//count++;
					tx = -G_y[x][y];
					ty = G_x[x][y];
				}
				////////////////////////////////////////
				// Other half
				d_i = (double)x; d_j = (double)y; 
				tx = -G_y[x][y];
				ty = G_x[x][y];
				st_x = x;
				st_y = y;
				while(1) {
					if (tx == 0.0 && ty == 0.0) break;
					nx = tx / sqrt(tx*tx+ty*ty);
					ny = ty / sqrt(tx*tx+ty*ty);
					if (ABS(nx) > ABS(ny)) t = 1/ABS(nx);
					else t = 1/ABS(ny);
					d_i -= nx*t;
					d_j -= ny*t;
					//(-ny, nx)
					if (d_i < 0 || d_i > IMAGE_X-1 || d_j < 0 || d_j > IMAGE_Y-1) break;
					int_i = round(d_i);
					int_j = round(d_j);
					////////////////////////////////////
					visit[int_i][int_j] = 1;
					if (image[int_i][int_j] != 0) break;
					///////////////////////////////////
					//TRACE("i = %.1f, j = %.1f\n", i, j);
					end_x = int_i; end_y = int_j;
					st_x = end_x; st_y = end_y;
					///////////////////////////////////
					p.x = (double)int_i; 
					p.y = (double)int_j; 
					//pnt_array.insert(pnt_array.begin(), p);
					//it = pnts_array.end();
					//it->insert(it->begin(), p);
					dq->insert(dq->begin(), p);
					////////////////////////////
					//sum += (int)RGB_GETRED(double_buffer.GetPixel(int_i, IMAGE_Y-1-int_j));
					//TRACE("sum = %d\n", sum);
					//count++;
					tx = -G_y[x][y];
					ty = G_x[x][y];
				} // while
			} // if
			//big_array.insert(big_array.end(), dq);
			/// Set Pixel in MemDC
			//dc.SetPixelV(x, (IMAGE_Y-1)-y, RGB(r, r, r));
		}
	}

}


void StoreEdgeStrokes2(int image_x, int image_y, imatrix& image) 
// try to maximize the length of connected points
{
	int x, y;
	//double d_i, d_j, tx, ty, nx, ny;
	//int	st_x, st_y, end_x, end_y;
	int int_i, int_j;
	imatrix visit;
	int i, j, xx, yy, found;
	double2D p;
	//PntsDeque* dq;
	deque<double2D>* dq;
	
	visit.init(image_x, image_y);
	visit.zero();
	//ClearMemDC(&dc); // clear the canvas white

	//gx = G_x[i][j];
	//gy = G_y[i][j];
	//g = G_mag[i][j];
	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			//COLORREF rgbcol = memDC.GetPixel(x, (IMAGE_Y-1)-y);
			if (image[x][y] == 0 && visit[x][y] == 0) {
				visit[x][y] = 1;
				dq = new deque<double2D>;
				big_array.insert(big_array.end(), dq);
				p.x = (double)x; 
				p.y = (double)y; 
				dq->insert(dq->end(), p);
				//////////////////////////////////////////////////////////////
				// draw strokes
				////////////////////////////////////////////////
				// One half
				//pen.CreatePen(PS_SOLID, 3, RGB(255, 255, 0));
				//pOldPen = (CPen *)dc.SelectObject(&pen);
				int_i = x;
				int_j = y;
				//dc.MoveTo(int_i, IMAGE_Y-1-int_j);
				while(1) {
					found = 0;
					for (i = -1; i <= 1; i++) {
						for (j = -1; j <= 1; j++) {
							xx = int_i + i;
							yy = int_j + j;
							if (xx < 0 || xx > IMAGE_X-1 || yy < 0 || yy > IMAGE_Y-1) continue;
							if (image[xx][yy] == 0 && visit[xx][yy] == 0) {
								found = 1;
								break; // found
							}
						}
						if (found) break;
					}
					///////////////////////////////
					if (!found) break; // dead end
					///////////////////////////////
					int_i = xx;
					int_j = yy;
					visit[int_i][int_j] = 1;
					///////////////////////////////////
					p.x = (double)int_i; 
					p.y = (double)int_j; 
					dq->insert(dq->end(), p);
					///////////////////////////////////
					//dc.LineTo(int_i, IMAGE_Y-1-int_j);
					////////////////////////////
				}
				//dc.SelectObject(pOldPen);
				//pen.DeleteObject(); 
				////////////////////////////////////////
				// Other half
				//pen.CreatePen(PS_SOLID, 3, RGB(255, 0, 0));
				//pOldPen = (CPen *)dc.SelectObject(&pen);
				int_i = x;
				int_j = y;
				//dc.MoveTo(int_i, IMAGE_Y-1-int_j);
				while(1) {
					found = 0;
					for (i = -1; i <= 1; i++) {
						for (j = -1; j <= 1; j++) {
							xx = int_i + i;
							yy = int_j + j;
							if (xx < 0 || xx > IMAGE_X-1 || yy < 0 || yy > IMAGE_Y-1) continue;
							if (image[xx][yy] == 0 && visit[xx][yy] == 0) {
								found = 1;
								break; // found
							}
						}
						if (found) break;
					}
					if (!found) break; // dead end
					///////////////////////////////
					int_i = xx;
					int_j = yy;
					visit[int_i][int_j] = 1;
					///////////////////////////////////
					p.x = (double)int_i; 
					p.y = (double)int_j; 
					dq->insert(dq->begin(), p);
					///////////////////////////////////
					//dc.LineTo(int_i, IMAGE_Y-1-int_j);
					////////////////////////////
				}
				//dc.SelectObject(pOldPen);
				//pen.DeleteObject(); 
				
			}
			/// Set Pixel in MemDC
			//dc.SetPixelV(x, (IMAGE_Y-1)-y, RGB(r, r, r));
		}
	}
}

//////////////////////////
MyList<MRBspline> bstrokes; // a list of B-spline strokes!
//MyList<MRBspline> bstrokes; // a list of Hermite spline strokes!

void StoreEdgeStrokes3(int image_x, int image_y, imatrix& image, MyList<MRBspline>& bstrokes) 
// try to maximize the length of connected points
// store each stroke to the list of Bspline strokes
{
	int x, y;
	//double d_i, d_j, tx, ty, nx, ny;
	//int	st_x, st_y, end_x, end_y;
	int int_i, int_j;
	imatrix visit;
	int i, j, xx, yy, found;
	double2D p;
	//PntsDeque* dq;

	//SimpleListNode<MRBspline>* s;
	MRBspline* s; // 
	
	visit.init(image_x, image_y);
	visit.zero();
	//ClearMemDC(&dc); // clear the canvas white

	//gx = G_x[i][j];
	//gy = G_y[i][j];
	//g = G_mag[i][j];
	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			//COLORREF rgbcol = memDC.GetPixel(x, (IMAGE_Y-1)-y);
			if (image[x][y] == 0 && visit[x][y] == 0) { // black pixel, but not visited
				visit[x][y] = 1; // now visited
				s = new MRBspline;
				bstrokes.AddRear(s); // Add this new B-spline stroke
				p.x = (double)x; 
				p.y = (double)y; 
				s->AddDataPointRear(p.x, p.y);
				//////////////////////////////////////////////////////////////
				// One half
				int_i = x;
				int_j = y;
				while(1) {
					found = 0;
					/////////////////////////////////
					// find a connected black pixel in the 8-neighborhood
					for (i = -1; i <= 1; i++) {
						for (j = -1; j <= 1; j++) {
							xx = int_i + i;
							yy = int_j + j;
							if (xx < 0 || xx > IMAGE_X-1 || yy < 0 || yy > IMAGE_Y-1) continue;
							if (image[xx][yy] == 0 && visit[xx][yy] == 0) {
								found = 1;
								break; // found
							}
						}
						if (found) break;
					}
					///////////////////////////////
					if (!found) break; // dead end
					///////////////////////////////
					int_i = xx;
					int_j = yy;
					visit[int_i][int_j] = 1;
					///////////////////////////////////
					p.x = (double)int_i; 
					p.y = (double)int_j; 
					//dq->insert(dq->end(), p); // add data points at the end!
					s->AddDataPointRear(p.x, p.y); // add data points at the end!
					///////////////////////////////////
					//dc.LineTo(int_i, IMAGE_Y-1-int_j);
					////////////////////////////
				}
				////////////////////////////////////////
				// Other half
				int_i = x;
				int_j = y;
				while(1) {
					found = 0;
					for (i = -1; i <= 1; i++) {
						for (j = -1; j <= 1; j++) {
							xx = int_i + i;
							yy = int_j + j;
							if (xx < 0 || xx > IMAGE_X-1 || yy < 0 || yy > IMAGE_Y-1) continue;
							if (image[xx][yy] == 0 && visit[xx][yy] == 0) {
								found = 1;
								break; // found
							}
						}
						if (found) break;
					}
					if (!found) break; // dead end
					///////////////////////////////
					int_i = xx;
					int_j = yy;
					visit[int_i][int_j] = 1;
					///////////////////////////////////
					p.x = (double)int_i; 
					p.y = (double)int_j; 
					//dq->insert(dq->begin(), p); // add data points at the head!
					s->AddDataPointHead(p.x, p.y); // add data points at the head!
					///////////////////////////////////
					//dc.LineTo(int_i, IMAGE_Y-1-int_j);
					////////////////////////////
				}
				//dc.SelectObject(pOldPen);
				//pen.DeleteObject(); 
				//////////////////////////////////
				// if this curve is too short, then it's a noise (so removed!)
				if (s->pnts.size() <= 5) 
					bstrokes.RemoveRearNode();
				//////////////////////////////////
			}
			/// Set Pixel in MemDC
			//dc.SetPixelV(x, (IMAGE_Y-1)-y, RGB(r, r, r));
		}
	}
}

void StoreEdgeStrokes4(int image_x, int image_y, imatrix& image, MyList<MRBspline>& bstrokes,
					   int thres) 
// store each stroke to the list of Bspline strokes
// Here we try to maintain the direction of the curve
// And when the next pixel requires strict left-turn or right-turn, then we stop!
{
	int x, y;
	//double d_i, d_j, tx, ty, nx, ny;
	//int	st_x, st_y, end_x, end_y;
	int int_i, int_j;
	imatrix visit;
	int i, j, xx, yy, found;
	double2D p;
	//PntsDeque* dq;
	//deque<double2D>* dq;
	vector v(2), w(2);
	double angle;

	//SimpleListNode<MRBspline>* s;
	MRBspline* s; // 
	
	visit.init(image_x, image_y);
	visit.zero();
	//ClearMemDC(&dc); // clear the canvas white

	MyListNode<MRBspline>* node; // make this curve point to the node in the list
	//gx = G_x[i][j];
	//gy = G_y[i][j];
	//g = G_mag[i][j];
	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			//COLORREF rgbcol = memDC.GetPixel(x, (IMAGE_Y-1)-y);
			if (image[x][y] == 0 && visit[x][y] == 0) { // black pixel, but not visited
				visit[x][y] = 1; // now visited
				s = new MRBspline;
				////////////////////////////////////////////////////////
				node = bstrokes.AddRear(s); // Add this new B-spline stroke
				s->node = node;
				///////////////////////////////////////////////////////
				p.x = (double)x; 
				p.y = (double)y; 
				s->AddDataPointRear(p.x, p.y);
				//////////////////////////////////////////////////////////////
				// One half
				int_i = x;
				int_j = y;
				v.zero();
				while(1) {
					found = 0;
					/////////////////////////////////
					// find a connected black pixel in the 8-neighborhood
					for (i = -1; i <= 1; i++) {
						for (j = -1; j <= 1; j++) {
							xx = int_i + i;
							yy = int_j + j;
							if (xx < 0 || xx > IMAGE_X-1 || yy < 0 || yy > IMAGE_Y-1) continue;
							if (image[xx][yy] == 0 && visit[xx][yy] == 0) {
								w[0] = (double)xx-int_i;
								w[1] = (double)yy-int_j;
								w.make_unit();
								if (v[0] == 0 && v[1] == 0) { // no previous segment
									found = 1;
									break; // found
								}
								else { // now we have at least one previous segment to compare
									angle = v * w;
									//TRACE("angle = %.1f\n", angle);
									if (angle < 1/sqrt(2.0)) // too big turn. not qualified
									//if (angle < sqrt(3.0)/2) // too big turn. not qualified
									//if (angle < 1/2.0) // too big turn. not qualified
										continue; // continue search in the neighborhood
									else found = 1;
									break; // found. stop the search!
								}
							}
						}
						if (found) break;
					}
					///////////////////////////////
					if (!found) break; // dead end
					///////////////////////////////
					int_i = xx;
					int_j = yy;
					visit[int_i][int_j] = 1;
					v.copy(w);
					///////////////////////////////////
					p.x = (double)int_i; 
					p.y = (double)int_j; 
					//dq->insert(dq->end(), p); // add data points at the end!
					s->AddDataPointRear(p.x, p.y); // add data points at the end!

					///////////////////////////////////
					//dc.LineTo(int_i, IMAGE_Y-1-int_j);
					////////////////////////////
				}
				////////////////////////////////////////
				// Other half
				int_i = x;
				int_j = y;
				if (s->pnts.size() >= 2) { // we have at least one segment
					v[0] = s->pnts[0].x-s->pnts[1].x;
					v[1] = s->pnts[0].y-s->pnts[1].y;
				}
				else v.zero();
				while(1) {
					found = 0;
					for (i = -1; i <= 1; i++) {
						for (j = -1; j <= 1; j++) {
							xx = int_i + i;
							yy = int_j + j;
							if (xx < 0 || xx > IMAGE_X-1 || yy < 0 || yy > IMAGE_Y-1) continue;
							if (image[xx][yy] == 0 && visit[xx][yy] == 0) {
								w[0] = (double)xx-int_i;
								w[1] = (double)yy-int_j;
								w.make_unit();
								//////////////////////////////////////////////								
								if (v[0] == 0 && v[1] == 0) { // no previous segment
									found = 1;
									break; // found
								}
								else { // now we have at least one previous segment to compare
									angle = v * w;
									if (angle < 1/sqrt(2.0)) // too big turn. not qualified
									//if (angle < sqrt(3.0)/2) // too big turn. not qualified
									//if (angle < 1/2.0) // too big turn. not qualified
										continue; // continue search in the neighborhood
									else found = 1;
									break; // found. stop the search!
								}
							}
						}
						if (found) break;
					}
					/////////////////////////////////
					if (!found) break; // dead end
					///////////////////////////////
					int_i = xx;
					int_j = yy;
					visit[int_i][int_j] = 1;
					v.copy(w);
					///////////////////////////////////
					p.x = (double)int_i; 
					p.y = (double)int_j; 
					//dq->insert(dq->begin(), p); // add data points at the head!
					s->AddDataPointHead(p.x, p.y); // add data points at the head!
					///////////////////////////////////
					//dc.LineTo(int_i, IMAGE_Y-1-int_j);
					////////////////////////////
				}
				//dc.SelectObject(pOldPen);
				//pen.DeleteObject(); 
				//////////////////////////////////
				// if this curve is too short, then it's a noise (so removed!)
				if ((signed)s->pnts.size() <= thres) 
					bstrokes.RemoveRearNode();
				else { // get the head and tail vectors
					s->SetHeadTailDir();
				}
				//////////////////////////////////
			}
			/// Set Pixel in MemDC
			//dc.SetPixelV(x, (IMAGE_Y-1)-y, RGB(r, r, r));
		}
	}

	MRBspline* curve;

	MyListNode<MRBspline>* z = bstrokes.headNode;
	for (z = bstrokes.headNode; z; z = z->getNext()) {
		curve = z->get(); // get the stroke pointer
		curve->SetInterpCntPnts();
	}
}

qmatrix<MRBspline*> b_map; 

void ConstructBStrokesMap(MyList<MRBspline>& bstrokes, qmatrix<MRBspline*>& b_map)
// Also, we create a map of strokes, storing the pointers to strokes from each pixel
{
	int m, n;
	
	//GLubyte r, g, b;

	MRBspline* curve;

	int	x, y;

	int image_x = IMAGE_X;
	int image_y = IMAGE_Y;
	b_map.init(image_x, image_y);
	b_map.clear(); // init all the deques

	/*
	for (i = 0; i < image_x; i++)
		for (j = 0; j < image_y; j++) {
			TRACE("b_map[%d][%d].size() = %d\n", i, j, b_map[i][j].size());
		}
	*/
	
	for (m = 0; m < bstrokes.Size(); m++) {
		curve = bstrokes[m]; // get the stroke pointer
		for (n = 0; n < (signed)curve->pnts.size(); n++) {
			//p.x = dq->operator[](n).x;
			x = round(curve->pnts[n].x);
			y = round(curve->pnts[n].y);
			b_map[x][y].push_back(curve); // put it at the back of deque! (cf. insert)
			//if (b_map[x][y].size() > 1) // can never be bigger than 1
			//	TRACE("B_MAP: b_map[%d][%d].size() = %d\n", x, y, b_map[x][y].size());
			if (n == 0)
				TRACE("[curve %d:start] [%d, %d]\n", m, x, y);
			if (n == curve->pnts.size()-1)
				TRACE("[curve %d:end  ] [%d, %d]\n", m, x, y);
		}
		
	}
}

void ConstructBStrokesMap2(MyList<MRBspline>& bstrokes, qmatrix<MRBspline*>& b_map)
// we create a map of strokes, storing the pointers to strokes from each pixel
// Here we use sample points not original data points!
{
	int m, n;
	
	//GLubyte r, g, b;

	MRBspline* curve;

	int	x, y;

	int image_x = IMAGE_X;
	int image_y = IMAGE_Y;
	b_map.init(image_x, image_y);
	b_map.clear(); // init all the deques

	/*
	for (i = 0; i < image_x; i++)
		for (j = 0; j < image_y; j++) {
			TRACE("b_map[%d][%d].size() = %d\n", i, j, b_map[i][j].size());
		}
	*/
	
	for (m = 0; m < bstrokes.Size(); m++) {
		curve = bstrokes[m]; // get the stroke pointer
		for (n = 0; n < (signed)curve->pnts.size(); n++) {
			//p.x = dq->operator[](n).x;
			x = round(curve->pnts[n].x);
			y = round(curve->pnts[n].y);
			b_map[x][y].push_back(curve); // put it at the back of deque! (cf. insert)
		}
		
	}
}

void ConstructBStrokesMap3(MyList<MRBspline>& bstrokes, qmatrix<MRBspline*>& b_map)
// we create a map of strokes, storing the pointers to strokes from each pixel
// Here we only store the ENDPOINTS!
{
	//GLubyte r, g, b;

	MRBspline* curve;

	int	x, y;

	int image_x = IMAGE_X;
	int image_y = IMAGE_Y;
	b_map.init(image_x, image_y);
	b_map.clear(); // init all the deques

	MyListNode<MRBspline>* s = bstrokes.headNode;
	for (s = bstrokes.headNode; s; s = s->getNext()) {
		curve = s->get(); // get the stroke pointer
		////////////////////////
        x = round(curve->pnts[0].x);
		y = round(curve->pnts[0].y);
		b_map[x][y].push_back(curve); // put it at the back of deque! (cf. insert)
		//if (x == 196 && y == 370)
		//TRACE("HEAD: b_map[%d][%d].size() = %d\n", x, y, b_map[x][y].size());
		////////////////////////
        x = round(curve->pnts[curve->pnts.size()-1].x);
		y = round(curve->pnts[curve->pnts.size()-1].y);
		b_map[x][y].push_back(curve); // put it at the back of deque! (cf. insert)
		//TRACE("TAIL: b_map[%d][%d].size() = %d\n", x, y, b_map[x][y].size());
	}
	//TRACE("FINAL: b_map[196][370].size() = %d\n", b_map[196][370].size());
}

void MergeStrokes(MRBspline* c1, int join1, MRBspline* c2, int join2, MyList<MRBspline>& bstrokes, 
				  qmatrix<MRBspline*>& b_map) 
// merge two strokes whose endpoints meet
{
	int i, j, x, y;
	deque<double2D> pnts;
	//deque<MRBspline*>::iterator it;

	//////////////////////////
	// convert the trace of c2 into c1 in b_map
	for (i = 0; i < (signed)c2->pnts.size(); i++) {
		x = round(c2->pnts[i].x);
		y = round(c2->pnts[i].y);
		for (j = 0; j < (signed)b_map[x][y].size(); j++) {
			if (b_map[x][y][j] == c2) {
				//it = &b_map[x][y][j];
				//b_map[x][y].erase(it);
				b_map[x][y][j] = c1;
			}
		}
	}
	////////////////////////////////////

	////////////////////////
	// copy c1->pnts to pnts
	for (i = 0; i < (signed)c1->pnts.size(); i++) {
		pnts.push_back(c1->pnts[i]);
	}

	////////////////////////////////////////////
	if (join1 == HEAD && join2 == HEAD) {
		for (i = 0; i < (signed)c2->pnts.size(); i++) {
			pnts.push_front(c2->pnts[i]);
		}
	}
	else if (join1 == HEAD && join2 == TAIL) {
		for (i = c2->pnts.size()-1; i >= 0; i--) {
			pnts.push_front(c2->pnts[i]);
		}
	}
	else if (join1 == TAIL && join2 == HEAD) {
		for (i = 0; i < (signed)c2->pnts.size(); i++) {
			pnts.push_back(c2->pnts[i]);
		}
	}
	else if (join1 == TAIL && join2 == TAIL) {
		for (i = c2->pnts.size()-1; i >= 0; i--) {
			pnts.push_back(c2->pnts[i]);
		}
	}
	
	///////////////////////////////////
	// remove c2 from MyList
	//if (c1 == c2) TRACE("c1 and c2 are IDENTICAL!\n");
	/*
	for (int m = 0; m < bstrokes.Size(); m++) {
		if (bstrokes[m] == c1) {
			TRACE("c1 is %d th curve\n", m);
		}
		if (bstrokes[m] == c2) {
			TRACE("c2 is %d th curve\n", m);
		}
	}
	*/
	//TRACE("[%d]-[%d]: c1->pnts[0].x = %f, c2->pnts[0].x = %f\n", 
	//	join1, join2, c1->pnts[0].x, c2->pnts[0].x);
	//////////////////////////////////
	// This causes problem. But if you remove ~MyList() then it's okay
	// in fact, you can't call "delete c2". I don't know why
	bstrokes.Remove(c2->node); 
	//////////////////////////////////
	TRACE("bstrokes Remove SUCCESS!\n");
	/////////////////////////////////
	c1->SetDataPnts(pnts);
	//c1->SetSamplePnts(pnts);
	//c1->SetCntPnts(pnts);
	c1->SetInterpCntPnts();
	//curve->DrawInterpCurve(&dc, r, g, b);
}

void CleanUpBStrokes(MyList<MRBspline>& bstrokes, qmatrix<MRBspline*>& b_map)
// Merge connected (or attached) strokes aligned in the same direction
// Remove all redundant strokes
{
	//PntsDeque* dq;
	//deque<double2D>* dq;
	deque<double2D> pnts;
	//vector knot;

	MRBspline *c1, *c2;

	int	x, y, s, t, xx, yy;

	bool merged = false;
	bool remain = true; // still something to merge

	MyListNode<MRBspline> *node;
	
	//for (m = 0; m < bstrokes.Size(); m++) {
	while (remain) {
		remain = false; // assume there's nothing to merge any more
		for (node = bstrokes.headNode; node; node=node->nextNode) {
			/////////////////////////////////
			c1 = node->obj_ptr;
			//c1 = bstrokes[m]; // get the stroke pointer
			/////////////////////////////////////
			// check the head of c1
			x = round(c1->pnts[0].x);
			y = round(c1->pnts[0].y);
			//TRACE("c1->pnts[0]: x = %d, y = %d\n", x, y);
			merged = false;
			for (s = -1; s <= 1; s++) {
				for (t = -1; t <= 1; t++) {
					xx = x + s;
					yy = y + t;
					if (xx < 0 || xx > IMAGE_X-1 || yy < 0 || yy > IMAGE_Y-1) continue;
					if (b_map[xx][yy].size() == 0) continue; // no curve pixel here
					//TRACE("b_map[%d][%d].size() = %d\n", xx, yy, b_map[xx][yy].size());
					//////////////////////////////////////
					// now there's something in this pixel
					c2 = b_map[xx][yy][0]; // first element 
					
					if (c1 == c2) continue; // can't merge with itself
					
					if (xx == round(c2->pnts[0].x) && yy == round(c2->pnts[0].y)) {
						MergeStrokes(c1, HEAD, c2, HEAD, bstrokes, b_map); 
						merged = true;
						remain = true; // at least one more round is required
					}
					else if (xx == round(c2->pnts[c2->pnts.size()-1].x) 
						&& yy == round(c2->pnts[c2->pnts.size()-1].y)) {
						MergeStrokes(c1, HEAD, c2, TAIL, bstrokes, b_map); 
						merged = true;
						remain = true; // at least one more round is required
					}
					if (merged) break;
				} // for t
				if (merged) break;
			} // for s
			/////////////////////////////////////////////
			// check the tail of c1
			///*
			x = round(c1->pnts[c1->pnts.size()-1].x);
			y = round(c1->pnts[c1->pnts.size()-1].y);
			merged = false;
			for (s = -1; s <= 1; s++) {
				for (t = -1; t <= 1; t++) {
					xx = x + s;
					yy = y + t;
					if (xx < 0 || xx > IMAGE_X-1 || yy < 0 || yy > IMAGE_Y-1) continue;
					if (b_map[xx][yy].size() == 0) continue; // no curve pixel here
					//////////////////////////////////////
					// now there's something in this pixel
					c2 = b_map[xx][yy][0]; // first element 
					if (c1 == c2) continue; // can't merge with itself
					if (xx == round(c2->pnts[0].x) && yy == round(c2->pnts[0].y)) {
						MergeStrokes(c1, TAIL, c2, HEAD, bstrokes, b_map); 
						merged = true;
						remain = true; // at least one more round is required
					}
					else if (xx == round(c2->pnts[c2->pnts.size()-1].x) 
						&& yy == round(c2->pnts[c2->pnts.size()-1].y)) {
						MergeStrokes(c1, TAIL, c2, TAIL, bstrokes, b_map); 
						merged = true;
						remain = true; // at least one more round is required
					}
					if (merged) break;
				} // for t
				if (merged) break;
			} // for s
			//*/
		} // for (node = bstrokes->headNode)
	} // while (remain)
}

double GetMergeEnergy(MRBspline* c1, int join1, MRBspline* c2, int join2, MyList<MRBspline>& bstrokes, 
				  qmatrix<MRBspline*>& b_map, double sigma, vector& GAU) 
// Get merge energy by connecting two curves
{
	int i, x;
	deque<double2D> pnts;
	//deque<MRBspline*>::iterator it;
	
	////////////////////////////////////
	// determint join2
	/*
	d1 = (join1 == HEAD) ? dist2(pnts[0].x, pnts[0].y, c2->pnts[0].x, c2->pnts[0].y) :
		dist2(pnts[pnts.size()-1].x, pnts[pnts.size()-1].y, c2->pnts[0].x, c2->pnts[0].y); 
	d2 = (join1 == HEAD) ? dist2(pnts[0].x, pnts[0].y, c2->pnts[c2->pnts.size()-1].x, c2->pnts[c2->pnts.size()-1].y) :
		dist2(pnts[pnts.size()-1].x, pnts[pnts.size()-1].y, c2->pnts[c2->pnts.size()-1].x, c2->pnts[c2->pnts.size()-1].y); 
	join2 = (d1 <= d2) ? HEAD : TAIL;
	*/
	
	////////////////////////
	// copy c1->pnts to pnts
	for (i = 0; i < (signed)c1->pnts.size(); i++) {
		pnts.push_back(c1->pnts[i]);
	}

	int merge_index;
	double distance;
	
	////////////////////////////////////////////
	if (join1 == HEAD && join2 == HEAD) {
		for (i = 0; i < (signed)c2->pnts.size(); i++) {
			pnts.push_front(c2->pnts[i]);
		}
		merge_index = c2->pnts.size()-1;
		distance = dist2(c1->pnts[0].x, c1->pnts[0].y, c2->pnts[0].x, c2->pnts[0].y);
	}
	else if (join1 == HEAD && join2 == TAIL) {
		for (i = c2->pnts.size()-1; i >= 0; i--) {
			pnts.push_front(c2->pnts[i]);
		}
		merge_index = c2->pnts.size()-1;
		distance = dist2(c1->pnts[0].x, c1->pnts[0].y, 
			c2->pnts[c2->pnts.size()-1].x, c2->pnts[c2->pnts.size()-1].y);
	}
	else if (join1 == TAIL && join2 == HEAD) {
		for (i = 0; i < (signed)c2->pnts.size(); i++) {
			pnts.push_back(c2->pnts[i]);
		}
		merge_index = c1->pnts.size()-1;
		distance = dist2(c1->pnts[c1->pnts.size()-1].x, c1->pnts[c1->pnts.size()-1].y, 
			c2->pnts[0].x, c2->pnts[0].y);
	}
	else if (join1 == TAIL && join2 == TAIL) {
		for (i = c2->pnts.size()-1; i >= 0; i--) {
			pnts.push_back(c2->pnts[i]);
		}
		merge_index = c1->pnts.size()-1;
		distance = dist2(c1->pnts[c1->pnts.size()-1].x, c1->pnts[c1->pnts.size()-1].y, 
			c2->pnts[c2->pnts.size()-1].x, c2->pnts[c2->pnts.size()-1].y);
	}

	vector v(2);
	vector w(2);
	double angle;
	deque<double2D> tan(pnts.size());
	deque<double2D> tan2(pnts.size()); // tangent vectors

	int half = GAU.getMax()-1;

	TRACE("half = %d\n", half);
	TRACE("merge_index = %d\n", merge_index);
	TRACE("tan.size() = %d\n", tan.size());
	///////////////////////////////
	// init tangents
	v[0] = pnts[1].x - pnts[0].x;
	v[1] = pnts[1].y - pnts[0].y;
	v.make_unit();
	tan[0].x = v[0];
	tan[0].y = v[1]; 
	for (i = 1; i < (signed)pnts.size()-1; i++) {
		v[0] = pnts[i+1].x - pnts[i-1].x;
		v[1] = pnts[i+1].y - pnts[i-1].y;
		v.make_unit();
		//pnts.push_back(p);
		tan[i].x = v[0];
		tan[i].y = v[1]; 
		//TRACE("tan[%d].x = %f\n", i, tan[i].x);
	}
	v[0] = pnts[i].x - pnts[i-1].x;
	v[1] = pnts[i].y - pnts[i-1].y;
	v.make_unit();
	tan[i].x = v[0];
	tan[i].y = v[1]; 

	//deque<MRBspline*>::iterator it;

	

	//step_size = 1.0;
	bool remain = true; // still there's some points to move!

	double w_sum;
	int s, k;

	///////////////////////////////////////////
	// Gaussian smooth the tangents
	for (i = 0; i < (signed)tan.size(); i++) { 
		v[0] = v[1] = 0.0;
		w_sum = 0.0;
		for (s = -half; s <= half; s++) {
			x = i+s; 
			if (x < 0 || x > (signed)tan.size()-1) continue; // out of range
			/////////////////////////////////////////////////////
			k = ABS(s); // gaussian parameter
			////////////////////////////////////////////
			v[0] += tan[x].x * GAU[k];
			v[1] += tan[x].y * GAU[k];
			w_sum += GAU[k];
		}
		v[0] /= w_sum; 
		v[1] /= w_sum; 
		tan2[i].x = v[0];
		tan2[i].y = v[1];
		//v.print();
		//TRACE("tan2[%d].x = %f\n", i, tan2[i].x);
		///////////////////////////////
	}

	//double max_angle = -1.0;
	//int max_index = -1;

	//angle_thres = angle_thres * PI / 180.0; // convert to radian angle

	v[0] = tan2[merge_index-1].x;
	v[1] = tan2[merge_index-1].y;
	v.make_unit();
	w[0] = tan2[merge_index+1].x;
	w[1] = tan2[merge_index+1].y;
	w.make_unit();
	//v.print();
	//w.print();
	angle = v*w;
	if (angle > 1.0) angle = 1.0;
	if (angle < -1.0) angle = -1.0;
	angle = acos(angle); // acos: ranges from 0 to PI
	//TRACE("angle = %f\n", angle);
	//if (angle > max_angle) {
	//	max_angle = angle;
	//	max_index = i;
	//}
	double merge_e;
	
	merge_e = angle * distance;

	return (merge_e);
	///////////////////////////////
}

double GetMergeEnergy2(MRBspline* c1, int join1, MRBspline* c2, int join2, MyList<MRBspline>& bstrokes, 
				  double sigma, vector& GAU) 
// Get merge energy with ignoring the connecting angle
// and only compute around the merging point
{
	int i, j, x;
	deque<double2D> pnts;
	//deque<MRBspline*>::iterator it;
	
	////////////////////////////////////
	// determint join2
	/*
	d1 = (join1 == HEAD) ? dist2(pnts[0].x, pnts[0].y, c2->pnts[0].x, c2->pnts[0].y) :
		dist2(pnts[pnts.size()-1].x, pnts[pnts.size()-1].y, c2->pnts[0].x, c2->pnts[0].y); 
	d2 = (join1 == HEAD) ? dist2(pnts[0].x, pnts[0].y, c2->pnts[c2->pnts.size()-1].x, c2->pnts[c2->pnts.size()-1].y) :
		dist2(pnts[pnts.size()-1].x, pnts[pnts.size()-1].y, c2->pnts[c2->pnts.size()-1].x, c2->pnts[c2->pnts.size()-1].y); 
	join2 = (d1 <= d2) ? HEAD : TAIL;
	*/
	int merge_index;
	double distance;

	int half = GAU.getMax()-1; // examine only in the range of Gaussian
	
	////////////////////////
	// copy c1->pnts to pnts (up to half)
	for (i = 0; i < (signed)c1->pnts.size(); i++) {
		pnts.push_back(c1->pnts[i]);
		if (i == half) break;
	}
	
	////////////////////////////////////////////
	if (join1 == HEAD && join2 == HEAD) {
		for (i = 0; i < (signed)c2->pnts.size(); i++) {
			pnts.push_front(c2->pnts[i]);
			if (i == half) break;
		}
		merge_index = (half < (signed)c2->pnts.size()-1) ? half : c2->pnts.size()-1;
		distance = dist2(c1->pnts[0].x, c1->pnts[0].y, c2->pnts[0].x, c2->pnts[0].y);
	}
	else if (join1 == HEAD && join2 == TAIL) {
		for (i = c2->pnts.size()-1, j = 0; i >= 0; i--, j++) {
			pnts.push_front(c2->pnts[i]);
			if (j == half) break;
		}
		merge_index = (half < (signed)c2->pnts.size()-1) ? half : c2->pnts.size()-1;
		distance = dist2(c1->pnts[0].x, c1->pnts[0].y, 
			c2->pnts[c2->pnts.size()-1].x, c2->pnts[c2->pnts.size()-1].y);
	}
	else if (join1 == TAIL && join2 == HEAD) {
		for (i = 0; i < (signed)c2->pnts.size(); i++) {
			pnts.push_back(c2->pnts[i]);
			if (i == half) break;
		}
		merge_index = (half < (signed)c1->pnts.size()-1) ? half : (signed)c1->pnts.size()-1;
		distance = dist2(c1->pnts[c1->pnts.size()-1].x, c1->pnts[c1->pnts.size()-1].y, 
			c2->pnts[0].x, c2->pnts[0].y);
	}
	else if (join1 == TAIL && join2 == TAIL) {
		for (i = c2->pnts.size()-1, j = 0; i >= 0; i--, j++) {
			pnts.push_back(c2->pnts[i]);
			if (j == half) break;
		}
		merge_index = (half < (signed)c1->pnts.size()-1) ? half : (signed)c1->pnts.size()-1;
		distance = dist2(c1->pnts[c1->pnts.size()-1].x, c1->pnts[c1->pnts.size()-1].y, 
			c2->pnts[c2->pnts.size()-1].x, c2->pnts[c2->pnts.size()-1].y);
	}

	vector v(2);
	vector w(2);
	double angle;
	deque<double2D> tan(pnts.size());
	deque<double2D> tan2(pnts.size()); // tangent vectors

	//TRACE("c1->pnts.size() = %d\n", c1->pnts.size());
	//TRACE("c2->pnts.size() = %d\n", c2->pnts.size());
	//TRACE("half = %d\n", half);
	//TRACE("merge_index = %d\n", merge_index);
	//TRACE("tan.size() = %d\n", tan.size());
	///////////////////////////////
	// init tangents
	v[0] = pnts[1].x - pnts[0].x;
	v[1] = pnts[1].y - pnts[0].y;
	v.make_unit();
	tan[0].x = v[0];
	tan[0].y = v[1]; 
	//merge_index
	for (i = 1; i < merge_index; i++) {
		v[0] = pnts[i+1].x - pnts[i-1].x;
		v[1] = pnts[i+1].y - pnts[i-1].y;
		v.make_unit();
		//pnts.push_back(p);
		tan[i].x = v[0];
		tan[i].y = v[1]; 
		//TRACE("tan[%d].x = %f\n", i, tan[i].x);
	}
	// Ignore the connecting segment!
	v[0] = pnts[merge_index].x - pnts[merge_index-1].x;
	v[1] = pnts[merge_index].y - pnts[merge_index-1].y;
	v.make_unit();
	tan[merge_index].x = v[0];
	tan[merge_index].y = v[1]; 
	v[0] = pnts[merge_index+2].x - pnts[merge_index+1].x;
	v[1] = pnts[merge_index+2].y - pnts[merge_index+1].y;
	v.make_unit();
	tan[merge_index+1].x = v[0];
	tan[merge_index+1].y = v[1]; 
	for (i = merge_index+2; i < (signed)pnts.size()-1; i++) {
		v[0] = pnts[i+1].x - pnts[i-1].x;
		v[1] = pnts[i+1].y - pnts[i-1].y;
		v.make_unit();
		//pnts.push_back(p);
		tan[i].x = v[0];
		tan[i].y = v[1]; 
		//TRACE("tan[%d].x = %f\n", i, tan[i].x);
	}
	v[0] = pnts[i].x - pnts[i-1].x;
	v[1] = pnts[i].y - pnts[i-1].y;
	v.make_unit();
	tan[i].x = v[0];
	tan[i].y = v[1]; 

	//deque<MRBspline*>::iterator it;

	//step_size = 1.0;
	bool remain = true; // still there's some points to move!

	double w_sum;
	int s, k;

	///////////////////////////////////////////
	// Gaussian smooth the tangents
	for (i = 0; i < (signed)tan.size(); i++) { 
		v[0] = v[1] = 0.0;
		w_sum = 0.0;
		for (s = -half; s <= half; s++) {
			x = i+s; 
			if (x < 0 || x > (signed)tan.size()-1) continue; // out of range
			/////////////////////////////////////////////////////
			k = ABS(s); // gaussian parameter
			////////////////////////////////////////////
			v[0] += tan[x].x * GAU[k];
			v[1] += tan[x].y * GAU[k];
			w_sum += GAU[k];
		}
		v[0] /= w_sum; 
		v[1] /= w_sum; 
		tan2[i].x = v[0];
		tan2[i].y = v[1];
		//v.print();
		//TRACE("tan2[%d].x = %f\n", i, tan2[i].x);
		///////////////////////////////
	}

	//double max_angle = -1.0;
	//int max_index = -1;

	//angle_thres = angle_thres * PI / 180.0; // convert to radian angle

	v[0] = tan2[merge_index-1].x;
	v[1] = tan2[merge_index-1].y;
	v.make_unit();
	w[0] = tan2[merge_index+1].x;
	w[1] = tan2[merge_index+1].y;
	w.make_unit();
	//v.print();
	//w.print();
	angle = v*w;
	if (angle > 1.0) angle = 1.0;
	if (angle < -1.0) angle = -1.0;
	angle = acos(angle); // acos: ranges from 0 to PI
	//TRACE("angle = %f\n", angle);
	//if (angle > max_angle) {
	//	max_angle = angle;
	//	max_index = i;
	//}
	double merge_e;
	
	merge_e = angle * distance;

	return (merge_e);
	///////////////////////////////
}

double GetMergeEnergy3(CDC& dc2, MRBspline* c1, int join1, MRBspline* c2, int join2, MyList<MRBspline>& bstrokes)
// Get merge energy with ignoring the connecting angle
// and without using Gaussian
{
	deque<double2D> pnts;
	//deque<MRBspline*>::iterator it;
	//int merge_index;
	//double distance;
	
	vector v(2);
	vector w(2);
	double angle;
	double merge_e;

	///////////////////////////////////////////////////////
	// Check if the connecting line touches other line! (disallowed)
	/*
	double x1, y1, x2, y2, slope, x, y;
	GLubyte r;
	int	xi, yi;

	x1 = join1 == HEAD ? (double)c1->pnts[0].x : (double)c1->pnts[c1->pnts.size()-1].x;
	y1 = join1 == HEAD ? (double)c1->pnts[0].y : (double)c1->pnts[c1->pnts.size()-1].y;
	x2 = join2 == HEAD ? (double)c2->pnts[0].x : (double)c2->pnts[c2->pnts.size()-1].x;
	y2 = join2 == HEAD ? (double)c2->pnts[0].y : (double)c2->pnts[c2->pnts.size()-1].y;

	if (x1 != x2) slope = (y2 - y1) / (x2 - x1);
	x = x1; y = y1;
	while(1) {
		if (x2 == x1 && y1 == y2) break; // identical point 
		if (x2 == x1) { // vertical line
			if (y2 > y1) y++;
			else y--;
			if (y == y2) break;
			xi = round(x);	yi = round(y);
			r = (GLubyte)RGB_GETRED(dc2.GetPixel(xi, IMAGE_Y-1-yi));
			if (r == 0) return 10000; // touches other line! merge disallowed!
		}
		else if ( ABS(slope) >= 1.0 ) {
			if (y2 > y1) { y++;	x += 1/slope; }
			else { y--;	x -= 1/slope; }
			if (y == y2) break;
			xi = round(x);	yi = round(y);
			r = (GLubyte)RGB_GETRED(dc2.GetPixel(xi, IMAGE_Y-1-yi));
			if (r == 0) return 10000; // touches other line! merge disallowed!
		}
		else if ( ABS(slope) < 1.0 ) {
			if (x2 > x1) { x++;	y += slope; }
			else { x--;	y -= slope; }
			if (x == x2) break;
			xi = round(x);	yi = round(y);
			r = (GLubyte)RGB_GETRED(dc2.GetPixel(xi, IMAGE_Y-1-yi));
			if (r == 0) return 10000; // touches other line! merge disallowed!
		}
	}
	*/
	/////////////////////////////////////////////////////////
	
	v[0] = join1 == HEAD ? c1->h[0] : c1->t[0];
	v[1] = join1 == HEAD ? c1->h[1] : c1->t[1];
	//v.make_unit();
	w[0] = join2 == HEAD ? -c2->h[0] : -c2->t[0]; // must be inversed
	w[1] = join2 == HEAD ? -c2->h[1] : -c2->t[1];
	//w.make_unit();
	//v.print();
	//w.print();
	angle = v * w;
	if (angle > 1.0) angle = 1.0;
	if (angle < -1.0) angle = -1.0;
	angle = acos(angle) * 180 / PI; // acos: ranges from 0 to 180
	//TRACE("angle = %f\n", angle);
	//if (angle > max_angle) {
	//	max_angle = angle;
	//	max_index = i;
	//}

	
	merge_e = angle;
	
	//merge_e = angle * distance;

	return (merge_e);
	///////////////////////////////
}

void MergeBStrokes(MRBspline* c1, int join1, MRBspline* c2, int join2, MyList<MRBspline>& bstrokes, 
				  qmatrix<MRBspline*>& b_map) 
// merge two strokes whose endpoints meet
{
	int i, x, y;
	deque<double2D> pnts;
	//deque<MRBspline*>::iterator it;

	////////////////////////////////////
	// determint join2
	/*
	d1 = (join1 == HEAD) ? dist2(c1->pnts[0].x, c1->pnts[0].y, c2->pnts[0].x, c2->pnts[0].y) :
		dist2(c1->pnts[c1->pnts.size()-1].x, c1->pnts[c1->pnts.size()-1].y, c2->pnts[0].x, c2->pnts[0].y); 
	d2 = (join1 == HEAD) ? dist2(c1->pnts[0].x, c1->pnts[0].y, c2->pnts[c2->pnts.size()-1].x, c2->pnts[c2->pnts.size()-1].y) :
		dist2(c1->pnts[c1->pnts.size()-1].x, c1->pnts[c1->pnts.size()-1].y, c2->pnts[c2->pnts.size()-1].x, c2->pnts[c2->pnts.size()-1].y); 
	join2 = (d1 <= d2) ? HEAD : TAIL;
	*/
	
	////////////////////////
	// copy c1->pnts to pnts
	for (i = 0; i < (signed)c1->pnts.size(); i++) {
		pnts.push_back(c1->pnts[i]);
	}
	
	////////////////////////////////////////////
	if (join1 == HEAD && join2 == HEAD) {
		for (i = 0; i < (signed)c2->pnts.size(); i++) {
			pnts.push_front(c2->pnts[i]);
		}
		////////////////////
		x = round(c1->pnts[0].x);
		y = round(c1->pnts[0].y);
		b_map.remove(x, y, c1);
		////////////////////
		x = round(c2->pnts[0].x);
		y = round(c2->pnts[0].y);
		b_map.remove(x, y, c2);
		/////////////////////////
		x = round(c2->pnts[c2->pnts.size()-1].x);
		y = round(c2->pnts[c2->pnts.size()-1].y);
		b_map.remove(x, y, c2);
		b_map[x][y].push_back(c1);
	}
	else if (join1 == HEAD && join2 == TAIL) {
		for (i = c2->pnts.size()-1; i >= 0; i--) {
			pnts.push_front(c2->pnts[i]);
		}
		////////////////////
		x = round(c1->pnts[0].x);
		y = round(c1->pnts[0].y);
		b_map.remove(x, y, c1);
		////////////////////
		x = round(c2->pnts[c2->pnts.size()-1].x);
		y = round(c2->pnts[c2->pnts.size()-1].y);
		b_map.remove(x, y, c2);
		/////////////////////////
		x = round(c2->pnts[0].x);
		y = round(c2->pnts[0].y);
		b_map.remove(x, y, c2);
		b_map[x][y].push_back(c1);
	}
	else if (join1 == TAIL && join2 == HEAD) {
		for (i = 0; i < (signed)c2->pnts.size(); i++) {
			pnts.push_back(c2->pnts[i]);
		}
		////////////////////
		x = round(c1->pnts[c1->pnts.size()-1].x);
		y = round(c1->pnts[c1->pnts.size()-1].y);
		b_map.remove(x, y, c1);
		////////////////////
		x = round(c2->pnts[0].x);
		y = round(c2->pnts[0].y);
		b_map.remove(x, y, c2);
		/////////////////////////
		x = round(c2->pnts[c2->pnts.size()-1].x);
		y = round(c2->pnts[c2->pnts.size()-1].y);
		b_map.remove(x, y, c2);
		b_map[x][y].push_back(c1);
	}
	else if (join1 == TAIL && join2 == TAIL) {
		for (i = c2->pnts.size()-1; i >= 0; i--) {
			pnts.push_back(c2->pnts[i]);
		}
		////////////////////
		x = round(c1->pnts[c1->pnts.size()-1].x);
		y = round(c1->pnts[c1->pnts.size()-1].y);
		b_map.remove(x, y, c1);
		////////////////////
		x = round(c2->pnts[c2->pnts.size()-1].x);
		y = round(c2->pnts[c2->pnts.size()-1].y);
		b_map.remove(x, y, c2);
		/////////////////////////
		x = round(c2->pnts[0].x);
		y = round(c2->pnts[0].y);
		b_map.remove(x, y, c2);
		b_map[x][y].push_back(c1);
	}
	
	///////////////////////////////////
	// remove c2 from MyList
	//TRACE("c2->pnts[0].x = %f\n", c2->pnts[0].x);
	bstrokes.Remove(c2->node); 
	//TRACE("bstroke Remove success!\n");
	/////////////////////////////////
	c1->SetDataPnts(pnts);
	//c1->SetSamplePnts(pnts);
	//c1->SetCntPnts(pnts);
	c1->SetInterpCntPnts();
	//curve->DrawInterpCurve(&dc, r, g, b);
}

void MergeBStrokes2(MRBspline* c1, int join1, MRBspline* c2, int join2, MyList<MRBspline>& bstrokes)
// merge two strokes whose endpoints meet
// And we don't use b_map here!
{
	int i;
	deque<double2D> pnts;
	//deque<MRBspline*>::iterator it;

	////////////////////////////////////
	////////////////////////
	// copy c1->pnts to pnts
	for (i = 0; i < (signed)c1->pnts.size(); i++) {
		pnts.push_back(c1->pnts[i]);
	}
	
	////////////////////////////////////////////
	if (join1 == HEAD && join2 == HEAD) {
		for (i = 0; i < (signed)c2->pnts.size(); i++) {
			pnts.push_front(c2->pnts[i]);
		}
	}
	else if (join1 == HEAD && join2 == TAIL) {
		for (i = c2->pnts.size()-1; i >= 0; i--) {
			pnts.push_front(c2->pnts[i]);
		}
	}
	else if (join1 == TAIL && join2 == HEAD) {
		for (i = 0; i < (signed)c2->pnts.size(); i++) {
			pnts.push_back(c2->pnts[i]);
		}
	}
	else if (join1 == TAIL && join2 == TAIL) {
		for (i = c2->pnts.size()-1; i >= 0; i--) {
			pnts.push_back(c2->pnts[i]);
		}
	}
	
	///////////////////////////////////
	// remove c2 from MyList
	//TRACE("c2->pnts[0].x = %f\n", c2->pnts[0].x);
	bstrokes.Remove(c2->node); 
	//TRACE("bstroke Remove success!\n");
	/////////////////////////////////
	c1->SetDataPnts(pnts);
	//c1->SetSamplePnts(pnts);
	//c1->SetCntPnts(pnts);
	c1->SetInterpCntPnts();
	//curve->DrawInterpCurve(&dc, r, g, b);
}

void MergeBStrokes3(MRBspline* c1, int join1, MRBspline* c2, int join2, MyList<MRBspline>& bstrokes)
// merge two strokes whose endpoints meet
// And we don't use b_map here!
// And we SIMPLIFY THE MERGED AREA!
{
	int i;
	deque<double2D> pnts;
	//deque<MRBspline*>::iterator it;

	////////////////////////////////////
	int merge_index;
	
	////////////////////////
	// copy c1->pnts to pnts
	for (i = 0; i < (signed)c1->pnts.size(); i++) {
		pnts.push_back(c1->pnts[i]);
	}
	
	////////////////////////////////////////////
	if (join1 == HEAD && join2 == HEAD) {
		for (i = 0; i < (signed)c2->pnts.size(); i++) {
			pnts.push_front(c2->pnts[i]);
		}
		merge_index = c2->pnts.size()-1;
	}
	else if (join1 == HEAD && join2 == TAIL) {
		for (i = c2->pnts.size()-1; i >= 0; i--) {
			pnts.push_front(c2->pnts[i]);
		}
		merge_index = c2->pnts.size()-1;
	}
	else if (join1 == TAIL && join2 == HEAD) {
		for (i = 0; i < (signed)c2->pnts.size(); i++) {
			pnts.push_back(c2->pnts[i]);
		}
		merge_index = c1->pnts.size()-1;
	}
	else if (join1 == TAIL && join2 == TAIL) {
		for (i = c2->pnts.size()-1; i >= 0; i--) {
			pnts.push_back(c2->pnts[i]);
		}
		merge_index = c1->pnts.size()-1;
	}
	
	///////////////////////////////////
	// remove c2 from MyList
	//TRACE("c2->pnts[0].x = %f\n", c2->pnts[0].x);
	bstrokes.Remove(c2->node); 
	//TRACE("bstroke Remove success!\n");
	
	////////////////////////////////////////////
	// Smooth the connecting area
	/*
	double remove_thres = 90; // if it is bigger than this, remove!
	double no_remove_thres = 90; // if the subsequent angle is bigger than this, can't!
	double angle;
	vector v(2), w(2), z(2);
	bool remain = true;
	///////////////////////////////
	while (remain) {
		remain = false;
		
		if (merge_index+1 < (signed)pnts.size()-1) {
			////////////////////////////
			v[0] = pnts[merge_index+1].x - pnts[merge_index].x;
			v[1] = pnts[merge_index+1].y - pnts[merge_index].y;
			v.make_unit();
			w[0] = pnts[merge_index+2].x - pnts[merge_index+1].x;
			w[1] = pnts[merge_index+2].y - pnts[merge_index+1].y;
			w.make_unit();
			angle = v*w;
			if (angle > 1.0) angle = 1.0;
			if (angle < -1.0) angle = -1.0;
			angle = acos(angle) * 180.0 / PI; // acos: ranges from 0 to 180
			if (merge_index+2 < (signed)pnts.size()-1) {
				z[0] = pnts[merge_index+3].x - pnts[merge_index+2].x;
				z[1] = pnts[merge_index+3].y - pnts[merge_index+2].y;
				z.make_unit();
			}
			else z.copy(w);
			//////////////////////////
			if ( angle > remove_thres ) { // the smaller the better
				////////////////////////////////////
				angle = w*z;
				if (angle > 1.0) angle = 1.0;
				if (angle < -1.0) angle = -1.0;
				angle = acos(angle)  * 180.0 / PI; // if the connected segment angle is too big, you can' remove!	
				//if (angle < no_remove_thres) { // now you can remove this point!
					pnts.erase(pnts.begin() + merge_index + 1); 
					remain = true;
				//}
			}
		}

		if (merge_index > 0) {
			////////////////////////////
			v[0] = pnts[merge_index+1].x - pnts[merge_index].x;
			v[1] = pnts[merge_index+1].y - pnts[merge_index].y;
			v.make_unit();
			w[0] = pnts[merge_index].x - pnts[merge_index-1].x;
			w[1] = pnts[merge_index].y - pnts[merge_index-1].y;
			w.make_unit();
			angle = v*w;
			if (angle > 1.0) angle = 1.0;
			if (angle < -1.0) angle = -1.0;
			angle = acos(angle)  * 180.0 / PI; // acos: ranges from 0 to PI
			if (merge_index > 1) {
				z[0] = pnts[merge_index-1].x - pnts[merge_index-2].x;
				z[1] = pnts[merge_index-1].y - pnts[merge_index-2].y;
				z.make_unit();
			}
			else z.copy(w);
			//////////////////////////
			if ( angle > remove_thres ) { // the smaller the better
				////////////////////////////////////
				angle = w*z;
				if (angle > 1.0) angle = 1.0;
				if (angle < -1.0) angle = -1.0;
				angle = acos(angle)  * 180.0 / PI; // if the connected segment angle is too big, you can' remove!
				//if (angle < no_remove_thres) { // now you can remove this point!
					pnts.erase(pnts.begin() + merge_index + 1); 
					merge_index--;
					remain = true;
				//}
			}
		}

	} // while (remain)
	*/

	/////////////////////////////////
	c1->SetDataPnts(pnts);
	//c1->SetSamplePnts(pnts);
	//c1->SetCntPnts(pnts);
	c1->SetInterpCntPnts();
	c1->SetHeadTailDir();
	//curve->DrawInterpCurve(&dc, r, g, b);
}

bool MergeBStrokes4(CDC& dc, MRBspline* c1, int join1, MRBspline* c2, int join2, MyList<MRBspline>& bstrokes)
// merge two strokes whose endpoints meet
// here we check if the connecting line touches any other curve (disallowed!)
// And we don't use b_map here!
// And we SIMPLIFY THE MERGED AREA!
{
	///////////////////////////////////////////////////////
	// Check if the connecting line touches other line! (disallowed)
	///*
	double x1, y1, x2, y2;
	GLubyte r;
	int	xi, yi;
	double step_size, dist, t;

	x1 = (join1 == HEAD) ? (double)c1->pnts[0].x : (double)c1->pnts[c1->pnts.size()-1].x;
	y1 = (join1 == HEAD) ? (double)c1->pnts[0].y : (double)c1->pnts[c1->pnts.size()-1].y;
	
	x2 = (join2 == HEAD) ? (double)c2->pnts[0].x : (double)c2->pnts[c2->pnts.size()-1].x;
	y2 = (join2 == HEAD) ? (double)c2->pnts[0].y : (double)c2->pnts[c2->pnts.size()-1].y;

	///*
	dist = 	dist2(x1, y1, x2, y2);
	if (dist > 0.0) {
		//TRACE("dist = %f\n", dist);
		step_size = 1.0 / dist;
		xi = round(x1);	yi = round(y1);
		for (t = 0.0+step_size; t <= 1.0-step_size; t+=step_size) {
			xi = round( (1 - t) * x1 + t * x2 ); // proceed by exactly unit_distance 1.0
			yi = round( (1 - t) * y1 + t * y2 );
			//if (xi == round(x2) && yi == round(y2)) break;
			r = (GLubyte)RGB_GETRED(dc.GetPixel(xi, IMAGE_Y-1-yi));
			if (r == 0) return false; // touches other line! merge disallowed!
		}
	}
	//*/

	/*
	double x, y, slope;

	if (x1 != x2) slope = (y2 - y1) / (x2 - x1);
	x = x1; y = y1;
	while(1) {
		if (x2 == x1 && y1 == y2) break; // identical point 	
		if (x2 == x1) { // vertical line
			if (y2 > y1) y += 1.0;
			else y -= 1.0;
			if (y == y2) break;
			xi = round(x);	yi = round(y);
			r = (GLubyte)RGB_GETRED(dc.GetPixel(xi, IMAGE_Y-1-yi));
			if (r == 0) return false; // touches other line! merge disallowed!
		}
		else if ( ABS(slope) >= 1.0 ) {
			if (y2 > y1) { y++;	x += 1/slope; }
			else { y--;	x -= 1/slope; }
			if (y == y2) break;
			xi = round(x);	yi = round(y);
			r = (GLubyte)RGB_GETRED(dc.GetPixel(xi, IMAGE_Y-1-yi));
			if (r == 0) return false; // touches other line! merge disallowed!
		}
		else { // ( ABS(slope) < 1.0 )
			if (x2 > x1) { x++;	y += slope; }
			else { x--;	y -= slope; }
			if (x == x2) break;
			xi = round(x);	yi = round(y);
			r = (GLubyte)RGB_GETRED(dc.GetPixel(xi, IMAGE_Y-1-yi));
			if (r == 0) return false; // touches other line! merge disallowed!
		}
	}
	*/
	/////////////////////////////////////////////////////////

	int i;
	deque<double2D> pnts;
	//deque<MRBspline*>::iterator it;

	////////////////////////////////////
	int merge_index;
	
	////////////////////////
	// copy c1->pnts to pnts
	for (i = 0; i < (signed)c1->pnts.size(); i++) {
		pnts.push_back(c1->pnts[i]);
	}
	
	////////////////////////////////////////////
	if (join1 == HEAD && join2 == HEAD) {
		for (i = 0; i < (signed)c2->pnts.size(); i++) {
			pnts.push_front(c2->pnts[i]);
		}
		merge_index = c2->pnts.size()-1;
	}
	else if (join1 == HEAD && join2 == TAIL) {
		for (i = c2->pnts.size()-1; i >= 0; i--) {
			pnts.push_front(c2->pnts[i]);
		}
		merge_index = c2->pnts.size()-1;
	}
	else if (join1 == TAIL && join2 == HEAD) {
		for (i = 0; i < (signed)c2->pnts.size(); i++) {
			pnts.push_back(c2->pnts[i]);
		}
		merge_index = c1->pnts.size()-1;
	}
	else if (join1 == TAIL && join2 == TAIL) {
		for (i = c2->pnts.size()-1; i >= 0; i--) {
			pnts.push_back(c2->pnts[i]);
		}
		merge_index = c1->pnts.size()-1;
	}
	
	///////////////////////////////////
	// remove c2 from MyList
	//TRACE("c2->pnts[0].x = %f\n", c2->pnts[0].x);
	bstrokes.Remove(c2->node); 
	//TRACE("bstroke Remove success!\n");
	
	////////////////////////////////////////////
	// Smooth the connecting area
	/*
	double remove_thres = 90; // if it is bigger than this, remove!
	double no_remove_thres = 90; // if the subsequent angle is bigger than this, can't!
	double angle;
	vector v(2), w(2), z(2);
	bool remain = true;
	///////////////////////////////
	while (remain) {
		remain = false;
		
		if (merge_index+1 < (signed)pnts.size()-1) {
			////////////////////////////
			v[0] = pnts[merge_index+1].x - pnts[merge_index].x;
			v[1] = pnts[merge_index+1].y - pnts[merge_index].y;
			v.make_unit();
			w[0] = pnts[merge_index+2].x - pnts[merge_index+1].x;
			w[1] = pnts[merge_index+2].y - pnts[merge_index+1].y;
			w.make_unit();
			angle = v*w;
			if (angle > 1.0) angle = 1.0;
			if (angle < -1.0) angle = -1.0;
			angle = acos(angle) * 180.0 / PI; // acos: ranges from 0 to 180
			if (merge_index+2 < (signed)pnts.size()-1) {
				z[0] = pnts[merge_index+3].x - pnts[merge_index+2].x;
				z[1] = pnts[merge_index+3].y - pnts[merge_index+2].y;
				z.make_unit();
			}
			else z.copy(w);
			//////////////////////////
			if ( angle > remove_thres ) { // the smaller the better
				////////////////////////////////////
				angle = w*z;
				if (angle > 1.0) angle = 1.0;
				if (angle < -1.0) angle = -1.0;
				angle = acos(angle)  * 180.0 / PI; // if the connected segment angle is too big, you can' remove!	
				//if (angle < no_remove_thres) { // now you can remove this point!
					pnts.erase(pnts.begin() + merge_index + 1); 
					remain = true;
				//}
			}
		}

		if (merge_index > 0) {
			////////////////////////////
			v[0] = pnts[merge_index+1].x - pnts[merge_index].x;
			v[1] = pnts[merge_index+1].y - pnts[merge_index].y;
			v.make_unit();
			w[0] = pnts[merge_index].x - pnts[merge_index-1].x;
			w[1] = pnts[merge_index].y - pnts[merge_index-1].y;
			w.make_unit();
			angle = v*w;
			if (angle > 1.0) angle = 1.0;
			if (angle < -1.0) angle = -1.0;
			angle = acos(angle)  * 180.0 / PI; // acos: ranges from 0 to PI
			if (merge_index > 1) {
				z[0] = pnts[merge_index-1].x - pnts[merge_index-2].x;
				z[1] = pnts[merge_index-1].y - pnts[merge_index-2].y;
				z.make_unit();
			}
			else z.copy(w);
			//////////////////////////
			if ( angle > remove_thres ) { // the smaller the better
				////////////////////////////////////
				angle = w*z;
				if (angle > 1.0) angle = 1.0;
				if (angle < -1.0) angle = -1.0;
				angle = acos(angle)  * 180.0 / PI; // if the connected segment angle is too big, you can' remove!
				//if (angle < no_remove_thres) { // now you can remove this point!
					pnts.erase(pnts.begin() + merge_index + 1); 
					merge_index--;
					remain = true;
				//}
			}
		}

	} // while (remain)
	*/

	/////////////////////////////////
	c1->SetDataPnts(pnts);
	//c1->SetSamplePnts(pnts);
	//c1->SetCntPnts(pnts);
	c1->SetInterpCntPnts();
	c1->SetHeadTailDir();
	//curve->DrawInterpCurve(&dc, r, g, b);

	return true; // merge success!
}

void MergeBStrokesAll2(MyList<MRBspline>& bstrokes, double sigma, double merge_thres, int half_w)
// Merge close strokes aligned in the same direction
// this time, we don't use b_map, but we search all the strokes in the linked list!
{
	//PntsDeque* dq;
	//deque<double2D>* dq;
	deque<double2D> pnts;
	//vector knot;

	MRBspline *c1, *c2, *min_curve;

	double min_e, merge_e;
	double x, y, xx, yy;

	bool merged = false;
	bool remain = true; // still something to merge

	vector GAU;
	MakeGaussVector(sigma, GAU);

	MyListNode<MRBspline>* node;
	MyListNode<MRBspline>* node2;

	//int half_w = 1; // half_w x half_w
	int min_join2, join2;
	double d1, d2, min_d;
	
	//for (m = 0; m < bstrokes.Size(); m++) {
	while (remain) {
		remain = false; // assume there's nothing to merge any more
		for (node = bstrokes.headNode; node; node=node->nextNode) {
			/////////////////////////////////
			c1 = node->obj_ptr;
			//c1 = bstrokes[m]; // get the stroke pointer
			/////////////////////////////////////
			// check the head of c1
			x = c1->pnts[0].x;
			y = c1->pnts[0].y;
			//merged = false;
			min_e = 10000000; // init
			merge_e = 10000000;
			min_curve = NULL;
			for (node2 = bstrokes.headNode; node2; node2=node2->nextNode) {
				if (node2 == node) continue; // itself!
					c2 = node2->obj_ptr; 
					if (c1 == c2) continue; // can't merge with itself
					/////////////////////////////
					// examine head
					xx = c2->pnts[0].x;
					yy = c2->pnts[0].y;
					d1 = dist2(x, y, xx, yy);
					// examine tail
					xx = c2->pnts[c2->pnts.size()-1].x;
					yy = c2->pnts[c2->pnts.size()-1].y;
					d2 = dist2(x, y, xx, yy);
					if (d1 < d2) { join2 = HEAD; min_d = d1; }
					else { join2 = TAIL; min_d = d2; }
					if ( min_d < (double)half_w ) { // candidate for merge!
						merge_e = GetMergeEnergy2(c1, HEAD, c2, join2, bstrokes, sigma, GAU);
						if (merge_e < min_e) {
							min_e = merge_e;
							min_curve = c2;
							min_join2 = join2;
						}
					}
			} // for node2
			if (min_e < merge_thres) {
				//MergeBStrokes2(c1, HEAD, min_curve, min_join2, bstrokes); 
				MergeBStrokes3(c1, HEAD, min_curve, min_join2, bstrokes); 
				remain = true;
			}

			/////////////////////////////////////
			// check the tail of c1
			x = c1->pnts[c1->pnts.size()-1].x;
			y = c1->pnts[c1->pnts.size()-1].y;
			//merged = false;
			min_e = 10000000; // init
			merge_e = 10000000;
			min_curve = NULL;
			for (node2 = bstrokes.headNode; node2; node2=node2->nextNode) {
				if (node2 == node) continue; // itself!
					c2 = node2->obj_ptr; 
					if (c1 == c2) continue; // can't merge with itself
					/////////////////////////////
					// examine head
					xx = c2->pnts[0].x;
					yy = c2->pnts[0].y;
					d1 = dist2(x, y, xx, yy);
					// examine tail
					xx = c2->pnts[c2->pnts.size()-1].x;
					yy = c2->pnts[c2->pnts.size()-1].y;
					d2 = dist2(x, y, xx, yy);
					if (d1 < d2) { join2 = HEAD; min_d = d1; }
					else { join2 = TAIL; min_d = d2; }
					if ( min_d < (double)half_w ) { // candidate for merge!
						merge_e = GetMergeEnergy2(c1, TAIL, c2, join2, bstrokes, sigma, GAU);
						if (merge_e < min_e) {
							min_e = merge_e;
							min_curve = c2;
							min_join2 = join2;
						}
					}
			} // for node2
			if (min_e < merge_thres) {
				//MergeBStrokes2(c1, TAIL, min_curve, min_join2, bstrokes); 
				MergeBStrokes3(c1, TAIL, min_curve, min_join2, bstrokes); 
				remain = true;
			}

		} // for (node = bstrokes->headNode)
	} // while (remain)
}

void MergeBStrokesAll3(CDC& dc, MyList<MRBspline>& bstrokes, double merge_thres, int half_w)
// Merge close strokes aligned in the same direction
// this time, we don't use b_map, but we search all the strokes in the linked list!
// And here we use a faster merge energy calculation method (much faster)!
{
	//PntsDeque* dq;
	//deque<double2D>* dq;
	deque<double2D> pnts;
	//vector knot;

	MRBspline *c1, *c2, *min_curve;

	double min_e, merge_e;
	double x, y, xx, yy;

	bool merged = false;
	bool remain = true; // still something to merge

	////////////////////////////////////////////////////
	DrawInterpBStrokes2(dc, bstrokes, 0, 0, 0, 1); // for collision detection

	//vector GAU;
	//MakeGaussVector(sigma, GAU);

	MyListNode<MRBspline>* node;
	MyListNode<MRBspline>* node2;

	//int half_w = 1; // half_w x half_w
	int min_join2, join2;
	double d1, d2, min_d;
	bool merge_success = false;
	bool head_in_capture_range;
	bool tail_in_capture_range;
	
	//for (m = 0; m < bstrokes.Size(); m++) {
	while (remain) {
		remain = false; // assume there's nothing to merge any more
		for (node = bstrokes.headNode; node; node=node->nextNode) {
			/////////////////////////////////
			c1 = node->obj_ptr;
			//c1 = bstrokes[m]; // get the stroke pointer
			/////////////////////////////////////
			// check the head of c1
			x = c1->pnts[0].x;
			y = c1->pnts[0].y;
			//merged = false;
			min_e = 10000000; // init
			merge_e = 10000000;
			min_curve = NULL;
			for (node2 = bstrokes.headNode; node2; node2=node2->nextNode) {
				if (node2 == node) continue; // itself!
				c2 = node2->obj_ptr; 
				if (c1 == c2) continue; // can't merge with itself
				d1 = d2 = 10000.0;
				head_in_capture_range = false;
				tail_in_capture_range = false;
				/////////////////////////////
				// examine head
				xx = c2->pnts[0].x;
				yy = c2->pnts[0].y;
				if ( ABS(x-xx) <= half_w && ABS(y-yy) <= half_w) { // in the capture range
					head_in_capture_range = true;
					d1 = dist2(x, y, xx, yy); 
				}
				// examine tail
				xx = c2->pnts[c2->pnts.size()-1].x;
				yy = c2->pnts[c2->pnts.size()-1].y;
				if ( ABS(x-xx) <= half_w && ABS(y-yy) <= half_w) { // in the capture range
					tail_in_capture_range = true;
					d2 = dist2(x, y, xx, yy); 
				}
				//if (d1 == 10000.0 && d2 == 10000.0) continue; // both failed!
				if (!head_in_capture_range && !tail_in_capture_range) continue; // both failed!
				//////////////////////////////////////
				// at least one of them qualifies
				if (d1 < d2) { join2 = HEAD; min_d = d1; }
				else { join2 = TAIL; min_d = d2; }
				//merge_e = GetMergeEnergy2(c1, HEAD, c2, join2, bstrokes, sigma, GAU);
				merge_e = GetMergeEnergy3(dc, c1, HEAD, c2, join2, bstrokes);
				if (merge_e < min_e) {
					min_e = merge_e;
					min_curve = c2;
					min_join2 = join2;
				}
			}
			if (min_e < merge_thres) {
				//MergeBStrokes3(c1, HEAD, min_curve, min_join2, bstrokes); 
				merge_success = MergeBStrokes4(dc, c1, HEAD, min_curve, min_join2, bstrokes); 
				//merged = true;
				if (merge_success)	remain = true;
			}
				
			/////////////////////////////////////
			// check the tail of c1
			x = c1->pnts[c1->pnts.size()-1].x;
			y = c1->pnts[c1->pnts.size()-1].y;
			//merged = false;
			min_e = 10000000; // init
			merge_e = 10000000;
			min_curve = NULL;
			for (node2 = bstrokes.headNode; node2; node2=node2->nextNode) {
				if (node2 == node) continue; // itself!
				c2 = node2->obj_ptr; 
				if (c1 == c2) continue; // can't merge with itself
				d1 = d2 = 10000.0;
				/////////////////////////////
				// examine head
				xx = c2->pnts[0].x;
				yy = c2->pnts[0].y;
				if ( ABS(x-xx) <= half_w && ABS(y-yy) <= half_w) // in the capture range
					d1 = dist2(x, y, xx, yy);
				// examine tail
				xx = c2->pnts[c2->pnts.size()-1].x;
				yy = c2->pnts[c2->pnts.size()-1].y;
				if ( ABS(x-xx) <= half_w && ABS(y-yy) <= half_w) // in the capture range
					d2 = dist2(x, y, xx, yy);
				if (d1 == 10000.0 && d2 == 10000.0) continue; // both failed!
				//////////////////////////////////////
				if (d1 < d2) { join2 = HEAD; min_d = d1; }
				else { join2 = TAIL; min_d = d2; }
				//merge_e = GetMergeEnergy2(c1, TAIL, c2, join2, bstrokes, sigma, GAU);
				merge_e = GetMergeEnergy3(dc, c1, TAIL, c2, join2, bstrokes);
				if (merge_e < min_e) {
					min_e = merge_e;
					min_curve = c2;
					min_join2 = join2;
				}
			} // for node2
			if (min_e < merge_thres) {
				MergeBStrokes3(c1, TAIL, min_curve, min_join2, bstrokes); 
				remain = true;
				//merge_success = MergeBStrokes4(dc, c1, TAIL, min_curve, min_join2, bstrokes); 
				//if (merge_success) remain = true;
			}
		} // for (node = bstrokes->headNode)
	} // while (remain)
}

bool MergeSingleBStroke2(MRBspline* c1, int join1, MyList<MRBspline>& bstrokes, 
						 double sigma, double merge_thres, int half_w)
// merge a single bstroke with a neighboring stroke at either HEAD or TAIL (join1)
{
	//PntsDeque* dq;
	//deque<double2D>* dq;
	deque<double2D> pnts;
	//vector knot;

	MRBspline *c2, *min_curve;

	double min_e, merge_e;
	double x, y, xx, yy;

	bool merged;

	vector GAU;
	MakeGaussVector(sigma, GAU);

	//MyListNode<MRBspline>* node;
	MyListNode<MRBspline>* node2;

	//int half_w = 1; // half_w x half_w
	int min_join2, join2;
	double d1, d2, min_d;

	merged = false;

	/////////////////////////////
	// merge at HEAD
	if (join1 == HEAD) {
		/////////////////////////////////
		//c1 = node->obj_ptr;
		/////////////////////////////////////
		// check the head of c1
		x = c1->pnts[0].x;
		y = c1->pnts[0].y;
		//merged = false;
		min_e = 10000000; // init
		merge_e = 10000000;
		min_curve = NULL;
		for (node2 = bstrokes.headNode; node2; node2=node2->nextNode) {
			c2 = node2->obj_ptr; 
			if (c1 == c2) continue; // can't merge with itself
			//d1 = d2 = 0.0;
			/////////////////////////////
			// examine head
			xx = c2->pnts[0].x;
			yy = c2->pnts[0].y;
			//if ( ABS(x-xx) <= half_w && ABS(y-yy) <= half_w) // in the capture range
			d1 = dist2(x, y, xx, yy); 
			// examine tail
			xx = c2->pnts[c2->pnts.size()-1].x;
			yy = c2->pnts[c2->pnts.size()-1].y;
			//if ( ABS(x-xx) <= half_w && ABS(y-yy) <= half_w) // in the capture range
			d2 = dist2(x, y, xx, yy); 
			//if (d1 == 0.0 && d2 == 0.0) continue; // both failed
			//////////////////////////////////////
			// at least one of them qualifies
			if (d1 < d2) { join2 = HEAD; min_d = d1; }
			else { join2 = TAIL; min_d = d2; }
			if ( min_d < (double)half_w ) { // candidate for merge!
				merge_e = GetMergeEnergy2(c1, HEAD, c2, join2, bstrokes, sigma, GAU);
				if (merge_e < min_e) {
					min_e = merge_e;
					min_curve = c2;
					min_join2 = join2;
				}
			}
		} // for node2
		if (min_e < merge_thres) {
			//MergeBStrokes2(c1, HEAD, min_curve, min_join2, bstrokes); 
			MergeBStrokes3(c1, HEAD, min_curve, min_join2, bstrokes); 
			merged = true;
		}
	}

	if (join1 == TAIL) {
		/////////////////////////////////////
		// check the tail of c1
		x = c1->pnts[c1->pnts.size()-1].x;
		y = c1->pnts[c1->pnts.size()-1].y;
		//merged = false;
		min_e = 10000000; // init
		merge_e = 10000000;
		min_curve = NULL;
		for (node2 = bstrokes.headNode; node2; node2=node2->nextNode) {
			c2 = node2->obj_ptr; 
			if (c1 == c2) continue; // can't merge with itself
			/////////////////////////////
			// examine head
			xx = c2->pnts[0].x;
			yy = c2->pnts[0].y;
			d1 = dist2(x, y, xx, yy);
			// examine tail
			xx = c2->pnts[c2->pnts.size()-1].x;
			yy = c2->pnts[c2->pnts.size()-1].y;
			d2 = dist2(x, y, xx, yy);
			if (d1 < d2) { join2 = HEAD; min_d = d1; }
			else { join2 = TAIL; min_d = d2; }
			if ( min_d < (double)half_w ) { // candidate for merge!
				merge_e = GetMergeEnergy2(c1, TAIL, c2, join2, bstrokes, sigma, GAU);
				if (merge_e < min_e) {
					min_e = merge_e;
					min_curve = c2;
					min_join2 = join2;
				}
			}
		} // for node2
		if (min_e < merge_thres) {
			//MergeBStrokes2(c1, TAIL, min_curve, min_join2, bstrokes); 
			MergeBStrokes3(c1, TAIL, min_curve, min_join2, bstrokes); 
			merged = true;
		}
	}

	return merged;
}

bool MergeSingleBStroke3(CDC& dc, MRBspline* c1, int join1, MyList<MRBspline>& bstrokes, 
						 double sigma, double merge_thres, int half_w)
// merge a single bstroke with a neighboring stroke at either HEAD or TAIL (join1)
// here we try to minimize the time for computing merge energy
{
	//PntsDeque* dq;
	//deque<double2D>* dq;
	deque<double2D> pnts;
	//vector knot;

	MRBspline *c2, *min_curve;

	double min_e, merge_e;
	double x, y, xx, yy;

	bool merged;

	vector GAU;
	//MakeGaussVector(sigma, GAU);

	//MyListNode<MRBspline>* node;
	MyListNode<MRBspline>* node2;

	////////////////////////////////////////////////////
	//DrawInterpBStrokes2(dc2, bstrokes, 0, 0, 0, 1); // for collision detection

	//int half_w = 1; // half_w x half_w
	int min_join2, join2;
	double d1, d2, min_d;

	merged = false;
	bool head_in_capture_range, tail_in_capture_range;

	/////////////////////////////
	// merge at HEAD
	///*
	if (join1 == HEAD) {
		/////////////////////////////////
		//c1 = node->obj_ptr;
		/////////////////////////////////////
		// check the head of c1
		x = c1->pnts[0].x;
		y = c1->pnts[0].y;
		//merged = false;
		min_e = 10000000; // init
		merge_e = 10000000;
		min_curve = NULL;
		for (node2 = bstrokes.headNode; node2; node2=node2->nextNode) {
			c2 = node2->obj_ptr; 
			if (c1 == c2) continue; // can't merge with itself
			d1 = d2 = 10000.0;
			/////////////////////////////
			// examine head
			xx = c2->pnts[0].x;
			yy = c2->pnts[0].y;
			if ( ABS(x-xx) <= half_w && ABS(y-yy) <= half_w) // in the capture range
				d1 = dist2(x, y, xx, yy); 
			// examine tail
			xx = c2->pnts[c2->pnts.size()-1].x;
			yy = c2->pnts[c2->pnts.size()-1].y;
			if ( ABS(x-xx) <= half_w && ABS(y-yy) <= half_w) // in the capture range
				d2 = dist2(x, y, xx, yy); 
			if (d1 == 10000.0 && d2 == 10000.0) continue; // both failed
			//////////////////////////////////////
			// at least one of them qualifies
			if (d1 < d2) { join2 = HEAD; min_d = d1; }
			else { join2 = TAIL; min_d = d2; }
			//merge_e = GetMergeEnergy2(c1, HEAD, c2, join2, bstrokes, sigma, GAU);
			merge_e = GetMergeEnergy3(dc, c1, HEAD, c2, join2, bstrokes);
			if (merge_e < min_e) {
				min_e = merge_e;
				min_curve = c2;
				min_join2 = join2;
			}
		} // for node2
		if (min_e < merge_thres) {
			MergeBStrokes3(c1, HEAD, min_curve, min_join2, bstrokes); 
			merged = true;
			//if ( MergeBStrokes4(dc, c1, HEAD, min_curve, min_join2, bstrokes) ) 
			//	merged = true;
		}
	}
	//*/

	///*
	if (join1 == TAIL) {
		/////////////////////////////////////
		// check the tail of c1
		x = c1->pnts[c1->pnts.size()-1].x;
		y = c1->pnts[c1->pnts.size()-1].y;
		//merged = false;
		min_e = 10000000; // init
		merge_e = 10000000;
		min_curve = NULL;
		for (node2 = bstrokes.headNode; node2; node2=node2->nextNode) {
			c2 = node2->obj_ptr; 
			if (c1 == c2) continue; // can't merge with itself
			d1 = d2 = 10000.0;
			head_in_capture_range = false;
			tail_in_capture_range = false;
			/////////////////////////////
			// examine head
			xx = c2->pnts[0].x;
			yy = c2->pnts[0].y;
			if ( ABS(x-xx) <= half_w && ABS(y-yy) <= half_w) { // in the capture range
				d1 = dist2(x, y, xx, yy);
				head_in_capture_range = true;
			}
			// examine tail
			xx = c2->pnts[c2->pnts.size()-1].x;
			yy = c2->pnts[c2->pnts.size()-1].y;
			if ( ABS(x-xx) <= half_w && ABS(y-yy) <= half_w) { // in the capture range
				d2 = dist2(x, y, xx, yy);
				tail_in_capture_range = true;
			}
			if (!head_in_capture_range && !tail_in_capture_range) continue;
			//if (d1 == 10000.0 || d2 == 10000.0) continue; // either failed
			//////////////////////////////////////
			if (d1 <= d2) { join2 = HEAD; min_d = d1; }
			else { join2 = TAIL; min_d = d2; }
			//merge_e = GetMergeEnergy2(c1, TAIL, c2, join2, bstrokes, sigma, GAU);
			merge_e = GetMergeEnergy3(dc, c1, TAIL, c2, join2, bstrokes);
			if (merge_e < min_e) {
				min_e = merge_e;
				min_curve = c2;
				min_join2 = join2;
			}
		} // for node2
		if (min_e < merge_thres) {
			MergeBStrokes3(c1, TAIL, min_curve, min_join2, bstrokes); 
			merged = true;
			//if ( MergeBStrokes4(dc, c1, TAIL, min_curve, min_join2, bstrokes) ) 
			//	merged = true;
		}
	}
	//*/

	return merged;
}

void MergeBStrokesAll(MyList<MRBspline>& bstrokes, qmatrix<MRBspline*>& b_map, 
					  double sigma, double merge_thres, int half_w)
// Merge close strokes aligned in the same direction
{
	//PntsDeque* dq;
	//deque<double2D>* dq;
	deque<double2D> pnts;
	//vector knot;

	MRBspline *c1, *c2, *min_curve;

	int	k, s, t, x, y, xx, yy;
	double min_e, merge_e;

	bool merged = false;
	bool remain = true; // still something to merge

	vector GAU;
	MakeGaussVector(sigma, GAU);

	MyListNode<MRBspline> *node;

	//int half_w = 1; // half_w x half_w
	int min_join2, join2;
	
	//for (m = 0; m < bstrokes.Size(); m++) {
	while (remain) {
		remain = false; // assume there's nothing to merge any more
		for (node = bstrokes.headNode; node; node=node->nextNode) {
			/////////////////////////////////
			c1 = node->obj_ptr;
			//c1 = bstrokes[m]; // get the stroke pointer
			/////////////////////////////////////
			// check the head of c1
			x = round(c1->pnts[0].x);
			y = round(c1->pnts[0].y);
			//merged = false;
			min_e = 10000000; // init
			merge_e = 10000000;
			min_curve = NULL;
			for (s = -half_w; s <= half_w; s++) {
				for (t = -half_w; t <= half_w; t++) {
					xx = x + s;
					yy = y + t;
					if (xx < 0 || xx > IMAGE_X-1 || yy < 0 || yy > IMAGE_Y-1) continue;
					//TRACE("b_map[%d][%d].size() = %d\n", xx, yy, b_map[xx][yy].size());
					if (b_map[xx][yy].size() == 0) continue; // no curve endpoints here
					//TRACE("b_map[%d][%d].size() = %d\n", xx, yy, b_map[xx][yy].size());
					//////////////////////////////////////
					// now there's some endpoint in this pixel
					for (k = 0; k < (signed)b_map[xx][yy].size(); k++) {
					//for (k = 0; k < 1; k++) {
						c2 = b_map[xx][yy][k]; // each segment
						if (c1 == c2) continue; // can't merge with itself
						//TRACE("k = %d\n", k);
						//TRACE("xx = %d, yy = %d\n", xx, yy);
						//TRACE("c2->pnts[0].x = %f, c2->pnts[0].y = %f\n", c2->pnts[0].x, c2->pnts[0].y);
						if (xx == round(c2->pnts[0].x) && yy == round(c2->pnts[0].y)) {
							merge_e = GetMergeEnergy2(c1, HEAD, c2, HEAD, bstrokes, 
								sigma, GAU);
							join2 = HEAD;
						}
						else { // ending point
							merge_e = GetMergeEnergy2(c1, HEAD, c2, TAIL, bstrokes, 
								sigma, GAU);
							join2 = TAIL;
						}
						if (merge_e < min_e) {
							min_e = merge_e;
							min_curve = c2;
							min_join2 = join2;
						}
					}
				} // for t
			} // for s
			if (min_e < merge_thres) {
				MergeBStrokes(c1, HEAD, min_curve, min_join2, bstrokes, b_map); 
				//MergeStrokes(c1, HEAD, min_curve, min_join2, bstrokes, b_map); 
				remain = true;
			}

			///*
			/////////////////////////////////////
			// check the tail of c1
			x = round(c1->pnts[c1->pnts.size()-1].x);
			y = round(c1->pnts[c1->pnts.size()-1].y);
			//merged = false;
			min_e = 10000000; // init
			merge_e = 10000000;
			min_curve = NULL;
			for (s = -half_w; s <= half_w; s++) {
				for (t = -half_w; t <= half_w; t++) {
					xx = x + s;
					yy = y + t;
					if (xx < 0 || xx > IMAGE_X-1 || yy < 0 || yy > IMAGE_Y-1) continue;
					//TRACE("b_map[%d][%d].size() = %d\n", xx, yy, b_map[xx][yy].size());
					if (b_map[xx][yy].size() == 0) continue; // no curve endpoints here
					//////////////////////////////////////
					// now there's some endpoint in this pixel
					for (k = 0; k < (signed)b_map[xx][yy].size(); k++) {
						c2 = b_map[xx][yy][k]; // each segment
						if (c1 == c2) continue; // can't merge with itself
						if (xx == round(c2->pnts[0].x) && yy == round(c2->pnts[0].y)) {
							merge_e = GetMergeEnergy2(c1, TAIL, c2, HEAD, bstrokes, 
								sigma, GAU);
							join2 = HEAD;
						}
						else {
							merge_e = GetMergeEnergy2(c1, TAIL, c2, TAIL, bstrokes, 
								sigma, GAU);
							join2 = TAIL;
						}
						if (merge_e < min_e) {
							min_e = merge_e;
							min_curve = c2;
							min_join2 = join2;
						}
					}
				} // for t
			} // for s
			if (min_e < merge_thres) {
				MergeBStrokes(c1, TAIL, min_curve, min_join2, bstrokes, b_map); 
				remain = true;
			}
			//*/
		} // for (node = bstrokes->headNode)
	} // while (remain)
}

void MergeSingleBStroke(MRBspline* c1, MyList<MRBspline>& bstrokes, qmatrix<MRBspline*>& b_map, 
						double sigma, int half_w, double merge_thres)
// Merge a particular stroke with neighboring stroke
{
	//PntsDeque* dq;
	//deque<double2D>* dq;
	deque<double2D> pnts;
	//vector knot;

	MRBspline *c2, *min_curve;

	int	k, x, y, s, t, xx, yy;
	double min_e, merge_e;

	bool merged = false;
	bool remain = true; // still something to merge

	vector GAU;
	MakeGaussVector(sigma, GAU);

	//int half_w = 1; // half_w x half_w
	int min_join2, join2;
	
	//for (m = 0; m < bstrokes.Size(); m++) {
	/////////////////////////////////
	//c1 = node->obj_ptr;
	//c1 = bstrokes[m]; // get the stroke pointer
	/////////////////////////////////////
	// check the head of c1
	x = round(c1->pnts[0].x);
	y = round(c1->pnts[0].y);
	//merged = false;
	min_e = 10000000; // init
	merge_e = 10000000;
	min_curve = NULL;
	for (s = -half_w; s <= half_w; s++) {
		for (t = -half_w; t <= half_w; t++) {
			xx = x + s;
			yy = y + t;
			if (xx < 0 || xx > IMAGE_X-1 || yy < 0 || yy > IMAGE_Y-1) continue;
			//TRACE("b_map[%d][%d].size() = %d\n", xx, yy, b_map[xx][yy].size());
			if (b_map[xx][yy].size() == 0) continue; // no curve endpoints here
			//TRACE("b_map[%d][%d].size() = %d\n", xx, yy, b_map[xx][yy].size());
			//////////////////////////////////////
			// now there's some endpoint in this pixel
			for (k = 0; k < (signed)b_map[xx][yy].size(); k++) {
			//for (k = 0; k < 1; k++) {
				c2 = b_map[xx][yy][k]; // each segment
				if (c1 == c2) continue; // can't merge with itself
				//TRACE("k = %d\n", k);
				//TRACE("xx = %d, yy = %d\n", xx, yy);
				//TRACE("c2->pnts[0].x = %f, c2->pnts[0].y = %f\n", c2->pnts[0].x, c2->pnts[0].y);
				if (xx == round(c2->pnts[0].x) && yy == round(c2->pnts[0].y)) {
					merge_e = GetMergeEnergy(c1, HEAD, c2, HEAD, bstrokes, b_map, 
						sigma, GAU);
					join2 = HEAD;
				}
				else {
					merge_e = GetMergeEnergy(c1, HEAD, c2, TAIL, bstrokes, b_map, 
						sigma, GAU);
					join2 = TAIL;
				}
				if (merge_e < min_e) {
					min_e = merge_e;
					min_curve = c2;
					min_join2 = join2;
				}
			}
		} // for t
	} // for s
	//if (min_e < 0.5) {
	if (min_e < merge_thres) {
		MergeBStrokes(c1, HEAD, min_curve, min_join2, bstrokes, b_map); 
		//MergeStrokes(c1, HEAD, min_curve, min_join2, bstrokes, b_map); 
		remain = true;
	}

	///*
	/////////////////////////////////////
	// check the tail of c1
	x = round(c1->pnts[c1->pnts.size()-1].x);
	y = round(c1->pnts[c1->pnts.size()-1].y);
	//merged = false;
	min_e = 10000000; // init
	merge_e = 10000000;
	min_curve = NULL;
	for (s = -half_w; s <= half_w; s++) {
		for (t = -half_w; t <= half_w; t++) {
			xx = x + s;
			yy = y + t;
			if (xx < 0 || xx > IMAGE_X-1 || yy < 0 || yy > IMAGE_Y-1) continue;
			//TRACE("b_map[%d][%d].size() = %d\n", xx, yy, b_map[xx][yy].size());
			if (b_map[xx][yy].size() == 0) continue; // no curve endpoints here
			//////////////////////////////////////
			// now there's some endpoint in this pixel
			for (k = 0; k < (signed)b_map[xx][yy].size(); k++) {
				c2 = b_map[xx][yy][k]; // each segment
				if (c1 == c2) continue; // can't merge with itself
				if (xx == round(c2->pnts[0].x) && yy == round(c2->pnts[0].y)) {
					merge_e = GetMergeEnergy(c1, TAIL, c2, HEAD, bstrokes, b_map, 
						sigma, GAU);
					join2 = HEAD;
				}
				else {
					merge_e = GetMergeEnergy(c1, TAIL, c2, TAIL, bstrokes, b_map, 
						sigma, GAU);
					join2 = TAIL;
				}
				if (merge_e < min_e) {
					min_e = merge_e;
					min_curve = c2;
					min_join2 = join2;
				}
			}
		} // for t
	} // for s
	//if (min_e < 0.5) {
	if (min_e < merge_thres) {
		MergeBStrokes(c1, TAIL, min_curve, min_join2, bstrokes, b_map); 
		remain = true;
	}
	//*/
}

void DrawBStrokes(CDC& dc, MyList<MRBspline>& bstrokes, GLubyte r, GLubyte g, GLubyte b)
// Draw the Bstrokes from MyList
{
	int m, n;
	//PntsDeque* dq;
	deque<double2D> pnts;
	int interval; // interval
	double2D p;
	vector knot;

	MRBspline* curve;

	int	i, N;
	int final_pnt_inserted;
	
	//////////////////////////////////////////////////////////////
	// "interval" enables picking only sparse data points from original point sequence
	// This can be used to create smoother curves!
	//interval = 5;
	interval = 1;
	for (m = 0; m < bstrokes.Size(); m++) {
		//TRACE("big_array.size() = %d\n", big_array.size());
		//TRACE("m = %d\n", m);
		//TRACE("big_array[%d]->size() = %d\n", m, big_array[m]->size());
		//dq = big_array[m];
		curve = bstrokes[m]; // get the stroke pointer
		pnts.clear();
		final_pnt_inserted = 0; // initialize
		curve->SetPolylineCount(curve->pnts.size()); 
		for (n = 0; n < (signed)curve->pnts.size(); n+=interval) {
			//TRACE("big_array[%d]->size() = %d\n", m, big_array[m]->size());
			//TRACE("i'm here!\n");
			//p.x = dq->operator[](n).x;
			p.x = curve->pnts[n].x;
			p.y = IMAGE_Y - 1 - curve->pnts[n].y;
			//TRACE("p.x = %f, p.y = %f\n", p.x, p.y);
			pnts.insert(pnts.end(), p);			
			if (n == curve->pnts.size()-1) // final point inserted!
				final_pnt_inserted = 1;
		}
		if (!final_pnt_inserted) { // final point is not inserted, so insert it!
			//p.x = dq->operator[](dq->size()-1).x;
			p.x = curve->pnts[curve->pnts.size()-1].x;
			p.y = IMAGE_Y - 1 - curve->pnts[curve->pnts.size()-1].y;
			pnts.insert(pnts.end(), p);
		}
		////////////////////////////////////////////////
		N = pnts.size(); 

		curve->SetCntPnts(pnts);
		knot.init(N+4); // n + 1 + K
		// Knot definition
		knot[0] = knot[1] = knot[2] = knot[3] = 0.0;
		for (i = 4; i < N; i++)
			knot[i] = (double)i - 3;
		knot[N] = knot[N+1] = knot[N+2] = knot[N+3] = (double)N - 3;
				
		curve->SetKnotVector(knot);
		curve->DrawCurve(&dc, r, g, b);
		
		//curve.DrawCntPnts(dc, 0, 0, 0);
	}
	
}

void DrawInterpBStrokes(CDC& dc, MyList<MRBspline>& bstrokes, GLubyte r, GLubyte g, GLubyte b)
// Draw the interpolating B-spline strokes from MyList
// Also, this samples the data points using intervals, and set the data points with samples
{
	int m, n;
	//PntsDeque* dq;
	deque<double2D> pnts;
	int interval; // interval
	double2D p;
	//vector knot;

	MRBspline* curve;

	int N; 
	int final_pnt_inserted;
	
	//////////////////////////////////////////////////////////////
	// "interval" enables picking only sparse data points from original point sequence
	// This can be used to create smoother curves!
	//interval = 100;
	//interval = 50;
	//interval = 5;
	interval = 1;
	for (m = 0; m < bstrokes.Size(); m++) {
		//TRACE("big_array.size() = %d\n", big_array.size());
		//TRACE("m = %d\n", m);
		//TRACE("big_array[%d]->size() = %d\n", m, big_array[m]->size());
		//dq = big_array[m];
		curve = bstrokes[m]; // get the stroke pointer
		pnts.clear();
		final_pnt_inserted = 0; // initialize
		//curve->SetPolylineCount(curve->pnts.size()); 
		for (n = 0; n < (signed)curve->pnts.size(); n+=interval) {
			//p.x = dq->operator[](n).x;
			p.x = curve->pnts[n].x;
			p.y = curve->pnts[n].y;
			//p.y = IMAGE_Y - 1 - curve->pnts[n].y; // Now we convert the y-coord to GDI mode!
			//TRACE("p.x = %f, p.y = %f\n", p.x, p.y);
			pnts.insert(pnts.end(), p);			
			if (n == curve->pnts.size()-1) // final point inserted!
				final_pnt_inserted = 1;
		}
		if (!final_pnt_inserted) { // final point is not inserted, so insert it!
			//p.x = dq->operator[](dq->size()-1).x;
			p.x = curve->pnts[curve->pnts.size()-1].x;
			//p.y = IMAGE_Y - 1 - curve->pnts[curve->pnts.size()-1].y;
			p.y = curve->pnts[curve->pnts.size()-1].y;
			pnts.insert(pnts.end(), p);
		}
		////////////////////////////////////////////////
		N = pnts.size(); 

		//curve->SetCntPnts(pnts);
		//curve->SetSamplePnts(pnts);
		curve->SetPolylineCount(N); 
		curve->SetInterpCntPnts();
		//curve->DrawInterpCurve(&dc, r, g, b);
		curve->DrawBezierSegments(dc, r, g, b, 3); // Draw as a sequence of Bezier curves
		//curve.DrawCntPnts(dc, 0, 0, 0);
		/*
		for (i = 0; i < N; i++) 
			DrawPointMemDC(&dc, (int)pnts[i].x, (int)pnts[i].y, 5, 0, 0, 255);
		*/

	}
	
}

void SampleBStrokes(MyList<MRBspline>& bstrokes, int interval)
// sample points using interval
{
	int n;
	//PntsDeque* dq;
	deque<double2D> pnts;
	double2D p;
	//vector knot;

	MRBspline* curve;

	int	N;
	int final_pnt_inserted;
	
	MyListNode<MRBspline>* s = bstrokes.headNode;
	for (s = bstrokes.headNode; s; s = s->getNext()) {
		curve = s->get(); // get the stroke pointer
		pnts.clear();
		final_pnt_inserted = 0; // initialize
		//curve->SetPolylineCount(curve->pnts.size()); 
		for (n = 0; n < (signed)curve->pnts.size(); n+=interval) {
			//p.x = dq->operator[](n).x;
			p.x = curve->pnts[n].x;
			p.y = curve->pnts[n].y;
			//p.y = IMAGE_Y - 1 - curve->pnts[n].y; // Now we convert the y-coord to GDI mode!
			//TRACE("p.x = %f, p.y = %f\n", p.x, p.y);
			//pnts.insert(pnts.end(), p);			
			pnts.push_back(p);			
			if (n == curve->pnts.size()-1) // final point inserted!
				final_pnt_inserted = 1;
		}
		if (!final_pnt_inserted) { // final point is not inserted, so insert it!
			//p.x = dq->operator[](dq->size()-1).x;
			p.x = curve->pnts[curve->pnts.size()-1].x;
			//p.y = IMAGE_Y - 1 - curve->pnts[curve->pnts.size()-1].y;
			p.y = curve->pnts[curve->pnts.size()-1].y;
			//pnts.insert(pnts.end(), p);
			pnts.push_back(p);			
		}
		////////////////////////////////////////////////
		N = pnts.size(); 

		
		curve->SetDataPnts(pnts); // Note the original data points are replaced with sample points!
		//curve->SetSamplePnts(pnts);
		//curve->SetPolylineCount(N); 
		//curve->SetCntPnts(pnts);
		curve->SetInterpCntPnts();
		//curve->DrawInterpCurve(&dc, r, g, b);
		/*
		r = (GLubyte)intrand(0, 255);
		g = (GLubyte)intrand(0, 255);
		b = (GLubyte)intrand(0, 255);
		curve->DrawBezierSegments(dc, r, g, b, 3); // Draw as a sequence of Bezier curves
		*/
		//curve.DrawCntPnts(dc, 0, 0, 0);
		/*
		for (i = 0; i < N; i++) 
			DrawPointMemDC(&dc, (int)pnts[i].x, (int)pnts[i].y, 5, 0, 0, 255);
		*/

	}
}

void DrawBStrokesPoints(CDC& dc, MyList<MRBspline>& bstrokes, GLubyte r, GLubyte g, GLubyte b)
// Draw the interpolating B-spline strokes data points
// Note that sample points are already sampled!
{
	//PntsDeque* dq;
	//deque<double2D>* dq;
	//deque<double2D> pnts;
	MRBspline* curve;

	double2D p, q;

	int	i;
	//ClearMemDC(&dc); // clear the canvas white

	bool something_wrong = false;

	MyListNode<MRBspline>* s = bstrokes.headNode;
	for (s = bstrokes.headNode; s; s = s->getNext()) {
		curve = s->get(); // get the stroke pointer
		//curve->DrawBezierSegments(dc, r, g, b, 3); // Draw as a sequence of Bezier curves
		//curve.DrawCntPnts(dc, 0, 0, 0);
		///*
		q.x = curve->pnts[0].x;
		q.y = curve->pnts[0].y;
		for (i = 0; i < (signed)curve->pnts.size(); i++) {
			p.x = curve->pnts[i].x;
			p.y = curve->pnts[i].y;
			DrawPointMemDC(&dc, round(p.x), IMAGE_Y-1-round(p.y), 3, r, g, b);
			if ( dist2(p.x, p.y, q.x, q.y) > 5 ) {
				something_wrong = true;
			}
			q.x = p.x;
			q.y = p.y;
			//DrawPointMemDC(&dc, round(curve->pnts[i].x), IMAGE_Y-1-round(curve->pnts[i].y), 3, r, g, b);
		}
		if (something_wrong) break;
		//*/
	}
	if (something_wrong) {
		for (i = 0; i < (signed)curve->pnts.size(); i++) {
			p.x = curve->pnts[i].x;
			p.y = curve->pnts[i].y;
			//TRACE("p.x = %f, p.y = %f\n", p.x, p.y);
			//DrawPointMemDC(&dc, round(curve->pnts[i].x), IMAGE_Y-1-round(curve->pnts[i].y), 3, r, g, b);
		}
	}
}

void DrawInterpBStrokes2(CDC& dc, MyList<MRBspline>& bstrokes, GLubyte r, GLubyte g, GLubyte b,
						 int pen_width)
// Draw the interpolating B-spline strokes from MyList
// Note that sample points are already sampled!
{
	//PntsDeque* dq;
	deque<double2D> pnts;
	MRBspline* curve;

	//ClearMemDC(&dc); // clear the canvas white
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC2, 0, 0, SRCCOPY); 
	
	MyListNode<MRBspline>* s = bstrokes.headNode;
	for (s = bstrokes.headNode; s; s = s->getNext()) {
		curve = s->get(); // get the stroke pointer
		curve->DrawBezierSegments(dc, r, g, b, pen_width); // Draw as a sequence of Bezier curves
		//curve.DrawCntPnts(dc, 0, 0, 0);
		/*
		for (i = 0; i < N; i++) 
			DrawPointMemDC(&dc, (int)pnts[i].x, (int)pnts[i].y, 5, 0, 0, 255);
		*/

	}
}

void DrawInterpBStrokes3(CDC& dc, MyList<MRBspline>& bstrokes, GLubyte r, GLubyte g, GLubyte b,
						 int pen_width)
// Draw the interpolating B-spline strokes from MyList
// Note that sample points are already sampled!
{
	//PntsDeque* dq;
	deque<double2D> pnts;
	MRBspline* curve;

	//ClearMemDC(&dc); // clear the canvas white
	//dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC2, 0, 0, SRCCOPY); 
	
	MyListNode<MRBspline>* s = bstrokes.headNode;
	for (s = bstrokes.headNode; s; s = s->getNext()) {
		curve = s->get(); // get the stroke pointer
		curve->DrawBezierSegments(dc, r, g, b, pen_width); // Draw as a sequence of Bezier curves
		//curve.DrawCntPnts(dc, 0, 0, 0);
		/*
		for (i = 0; i < N; i++) 
			DrawPointMemDC(&dc, (int)pnts[i].x, (int)pnts[i].y, 5, 0, 0, 255);
		*/

	}
}


void DrawNormalBStrokes(CDC& dc, MyList<MRBspline>& bstrokes, GLubyte r, GLubyte g, GLubyte b)
// Draw the normal B-spline strokes (not interpolating Bezier segments)
{
	//PntsDeque* dq;
	deque<double2D> pnts;
	MRBspline* curve;

	//ClearMemDC(&dc); // clear the canvas white
	dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC2, 0, 0, SRCCOPY); 
	
	MyListNode<MRBspline>* s = bstrokes.headNode;
	for (s = bstrokes.headNode; s; s = s->getNext()) {
		curve = s->get(); // get the stroke pointer
		curve->SetCntPnts();
		curve->DrawCurve2(&dc, r, g, b);
		//curve->DrawBezierSegments(dc, r, g, b, pen_width); // Draw as a sequence of Bezier curves
		//curve.DrawCntPnts(dc, 0, 0, 0);
		/*
		for (i = 0; i < N; i++) 
			DrawPointMemDC(&dc, (int)pnts[i].x, (int)pnts[i].y, 5, 0, 0, 255);
		*/

	}
}

void DrawInterpBStrokesRandCol2(CDC& dc, MyList<MRBspline>& bstrokes, int pen_width)
// Draw the interpolating B-spline strokes from MyList
// Note that sample points are already sampled!
{
	deque<double2D> pnts;
	GLubyte r, g, b;

	MRBspline* curve;

	srand( (unsigned)time( NULL ) );	
	
	//for (m = 0; m < bstrokes.Size(); m++) {
	//	curve = bstrokes[m]; // get the stroke pointer
	MyListNode<MRBspline>* s = bstrokes.headNode;
	for (s = bstrokes.headNode; s; s = s->getNext()) {
		curve = s->get(); // get the stroke pointer
		r = (GLubyte)intrand(0, 255);
		g = (GLubyte)intrand(0, 255);
		b = (GLubyte)intrand(0, 255);
		curve->DrawBezierSegments(dc, r, g, b, pen_width); // Draw as a sequence of Bezier curves
		//curve.DrawCntPnts(dc, 0, 0, 0);
		///*
		for (int i = 0; i < (signed)curve->pnts.size(); i++) 
			DrawPointMemDC(&dc, round(curve->pnts[i].x), round(IMAGE_Y-1-curve->pnts[i].y), 1, 0, 0, 255);
		//*/

	}
}


void DrawInterpBStrokesRandCol(CDC& dc, MyList<MRBspline>& bstrokes)
// Draw the interpolating B-spline strokes from MyList
// use random color for each stroke
{
	int m, n;
	deque<double2D> pnts;
	int interval; // interval
	double2D p;
	//vector knot;
	GLubyte r, g, b;

	MRBspline* curve;

	int N;
	int final_pnt_inserted;
	
	//////////////////////////////////////////////////////////////
	// "interval" enables picking only sparse data points from original point sequence
	// This can be used to create smoother curves!
	//interval = 100;
	//interval = 50;
	//interval = 5;
	interval = 1;
	for (m = 0; m < bstrokes.Size(); m++) {
		//TRACE("big_array.size() = %d\n", big_array.size());
		//TRACE("m = %d\n", m);
		//TRACE("big_array[%d]->size() = %d\n", m, big_array[m]->size());
		//dq = big_array[m];
		curve = bstrokes[m]; // get the stroke pointer
		pnts.clear();
		final_pnt_inserted = 0; // initialize
		//curve->SetPolylineCount(curve->pnts.size()); 
		for (n = 0; n < (signed)curve->pnts.size(); n+=interval) {
			//p.x = dq->operator[](n).x;
			p.x = curve->pnts[n].x;
			p.y = curve->pnts[n].y;
			//p.y = IMAGE_Y - 1 - curve->pnts[n].y; // Now we convert the y-coord to GDI mode!
			//TRACE("p.x = %f, p.y = %f\n", p.x, p.y);
			pnts.insert(pnts.end(), p);			
			if (n == curve->pnts.size()-1) // final point inserted!
				final_pnt_inserted = 1;
		}
		if (!final_pnt_inserted) { // final point is not inserted, so insert it!
			//p.x = dq->operator[](dq->size()-1).x;
			p.x = curve->pnts[curve->pnts.size()-1].x;
			//p.y = IMAGE_Y - 1 - curve->pnts[curve->pnts.size()-1].y;
			p.y = curve->pnts[curve->pnts.size()-1].y;
			pnts.insert(pnts.end(), p);
		}
		////////////////////////////////////////////////
		N = pnts.size(); 

		//curve->SetCntPnts(pnts);
		curve->SetDataPnts(pnts); // Note the original data points are replaced with sample points!
		//curve->SetSamplePnts(pnts);
		curve->SetPolylineCount(N); 
		curve->SetInterpCntPnts();
		//curve->DrawInterpCurve(&dc, r, g, b);
		r = (GLubyte)intrand(0, 255);
		g = (GLubyte)intrand(0, 255);
		b = (GLubyte)intrand(0, 255);
		curve->DrawBezierSegments(dc, r, g, b, 3); // Draw as a sequence of Bezier curves
		//curve.DrawCntPnts(dc, 0, 0, 0);
		/*
		for (i = 0; i < N; i++) 
			DrawPointMemDC(&dc, (int)pnts[i].x, (int)pnts[i].y, 5, 0, 0, 255);
		*/

	}
}

void DrawHermiteStrokes(CDC& dc, MyList<MRBspline>& hstrokes, Field& gfield, 
						GLubyte r, GLubyte g, GLubyte b)
// Draw the Hermite strokes from MyList
{
	int m, n;
	deque<double2D> pnts;
	int interval; // interval
	double2D p;
	vector knot;

	MRBspline* curve;

	int final_pnt_inserted;
	int N;
	
	//////////////////////////////////////////////////////////////
	// "interval" enables picking only sparse data points from original point sequence
	// This can be used to create smoother curves!
	//interval = 30;
	//interval = 15;
	interval = 5;
	//interval = 1;
	for (m = 0; m < hstrokes.Size(); m++) {
		//TRACE("big_array.size() = %d\n", big_array.size());
		//TRACE("m = %d\n", m);
		//TRACE("big_array[%d]->size() = %d\n", m, big_array[m]->size());
		//dq = big_array[m];
		curve = hstrokes[m]; // get the stroke pointer
		pnts.clear();
		final_pnt_inserted = 0; // initialize
		curve->SetPolylineCount(curve->pnts.size()); 
		for (n = 0; n < (signed)curve->pnts.size(); n+=interval) {
			//TRACE("big_array[%d]->size() = %d\n", m, big_array[m]->size());
			//TRACE("i'm here!\n");
			//p.x = dq->operator[](n).x;
			p.x = curve->pnts[n].x;
			p.y = IMAGE_Y - 1 - curve->pnts[n].y;
			//TRACE("p.x = %f, p.y = %f\n", p.x, p.y);
			pnts.insert(pnts.end(), p);			
			if (n == curve->pnts.size()-1) // final point inserted!
				final_pnt_inserted = 1;
		}
		if (!final_pnt_inserted) { // final point is not inserted, so insert it!
			//p.x = dq->operator[](dq->size()-1).x;
			p.x = curve->pnts[curve->pnts.size()-1].x;
			p.y = IMAGE_Y - 1 - curve->pnts[curve->pnts.size()-1].y;
			pnts.insert(pnts.end(), p);
		}
		////////////////////////////////////////////////
		N = pnts.size(); 

		curve->SetCntPnts(pnts);
		//curve->SetTangents(pnts);
		curve->SetTangents(pnts, gfield);
		//knot.init(N+4); // n + 1 + K
		// Knot definition
		//knot[0] = knot[1] = knot[2] = knot[3] = 0.0;
		//for (i = 4; i < N; i++)
		//	knot[i] = (double)i - 3;
		//knot[N] = knot[N+1] = knot[N+2] = knot[N+3] = (double)N - 3;
		//curve->SetKnotVector(knot);
		curve->DrawHermiteCurve(dc, r, g, b);
		//curve.DrawCntPnts(dc, 0, 0, 0);
	}
	
}

void DrawBsplineStrokes(CDC& dc, GLubyte r, GLubyte g, GLubyte b)
{
	int m, n;
	CPen pen, *pOldPen;
	int	st_x, st_y, end_x, end_y;

	pen.CreatePen(PS_SOLID, 3, RGB(r, g, b));
	pOldPen = (CPen *)dc.SelectObject(&pen);

	for (m = 0; m < (signed)big_array.size(); m++) {
		//TRACE("big_array.size() = %d\n", big_array.size());
		for (n = 0; n < (signed)big_array[m]->size()-1; n++) {
			//TRACE("big_array[%d]->size() = %d\n", m, big_array[m]->size());
			//TRACE("i'm here!\n");
			st_x = round(big_array[m]->operator[](n).x);
			st_y = round(big_array[m]->operator[](n).y);
			end_x = round(big_array[m]->operator[](n+1).x);
			end_y = round(big_array[m]->operator[](n+1).y);
			dc.MoveTo(st_x, IMAGE_Y-1-st_y);
			dc.LineTo(end_x, IMAGE_Y-1-end_y);
		}
	}
	dc.SelectObject(pOldPen);
	pen.DeleteObject(); 
}

void DrawBsplineStrokes2(CDC& dc, GLubyte r, GLubyte g, GLubyte b)
{
	int m, n;
	MRBspline curve;
	//PntsDeque* dq;
	deque<double2D>* dq;
	deque<double2D> pnts;
	int interval; // interval
	double2D p;
	vector knot;

	int	N, i;
	int final_pnt_inserted;
	
	interval = 5;
	//interval = 1;
	for (m = 0; m < (signed)big_array.size(); m++) {
		//TRACE("big_array.size() = %d\n", big_array.size());
		//TRACE("m = %d\n", m);
		//TRACE("big_array[%d]->size() = %d\n", m, big_array[m]->size());
		dq = big_array[m];
		pnts.clear();
		final_pnt_inserted = 0;
		curve.SetPolylineCount(dq->size()); 
		for (n = 0; n < (signed)dq->size(); n+=interval) {
			//TRACE("big_array[%d]->size() = %d\n", m, big_array[m]->size());
			//TRACE("i'm here!\n");
			p.x = dq->operator[](n).x;
			p.y = IMAGE_Y - 1 - dq->operator[](n).y;
			//TRACE("p.x = %f, p.y = %f\n", p.x, p.y);
			pnts.insert(pnts.end(), p);			
			if (n == dq->size()-1)
				final_pnt_inserted = 1;
		}
		if (!final_pnt_inserted) { // final point is not inserted, so insert it!
			p.x = dq->operator[](dq->size()-1).x;
			p.y = IMAGE_Y - 1 - dq->operator[](dq->size()-1).y;
			pnts.insert(pnts.end(), p);
		}
		////////////////////////////////////////////////
		N = pnts.size();

		curve.SetCntPnts(pnts);
		knot.init(N+4); // n + 1 + K
		// Knot definition
		knot[0] = knot[1] = knot[2] = knot[3] = 0.0;
		for (i = 4; i < N; i++)
			knot[i] = (double)i - 3;
		knot[N] = knot[N+1] = knot[N+2] = knot[N+3] = (double)N - 3;
				
		curve.SetKnotVector(knot);
		curve.DrawCurve(&dc, r, g, b);
		//curve.DrawCntPnts(dc, 0, 0, 0);
	}
}



/*
void DrawBsplineStrokes(CDC *dc, MRBspline& curve, int r, int g, int b)
{
	int vert[2], old[2];
	int	count, i, j, k, M, N, x, y, y1, y2, z;
	int m;
	int	st_x, st_y, end_x, end_y;
	int level_down_flag = 0;
		
	count = pnts.size();

	if (count < 4) { // can't generate cubic B-spline. Just display the polyline
		CPen pen;
		pen.CreatePen(PS_SOLID, 3, RGB(r, g, b)); // Thickened for PRESENCE paper! (from 2 to 3)
		CPen *pOldPen = (CPen *)dc->SelectObject(&pen);
		//old[0] = free.x;
		//old[1] = free.y;
		dc->MoveTo(pnts[0].x, pnts[0].y);
		for (i = 1; i < pnts.size(); i++) {
			dc->LineTo(pnts[i].x, pnts[i].x);
		}
		dc->SelectObject(pOldPen);
	}
	else { // count >= 4
		////////////////////////////////////////////////////////
		// Let M be the given number of data points on the segment, where 2^j+3 <= M < 2^(j+1)+3
		// Number of control points that should be sampled: N = 2^j+3
		// Take out two end points => N-2 = 2^j+3-2 = 2^j+1 internal control points
		// Let x be the number of control points sampled with interval 1
		// Let y be the number of control points sampled with interval 2
		// Two linear equations: x+2y = M-2; x+y = N-2; => y = M-N, x = N-2-y
		// if M-N is an even number, sample (M-N)/2 points with interval 2 at both ends
		// if M-N is an odd number, sample (int)((M-N)/2) points with interval 2 in the first end,
		// and sample yy = (int)((M-N)/2) + 1 points with interval 2 in the last end.
		M = count;
		for (j=0; j < 10; j++) {
			if (M < (int)pow(2, j+1) + 3) 
				break; // j is the target level: N = 2^j+3
		}
		N = (int)pow(2, j) + 3;
		y = M - N;
		x = N - 2 - y;
		y1 = y / 2;
		if (even(y)) y2 = y1; // y is even number
		else	y2 = y1 + 1; // y is odd number

		vector cnt_x(N);
		vector cnt_y(N);
	
		// Get control points
		i = k = z = 0; // i: local counter, k: global counter, z: data point index counter
		//old[0] = free.x;
		//old[1] = free.y;
		//cnt_x[k] = (double)free.x; 
		//cnt_y[k] = (double)IMAGE_Y-1-free.y;
		cnt_x[k] = (double)pnts[0].x; 
		cnt_y[k] = (double)pnts[0].y;
		k++;
		// First y1 samples
		for (i = 1, z = 0; i <= y1; i++) {
			z += 2;
			//cnt_x[k] = (double)vert[0];	
			//cnt_y[k] = (double)IMAGE_Y-1-vert[1];
			cnt_x[k] = (double)pnts[z].x;	
			cnt_y[k] = (double)pnts[z].y;
			k++;
		}
		// Middle x samples
		for (i = 1; i <= x; i++) {
			z += 1;
			cnt_x[k] = (double)pnts[z].x;	
			cnt_y[k] = (double)pnts[z].y;
			k++;
		}
		// Final y2 samples
		for (i = 1; i <= y2; i++) {
			z += 1;
			cnt_x[k] = (double)pnts[z].x;	
			cnt_y[k] = (double)pnts[z].y;
			k++;
			z += 1;
		}
		// final control point
		z++;
		cnt_x[k] = (double)pnts[z].x;	
		cnt_y[k] = (double)pnts[z].y;

		TRACE("j = %d, level_down = %d\n", j, level_down);
		if (j - level_down < 0) { 
			level_down = j; // shouldn't allow lower level than 0
			level_down_flag = 1;
		}

		if (j - level_down >= 0) { 
		// the final level should be at least 0 (because we have A, B matrices from level 1)
			for (i = 0; i < level_down; i++) {
				//tmp = A[j-i] * cnt_x;
				//A[j-i] * cnt_x;
				MatVecMultOverwrite(A[j-i], cnt_x);
				//cnt_x.print();
				MatVecMultOverwrite(A[j-i], cnt_y);
				//tmp.print();
				//cnt_x.copy(A[j-i] * cnt_x); 
				//cnt_y = A[j-i] * cnt_y; 
			}
			N = (int)pow(2, j-level_down) + 3;
		}	
		//else return; // do not need to draw anything
		
		/////////////////////////////////////////////////////////////////////////////////////
		// Multiplying A with cnt_pnts changes the starting and ending point coordinates slightly
		// So we force them to have the same coordinates as originals
		//cnt_x[0] = (double)pnts[0].x;	
		//cnt_y[0] = (double)pnts[0].y;	
		//cnt_x[N-1] = (double)pnts[pnts.size()-1].x;	
		//cnt_y[N-1] = (double)pnts[pnts.size()-1].y;	

		vector knot(N+4); // n + 1 + K

		// Knot definition
		knot[0] = knot[1] = knot[2] = knot[3] = 0.0;
		for (i = 4; i < N; i++)
			knot[i] = (double)i - 3;
		knot[N] = knot[N+1] = knot[N+2] = knot[N+3] = (double)N - 3;
				
		curve.SetKnotVector(knot);
		curve.SetCntPnts(cnt_x, cnt_y);
		curve.DrawCurve(dc, r, g, b);
		curve.DrawCntPnts(dc, 0, 0, 0);
	}
	//return level_down_flag; // returns 1 if level_down is out of bounds
}
*/


////////////////////////////////////////////////////////////////////////////
// Global statistical segment
bool prob_pixel(double r, double g, double b, pixel_dist& s, double factor)
{
	if (s.r_mean == 0.0 && s.g_mean == 0.0 && s.b_mean == 0.0)
		return false;
	else {
		if ( ABS(r-s.r_mean) <= factor * s.r_std 
			&& ABS(g-s.g_mean) <= factor * s.g_std 
			&& ABS(b-s.b_mean) <= factor * s.b_std) 
			return true;
		else return false;
		/*
		TRACE("\n");
		TRACE("r = %f\n", r);
		TRACE("g = %f\n", g);
		TRACE("b = %f\n", b);
		TRACE("r_mean = %f\n", s.r_mean);
		TRACE("g_mean = %f\n", s.g_mean);
		TRACE("b_mean = %f\n", s.b_mean);
		TRACE("r_std = %f\n", s.r_std);
		TRACE("g_std = %f\n", s.g_std);
		TRACE("b_std = %f\n", s.b_std);
		*/
	}
}

double prob_pixel_dist(double r, double g, double b, pixel_dist& s)
{
	double dist;
	//double factor;

	//factor = 3.5;

	//p_r = gauss2(r, s.r_mean, s.r_std);
	//p_g = gauss2(g, s.g_mean, s.g_std);
	//p_b = gauss2(b, s.b_mean, s.b_std);

	//if (s.r_mean == 0.0 && s.g_mean == 0.0 && s.b_mean == 0.0)
	//	return false;
	//else {

	dist = 0.0;
	dist += ABS(r-s.r_mean);
	dist += ABS(g-s.g_mean);
	dist += ABS(b-s.b_mean);
	dist /= 3.0;

	//TRACE("dist = %f\n", dist);

	return dist;
}

void GlobalSegment(pixel_dist& pix_d, imatrix& pixel_mark)
{
	int	i, j;
	int MAX_GRADIENT = -1;
	GLubyte r, g, b;

	//imatrix marked(image_x, image_y);
	//image2.init(image_x, image_y);
	
	//imatrix tmp(image_x, image_y);
	for (j = 0; j < IMAGE_Y; j++) {
		for (i = 0; i < IMAGE_X; i++) {
			r = Dbuffer[(j * IMAGE_X + i) * 3 + 0];
			g = Dbuffer[(j * IMAGE_X + i) * 3 + 1];
			b = Dbuffer[(j * IMAGE_X + i) * 3 + 2];
			//image2[i][j] = 0; // thin edge above hi_thres
			if ( prob_pixel((double)r, (double)g, (double)b, pix_d, 2.5) )
				pixel_mark[i][j] = 125; // matched pixel
		}
	}
}

void GlobalSegmentAll(pixel_dist* pix_d, imatrix& pixel_mark)
{
	int	i, j, k;
	int MAX_GRADIENT = -1;
	int r, g, b;
	int min_k;
	double min_dist, dist;
	int s, t, half, count;

	//imatrix marked(image_x, image_y);
	//image2.init(image_x, image_y);
	
	half = 5;
	//imatrix tmp(image_x, image_y);
	
	for (j = 0; j < IMAGE_Y; j++) {
		for (i = 0; i < IMAGE_X; i++) {
			count = 0;
			r = g = b = 0;
			for (s = -half; s <= half; s++) {
				for (t = -half; t <= half; t++) {
					if (i+s > IMAGE_X-1 || i+s < 0 || j+t > IMAGE_Y-1 || j+t < 0)
						continue;
					count++;					
					r += Dbuffer[((j+t) * IMAGE_X + (i+s)) * 3 + 0];
					g += Dbuffer[((j+t) * IMAGE_X + (i+s)) * 3 + 1];
					b += Dbuffer[((j+t) * IMAGE_X + (i+s)) * 3 + 2];
				}
			}
			r /= count;
			g /= count;
			b /= count;
			//image2[i][j] = 0; // thin edge above hi_thres
			min_k = -1;
			min_dist = 10000000000;
			for (k = 0; k <= pix_d_count; k++) {
				dist = prob_pixel_dist((double)r, (double)g, (double)b, pix_d[k]);
				if (dist < min_dist) {
					min_dist = dist;
					min_k = k;
				}
			}
			pixel_mark[i][j] = (int)((min_k+1)*255./(pix_d_count+1.)); // matched pixel
		}
	}
}

void adaptive_hyster_visit(int x0, int y0, imatrix& image2, double lo_thres, double lo_thres2)
{
	int	i, j, x, y;
	int	done_flag;
	double g;

	//image2[x0][y0] = 0; // now marked as edge
	done_flag = 0;
	for (j = -1; j <= 1; j++) {
		for (i = -1; i <= 1; i++) {
			x = x0 + i;
			y = y0 + j;
			if (x <= 0 || x >= IMAGE_X-1 || y <= 0 || y >= IMAGE_Y-1)
				continue;
			if (image2[x][y] == 0) continue; // already marked as edge
			if (!thin_edge[x][y]) continue; // not a thin edge
			g = G_mag[x][y];
			if (pixel_mark[x][y] <= 102) { // foreground pixels
				if (g > lo_thres) {
					image2[x][y] = 0; // newly marked as edge pixel
					adaptive_hyster_visit(x, y, image2, lo_thres, lo_thres2);
					//done_flag = 1; // found an extending edge pixel
					//break;
				}
			}
			else {
				if (g > lo_thres2) {
					image2[x][y] = 0; // newly marked as edge pixel
					adaptive_hyster_visit(x, y, image2, lo_thres, lo_thres2);
					//done_flag = 1; // found an extending edge pixel
					//break;
				}
			}
		}
		//if (done_flag) break; // found the right neighboring edge pixel. Get out!
	}
}

double GlobalAdaptiveCanny(imatrix& image, imatrix& image2)
{
	int	i, j, k, i1, i2, j1, j2;
	double MAX_GRADIENT = -1;
	
	int gau_w, gau_w2;
	double hi_thres, hi_thres2, lo_thres, lo_thres2;

	gau_w = MakeGaussMask(1.0, gau);
	gau_w2 = MakeGaussMask(0.4, gau2);
	hi_thres = 0.1;
	lo_thres = 0.1;
	hi_thres2 = 0.17;
	lo_thres2 = 0.07;

	//imatrix marked(IMAGE_X, IMAGE_Y);
	//image2.init(IMAGE_X, IMAGE_Y);
	
	//imatrix tmp(IMAGE_X, IMAGE_Y);
	double	x, y;
	
	//////////////////////////////////////////////
	// Gaussian smoothing (adaptive)
	for (j = 0; j < IMAGE_Y; j++) {
		for (i = 0; i < IMAGE_X; i++) {
			if (pixel_mark[i][j]) { // selected pixels
				x = gau[0] * image[i][j];	
				y = gau[0] * image[i][j];
				//TRACE("x = %f, y = %f\n", x, y);
				for (k = 1; k < gau_w; k++) {
					i1 = (i+k)%IMAGE_X;
					i2 = (i-k+IMAGE_X)%IMAGE_X;
					x += gau[k] * image[i1][j] + gau[k] * image[i2][j];
					j1 = (j+k)%IMAGE_Y;
					j2 = (j-k+IMAGE_Y)%IMAGE_Y;
					y += gau[k] * image[i][j1] + gau[k] * image[i][j2];
				}
				tmp_x[i][j] = x;
				tmp_y[i][j] = y;
			}
			else {
				x = gau2[0] * image[i][j];	
				y = gau2[0] * image[i][j];
				//TRACE("x = %f, y = %f\n", x, y);
				for (k = 1; k < gau_w2; k++) {
					i1 = (i+k)%IMAGE_X;
					i2 = (i-k+IMAGE_X)%IMAGE_X;
					x += gau2[k] * image[i1][j] + gau2[k] * image[i2][j];
					j1 = (j+k)%IMAGE_Y;
					j2 = (j-k+IMAGE_Y)%IMAGE_Y;
					y += gau2[k] * image[i][j1] + gau2[k] * image[i][j2];
				}
				tmp_x[i][j] = x;
				tmp_y[i][j] = y;
			}
			//TRACE("x = %f, y = %f\n", x, y);
			if (x > 255) x = 255;
			if (y > 255) y = 255;
			//image[i][j] = (int)x;
			//image[i][j] = (int)y;
		}
	}

	for (j = 1; j < IMAGE_Y - 1; j++) {
		for (i = 1; i < IMAGE_X - 1; i++) {
			G_x[i][j] = (tmp_x[i+1][j-1] + 2*tmp_x[i+1][j] + tmp_x[i+1][j+1] 
				- tmp_x[i-1][j-1] - 2*tmp_x[i-1][j] - tmp_x[i-1][j+1]);
			G_y[i][j] = (tmp_y[i-1][j+1] + 2*tmp_y[i][j+1] + tmp_y[i+1][j+1]
				- tmp_y[i-1][j-1] - 2*tmp_y[i][j-1] - tmp_y[i+1][j-1]);
			//G_mag[i][j] = sqrt(G_x[i][j] * G_x[i][j] + G_y[i][j] * G_y[i][j]);
			G_mag[i][j] = norm2(G_x[i][j], G_y[i][j]);
			
			/*
			if (G_mag[i][j] > MAX_GRADIENT) {
				MAX_GRADIENT = G_mag[i][j];
				//TRACE("p[i][j].gx = %01.f\n", p[i][j].gx);
				//TRACE("p[i][j].gy = %01.f\n", p[i][j].gy);
				//TRACE("MAX_GRADIENT = %0.1f\n", MAX_GRADIENT);
			}
			*/
		}
	}

	// Normalize each gradient value & init marked image
	//TRACE("MAX_GRADIENT = %f\n", MAX_GRADIENT);
	//TRACE("max_grad2 = %f\n", max_grad2);
	//TRACE("hi_thres = %f\n", hi_thres);
	for (j = 0; j < IMAGE_Y; j++) {
		for (i = 0; i < IMAGE_X; i++) {
			if (i == 0 || i == IMAGE_X-1 || j == 0 || j == IMAGE_Y-1) {
				image2[i][j] = 255;
				thin_edge[i][j] = 0; // init thin edge list
				continue;
			}
			G_mag[i][j] = (G_mag[i][j] / max_grad2); // G_mag between [0, 1]
			image2[i][j] = (int)(G_mag[i][j] * 255);

			//marked[i][j] = 0; // init marked image for hysteresis
			thin_edge[i][j] = 0; // init thin edge list
		}
	}

	double	gx, gy;
	double	g, g1, g2, g3, g4;
	double	t; // interpolation parameter
	
	//////////////////////////////////////////
	// Nonmaxima suppression
	for (j = 1; j < IMAGE_Y-1; j++) {
		for (i = 1; i < IMAGE_X-1; i++) {
			gx = G_x[i][j];
			gy = G_y[i][j];
			g = G_mag[i][j];
			//TRACE("gx = %f, gy = %f, g = %f\n", gx, gy, g);
			//if (gx < 0.01 && gy < 0.01) continue; // not an edge
			if (fabs(gx) >= fabs(gy)) { // close to horizontal (note: gy can be 0)
				t = fabs(gy) / fabs(gx); 
				//TRACE("t = %f\n", t);
				g1 = G_mag[i+1][j]; // right
				g2 = G_mag[i-1][j]; // left
				//TRACE("g1 = %f, g2 = %f\n", g1, g2);
				if (gx*gy >= 0.0) { // 1 or 3 quadrant
					g3 = G_mag[i+1][j+1]; // right up
					g4 = G_mag[i-1][j-1]; // left down
				}
				else { // 2 or 4 quadrant
					g3 = G_mag[i+1][j-1]; // right down
					g4 = G_mag[i-1][j+1]; // left up
				}
			}
			else { // close to vertical (note: gx can be 0)
				t = fabs(gx) / fabs(gy);
				g1 = G_mag[i][j+1]; // up
				g2 = G_mag[i][j-1]; // down
				if (gx*gy >= 0.0) { // 1 or 3 quadrant
					g3 = G_mag[i+1][j+1]; // up right
					g4 = G_mag[i-1][j-1]; // down left
				}
				else { // 2 or 4 quadrant
					g3 = G_mag[i-1][j+1]; // up left
					g4 = G_mag[i+1][j-1]; // down right
				}
			}
			if ( g > ((1-t)*g1 + t*g3) && g > ((1-t)*g2 + t*g4) ) {
                thin_edge[i][j] = 1; // it's a thin edge
				if (pixel_mark[i][j]) { // selected pixels
					//TRACE("g = %f\n", g);
					if (g > hi_thres) {
					//if (g > 0.0) {
						//rr = Dbuffer[(j * IMAGE_X + i) * 3 + 0];
						//gg = Dbuffer[(j * IMAGE_X + i) * 3 + 1];
						//bb = Dbuffer[(j * IMAGE_X + i) * 3 + 2];
						/*
						if ( prob2((double)rr, (double)gg, (double)bb, g, off_edge, factor1) )
							off_mark[i][j] = 255; // off edge
						*/
						image2[i][j] = 0; // thin edge above hi_thres
					}
					else 
						image2[i][j] = 255; // thin edge below hi_thres
				}
				else {
					if (g > hi_thres2) {
						image2[i][j] = 0; // thin edge above hi_thres
					}
					else 
						image2[i][j] = 255; // thin edge below hi_thres
				}
			}
			else { // non-maximum
				image2[i][j] = 255;
			}
			
		}
	}

	//////////////////////////////////////////
	// Hysteresis thresholding
	/*
	for (j = 1; j < IMAGE_Y-1; j++) {
		for (i = 1; i < IMAGE_X-1; i++) {
			if (image2[i][j] == 0) { // computed thinned edges above hi_thres
				adaptive_hyster_visit(i, j, image2, lo_thres, lo_thres2); // visit neighboring pixels
			}
		}
	}
	*/
	//////////////////////////////////////////
	// removing off_edges
	/*
	for (j = 1; j < IMAGE_Y-1; j++) {
		for (i = 1; i < IMAGE_X-1; i++) {
			if (off_mark[i][j] == 255) { // marked off edge
				off_edge_visit(IMAGE_X, IMAGE_Y, i, j); // visit neighboring pixels
			}
		}
	}
	*/
	
	return MAX_GRADIENT;
}

double GlobalAdaptiveCanny2(imatrix& image, imatrix& image2)
{
	int	i, j, k, i1, i2, j1, j2;
	double MAX_GRADIENT = -1;
	
	int gau_w, gau_w2;
	double hi_thres, hi_thres2, lo_thres, lo_thres2;

	gau_w = MakeGaussMask(0.8, gau);
	gau_w2 = MakeGaussMask(0.4, gau2);
	hi_thres = 0.21;
	lo_thres = 0.16;
	hi_thres2 = 0.17;
	lo_thres2 = 0.07;

	//imatrix marked(IMAGE_X, IMAGE_Y);
	//image2.init(IMAGE_X, IMAGE_Y);
	
	//imatrix tmp(IMAGE_X, IMAGE_Y);
	double	x, y;
	
	//////////////////////////////////////////////
	// Gaussian smoothing (adaptive)
	for (j = 0; j < IMAGE_Y; j++) {
		for (i = 0; i < IMAGE_X; i++) {
			if (pixel_mark[i][j] <= 102) { // foreground pixels
				x = gau[0] * image[i][j];	
				y = gau[0] * image[i][j];
				//TRACE("x = %f, y = %f\n", x, y);
				for (k = 1; k < gau_w; k++) {
					i1 = (i+k)%IMAGE_X;
					i2 = (i-k+IMAGE_X)%IMAGE_X;
					x += gau[k] * image[i1][j] + gau[k] * image[i2][j];
					j1 = (j+k)%IMAGE_Y;
					j2 = (j-k+IMAGE_Y)%IMAGE_Y;
					y += gau[k] * image[i][j1] + gau[k] * image[i][j2];
				}
				tmp_x[i][j] = x;
				tmp_y[i][j] = y;
			}
			else { // other area
				x = gau2[0] * image[i][j];	
				y = gau2[0] * image[i][j];
				//TRACE("x = %f, y = %f\n", x, y);
				for (k = 1; k < gau_w2; k++) {
					i1 = (i+k)%IMAGE_X;
					i2 = (i-k+IMAGE_X)%IMAGE_X;
					x += gau2[k] * image[i1][j] + gau2[k] * image[i2][j];
					j1 = (j+k)%IMAGE_Y;
					j2 = (j-k+IMAGE_Y)%IMAGE_Y;
					y += gau2[k] * image[i][j1] + gau2[k] * image[i][j2];
				}
				tmp_x[i][j] = x;
				tmp_y[i][j] = y;
			}
			//TRACE("x = %f, y = %f\n", x, y);
			if (x > 255) x = 255;
			if (y > 255) y = 255;
			//image[i][j] = (int)x;
			//image[i][j] = (int)y;
		}
	}

	for (j = 1; j < IMAGE_Y - 1; j++) {
		for (i = 1; i < IMAGE_X - 1; i++) {
			G_x[i][j] = (tmp_x[i+1][j-1] + 2*tmp_x[i+1][j] + tmp_x[i+1][j+1] 
				- tmp_x[i-1][j-1] - 2*tmp_x[i-1][j] - tmp_x[i-1][j+1]);
			G_y[i][j] = (tmp_y[i-1][j+1] + 2*tmp_y[i][j+1] + tmp_y[i+1][j+1]
				- tmp_y[i-1][j-1] - 2*tmp_y[i][j-1] - tmp_y[i+1][j-1]);
			//G_mag[i][j] = sqrt(G_x[i][j] * G_x[i][j] + G_y[i][j] * G_y[i][j]);
			G_mag[i][j] = norm2(G_x[i][j], G_y[i][j]);
			
			/*
			if (G_mag[i][j] > MAX_GRADIENT) {
				MAX_GRADIENT = G_mag[i][j];
				//TRACE("p[i][j].gx = %01.f\n", p[i][j].gx);
				//TRACE("p[i][j].gy = %01.f\n", p[i][j].gy);
				//TRACE("MAX_GRADIENT = %0.1f\n", MAX_GRADIENT);
			}
			*/
		}
	}

	// Normalize each gradient value & init marked image
	//TRACE("MAX_GRADIENT = %f\n", MAX_GRADIENT);
	//TRACE("max_grad2 = %f\n", max_grad2);
	//TRACE("hi_thres = %f\n", hi_thres);
	for (j = 0; j < IMAGE_Y; j++) {
		for (i = 0; i < IMAGE_X; i++) {
			if (i == 0 || i == IMAGE_X-1 || j == 0 || j == IMAGE_Y-1) {
				image2[i][j] = 255;
				thin_edge[i][j] = 0; // init thin edge list
				continue;
			}
			G_mag[i][j] = (G_mag[i][j] / max_grad2); // G_mag between [0, 1]
			image2[i][j] = (int)(G_mag[i][j] * 255);

			//marked[i][j] = 0; // init marked image for hysteresis
			thin_edge[i][j] = 0; // init thin edge list
		}
	}

	double	gx, gy;
	double	g, g1, g2, g3, g4;
	double	t; // interpolation parameter
	
	//////////////////////////////////////////
	// Nonmaxima suppression
	for (j = 1; j < IMAGE_Y-1; j++) {
		for (i = 1; i < IMAGE_X-1; i++) {
			gx = G_x[i][j];
			gy = G_y[i][j];
			g = G_mag[i][j];
			//TRACE("gx = %f, gy = %f, g = %f\n", gx, gy, g);
			//if (gx < 0.01 && gy < 0.01) continue; // not an edge
			if (fabs(gx) >= fabs(gy)) { // close to horizontal (note: gy can be 0)
				t = fabs(gy) / fabs(gx); 
				//TRACE("t = %f\n", t);
				g1 = G_mag[i+1][j]; // right
				g2 = G_mag[i-1][j]; // left
				//TRACE("g1 = %f, g2 = %f\n", g1, g2);
				if (gx*gy >= 0.0) { // 1 or 3 quadrant
					g3 = G_mag[i+1][j+1]; // right up
					g4 = G_mag[i-1][j-1]; // left down
				}
				else { // 2 or 4 quadrant
					g3 = G_mag[i+1][j-1]; // right down
					g4 = G_mag[i-1][j+1]; // left up
				}
			}
			else { // close to vertical (note: gx can be 0)
				t = fabs(gx) / fabs(gy);
				g1 = G_mag[i][j+1]; // up
				g2 = G_mag[i][j-1]; // down
				if (gx*gy >= 0.0) { // 1 or 3 quadrant
					g3 = G_mag[i+1][j+1]; // up right
					g4 = G_mag[i-1][j-1]; // down left
				}
				else { // 2 or 4 quadrant
					g3 = G_mag[i-1][j+1]; // up left
					g4 = G_mag[i+1][j-1]; // down right
				}
			}
			if ( g > ((1-t)*g1 + t*g3) && g > ((1-t)*g2 + t*g4) ) {
                thin_edge[i][j] = 1; // it's a thin edge
				if (pixel_mark[i][j] <= 102) { // foreground pixels
					//TRACE("g = %f\n", g);
					if (g > hi_thres) {
					//if (g > 0.0) {
						//rr = Dbuffer[(j * IMAGE_X + i) * 3 + 0];
						//gg = Dbuffer[(j * IMAGE_X + i) * 3 + 1];
						//bb = Dbuffer[(j * IMAGE_X + i) * 3 + 2];
						/*
						if ( prob2((double)rr, (double)gg, (double)bb, g, off_edge, factor1) )
							off_mark[i][j] = 255; // off edge
						*/
						image2[i][j] = 0; // thin edge above hi_thres
					}
					else 
						image2[i][j] = 255; // thin edge below hi_thres
				}
				else {
					if (g > hi_thres2) {
						image2[i][j] = 0; // thin edge above hi_thres
					}
					else 
						image2[i][j] = 255; // thin edge below hi_thres
				}
			}
			else { // non-maximum
				image2[i][j] = 255;
			}
			
		}
	}

	//////////////////////////////////////////
	// Hysteresis thresholding
	///*
	for (j = 1; j < IMAGE_Y-1; j++) {
		for (i = 1; i < IMAGE_X-1; i++) {
			if (image2[i][j] == 0) { // computed thinned edges above hi_thres
				adaptive_hyster_visit(i, j, image2, lo_thres, lo_thres2); // visit neighboring pixels
			}
		}
	}
	//*/
	//////////////////////////////////////////
	// removing off_edges
	/*
	for (j = 1; j < IMAGE_Y-1; j++) {
		for (i = 1; i < IMAGE_X-1; i++) {
			if (off_mark[i][j] == 255) { // marked off edge
				off_edge_visit(IMAGE_X, IMAGE_Y, i, j); // visit neighboring pixels
			}
		}
	}
	*/
	
	return MAX_GRADIENT;
}

void OnGlobalSegment(CDC& dc)
{
	if (file_loaded) {
		//GlobalSegment(pix_d[pix_d_count], pixel_mark);
		GlobalSegmentAll(pix_d, pixel_mark);
		//GlobalAdaptiveCanny(gray, gray2);
		GlobalAdaptiveCanny2(gray, gray2);
		DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, pixel_mark);
		//DrawGrayImage(memDC, IMAGE_X, IMAGE_Y, gray2);
		dc.BitBlt(0, 0, IMAGE_X, IMAGE_Y, &memDC, 0, 0, SRCCOPY);
	}
}

////////////////////////////////////////////////////////////
// time measuring
static time_t StartingTime;   // starting time of clock 

// Function to initialize static global variable StartingTime
// to the number of ticks of the clock
// Pre:  none
// Post: StartingTime has been initialized to clock()
//

void StartTimer(void)
{
   StartingTime = clock();
}

//
// Function to return the elapsed time in seconds since 
// static global variable StartingTime was initialized
// Pre:  StartingTime has been initialized to a value of clock.
// Post: The elapsed time since the initialization of StartingTime 
//       has been returned.
//

double ElapsedTime(void)
{
   //return (double(clock() - StartingTime));
   return (double(clock() - StartingTime)/CLOCKS_PER_SEC);
}

void GetGrayImageFromMemDC(int image_x, int image_y, imatrix& image, CDC& dc)
{
	GLubyte	r, g, b;
	int 	min, max;
	int 	x, y;

	//image.init(image_x, image_y);

	for (y=0; y < image_y; y++) {
		for (x=0; x < image_x; x++) {
			r = (GLubyte)RGB_GETRED(dc.GetPixel(x, image_y-1-y));
			g = (GLubyte)RGB_GETGREEN(dc.GetPixel(x, image_y-1-y));
			b = (GLubyte)RGB_GETBLUE(dc.GetPixel(x, image_y-1-y));
			if (r > g) {
				max = r;
				min = g;
			}
			else {	
				max = g;
				min = r;	
			}
			if (b > max)
				max = b;
			else if (b < min)
				min = b;
			image[x][y] = (int) ((min + max) / 2.0);

		}
	}
}

void GetColorImageFromMemDC(int image_x, int image_y, cimatrix& cmap, CDC& dc)
{
	//GLubyte	r, g, b;
	int 	x, y;

	//image.init(image_x, image_y);

	for (y=0; y < image_y; y++) {
		for (x=0; x < image_x; x++) {
			cmap[x][y].r = (GLubyte)RGB_GETRED(dc.GetPixel(x, image_y-1-y));
			cmap[x][y].g = (GLubyte)RGB_GETGREEN(dc.GetPixel(x, image_y-1-y));
			cmap[x][y].b = (GLubyte)RGB_GETBLUE(dc.GetPixel(x, image_y-1-y));
		}
	}
}
