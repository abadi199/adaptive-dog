// generated by classgen.pl

#ifndef MYLIST_H
#define MYLIST_H

#include <cstdlib>

template <class T> class MyListNode {
public:
	T* obj_ptr;
	MyListNode<T>* nextNode;
	MyListNode<T>* prevNode;
public:
	MyListNode () { prevNode = nextNode = NULL; } 
	~MyListNode () { 
		if (obj_ptr == NULL) {
			TRACE("~MyListNode(): obj_ptr == NULL\n");
			exit(1);
		}
		delete obj_ptr; 
	} 
	T* get() { return obj_ptr; }
	//void set(T &object) { this->object = object; }
	void set(T* obj_ptr) { this->obj_ptr = obj_ptr; }
	MyListNode<T>* getNext() { return nextNode; }
	MyListNode<T>* getPrev() { return prevNode; }
	void setNext(MyListNode<T> *nextNode) { this->nextNode = nextNode; }
	void setPrev(MyListNode<T> *prevNode) { this->prevNode = prevNode; }


};

template <class T> class MyList {
public:
	int size;
	MyListNode<T> *headNode;
	MyListNode<T> *currentNode, *lastCurrentNode;
	MyListNode<T> *lastNode;
public:
	// Constructor
	MyList() {
		//headNode = new MyListNode<T>;
		//headNode->setNext(NULL);
		headNode = NULL;
		currentNode = NULL;
		lastNode = NULL; // 
		size = 0;
	}
	// Destructor
	void ClearAll() {
		MyListNode<T> *pointerToDelete, *pointer = headNode;
		while (pointer != NULL) {
			pointerToDelete = pointer;
			pointer = pointer->getNext();
			delete pointerToDelete;
		}
	}
	~MyList() {
		ClearAll();
	}
	void init() {
		ClearAll();
		headNode = NULL;
		currentNode = NULL;
		lastNode = NULL; // 
		size = 0;
	}
	T* Get() { 
		if (currentNode == NULL) 
			Start();
		return currentNode->get(); // return the pointer to the object
	}
	T* operator[](int index) { 
		//if (currentNode == NULL) 
		//	start();
		if (index > size-1) return NULL; // index range error
		MyListNode<T>* s = headNode;
		for (int count = 0; s; s = s->getNext(), count++) {
			if (count == index) return s->get(); // return the pointer to the node
		}
		TRACE("MyList operator[]: coudn't find the element!\n");
		exit(1);
	}
	MyListNode<T>* AddHead(T* addObject) { // add the item to the head
		MyListNode<T> *newNode = new MyListNode<T>;
		newNode->set(addObject);
		if (headNode == NULL) {
			lastNode = newNode; // this will also be the lastnode
		}
		else { // at least one headnode
			newNode->setNext(headNode);
			headNode->setPrev(newNode);
		}
		headNode = newNode;
		size++;
		return newNode;
	}
	MyListNode<T>* AddRear(T* addObject) { // 
		MyListNode<T> *newNode = new MyListNode<T>;
		newNode->set(addObject);
		if (headNode == NULL) { // There's no node in the list
			headNode = newNode; // this will also be the headnode
		}
		else { // there's at least one node in the list
			newNode->setPrev(lastNode);
			lastNode->setNext(newNode);
		}
		lastNode = newNode;
		size++;
		return newNode; 
	}
	void Print() {
		if (headNode == NULL) return;
		MyListNode<T>* s = headNode;
		for (; s; s = s->getNext()) {
			TRACE("s->object.xc = %d ", s->object.xc);
		}
	}
	/*
	MyListNode<T>* RandomSelect() {
		if (headNode == NULL) return NULL;

		//srand( (unsigned)time( NULL ) );

		int N = (int) ( (size-1) * (float)rand() / RAND_MAX );
		//TRACE("size = %d, N = %d\n", size, N);
		MyListNode<T>* s = headNode;
		for (int count = 0; s; s = s->getNext(), count++) {
			if (count == N) return s;
		}
	}
	*/
	T* RandomSelect() { // return the T object, not the node
		if (headNode == NULL) return NULL;

		//srand( (unsigned)time( NULL ) );

		int N = (int) ( (size-1) * (float)rand() / RAND_MAX );
		//TRACE("size = %d, N = %d\n", size, N);
		MyListNode<T>* s = headNode;
		for (int count = 0; s; s = s->getNext(), count++) {
			if (count == N) return s->get();
		}
	}
	void Remove() {
		lastCurrentNode->setNext(currentNode->getNext());
		delete currentNode;
		currentNode = lastCurrentNode;
		size--;
	}
	void Remove(MyListNode<T>* node) {
		if (node == NULL) return;

		if (node->prevNode && node->nextNode) { // neither headNode nor lastNode
			node->prevNode->nextNode = node->nextNode;
			node->nextNode->prevNode = node->prevNode;
		}
		else if (node->prevNode == NULL && node->nextNode == NULL) { // headNode and lastNode
			headNode = NULL;
			lastNode = NULL;
		}
		else if (node->prevNode == NULL) { // headNode
			TRACE("LET's REMOVE HEADNODE!\n");
			node->nextNode->prevNode = NULL;	
			headNode = node->nextNode;
		}
		else if (node->nextNode == NULL) { // lastNode
			node->prevNode->nextNode = NULL;
			lastNode = node->prevNode;
		}
		//lastCurrentNode->setNext(currentNode->getNext());
		delete node;
		//currentNode = lastCurrentNode;
		size--;
	}
	void RemoveRearNode() {
		MyListNode<T>* node = lastNode; 

		if (node == NULL) return;

		if (node->prevNode == NULL) { // headNode and lastNode
			headNode = NULL;
			lastNode = NULL;
		}
		else { // lastNode but not headNode
			node->prevNode->nextNode = NULL;
			lastNode = node->prevNode;
		}
		//lastCurrentNode->setNext(currentNode->getNext());
		delete node;
		//currentNode = lastCurrentNode;
		size--;
	}
	void Start() {
		lastCurrentNode = headNode;
		currentNode = headNode;
	}
	bool Next() {
		// If the currentNode now points at nothing, we've reached the end
		if (currentNode == NULL)
			return false;

		// Update the last node and current node
		lastCurrentNode = currentNode;
		currentNode = currentNode->getNext();

		// If currentNode points at nothing or there is nothing added, we can immediately return false
		if (currentNode == NULL || size == 0) 
			return false;
		else
			return true;
	}
	int Size() { return size; };
};

#endif
