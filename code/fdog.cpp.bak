#include "stdafx.h"

#include <cmath>
#include "globals.h"

#include "fdog.h"
#include "myvec.h"

#define ABS(x) ( ((x)>0) ? (x) : (-(x)) )

inline double gauss(double x, double mean, double sigma)
{
	return ( exp( (-(x-mean)*(x-mean)) / (2*sigma*sigma) ) / sqrt(PI * 2.0 * sigma * sigma) );
}

void MakeGaussianVector(double sigma, myvec& GAU)
{
	int i, j;

	double threshold = 0.001;

	i = 0;
	while(1) {
		i++;
		if ( gauss((double)i, 0.0, sigma) < threshold )
			break;
	}
	GAU.init(i+1); // size of GAU myvec
	GAU.zero(); 

	GAU[0] = gauss((double)0.0, 0.0, sigma);
	for (j = 1; j < GAU.getMax(); j++) {
		GAU[j] = gauss((double)j, 0.0, sigma);
	}
}

void GetDirectionalDoG(imatrix& image, ETF& e, mymatrix& dog, myvec& GAU1, myvec& GAU2, double tau)
{
	myvec vn(2);
	double x, y, d_x, d_y;
	double weight1, weight2, w_sum1, sum1, sum2, w_sum2;

	int s;
	int x1, y1;
	int i, j;
	int dd;
	double val;

	int half_w1, half_w2;

	half_w1 = GAU1.getMax()-1;
	half_w2 = GAU2.getMax()-1;

	int image_x, image_y;

	image_x = image.getRow();
	image_y = image.getCol();
	
	int flow_DOG_sign = 0; 
	
	for (i = 0; i < image_x; i++) {
		for (j = 0; j < image_y; j++) {
			sum1 = sum2 = 0.0;
			w_sum1 = w_sum2 = 0.0;
			weight1 = weight2 = 0.0;
	
			vn[0] = -e[i][j].ty;
			vn[1] = e[i][j].tx;

			if (vn[0] == 0.0 && vn[1] == 0.0) {
				sum1 = 255.0;
				sum2 = 255.0;
				dog[i][j] = sum1 - tau * sum2;
				continue;
			}
			d_x = i; d_y = j;
			////////////////////////////////////////
			for (s = -half_w2; s <= half_w2; s++) { 
				////////////////////////
				x = d_x + vn[0] * s;
				y = d_y + vn[1] * s;
				/////////////////////////////////////////////////////
				if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
					continue;
				x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				val = image[x1][y1];
				/////////////////////////////////////////////////////////
				dd = ABS(s);
				if (dd > half_w1) weight1 = 0.0;
				else weight1 = GAU1[dd];
				//////////////////////////////////
				sum1 += val * weight1;
				w_sum1 += weight1;
				/////////////////////////////////////////////////////
				weight2 = GAU2[dd];
				sum2 += val * weight2;
				w_sum2 += weight2;
			}
			/////////////////////////
			sum1 /= w_sum1; 
			sum2 /= w_sum2; 
			//////////////////////////////////////
			dog[i][j] = sum1 - tau * sum2;
		}
	}
}

void GetDirectionalDoGSubpixel(imatrix& image, ETF& e, mymatrix& dog, myvec& GAU1, myvec& GAU2, double tau)
{
	myvec vn(2);
	double x, y, d_x, d_y;
	double weight1, weight2, w_sum1, sum1, sum2, w_sum2;

	int s;
	int x1, y1, x2, y2;
	double lt, lb, rt, rb;
	double uu, vv, bb, tt;
	int i, j;
	int dd;
	double val;

	int half_w1, half_w2;

	half_w1 = GAU1.getMax()-1;
	half_w2 = GAU2.getMax()-1;

	int image_x, image_y;

	image_x = image.getRow();
	image_y = image.getCol();
	
	int flow_DOG_sign = 0; 
	
	for (i = 0; i < image_x; i++) {
		for (j = 0; j < image_y; j++) {
			sum1 = sum2 = 0.0;
			w_sum1 = w_sum2 = 0.0;
			weight1 = weight2 = 0.0;
	
			vn[0] = -e[i][j].ty;
			vn[1] = e[i][j].tx;

			if (vn[0] == 0.0 && vn[1] == 0.0) {
				sum1 = 255.0;
				sum2 = 255.0;
				dog[i][j] = sum1 - tau * sum2;
				continue;
			}
			d_x = i; d_y = j;
			////////////////////////////////////////
			for (s = -half_w2; s <= half_w2; s++) { 
				////////////////////////
				x = d_x + vn[0] * s;
				y = d_y + vn[1] * s;
				/////////////////////////////////////////////////////
				if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
					continue;
				/////////////////////////////////////////
				x1 = (int)x;	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				x2 = (int)x+1;	if (x2 < 0) x2 = 0; if (x2 > IMAGE_X-1) x2 = IMAGE_X-1;
				y1 = (int)y;	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				y2 = (int)y+1;	if (y2 < 0) y2 = 0; if (y2 > IMAGE_Y-1) y2 = IMAGE_Y-1;
				lb = (double)image[x1][y1];
				rb = (double)image[x2][y1];
				lt = (double)image[x1][y2];
				rt = (double)image[x2][y2];
				uu = x - x1;
				vv = y - y1;
				bb = (1-uu) * lb + uu * rb;
				tt = (1-uu) * lt + uu * rt;
				val = (1-vv) * bb + vv * tt;
				
				//val = image[x1][y1];
				/////////////////////////////////////////////////////////
				dd = ABS(s);
				if (dd > half_w1) weight1 = 0.0;
				else weight1 = GAU1[dd];
				//////////////////////////////////
				sum1 += val * weight1;
				w_sum1 += weight1;
				/////////////////////////////////////////////////////
				weight2 = GAU2[dd];
				sum2 += val * weight2;
				w_sum2 += weight2;
			}
			/////////////////////////
			sum1 /= w_sum1; 
			sum2 /= w_sum2; 
			//////////////////////////////////////
			dog[i][j] = sum1 - tau * sum2;
		}
	}
}


void GetFlowInfluence(ETF& e, mymatrix& dog, mymatrix& tmp, myvec& GAU3)
// Find influence zone!
{
	myvec vt(2);
	double x, y, d_x, d_y;
	double weight1, w_sum1, sum1;

	int i_x, i_y, k;
	int x1, y1;
	double val;
	int i, j;

	int image_x = dog.getRow();
	int image_y = dog.getCol();

	int half_l;
	half_l = GAU3.getMax()-1;
	
	int flow_DOG_sign = 0; 
	
	double step_size = 1.0; 

	for (i = 0; i < image_x; i++) {
		for (j = 0; j < image_y; j++) {
			sum1 = 0.0;
			w_sum1 = 0.0;
			weight1 = 0.0;
			/////////////////////////////////
			val = dog[i][j];
			weight1 = GAU3[0]; 
			sum1 = val * weight1;
			w_sum1 += weight1;
			////////////////////////////////////////////////
			d_x = (double)i; d_y = (double)j; 
			i_x = i; i_y = j;
			////////////////////////////
			for (k = 0; k < half_l; k++) {
				vt[0] = e[i_x][i_y].tx;
				vt[1] = e[i_x][i_y].ty;
				if (vt[0] == 0.0 && vt[1] == 0.0) {
					break;
				}
				x = d_x;
				y = d_y;
				/////////////////////////////////////////////////////
				if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
					break;
				x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				val = dog[x1][y1];
				//////////////////////////////
				weight1 = GAU3[k]; 
				////////////////////
				sum1 += val * weight1;
				w_sum1 += weight1;
				/////////////////////////////////////////
				d_x += vt[0] * step_size; 
				d_y += vt[1] * step_size; 
				/////////////////////////////////////////
				i_x = round(d_x); 
				i_y = round(d_y); 
				if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
				/////////////////////////
			}
			////////////////////////////////////////////////
			d_x = (double)i; d_y = (double)j; 
			i_x = i; i_y = j;
			for (k = 0; k < half_l; k++) {
				vt[0] = -e[i_x][i_y].tx;
				vt[1] = -e[i_x][i_y].ty;
				if (vt[0] == 0.0 && vt[1] == 0.0) {
					break;
				}
				x = d_x;
				y = d_y;
				/////////////////////////////////////////////////////
				if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
					break;
				x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				val = dog[x1][y1];
				//////////////////////////////
				weight1 = GAU3[k]; 
				////////////////////
				sum1 += val * weight1;
				w_sum1 += weight1;
				/////////////////////////////////////////
				d_x += vt[0] * step_size; 
				d_y += vt[1] * step_size; 
				/////////////////////////////////////////
				i_x = round(d_x); 
				i_y = round(d_y); 
				if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
				/////////////////////////
			}
			////////////////////////////////////////
			sum1 /= w_sum1; 
			//////////////////////////////////////
			if (sum1 > 0) tmp[i][j] = 1.0; 
			else tmp[i][j] = 1.0 + tanh(sum1);
		}
	}
}

void GetFlowDoG(ETF& e, mymatrix& dog, mymatrix& tmp, myvec& GAU3)
{
	myvec vt(2);
	double x, y, d_x, d_y;
	double weight1, w_sum1, sum1;

	int i_x, i_y, k;
	int x1, y1;
	double val;
	int i, j;

	int image_x = dog.getRow();
	int image_y = dog.getCol();

	int half_l;
	half_l = GAU3.getMax()-1;
	
	int flow_DOG_sign = 0; 
	
	double step_size = 1.0; 

	for (i = 0; i < image_x; i++) {
		for (j = 0; j < image_y; j++) {
			sum1 = 0.0;
			w_sum1 = 0.0;
			weight1 = 0.0;
			/////////////////////////////////
			val = dog[i][j];
			weight1 = GAU3[0]; 
			sum1 = val * weight1;
			w_sum1 += weight1;
			////////////////////////////////////////////////
			d_x = (double)i; d_y = (double)j; 
			i_x = i; i_y = j;
			////////////////////////////
			for (k = 0; k < half_l; k++) {
				vt[0] = e[i_x][i_y].tx;
				vt[1] = e[i_x][i_y].ty;
				if (vt[0] == 0.0 && vt[1] == 0.0) {
					break;
				}
				x = d_x;
				y = d_y;
				/////////////////////////////////////////////////////
				if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
					break;
				x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				val = dog[x1][y1];
				//////////////////////////////
				weight1 = GAU3[k]; 
				//weight1 = 1.0; // box filter
				////////////////////
				sum1 += val * weight1;
				w_sum1 += weight1;
				/////////////////////////////////////////
				d_x += vt[0] * step_size; 
				d_y += vt[1] * step_size; 
				/////////////////////////////////////////
				i_x = round(d_x); 
				i_y = round(d_y); 
				if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
				/////////////////////////
			}
			////////////////////////////////////////////////
			d_x = (double)i; d_y = (double)j; 
			i_x = i; i_y = j;
			for (k = 0; k < half_l; k++) {
				vt[0] = -e[i_x][i_y].tx;
				vt[1] = -e[i_x][i_y].ty;
				if (vt[0] == 0.0 && vt[1] == 0.0) {
					break;
				}
				x = d_x;
				y = d_y;
				/////////////////////////////////////////////////////
				if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
					break;
				x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				val = dog[x1][y1];
				//////////////////////////////
				weight1 = GAU3[k]; 
				//weight1 = 1.0; // box filter
				////////////////////
				sum1 += val * weight1;
				w_sum1 += weight1;
				/////////////////////////////////////////
				d_x += vt[0] * step_size; 
				d_y += vt[1] * step_size; 
				/////////////////////////////////////////
				i_x = round(d_x); 
				i_y = round(d_y); 
				if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
				/////////////////////////
			}
			////////////////////////////////////////
			sum1 /= w_sum1; 
			//////////////////////////////////////
			if (sum1 > 0) tmp[i][j] = 1.0; 
			else tmp[i][j] = 1.0 + tanh(sum1);
		}
	}
}

void GetFlowDoGSubpixel(ETF& e, mymatrix& dog, mymatrix& tmp, myvec& GAU3)
{
	myvec vt(2);
	double x, y, d_x, d_y;
	double weight1, w_sum1, sum1;

	int i_x, i_y, k;
	int x1, y1, x2, y2;
	double lt, lb, rt, rb;
	double uu, vv, bb, tt;
	double val;
	int i, j;

	int image_x = dog.getRow();
	int image_y = dog.getCol();

	int half_l;
	half_l = GAU3.getMax()-1;
	
	int flow_DOG_sign = 0; 
	
	double step_size = 1.0; 

	for (i = 0; i < image_x; i++) {
		for (j = 0; j < image_y; j++) {
			sum1 = 0.0;
			w_sum1 = 0.0;
			weight1 = 0.0;
			/////////////////////////////////
			val = dog[i][j];
			weight1 = GAU3[0]; 
			sum1 = val * weight1;
			w_sum1 += weight1;
			////////////////////////////////////////////////
			d_x = (double)i; d_y = (double)j; 
			i_x = i; i_y = j;
			////////////////////////////
			for (k = 0; k < half_l; k++) {
				vt[0] = e[i_x][i_y].tx;
				vt[1] = e[i_x][i_y].ty;
				if (vt[0] == 0.0 && vt[1] == 0.0) {
					break;
				}
				x = d_x;
				y = d_y;
				/////////////////////////////////////////////////////
				if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
					break;
				////////////////////////////////////////////////////////////////////////
				x1 = (int)x;	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				x2 = (int)x+1;	if (x2 < 0) x2 = 0; if (x2 > IMAGE_X-1) x2 = IMAGE_X-1;
				y1 = (int)y;	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				y2 = (int)y+1;	if (y2 < 0) y2 = 0; if (y2 > IMAGE_Y-1) y2 = IMAGE_Y-1;
				lb = dog[x1][y1];
				rb = dog[x2][y1];
				lt = dog[x1][y2];
				rt = dog[x2][y2];
				uu = x - x1;
				vv = y - y1;
				bb = (1-uu) * lb + uu * rb;
				tt = (1-uu) * lt + uu * rt;
				val = (1-vv) * bb + vv * tt;

				//val = dog[x1][y1];
				//////////////////////////////
				weight1 = GAU3[k]; 
				//weight1 = 1.0; // box filter
				////////////////////
				sum1 += val * weight1;
				w_sum1 += weight1;
				/////////////////////////////////////////
				d_x += vt[0] * step_size; 
				d_y += vt[1] * step_size; 
				/////////////////////////////////////////
				i_x = round(d_x); 
				i_y = round(d_y); 
				if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
				/////////////////////////
			}
			////////////////////////////////////////////////
			d_x = (double)i; d_y = (double)j; 
			i_x = i; i_y = j;
			for (k = 0; k < half_l; k++) {
				vt[0] = -e[i_x][i_y].tx;
				vt[1] = -e[i_x][i_y].ty;
				if (vt[0] == 0.0 && vt[1] == 0.0) {
					break;
				}
				x = d_x;
				y = d_y;
				/////////////////////////////////////////////////////
				if (x > (double)IMAGE_X-1 || x < 0.0 || y > (double)IMAGE_Y-1 || y < 0.0) 
					break;
				////////////////////////////////////////////////////////////////////////
				x1 = (int)x;	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				x2 = (int)x+1;	if (x2 < 0) x2 = 0; if (x2 > IMAGE_X-1) x2 = IMAGE_X-1;
				y1 = (int)y;	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				y2 = (int)y+1;	if (y2 < 0) y2 = 0; if (y2 > IMAGE_Y-1) y2 = IMAGE_Y-1;
				lb = dog[x1][y1];
				rb = dog[x2][y1];
				lt = dog[x1][y2];
				rt = dog[x2][y2];
				uu = x - x1;
				vv = y - y1;
				bb = (1-uu) * lb + uu * rb;
				tt = (1-uu) * lt + uu * rt;
				val = (1-vv) * bb + vv * tt;
				//////////////////////////////
				weight1 = GAU3[k]; 
				//weight1 = 1.0; // box filter
				////////////////////
				sum1 += val * weight1;
				w_sum1 += weight1;
				/////////////////////////////////////////
				d_x += vt[0] * step_size; 
				d_y += vt[1] * step_size; 
				/////////////////////////////////////////
				i_x = round(d_x); 
				i_y = round(d_y); 
				if (d_x < 0 || d_x > IMAGE_X-1 || d_y < 0 || d_y > IMAGE_Y-1) break;
				/////////////////////////
			}
			////////////////////////////////////////
			sum1 /= w_sum1; 
			//////////////////////////////////////
			if (sum1 > 0) tmp[i][j] = 1.0; 
			else tmp[i][j] = 1.0 + tanh(sum1);
		}
	}
}

void GetFDoG(imatrix& image, ETF& e, double sigma, double sigma3, double tau) 
{
	int	i, j;

    int image_x = image.getRow();
	int image_y = image.getCol();

	myvec GAU1, GAU2, GAU3;
	MakeGaussianVector(sigma, GAU1); 
	MakeGaussianVector(sigma*1.6, GAU2); 

	int half_w1, half_w2, half_l;
	half_w1 = GAU1.getMax()-1;
	half_w2 = GAU2.getMax()-1;
	
	MakeGaussianVector(sigma3, GAU3); 
	half_l = GAU3.getMax()-1;
	
	mymatrix tmp(image_x, image_y);
	mymatrix dog(image_x, image_y);

	GetDirectionalDoG(image, e, dog, GAU1, GAU2, tau);
	GetFlowDoG(e, dog, tmp, GAU3);

	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			image[i][j] = round(tmp[i][j] * 255.);
		}
	}
}

void GetFDoGDoubleSubpixel(imatrix& image, ETF& e, matrix& gmag, double sigma, double sigma3, double tau) 
// store the fdog value as double for later nonmaxima suppression
// Also, do the computation using bilinear intepolation (avoids aliasing)
{
	int	i, j;

    int image_x = image.getRow();
	int image_y = image.getCol();

	myvec GAU1, GAU2, GAU3;
	MakeGaussianVector(sigma, GAU1); 
	MakeGaussianVector(sigma*1.6, GAU2); 

	int half_w1, half_w2, half_l;
	half_w1 = GAU1.getMax()-1;
	half_w2 = GAU2.getMax()-1;
	
	MakeGaussianVector(sigma3, GAU3); 
	half_l = GAU3.getMax()-1;
	
	mymatrix tmp(image_x, image_y);
	mymatrix dog(image_x, image_y);

	GetDirectionalDoGSubpixel(image, e, dog, GAU1, GAU2, tau);
	GetFlowDoGSubpixel(e, dog, tmp, GAU3);

	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			image[i][j] = round(tmp[i][j] * 255.);
			gmag[i][j] = tmp[i][j]; // the smaller, the stronger gradient
		}
	}
}

void GetFDoGDouble(imatrix& image, ETF& e, matrix& gmag, double sigma, double sigma3, double tau) 
// store the fdog value as double for later nonmaxima suppression
{
	int	i, j;

    int image_x = image.getRow();
	int image_y = image.getCol();

	myvec GAU1, GAU2, GAU3;
	MakeGaussianVector(sigma, GAU1); 
	MakeGaussianVector(sigma*1.6, GAU2); 

	int half_w1, half_w2, half_l;
	half_w1 = GAU1.getMax()-1;
	half_w2 = GAU2.getMax()-1;
	
	MakeGaussianVector(sigma3, GAU3); 
	half_l = GAU3.getMax()-1;
	
	mymatrix tmp(image_x, image_y);
	mymatrix dog(image_x, image_y);

	GetDirectionalDoG(image, e, dog, GAU1, GAU2, tau);
	GetFlowDoG(e, dog, tmp, GAU3);

	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			image[i][j] = round(tmp[i][j] * 255.);
			gmag[i][j] = tmp[i][j]; // the smaller, the stronger gradient
		}
	}
}

void GetDoGLIC(imatrix& image, ETF& e, double sigma, double sigma3, double tau) 
// Coherent Line Drawing, but use DOG + LIC!
{
	int	i, j;

    int image_x = image.getRow();
	int image_y = image.getCol();

	//myvec GAU1, GAU2, GAU3;
	myvec GAU3;
	//MakeGaussianVector(sigma, GAU1); 
	//MakeGaussianVector(sigma*1.6, GAU2); 

	//int half_w1, half_w2, 
	//int half_l;
	//half_w1 = GAU1.getMax()-1;
	//half_w2 = GAU2.getMax()-1;
	
	MakeGaussianVector(sigma3, GAU3); 
	//half_l = GAU3.getMax()-1;
	
	mymatrix tmp(image_x, image_y);
	mymatrix dog(image_x, image_y);

	//GetDirectionalDoG(image, e, dog, GAU1, GAU2, tau);
	GetDogSepDouble(image, sigma, dog, tau);
	GetFlowDoG(e, dog, tmp, GAU3);

	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			image[i][j] = round(tmp[i][j] * 255.);
		}
	}
}

void GetFMedian(imatrix& image, ETF& e, int itr) 
{
	int	i, j;

    int image_x = image.getRow();
	int image_y = image.getCol();
	
	imatrix tmp(image_x, image_y);
	tmp.copy(image);

	myvec vt(2), vn(2);
	int vec[3];
	double x, y;

	int k, m;
	int x1, y1;
	double cx, cy;

	double step_size = 1.0; 

	for (m = 0; m < itr; m++) {
		/////////////////////////////////
		// gradient direction
		for (i = 0; i < image_x; i++) {
			for (j = 0; j < image_y; j++) {
				////////////////////////////
				vn[0] = -e[i][j].ty;
				vn[1] = e[i][j].tx;
				///////////////////////////
				if (vn[0] == 0.0 && vn[1] == 0.0) continue;
				//////////////////////////////////
				cx = (double)i; cy = (double)j; 
				//////////////////////
				for (k = -1; k < 1; k++) {
					//////////////////////////
					x = cx + k * vn[0];
					y = cy + k * vn[1];
					/////////////////////////////////////////////////////
					x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > image_x-1) x1 = image_x-1;
					y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > image_y-1) y1 = image_y-1;
					/////////////////////////////////
					vec[k+1] = tmp[x1][y1];
					//////////////////////////////
				}
				///////////////////////////
				if (vec[0] >= vec[1])
					if (vec[1] >= vec[2]) image[i][j] = vec[1]; // 0 >= 1 >= 2
					else if (vec[0] >= vec[2]) image[i][j] = vec[2]; // 0 >= 2 > 1 
						else image[i][j] = vec[0]; // 2 > 0 >= 1 
				else // (vec[0] < vec[1])
					if (vec[0] >= vec[2]) image[i][j] = vec[0]; // 1 > 0 >= 2
					else if (vec[1] >= vec[2]) image[i][j] = vec[2]; // 1 >= 2 > 0  
						else image[i][j] = vec[1]; // 2 > 1 > 0 
				////////////////////////////////////////////////
			}
		}
		tmp.copy(image);
	}

	for (m = 0; m < itr; m++) {
		/////////////////////////////////
		// tangential direction
		for (i = 0; i < image_x; i++) {
			for (j = 0; j < image_y; j++) {
				/////////////////////////////////
				////////////////////////////
				vt[0] = e[i][j].tx;
				vt[1] = e[i][j].ty;
				///////////////////////////
				if (vt[0] == 0.0 && vt[1] == 0.0) continue;
				//////////////////////////////////
				cx = (double)i; cy = (double)j; 
				//////////////////////
				for (k = -1; k < 1; k++) {
					//////////////////////////
					x = cx + k * vt[0];
					y = cy + k * vt[1];
					/////////////////////////////////////////////////////
					x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > image_x-1) x1 = image_x-1;
					y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > image_y-1) y1 = image_y-1;
					/////////////////////////////////
					vec[k+1] = tmp[x1][y1];
					//////////////////////////////
				}
				///////////////////////////
				if (vec[0] >= vec[1])
					if (vec[1] >= vec[2]) image[i][j] = vec[1]; // 0 >= 1 >= 2
					else if (vec[0] >= vec[2]) image[i][j] = vec[2]; // 0 >= 2 > 1 
						else image[i][j] = vec[0]; // 2 > 0 >= 1 
				else // (vec[0] < vec[1])
					if (vec[0] >= vec[2]) image[i][j] = vec[0]; // 1 > 0 >= 2
					else if (vec[1] >= vec[2]) image[i][j] = vec[2]; // 1 >= 2 > 0  
						else image[i][j] = vec[1]; // 2 > 1 > 0 
				////////////////////////////////////////////////
			}
		}
		tmp.copy(image);
		
	}
}

void GetFMedian2(imatrix& image, ETF& e, int itr) 
// considering gradient, tangent directions at the same time
{
	int	i, j;

    int image_x = image.getRow();
	int image_y = image.getCol();
	
	imatrix tmp(image_x, image_y);
	tmp.copy(image);

	myvec vt(2), vn(2);
	//int vec[3];
	double x, y;

	deque<int> vec;
	int val;

	int k, m;
	int x1, y1;
	double cx, cy;

	for (m = 0; m < itr; m++) {
		/////////////////////////////////
		// gradient direction
		for (i = 0; i < image_x; i++) {
			for (j = 0; j < image_y; j++) {
				//////////////////////////
				vt[0] = e[i][j].tx;
				vt[1] = e[i][j].ty;
				////////////////////////////
				vn[0] = -e[i][j].ty;
				vn[1] = e[i][j].tx;
				///////////////////////////
				if (vt[0] == 0.0 && vt[1] == 0.0) continue;
				//////////////////////////////////
				cx = (double)i; cy = (double)j; 
				vec.clear();
				//////////////////////
				for (k = -1; k < 1; k++) {
					//////////////////////////
					x = cx + k * vt[0];
					y = cy + k * vt[1];
					/////////////////////////////////////////////////////
					x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > image_x-1) x1 = image_x-1;
					y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > image_y-1) y1 = image_y-1;
					/////////////////////////////////
					val = tmp[x1][y1];
					vec.push_back(val);
					//vec[k+1] = tmp[x1][y1];
					//////////////////////////////
				}
				for (k = -1; k < 1; k++) {
					if (k == 0) continue; // center pixel already included in the list
					//////////////////////////
					x = cx + k * vn[0];
					y = cy + k * vn[1];
					/////////////////////////////////////////////////////
					x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > image_x-1) x1 = image_x-1;
					y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > image_y-1) y1 = image_y-1;
					/////////////////////////////////
					val = tmp[x1][y1];
					vec.push_back(val);
					//vec[k+1] = tmp[x1][y1];
					//////////////////////////////
				}
				///////////////////////////
				sort(vec.begin(), vec.end());
				image[i][j] = vec[vec.size()/2]; 
				////////////////////////////////////////////////
			}
		}
		tmp.copy(image);
	}
}

void GetFMedian3(imatrix& image, ETF& e, int itr) 
// include the smoothed version in the mix
{
	int	i, j;

    int image_x = image.getRow();
	int image_y = image.getCol();
	
	imatrix tmp(image_x, image_y);
	tmp.copy(image);

	myvec vt(2), vn(2);
	//int vec[3];
	double x, y;

	deque<int> vec;
	int val;

	int k, m;
	int x1, y1;
	double cx, cy;

	imatrix image2(image_x, image_y);
	image2.copy(image);

	//GaussSmoothSep(gray2, 1.0); 

	for (m = 0; m < itr; m++) {
		GaussSmoothSep(image2, 1.0); 
		///////////////////////////////////
		for (i = 0; i < image_x; i++) {
			for (j = 0; j < image_y; j++) {
				//////////////////////////
				vt[0] = e[i][j].tx;
				vt[1] = e[i][j].ty;
				////////////////////////////
				vn[0] = -e[i][j].ty;
				vn[1] = e[i][j].tx;
				///////////////////////////
				if (vt[0] == 0.0 && vt[1] == 0.0) continue;
				//////////////////////////////////
				cx = (double)i; cy = (double)j; 
				vec.clear();
				//////////////////////
				for (k = -1; k < 1; k++) {
					//////////////////////////
					x = cx + k * vt[0];
					y = cy + k * vt[1];
					/////////////////////////////////////////////////////
					x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > image_x-1) x1 = image_x-1;
					y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > image_y-1) y1 = image_y-1;
					/////////////////////////////////
					val = tmp[x1][y1];
					vec.push_back(val);
					///////////////////////////
					val = image2[x1][y1];
					vec.push_back(val);
					//vec[k+1] = tmp[x1][y1];
					//////////////////////////////
				}
				for (k = -1; k < 1; k++) {
					if (k == 0) continue; // center pixel already included in the list
					//////////////////////////
					x = cx + k * vn[0];
					y = cy + k * vn[1];
					/////////////////////////////////////////////////////
					x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > image_x-1) x1 = image_x-1;
					y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > image_y-1) y1 = image_y-1;
					/////////////////////////////////
					val = tmp[x1][y1];
					vec.push_back(val);
					///////////////////////////
					val = image2[x1][y1];
					vec.push_back(val);
					//vec[k+1] = tmp[x1][y1];
					//////////////////////////////
				}
				///////////////////////////
				sort(vec.begin(), vec.end());
				image[i][j] = vec[vec.size()/2]; 
				////////////////////////////////////////////////
			}
		}
		tmp.copy(image);
		image2.copy(image);
	}
}

void GetFMedian4(imatrix& image, int itr) 
// x- and y- directional!
// include the smoothed version in the mix
{
	int	i, j;

    int image_x = image.getRow();
	int image_y = image.getCol();
	
	imatrix tmp(image_x, image_y);
	tmp.copy(image);

	//int vec[3];

	deque<int> vec;
	int val;

	int k, m;
	int x1, y1;

	imatrix image2(image_x, image_y);
	image2.copy(image);

	//GaussSmoothSep(gray2, 1.0); 

	for (m = 0; m < itr; m++) {
		GaussSmoothSep(image2, 1.0); 
		///////////////////////////////////
		for (i = 0; i < image_x; i++) {
			for (j = 0; j < image_y; j++) {
				//////////////////////////////////
				vec.clear();
				//////////////////////
				for (k = -1; k < 1; k++) {
					//////////////////////////
					x1 = i + k;
					y1 = j;
					/////////////////////////////////////////////////////
					if (x1 < 0) x1 = 0; if (x1 > image_x-1) x1 = image_x-1;
					if (y1 < 0) y1 = 0; if (y1 > image_y-1) y1 = image_y-1;
					/////////////////////////////////
					val = tmp[x1][y1];
					vec.push_back(val);
					///////////////////////////
					val = image2[x1][y1];
					vec.push_back(val);
					//vec[k+1] = tmp[x1][y1];
					//////////////////////////////
				}
				for (k = -1; k < 1; k++) {
					if (k == 0) continue; // center pixel already included in the list
					//////////////////////////
					x1 = i;
					y1 = j + k;
					/////////////////////////////////////////////////////
					if (x1 < 0) x1 = 0; if (x1 > image_x-1) x1 = image_x-1;
					if (y1 < 0) y1 = 0; if (y1 > image_y-1) y1 = image_y-1;
					/////////////////////////////////
					val = tmp[x1][y1];
					vec.push_back(val);
					///////////////////////////
					val = image2[x1][y1];
					vec.push_back(val);
					//vec[k+1] = tmp[x1][y1];
					//////////////////////////////
				}
				///////////////////////////
				sort(vec.begin(), vec.end());
				image[i][j] = vec[vec.size()/2]; 
				////////////////////////////////////////////////
			}
		}
		tmp.copy(image);
		image2.copy(image);
	}
}

void GetFMedian5(CDC& dc, imatrix& image, ETF& e, int itr) 
// include the smoothed version in the mix
// At each iteration, compute updated ETF 
{
	int	i, j;

    int image_x = image.getRow();
	int image_y = image.getCol();
	
	imatrix tmp(image_x, image_y);
	tmp.copy(image);

	myvec vt(2), vn(2);
	//int vec[3];
	double x, y;

	deque<int> vec;
	int val;

	int k, m;
	int x1, y1;
	double cx, cy;

	imatrix image2(image_x, image_y);
	image2.copy(image);

	//GaussSmoothSep(gray2, 1.0); 

	for (m = 0; m < itr; m++) {
		///////////////////////////////////
		GaussSmoothSep(image2, 1.0); 
		e.set(image2);
		e.Smooth(4, 2);
		DrawETF_LIC(dc, e, 10);
		///////////////////////////////////
		for (i = 0; i < image_x; i++) {
			for (j = 0; j < image_y; j++) {
				//////////////////////////
				vt[0] = e[i][j].tx;
				vt[1] = e[i][j].ty;
				////////////////////////////
				vn[0] = -e[i][j].ty;
				vn[1] = e[i][j].tx;
				///////////////////////////
				if (vt[0] == 0.0 && vt[1] == 0.0) continue;
				//////////////////////////////////
				cx = (double)i; cy = (double)j; 
				vec.clear();
				//////////////////////
				for (k = -1; k < 1; k++) {
					//////////////////////////
					x = cx + k * vt[0];
					y = cy + k * vt[1];
					/////////////////////////////////////////////////////
					x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > image_x-1) x1 = image_x-1;
					y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > image_y-1) y1 = image_y-1;
					/////////////////////////////////
					val = tmp[x1][y1];
					vec.push_back(val);
					///////////////////////////
					val = image2[x1][y1];
					vec.push_back(val);
					//vec[k+1] = tmp[x1][y1];
					//////////////////////////////
				}
				for (k = -1; k < 1; k++) {
					if (k == 0) continue; // center pixel already included in the list
					//////////////////////////
					x = cx + k * vn[0];
					y = cy + k * vn[1];
					/////////////////////////////////////////////////////
					x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > image_x-1) x1 = image_x-1;
					y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > image_y-1) y1 = image_y-1;
					/////////////////////////////////
					val = tmp[x1][y1];
					vec.push_back(val);
					///////////////////////////
					val = image2[x1][y1];
					vec.push_back(val);
					//vec[k+1] = tmp[x1][y1];
					//////////////////////////////
				}
				///////////////////////////
				sort(vec.begin(), vec.end());
				image[i][j] = vec[vec.size()/2]; 
				////////////////////////////////////////////////
			}
		}
		tmp.copy(image);
		image2.copy(image);
	}
}

void GetFDoGRedZone(imatrix& image, ETF& e, imatrix& redzone, imatrix& bw, double sigma, double sigma3, double tau) 
// don't touch the red zone
{
	int	i, j;

    int image_x = image.getRow();
	int image_y = image.getCol();

	myvec GAU1, GAU2, GAU3;
	MakeGaussianVector(sigma, GAU1); 
	MakeGaussianVector(sigma*1.6, GAU2); 

	int half_w1, half_w2, half_l;
	half_w1 = GAU1.getMax()-1;
	half_w2 = GAU2.getMax()-1;
	
	MakeGaussianVector(sigma3, GAU3); 
	half_l = GAU3.getMax()-1;
	
	mymatrix tmp(image_x, image_y);
	mymatrix dog(image_x, image_y);

	GetDirectionalDoG(gray, e, dog, GAU1, GAU2, tau);
	GetFlowDoG(e, dog, tmp, GAU3);

	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			if (!redzone[i][j]) image[i][j] = round(tmp[i][j] * 255.);
			else image[i][j] = bw[i][j];
		}
	}
}

void GetLinearDoG(ETF& e, mymatrix& dog, mymatrix& tmp, myvec& GAU3)
{
	myvec vt(2);
	double x, y, c_x, c_y;
	double weight1, w_sum1, sum1;

	int k;
	int x1, y1;
	double val;
	int i, j;

	int image_x = dog.getRow();
	int image_y = dog.getCol();

	int half_l;
	half_l = GAU3.getMax()-1;
	
	int flow_DOG_sign = 0; 
	
	double step_size = 1.0; 

	for (i = 0; i < image_x; i++) {
		for (j = 0; j < image_y; j++) {
			sum1 = 0.0;
			w_sum1 = 0.0;
			weight1 = 0.0;
			/////////////////////////////////
			val = dog[i][j];
			weight1 = GAU3[0]; 
			sum1 = val * weight1;
			w_sum1 += weight1;
			////////////////////////////////////////////////
			c_x = (double)i; c_y = (double)j; 
			//i_x = i; i_y = j;
			////////////////////////////
			vt[0] = e[i][j].tx;
			vt[1] = e[i][j].ty;
			for (k = -half_l; k <= half_l; k++) {
				x = c_x + k * vt[0];
				y = c_y + k * vt[1];
				/////////////////////////////////////////////////////
				x1 = round(x);	if (x1 < 0) x1 = 0; if (x1 > IMAGE_X-1) x1 = IMAGE_X-1;
				y1 = round(y);	if (y1 < 0) y1 = 0; if (y1 > IMAGE_Y-1) y1 = IMAGE_Y-1;
				//////////////////////////////////
				val = dog[x1][y1];
				//////////////////////////////
				weight1 = GAU3[k]; 
				////////////////////
				sum1 += val * weight1;
				w_sum1 += weight1;
				/////////////////////////////////////////
			}
			////////////////////////////////////////
			sum1 /= w_sum1; 
			//////////////////////////////////////
			if (sum1 > 0) tmp[i][j] = 1.0; 
			else tmp[i][j] = 1.0 + tanh(sum1);
		}
	}
}

void GetDoubleLinearDoG(imatrix& image, ETF& e, mymatrix& tmp, myvec& GAU1, myvec& GAU2, myvec& GAU3, double tau)
// linear in both main and minor axes
{
	myvec vt(2), vn(2);
	double x, y, c_x, c_y, d_x, d_y;
	double weight1, w_sum1, sum1;
	double weight2, w_sum2, sum2;
	double weight3, w_sum3, sum3;

	int k, s, dd;
	int x1, y1;
	double val, dog;
	int i, j;

	int image_x = e.getRow();
	int image_y = e.getCol();

	int half_w1, half_w2;

	half_w1 = GAU1.getMax()-1;
	half_w2 = GAU2.getMax()-1;

	int half_l;
	half_l = GAU3.getMax()-1;
	
	int flow_DOG_sign = 0; 
	
	for (i = 0; i < image_x; i++) {
		for (j = 0; j < image_y; j++) {
			sum3 = 0.0;
			w_sum3 = 0.0;
			weight3 = 0.0;
			/////////////////////////////////
			c_x = (double)i; c_y = (double)j; 
			////////////////////////////
			vt[0] = e[i][j].tx;
			vt[1] = e[i][j].ty;
			vn[0] = -e[i][j].ty;
			vn[1] = e[i][j].tx;
			///////////////////////////////
			if (vt[0] == 0.0 && vt[1] == 0.0) {
				tmp[i][j] = 1.0; // non edge
			}
			for (k = -half_l; k <= half_l; k++) {
				sum1 = sum2 = 0.0;
				w_sum1 = w_sum2 = 0.0;
				d_x = c_x + k * vt[0];
				d_y = c_y + k * vt[1];
				/////////////////////////////////////////////////////
				x1 = round(d_x); if (x1 < 0 || x1 > image_x-1) continue;
				y1 = round(d_y); if (y1 < 0 || y1 > image_y-1) continue;
				//////////////////////////////////
				for (s = -half_w2; s <= half_w2; s++) { 
					////////////////////////
					x = d_x + vn[0] * s;
					y = d_y + vn[1] * s;
					/////////////////////////////////////////////////////
					if (x > image_x-1 || x < 0.0 || y > image_y-1 || y < 0.0) continue;
					x1 = round(x);	
					y1 = round(y);	
					///////////////////////////
					val = image[x1][y1];
					/////////////////////////////////////////////////////////
					dd = ABS(s);
					if (dd > half_w1) weight1 = 0.0;
					else weight1 = GAU1[dd];
					//////////////////////////////////
					sum1 += val * weight1;
					w_sum1 += weight1;
					/////////////////////////////////////////////////////
					weight2 = GAU2[dd];
					sum2 += val * weight2;
					w_sum2 += weight2;
				}
				/////////////////////////
				sum1 /= w_sum1; 
				sum2 /= w_sum2; 
				//////////////////////////////////////
				dog = sum1 - tau * sum2;
				//////////////////////////////
				weight3 = GAU3[k]; 
				////////////////////
				sum3 += dog * weight3;
				w_sum3 += weight3;
				/////////////////////////////////////////
			}
			////////////////////////////////////////
			sum3 /= w_sum3; 
			//////////////////////////////////////
			if (sum3 > 0) tmp[i][j] = 1.0; 
			else tmp[i][j] = 1.0 + tanh(sum3);

		}
	}
}

void GetLDoG(imatrix& image, ETF& e, double sigma, double sigma3, double tau) 
// Collect the evidence along a line (not the flow-axis)
{
	int	i, j;

    int image_x = image.getRow();
	int image_y = image.getCol();

	myvec GAU1, GAU2, GAU3;
	MakeGaussianVector(sigma, GAU1); 
	MakeGaussianVector(sigma*1.6, GAU2); 

	int half_w1, half_w2, half_l;
	half_w1 = GAU1.getMax()-1;
	half_w2 = GAU2.getMax()-1;
	
	MakeGaussianVector(sigma3, GAU3); 
	half_l = GAU3.getMax()-1;
	
	mymatrix tmp(image_x, image_y);
	//mymatrix dog(image_x, image_y);

	//GetDirectionalDoG(gray, e, dog, GAU1, GAU2, tau);
	//GetLinearDoG(e, dog, tmp, GAU3);
	GetDoubleLinearDoG(gray, e, tmp, GAU1, GAU2, GAU3, tau);

	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			image[i][j] = round(tmp[i][j] * 255.);
		}
	}
}

void GaussSmoothSep(imatrix& image, double sigma)
{
	int	i, j;
	int MAX_GRADIENT = -1;
	double g, max_g, min_g;
	int s, t;
	int x, y;
	double weight, w_sum;

	int image_x = image.getRow();
	int image_y = image.getCol();

	myvec GAU1;
	MakeGaussianVector(sigma, GAU1); 
	int half = GAU1.getMax()-1;

	mymatrix tmp(image_x, image_y);
		
	max_g = -1;
	min_g = 10000000;
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			g = 0.0;
			weight = w_sum = 0.0;
			for (s = -half; s <= half; s++) {
				x = i+s; y = j;
				if (x > IMAGE_X-1) x = IMAGE_X-1;
				else if (x < 0) x = 0;
				if (y > IMAGE_Y-1) y = IMAGE_Y-1;
				else if (y < 0) y = 0;
				weight = GAU1[ABS(s)];
				g += weight * image[x][y];
				w_sum += weight;
			}
			g /= w_sum;
			if (g > max_g) max_g = g;
			if (g < min_g) min_g = g;
			tmp[i][j] = g;
		}
	}
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			g = 0.0;
			weight = w_sum = 0.0;
			for (t = -half; t <= half; t++) {
					x = i; y = j+t;
					if (x > IMAGE_X-1) x = IMAGE_X-1;
					else if (x < 0) x = 0;
					if (y > IMAGE_Y-1) y = IMAGE_Y-1;
					else if (y < 0) y = 0;
					weight = GAU1[ABS(t)];
					g += weight * tmp[x][y];
					w_sum += weight;
			}
			g /= w_sum;
			if (g > max_g) max_g = g;
			if (g < min_g) min_g = g;
			image[i][j] = round(g);
		}
	}
	
	//TRACE("max_g = %f\n", max_g);
	//TRACE("min_g = %f\n", min_g);
}

void GaussSmoothSepDouble(imatrix& image, double sigma, matrix& output)
// write as double values
// don't touch the original image
{
	int	i, j;
	int MAX_GRADIENT = -1;
	double g;
	//double max_g, min_g;
	int s, t;
	int x, y;
	double weight, w_sum;

	int image_x = image.getRow();
	int image_y = image.getCol();

	myvec GAU1;
	MakeGaussianVector(sigma, GAU1); 
	int half = GAU1.getMax()-1;

	mymatrix tmp(image_x, image_y);
		
	//TRACE("Gaussian half = %d\n", half);
	//max_g = -1;
	//min_g = 10000000;
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			g = 0.0;
			weight = w_sum = 0.0;
			for (s = -half; s <= half; s++) {
				x = i+s; y = j;
				if (x > image_x-1) x = image_x-1;
				else if (x < 0) x = 0;
				//if (y > IMAGE_Y-1) y = IMAGE_Y-1;
				//else if (y < 0) y = 0;
				weight = GAU1[ABS(s)];
				g += weight * image[x][y];
				w_sum += weight;
			}
			g /= w_sum;
			//if (g > max_g) max_g = g;
			//if (g < min_g) min_g = g;
			tmp[i][j] = g;
		}
	}
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			g = 0.0;
			weight = w_sum = 0.0;
			for (t = -half; t <= half; t++) {
				x = i; y = j+t;
				//if (x > IMAGE_X-1) x = IMAGE_X-1;
				//else if (x < 0) x = 0;
				if (y > image_y-1) y = image_y-1;
				else if (y < 0) y = 0;
				weight = GAU1[ABS(t)];
				g += weight * tmp[x][y];
				w_sum += weight;
			}
			g /= w_sum;
			//if (g > max_g) max_g = g;
			//if (g < min_g) min_g = g;
			/////////////////////////////
			output[i][j] = g;
			//image[i][j] = round(g);
		}
	}
	
	//TRACE("max_g = %f\n", max_g);
	//TRACE("min_g = %f\n", min_g);
}

void GaussSmoothSepDouble3(imatrix& image, double sigma, matrix& output)
// input is imatrix
// write as double values
// change the original image
// output is normalized to [0, 1]
{
	int	i, j;
	int MAX_GRADIENT = -1;
	double g;
	//double max_g, min_g;
	int s, t;
	int x, y;
	double weight, w_sum;

	int image_x = image.getRow();
	int image_y = image.getCol();

	myvec GAU1;
	MakeGaussianVector(sigma, GAU1); 
	int half = GAU1.getMax()-1;

	mymatrix tmp(image_x, image_y);
		
	//TRACE("Gaussian half = %d\n", half);
	//max_g = -1;
	//min_g = 10000000;
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			g = 0.0;
			weight = w_sum = 0.0;
			for (s = -half; s <= half; s++) {
				x = i+s; y = j;
				if (x > image_x-1) x = image_x-1;
				else if (x < 0) x = 0;
				//if (y > IMAGE_Y-1) y = IMAGE_Y-1;
				//else if (y < 0) y = 0;
				weight = GAU1[ABS(s)];
				g += weight * image[x][y];
				w_sum += weight;
			}
			g /= w_sum;
			//if (g > max_g) max_g = g;
			//if (g < min_g) min_g = g;
			tmp[i][j] = g;
		}
	}
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			g = 0.0;
			weight = w_sum = 0.0;
			for (t = -half; t <= half; t++) {
				x = i; y = j+t;
				//if (x > IMAGE_X-1) x = IMAGE_X-1;
				//else if (x < 0) x = 0;
				if (y > image_y-1) y = image_y-1;
				else if (y < 0) y = 0;
				weight = GAU1[ABS(t)];
				g += weight * tmp[x][y];
				w_sum += weight;
			}
			g /= w_sum;
			//if (g > max_g) max_g = g;
			//if (g < min_g) min_g = g;
			/////////////////////////////
			image[i][j] = round(g);
			output[i][j] = g/255.0;
		}
	}
	
	//TRACE("max_g = %f\n", max_g);
	//TRACE("min_g = %f\n", min_g);
}

void GaussSmoothSepDouble2(matrix& input, imatrix& gray, double sigma, matrix& output)
// input values are also double
// write as double values
// don't touch the original image
{
	int	i, j;
	int MAX_GRADIENT = -1;
	double g;
	//double max_g, min_g;
	int s, t;
	int x, y;
	double weight, w_sum;

	int image_x = input.getRow();
	int image_y = input.getCol();

	myvec GAU1;
	MakeGaussianVector(sigma, GAU1); 
	int half = GAU1.getMax()-1;

	matrix tmp(image_x, image_y);
		
	//TRACE("Gaussian half = %d\n", half);
	//max_g = -1;
	//min_g = 10000000;
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			g = 0.0;
			weight = w_sum = 0.0;
			for (s = -half; s <= half; s++) {
				x = i+s; y = j;
				if (x > IMAGE_X-1) x = IMAGE_X-1;
				else if (x < 0) x = 0;
				//if (y > IMAGE_Y-1) y = IMAGE_Y-1;
				//else if (y < 0) y = 0;
				weight = GAU1[ABS(s)];
				g += weight * input[x][y];
				w_sum += weight;
			}
			g /= w_sum;
			//if (g > max_g) max_g = g;
			//if (g < min_g) min_g = g;
			tmp[i][j] = g;
		}
	}
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			g = 0.0;
			weight = w_sum = 0.0;
			for (t = -half; t <= half; t++) {
				x = i; y = j+t;
				//if (x > IMAGE_X-1) x = IMAGE_X-1;
				//else if (x < 0) x = 0;
				if (y > IMAGE_Y-1) y = IMAGE_Y-1;
				else if (y < 0) y = 0;
				weight = GAU1[ABS(t)];
				g += weight * tmp[x][y];
				w_sum += weight;
			}
			g /= w_sum;
			//if (g > max_g) max_g = g;
			//if (g < min_g) min_g = g;
			/////////////////////////////
			output[i][j] = g;
			gray[i][j] = round(g*255);
			//image[i][j] = round(g);
		}
	}
	
	//TRACE("max_g = %f\n", max_g);
	//TRACE("min_g = %f\n", min_g);
}


void GaussColSmoothSep(cimatrix& image, double sigma)
{
	int	i, j;
	int MAX_GRADIENT = -1;
	double r, g, b;
	int s, t;
	int x, y;
	double weight;
	double w_sum;

	int image_x = image.getRow();
	int image_y = image.getCol();

	myvec GAU1;
	MakeGaussianVector(sigma, GAU1); 
	int half = GAU1.getMax()-1;

	mymatrix tmp[3];
	tmp[0].init(image_x, image_y);
	tmp[1].init(image_x, image_y);
	tmp[2].init(image_x, image_y);
		
	// horizontal
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			r = g = b = 0.0;
			weight = w_sum = 0.0;
			for (s = -half; s <= half; s++) {
				x = i+s; y = j;
				if (x > IMAGE_X-1) x = IMAGE_X-1;
				else if (x < 0) x = 0;
				if (y > IMAGE_Y-1) y = IMAGE_Y-1;
				else if (y < 0) y = 0;
				weight = GAU1[ABS(s)];
				r += weight * image[x][y].r;
				g += weight * image[x][y].g;
				b += weight * image[x][y].b;
				w_sum += weight;
			}
			r /= w_sum;
			g /= w_sum;
			b /= w_sum;
			tmp[0][i][j] = r;
			tmp[1][i][j] = g;
			tmp[2][i][j] = b;
		}
	}
	// vertical
	for (j = 0; j < image_y; j++) {
		for (i = 0; i < image_x; i++) {
			r = g = b = 0.0;
			weight = w_sum = 0.0;
			for (t = -half; t <= half; t++) {
					x = i; y = j+t;
					if (x > IMAGE_X-1) x = IMAGE_X-1;
					else if (x < 0) x = 0;
					if (y > IMAGE_Y-1) y = IMAGE_Y-1;
					else if (y < 0) y = 0;
					weight = GAU1[ABS(t)];
					r += weight * tmp[0][x][y];
					g += weight * tmp[1][x][y];
					b += weight * tmp[2][x][y];
					w_sum += weight;
			}
			r /= w_sum;
			g /= w_sum;
			b /= w_sum;
			image[i][j].r = round(r);
			image[i][j].g = round(g);
			image[i][j].b = round(b);
		}
	}
}

void ConstructMergedImage(imatrix& image, imatrix& gray, imatrix& merged) 
// use overlaying!
{
	int x, y;

	int image_x = image.getRow();
	int image_y = image.getCol();

	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			if (gray[x][y] == 0) {
				merged[x][y] = 0;
			}
			else {
				merged[x][y] = image[x][y];
			}
		}
	}
}

void ConstructMergedImageMult(imatrix& image, imatrix& gray, imatrix& merged) 
// use multiplication!
{
	int x, y;
	double gray_val, line_darkness;

	int image_x = image.getRow();
	int image_y = image.getCol();

	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			line_darkness = gray[x][y] / 255.0; // [0, 1]
			gray_val = image[x][y] / 255.0; // [0, 1]
			gray_val = gray_val * line_darkness; // gray_val gets darker at lines!
			merged[x][y] = round(gray_val * 255.0);
		}
	}
}


void ConstructMergedImageColor(cimatrix& image, imatrix& gray, cimatrix& merged) 
{
	int x, y;

	int image_x = image.getRow();
	int image_y = image.getCol();

	for (y = 0; y < image_y; y++) {
		for (x = 0; x < image_x; x++) {
			if (gray[x][y] == 0) {
				merged[x][y].r = 0;
				merged[x][y].g = 0;
				merged[x][y].b = 0;
			}
			else {
				merged[x][y].r = image[x][y].r;
				merged[x][y].g = image[x][y].g;
				merged[x][y].b = image[x][y].b;
			}
		}
	}
}

void Binarize(imatrix& image, double thres) 
{
	int	i, j;
	double val;

	int image_x = image.getRow();
	int image_y = image.getCol();
	
	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			val = image[i][j] / 255.0; // [0, 1]
			if (val < thres)
				image[i][j] = 0; // black
			else image[i][j] = 255; // white
		}
	}
}

void GrayThresholding(imatrix& image, double thres) 
// different from binarization
// we similarly include pixels below threshold, but draw them with original gray level, not black
{
	int	i, j;
	double val;

	int image_x = image.getRow();
	int image_y = image.getCol();
	
	for (i = 0; i < image_x; i++) { 
		for (j = 0; j < image_y; j++) {
			val = image[i][j] / 255.0; // [0, 1]
			if (val < thres)
				image[i][j] = round(val * 255.0); // original gray level
			else image[i][j] = 255; // white
		}
	}
}
