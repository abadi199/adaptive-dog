// generated by classgen.pl

#ifndef SIMPLELIST_H
#define SIMPLELIST_H

#include <cstdlib>

template <class T> class SimpleListNode {
public:
	T object;
	SimpleListNode<T>* nextNode;
	SimpleListNode<T>* prevNode;
public:
	SimpleListNode () { prevNode = nextNode = NULL; } // 
	T& get() { return object; }
	void set(T &object) { this->object = object; }
	SimpleListNode<T>* getNext() { return nextNode; }
	SimpleListNode<T>* getPrev() { return prevNode; }
	void setNext(SimpleListNode<T> *nextNode) { this->nextNode = nextNode; }
	void setPrev(SimpleListNode<T> *prevNode) { this->prevNode = prevNode; }

};

template <class T> class SimpleList {
public:
	int size;
	SimpleListNode<T> *headNode;
	SimpleListNode<T> *currentNode, *lastCurrentNode;
	SimpleListNode<T> *lastNode;
public:
	// Constructor
	SimpleList() {
		//headNode = new SimpleListNode<T>;
		//headNode->setNext(NULL);
		headNode = NULL;
		currentNode = NULL;
		lastNode = NULL; // 
		size = 0;
	}
	// Destructor
	~SimpleList() {
		SimpleListNode<T> *pointerToDelete, *pointer = headNode;
		while (pointer != NULL) {
			pointerToDelete = pointer;
			pointer = pointer->getNext();
			delete pointerToDelete;
		}
	}
	T& get() { 
		if (currentNode == NULL) 
			start();
		return currentNode->get(); 
	}
	void add(T& addObject) {
		SimpleListNode<T> *newNode = new SimpleListNode<T>;
		newNode->set(addObject);
		newNode->setNext(headNode->getNext());
		if (headNode->getNext() == NULL) lastNode = newNode; // 
		headNode->setNext(newNode); // New Order: headNode --> newNode --> headNode->getNext()
		size++;
	}
	void AddRear(T& addObject) { // 
		SimpleListNode<T> *newNode = new SimpleListNode<T>;
		newNode->set(addObject);
		if (headNode == NULL) { // There's no node in the list
			headNode = newNode; 
		}
		else { // there's at least one node in the list
			newNode->setPrev(lastNode);
			lastNode->setNext(newNode);
		}
		lastNode = newNode;
		size++;
	}
	void remove() {
		lastCurrentNode->setNext(currentNode->getNext());
		delete currentNode;
		currentNode = lastCurrentNode;
		size--;
	}
	SimpleListNode<T>* RandomSelect() {
		if (headNode == NULL) return NULL;

		//srand( (unsigned)time( NULL ) );

		int N = (int) ( (size-1) * (float)rand() / RAND_MAX );
		//TRACE("size = %d, N = %d\n", size, N);
		SimpleListNode<T>* s = headNode;
		for (int count = 0; s; s = s->getNext(), count++) {
			if (count == N) return s;
		}
		TRACE("SimpleList random select error: can't find element\n");
		exit(1);
	}
	void Print() {
		if (headNode == NULL) return;
		SimpleListNode<T>* s = headNode;
		for (; s; s = s->getNext()) {
			TRACE("s->object.xc = %d ", s->object.xc);
		}
	}
	void Remove(SimpleListNode<T>* node) {
		if (node == NULL) return;

		if (node->prevNode && node->nextNode) { // neither headNode nor lastNode
			node->prevNode->nextNode = node->nextNode;
			node->nextNode->prevNode = node->prevNode;
		}
		else if (node->prevNode == NULL && node->nextNode == NULL) { // headNode and lastNode
			headNode = NULL;
			lastNode = NULL;
		}
		else if (node->prevNode == NULL) { // headNode
			node->nextNode->prevNode = NULL;	
			headNode = node->nextNode;
		}
		else if (node->nextNode == NULL) { // lastNode
			node->prevNode->nextNode = NULL;
			lastNode = node->prevNode;
		}
		//lastCurrentNode->setNext(currentNode->getNext());
		delete node;
		//currentNode = lastCurrentNode;
		size--;
	}
	void start() {
		lastCurrentNode = headNode;
		currentNode = headNode;
	}
	bool next() {

		// If the currentNode now points at nothing, we've reached the end
		if (currentNode == NULL)
			return false;

		// Update the last node and current node
		lastCurrentNode = currentNode;
		currentNode = currentNode->getNext();

		// If currentNode points at nothing or there is nothing added, we can immediately return false
		if (currentNode == NULL || size == 0) 
			return false;
		else
			return true;
	}
	int getSize() { return size; };
};

#endif
